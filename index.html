<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="this is George Chen&#39;s blog!" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     George
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      


<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-computer-graphics0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/10/computer-graphics0/"
    >计算机图形学</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/10/computer-graphics0/" class="article-date">
  <time datetime="2020-09-10T14:45:58.000Z" itemprop="datePublished">2020-09-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E4%B8%93%E4%B8%9A%E9%80%89%E4%BF%AE/">专业选修</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>姜小峰</p>
<p>研究内容：如何将现实生活中所看到的物体利用数据结构存储在计算机中；并利用显卡将它在屏幕上显示出来。</p>
<blockquote>
<ul>
<li>有一定理论深度，包含许多算法</li>
<li>实践性较强</li>
</ul>
</blockquote>
<p>图形学和图像处理两个研究方向是相反的</p>
<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>图形学的定义：</p>
<blockquote>
<ul>
<li>研究通过计算机将数据转换成图形，并在专门显示设备上显示的原理、方法和技术的学科（注意与数据可视化的区别）</li>
<li>研究通过计算机将场景对象转换成图形并进行显示的一门学科</li>
</ul>
</blockquote>
<p>图形学的作用：</p>
<blockquote>
<ul>
<li>工业生产设计</li>
<li>医学、科学研究</li>
<li>3D电影、动漫、游戏</li>
</ul>
</blockquote>
<h3 id="图形和图像的区别"><a href="#图形和图像的区别" class="headerlink" title="图形和图像的区别"></a>图形和图像的区别</h3><p>图形是由不同属性的点、线、面等几何元素组合构成的图画，用来表示主客观世界中各物体的几何信息</p>
<p>图像则是对自然界事物的客观反映</p>
<h3 id="图形的处理"><a href="#图形的处理" class="headerlink" title="图形的处理"></a>图形的处理</h3><p>图形的处理有表示和显示两个方面：</p>
<blockquote>
<ul>
<li>用图形来表示场景对象；用图像来显示图形</li>
<li>（另一种说法）用点、线、面来建模形状、大小、位置、材质；用像素来绘制渲染点、线、面、颜色</li>
</ul>
</blockquote>
<p>造型的表示方法：</p>
<blockquote>
<ul>
<li>多边形网格</li>
<li>曲线曲面</li>
<li>细分曲面</li>
</ul>
</blockquote>
<p>渲染：对造型表示后的物体进行可视化，即根据三位物体模型生成二维图像</p>
<h3 id="相关学科"><a href="#相关学科" class="headerlink" title="相关学科"></a>相关学科</h3><blockquote>
<ul>
<li>图像处理</li>
<li>计算几何</li>
<li>计算机视觉</li>
</ul>
</blockquote>
<p>关系和区别：</p>
<blockquote>
<ul>
<li>图像到图像：数字图像处理</li>
<li>图像到知识：计算机视觉</li>
<li>知识到图像：计算机图形学</li>
<li>知识到知识：人工智能</li>
</ul>
</blockquote>
<h3 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h3><blockquote>
<ul>
<li>GPU计算发展迅猛</li>
<li>研究和谐自然的三维模型建模方法</li>
<li>实现高度真实的动态仿真</li>
</ul>
</blockquote>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/09/10/computer-graphics0/" data-id="ckf5ehrbk000hp0vn9wna5fpn"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%8Clearning/" rel="tag">计算机图形学，learning</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-ai0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/10/ai0/"
    >人工智能与知识工程</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/10/ai0/" class="article-date">
  <time datetime="2020-09-10T03:45:42.000Z" itemprop="datePublished">2020-09-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E4%B8%93%E4%B8%9A%E9%80%89%E4%BF%AE/">专业选修</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>陈文亮：<a href="mailto:wlchen@suda.edu.cn">wlchen@suda.edu.cn</a>;<a href="http://hlt.suda.edu.cn" target="_blank" rel="noopener">http://hlt.suda.edu.cn</a></p>
<p>课程目标：研究计算机实现智能的原理以及如何建造智能计算机</p>
<p>课程要求：</p>
<blockquote>
<ul>
<li>了解人工智能的基本概念、原理和方法（搜索推理技术、知识表示方法）</li>
<li>计算智能、专家系统、机器学习、强化学习、分布式人工智能、具有一定的人工智能算法的编程能力</li>
</ul>
</blockquote>
<p>考核：平时30%（上课问答10%、实验20%），考试70%（填空选择和简答）</p>
<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1-1-人工智能的定义与发展"><a href="#1-1-人工智能的定义与发展" class="headerlink" title="1.1 人工智能的定义与发展"></a>1.1 人工智能的定义与发展</h2><p>定义：</p>
<blockquote>
<ul>
<li>智能机器：能够在各种环境中自主地或交互地执行各种拟人任务的机器</li>
<li>人工智能（学科）：是计算机科学中涉及研究、设计和应用智能机器的一个分支</li>
<li>人工智能（能力）：是智能机器所执行的通常与人类智能有关的智能行为</li>
</ul>
</blockquote>
<p>起源和发展：</p>
<blockquote>
<ul>
<li>20世纪30年代：数理逻辑和关于计算的新思想</li>
<li>1956：人工智能概念的提出</li>
<li>50年代以游戏、博弈为对象进行研究</li>
<li>60年代以搜索方法、一般问题求解研究为主；机器定理证明</li>
<li>70年代：低谷；以自然语言理解、知识表示的研究为主</li>
<li>80年代：专家系统等</li>
<li>现状：人工智能实用化</li>
</ul>
</blockquote>
<h2 id="1-2-人工智能学派"><a href="#1-2-人工智能学派" class="headerlink" title="1.2 人工智能学派"></a>1.2 人工智能学派</h2><blockquote>
<ul>
<li>符号主义</li>
<li>连接主义</li>
<li>行为主义</li>
</ul>
</blockquote>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/09/10/ai0/" data-id="ckf5ehrb80006p0vndn3uexgl"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" rel="tag">人工智能</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-numeric-analysis0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/09/numeric-analysis0/"
    >数值分析</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/09/numeric-analysis0/" class="article-date">
  <time datetime="2020-09-09T01:22:09.000Z" itemprop="datePublished">2020-09-09</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E4%B8%93%E4%B8%9A%E9%80%89%E4%BF%AE/">专业选修</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>数值计算是沟通数学和计算机之间的桥梁</p>
<p>作业考试：每章作业</p>
<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1-1-计算方法的意义和特点"><a href="#1-1-计算方法的意义和特点" class="headerlink" title="1.1 计算方法的意义和特点"></a>1.1 计算方法的意义和特点</h2><p>无法采用传统数学方法获得所需解的三种有代表性的情形：</p>
<blockquote>
<ul>
<li>所涉及的数学模型无系统的求解析解的方法</li>
<li>所涉及数学模型的解法计算量大，只适用于规模较小的情形</li>
<li>基于离散数据建立的数学模型</li>
</ul>
</blockquote>
<p>计算方法（数值分析）是研究如何对给定的问题构建只需进行<strong>有限步</strong>的<strong>四则运算</strong>的计算模型，以便有效地借助计算机<strong>迅速</strong>求出所需要的数值解的任务</p>
<blockquote>
<ul>
<li>上述这种计算模型又称为计算格式</li>
</ul>
</blockquote>
<p>问题的解决过程：工程问题-数学模型-<strong>数值模型</strong>-程序-计算机运行</p>
<p>计算方法相比于数学学科的特点：</p>
<blockquote>
<ul>
<li>形式多样、内容分散，但有自己的一些研究原则；如相容性、（误差）稳定性、计算复杂性和并行性</li>
<li>计算方法是理论分析的严谨性和实用准则的近似性的对立统一<blockquote>
<ul>
<li>（严谨性）算法误差应当具有收敛性（趋近于0）</li>
<li>（实用性）计算成本的约束使得实际应用中的误差并不是越小越好</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>数值模型的一些基本概念：</p>
<blockquote>
<ul>
<li>误差：分为算法（方法）误差和舍入误差</li>
<li>迭代：一种建立数值模型的重要策略；多次迭代可以降低算法误差</li>
<li>收敛性：用于描述迭代过程中算法误差变化的性质；有时也用收敛速度来描述</li>
<li>稳定性：用于描述舍入误差的一种性质</li>
<li>计算复杂度：又称计算成本，分为计算量和存贮量</li>
<li>并行性</li>
</ul>
</blockquote>
<h2 id="1-2-计算格式的相容性与稳定性"><a href="#1-2-计算格式的相容性与稳定性" class="headerlink" title="1.2 计算格式的相容性与稳定性"></a>1.2 计算格式的相容性与稳定性</h2><h3 id="相容性"><a href="#相容性" class="headerlink" title="相容性"></a>相容性</h3><p>如果一个计算格式在取某种极限后可还原成某种数学模型，那么这个计算格式和此数学模型相容</p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果在用某一计算格式进行数值计算（迭代）的过程中，舍入误差不会严重积累（扩大），从而能够保证最终解满足所要求的精度，则称该计算格式数值稳定</p>
<blockquote>
<ul>
<li>稳定性分析通常基于对初始误差的传播状况的讨论</li>
<li>计算格式无法阻止舍入误差的传播，但能够防止舍入误差的扩大</li>
</ul>
</blockquote>
<h1 id="二、非线性方程的数值解法"><a href="#二、非线性方程的数值解法" class="headerlink" title="二、非线性方程的数值解法"></a>二、非线性方程的数值解法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>方程$f(x)=0$是非线性方程，则$f(x)$不满足下列条件：<br>$$f(x+y)=f(x)+f(y)$$</p>
<p>一般情况下，非线性方程难以求出精确解，一般只能求出数值解</p>
<p>非线性方程的数值计算策略：</p>
<blockquote>
<ul>
<li>区间收缩法：确定含根区间并不停收缩（二分法）</li>
<li>迭代法：选定初始值，然后通过迭代策略使其无限接近精确解（牛顿迭代法和弦截法）</li>
</ul>
</blockquote>
<h2 id="2-1-二分法"><a href="#2-1-二分法" class="headerlink" title="2.1 二分法"></a>2.1 二分法</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在给定闭区间$[a,b]$上$f(x)$连续且$f(a)f(b)&lt;0$</p>
<blockquote>
<p>该条件可以充分推导出$f(x)=0$在$[a,b]$上至少有一解$x=x^*$</p>
</blockquote>
<h3 id="二分法的计算步骤"><a href="#二分法的计算步骤" class="headerlink" title="二分法的计算步骤"></a>二分法的计算步骤</h3><p>对方程$f(x)=0$输入：</p>
<blockquote>
<ul>
<li>区间$[a,b]$</li>
<li>精度$\epsilon$：告诉程序何时停止，即$|\overline x-x^*|&lt;\epsilon$时程序应当返回结果</li>
</ul>
</blockquote>
<p>过程：</p>
<blockquote>
<ol>
<li>输入$a,b,\epsilon$</li>
<li>令$[a_0,b_0]=[a,b],\ 且对 k=0,1,2…,\ x_k=\frac12(a_k+b_k)$，检验如果$|b_k-a_k|&lt;\epsilon$，则令$\overline x=x_k$,停止运算  </li>
<li>做如下判断，并令$k=k+1$，返回2.：$$<br>f(a_k)f(x_k)=\begin{cases}<br>0\ then\ let\ [a_{k+1},b_{k+1}]=[x_{k+1},b_k]\<br>&lt;0\ then\ let\ [a_{k+1},b_{k+1}]=[a_k,x_{k+1}]\<br>=0\ then\ end\<br>\end{cases}<br>$$</li>
</ol>
</blockquote>
<h3 id="二分法的收敛性与事前误差估计"><a href="#二分法的收敛性与事前误差估计" class="headerlink" title="二分法的收敛性与事前误差估计"></a>二分法的收敛性与事前误差估计</h3><p>收敛性：二分法总是收敛的，因为</p>
<blockquote>
<p>$\lim_{k \to \infty} b_k-a_k = 0$<br>$|\overline x-x^*| \le \frac 12 (b_k-a_k) = \frac 1{2^{k+1}}(b-a)$</p>
</blockquote>
<p>误差分析（事前误差分析法）：</p>
<blockquote>
<ul>
<li>对给定的精度要求$|\overline x-x^*|&lt;\epsilon$,取$\epsilon= \frac 1{2^{k+1}}(b-a)$解得k的值 </li>
<li>此时k向下取整即为循环（迭代）次数</li>
<li>一般地，当$\epsilon=10^{-m},\ 则 \ k=[\frac{lg(b-a)+m}{lg2}]$</li>
</ul>
</blockquote>
<h3 id="二分法评述"><a href="#二分法评述" class="headerlink" title="二分法评述"></a>二分法评述</h3>
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/09/09/numeric-analysis0/" data-id="ckf5ehrci0020p0vn94a62urd"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90/" rel="tag">数值分析</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-algorithm0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/08/algorithm0/"
    >算法设计与分析基础知识</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/08/algorithm0/" class="article-date">
  <time datetime="2020-09-08T00:55:36.000Z" itemprop="datePublished">2020-09-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a> / <a class="article-category-link" href="/categories/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/notes/">notes</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>权丽君：<a href="mailto:ljquan@suda.edu.cn">ljquan@suda.edu.cn</a></p>
<p>为什么要学习算法：</p>
<blockquote>
<ul>
<li>算法是计算机科学的基石，是改造世界的有力工具</li>
<li>学习算方法可以开发人们的分析能力</li>
<li>算法进步是计算机技术进步的关键</li>
<li>算法应用无处不在</li>
<li>算法是计算机软件的灵魂：软件=数据结构+算法</li>
<li>即使计算机的速度和存储空间都是无限的，算法的研究仍然是必要的</li>
</ul>
</blockquote>
<p>数据结构着重于算法的实现；算法导论着重于算法设计的指导思想</p>
<p>课程目的：</p>
<blockquote>
<ul>
<li>偏向理论，掌握算法设计与分析的基本理论和方法，培养算法设计和分析的能力</li>
<li>培养实践能力、独立思考和创新能力</li>
<li>教学内容：基础知识、排序和顺序统计学、高级数据结构、算法设计策略</li>
</ul>
</blockquote>
<p>期末考试70%闭卷，论文汇报10%，作业考勤20%</p>
<h1 id="一、算法在计算机中的应用"><a href="#一、算法在计算机中的应用" class="headerlink" title="一、算法在计算机中的应用"></a>一、算法在计算机中的应用</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>算法是：</p>
<blockquote>
<ul>
<li>将输入转换成输出的计算步骤的一个序列（非形式化定义）</li>
<li>问题的程序化解决方案，是一个在时间和空间上的有穷的规则</li>
</ul>
</blockquote>
<p>算法的形式：包括算术、逻辑、全息、赋值、过程调用等运算形式</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>算法的特征<strong>重要</strong>：</p>
<blockquote>
<ul>
<li>具有输入，输出</li>
<li>具有（步骤）的确定性</li>
<li>有限性：算法必须是步骤有限的，这是算法和计算过程的本质区别</li>
<li>正确性：算法对问题每一个输入实例，都能产生正确的输出并停止</li>
<li>通用性</li>
</ul>
</blockquote>
<p>算法的正确性：</p>
<blockquote>
<ul>
<li>不正确的算法可能不会停止，或者在停止时给出的不是预期的结果</li>
<li>如果算法的错误率可以控制，也是有用的</li>
</ul>
</blockquote>
<h3 id="一些其他概念"><a href="#一些其他概念" class="headerlink" title="一些其他概念"></a>一些其他概念</h3><p>问题和问题实例的区别：</p>
<blockquote>
<ul>
<li>问题规定了输入和输出之间的关系，可以用通用语言来描述</li>
<li>某一个问题的实例包含了求解该问题所需的输入</li>
<li>问题的规模：算法输入的实际大小</li>
</ul>
</blockquote>
<p>算法和策略：</p>
<blockquote>
<ul>
<li>算法（规则）的设计可以总结出设计策略</li>
<li>设计策略可以指导规则的设计</li>
</ul>
</blockquote>
<h1 id="二、算法基础"><a href="#二、算法基础" class="headerlink" title="二、算法基础"></a>二、算法基础</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><h3 id="问题求解基础"><a href="#问题求解基础" class="headerlink" title="问题求解基础"></a>问题求解基础</h3><blockquote>
<ul>
<li>理解问题</li>
<li>决定计算方法、精确或近似解法、数据结构、算法设计技术</li>
<li>设计算法（并修改）</li>
<li>正确性证明（并修改）</li>
<li>分析算法（时间分析、空间分析；并修改）</li>
<li>根据算法编写代码</li>
</ul>
</blockquote>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>算法描述方法：伪代码</p>
<blockquote>
<ul>
<li>块结构用缩进表示</li>
<li>判断、循环、赋值语句及数组访问、注释等遵循C++风格</li>
<li>一般不设全局变量</li>
<li>复合数据用对象表示，对象赋值为指针赋值（浅拷贝）</li>
<li>参数按值传递（对象则传递指针）</li>
<li>return语句可以返回多个值</li>
<li>逻辑运算符是短路的</li>
<li>NIL表示空；error表示报错（无需异常处理）</li>
</ul>
</blockquote>
<h3 id="循环不变式证明算法正确性"><a href="#循环不变式证明算法正确性" class="headerlink" title="循环不变式证明算法正确性"></a>循环不变式证明算法正确性</h3><p><strong>重要</strong></p>
<p>循环不变式是在循环体每次执行前后都为真的谓词，它体现了循环程序中循环变量的变化规律</p>
<p>通常，算法所需要达到的目标在循环过程中是部分成立的，这与循环不变式密切相关</p>
<p>循环不变式性质：</p>
<blockquote>
<ul>
<li>初始化：循环不变式在循环开始之前为真</li>
<li>保持：若循环某次迭代之前它为真，这下次循环之前它仍然为真</li>
<li>终止：循环终止时，不变式为我们提供了一个有助于证明算法正确性的性质</li>
</ul>
</blockquote>
<h2 id="2-2-算法分析"><a href="#2-2-算法分析" class="headerlink" title="2.2 算法分析"></a>2.2 算法分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>算法分析通常是对时间和空间都预测</p>
<p>目的：预测算法需要资源的程度</p>
<blockquote>
<ul>
<li>有助于算法选择和算法优化</li>
</ul>
</blockquote>
<p>算法分析基于的假设：RAM模型</p>
<blockquote>
<ul>
<li>指令逐条执行，没有并发</li>
<li>包含常用指令，每条指令执行时间为常量</li>
<li>数据类型有整数类型和浮点数类型</li>
<li>不对存储层次进行建模</li>
</ul>
</blockquote>
<p>实例：插入排序P9－P11</p>
<blockquote>
<ul>
<li>插入排序的思想、性质和排序过程</li>
<li>插入排序的时间复杂度计算，且能用渐进记号表示</li>
</ul>
</blockquote>
<h3 id="执行时间"><a href="#执行时间" class="headerlink" title="执行时间"></a>执行时间</h3><p>算法的执行时间是算法中所有运算执行时间的总和</p>
<p>运算的分类：</p>
<blockquote>
<ul>
<li>时间囿界于常数的运算：运算的执行时间与操作数无关，每次执行时间是一个常数</li>
<li>时间非囿界于常数的运算：运算的执行时间与输入有关</li>
</ul>
</blockquote>
<p>算法的执行时间与输入数据有关：</p>
<blockquote>
<ul>
<li>与输入数据规模有关，一般规模越大，执行时间越长</li>
<li>与输入数据的配置有关，可分最好、最坏和平均情况等讨论；一般情况下，我们更关心算法的最坏情况执行时间</li>
</ul>
</blockquote>
<p>运行时间的增长量级：</p>
<blockquote>
<ul>
<li>运行时间的增长量级是对算法执行时间的抽象</li>
<li>此时，我们只考虑公式中最重要的项，并且忽略该项的常系数和其他项</li>
<li>此概念在后续会进行具体的描述</li>
</ul>
</blockquote>
<h3 id="算法正确性的证明"><a href="#算法正确性的证明" class="headerlink" title="算法正确性的证明"></a>算法正确性的证明</h3><p>分析结论的证明方法：</p>
<blockquote>
<ul>
<li>直接推导法</li>
<li>数学归纳法</li>
<li>反证法</li>
<li>反例法</li>
</ul>
</blockquote>
<h2 id="2-3-算法分析设计实例：分治法"><a href="#2-3-算法分析设计实例：分治法" class="headerlink" title="2.3 算法分析设计实例：分治法"></a>2.3 算法分析设计实例：分治法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote>
<ul>
<li>核心思想：分而治之，各个击破</li>
<li>递归结构：为解决一个给定的问题，算法一次或多次地调用自身</li>
<li>分治策略：将原问题划分为n个规模较小而结构相似的子问题进行求解</li>
<li>步骤：分解、解决、合并</li>
</ul>
</blockquote>
<h3 id="分治法分析"><a href="#分治法分析" class="headerlink" title="分治法分析"></a>分治法分析</h3><p>归并排序中MERGE操作的正确性：P19</p>
<p>时间复杂度分析：</p>
<blockquote>
<p>当一个算法含有对其自身的递归调用时，其运行时间可以用如下一个递归方程来表示：<br>$$<br>T(n)=<br>\begin{cases}<br>\Theta(1) , &amp;n \le c \<br>aT(n/b) + D(n) + C(n) , &amp;other\ casese<br>\end{cases}<br>$$<br>其中：</p>
<ul>
<li>$T(n)$是规模为n的一个问题的运行时间</li>
<li>$D(n)$是将问题分解（Divide）成子问题所需的时间</li>
<li>$C(n)$是将子问题合并成原问题所需的时间</li>
<li>此时，算法将这个规模为n的问题分解成$a$个规模为$1/b$的子问题进行递归求解，所以运行时间为$aT(n/b)$</li>
<li>注意，有时当规模$n \le c$时，算法无需递归，直接求解只需常量时间，记为$\Theta(1)$</li>
</ul>
</blockquote>
<p>在归并排序中，上述$a=b=2$;分解问题为常量时间$\Theta(1)$；合并问题需要一个n的线性函数时间$\Theta(n)$<br>即：<br>$$<br>T(n)=<br>\begin{cases}<br>c , &amp;n = 1 \<br>2T(n/2) + cn , &amp;n &gt; 1<br>\end{cases}<br>$$</p>
<p>求解这个递归式时，我们需要画出它的递归树进行分析，此时我们发现，树的每一层执行时间都为cn，树高为lgn<br>所以：<br>$$T(n) = cnlgn+cn = \Theta(nlgn)$$</p>
<h1 id="三、函数的增长"><a href="#三、函数的增长" class="headerlink" title="三、函数的增长"></a>三、函数的增长</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>对于足够大的输入规模，算法精确运行时间中的倍增常量和低阶项被输入规模本身刚到影响所支配</p>
<blockquote>
<p>此时，我们要研究算法的渐进效率；即在极限中，算法的运行时间如何随着输入规模的变大而增加</p>
</blockquote>
<h2 id="3-1-渐进记号"><a href="#3-1-渐进记号" class="headerlink" title="3.1 渐进记号"></a>3.1 渐进记号</h2><h3 id="渐近上界记号-O"><a href="#渐近上界记号-O" class="headerlink" title="渐近上界记号$O$"></a>渐近上界记号$O$</h3><p>定义：对于给定函数$g(n)$，$\Theta(g(n))$定义如下：<br>$$O(g(n))=\lbrace f(n) | \exists c,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le f(n) \le cg(n) \rbrace$$</p>
<blockquote>
<ul>
<li>此时，$f(n) \in O(g(n))$也可以表示成$f(n) = O(g(n))$</li>
<li>此时，我们称$g(n)$是$f(n)$的一个渐近上界</li>
<li>渐进上界用于描述算法最坏情况下的运行时间</li>
<li>紧确上界：最小的渐近上界</li>
</ul>
<p>渐近上界具有自反性、传递性,且满足加法法则和乘法法则</p>
</blockquote>
<p>非渐近紧确上界$o$:渐近上界除去紧确上界，定义如下<br>$$o(g(n))=\lbrace f(n) | \exists c,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le f(n) &lt; cg(n) \rbrace$$</p>
<blockquote>
<ul>
<li>此时可称$f(n)$渐近小于$g(n)$，当n足够大时，$f(n)$相比于$g(n)$来说变得微不足道，可以这样来证明：<br>$$\lim_{n \to \infty} \cfrac {f(n)}{g(n)} = 0$$</li>
<li>非渐近紧确上界具有传递性</li>
</ul>
</blockquote>
<h3 id="渐近下界记号-Omega"><a href="#渐近下界记号-Omega" class="headerlink" title="渐近下界记号$\Omega$"></a>渐近下界记号$\Omega$</h3><p>定义：对于给定函数$g(n)$，$\Omega(g(n))$定义如下：<br>$$\Omega(g(n))=\lbrace f(n) | \exists c,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le cg(n) \le f(n) \rbrace$$</p>
<blockquote>
<ul>
<li>此时，$f(n) \in \Omega(g(n))$也可以表示成$f(n) = \Omega(g(n))$</li>
<li>此时，我们称$g(n)$是$f(n)$的一个渐近下界</li>
<li>渐进下界用于描述算法最好情况下的运行时间</li>
<li>紧确下界：最大的渐近下界</li>
</ul>
<p>渐近下界具有自反性、传递性</p>
</blockquote>
<p>非渐近紧确下界$\omega$：渐近下界除去紧确下界，定义如下<br>$$\omega(g(n))=\lbrace f(n) | \exists c,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le cg(n) &lt; f(n) \rbrace$$</p>
<blockquote>
<ul>
<li>此时可称$f(n)$渐近大于$g(n)$，当n足够大时，$g(n)$相比于$f(n)$来说变得微不足道</li>
<li>非渐近紧确下界具有传递性</li>
</ul>
</blockquote>
<p>由定义可知，$O,\Omega$、$o,\omega$具有转置对称性（互为逆运算）</p>
<h3 id="渐近紧确界记号-Theta"><a href="#渐近紧确界记号-Theta" class="headerlink" title="渐近紧确界记号$\Theta$"></a>渐近紧确界记号$\Theta$</h3><p>定义：对于给定函数$g(n)$，$\Theta(g(n))$定义如下：<br>$$\Theta(g(n))=\lbrace f(n) | \exists c_1,c_2,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le c_1g(n) \le f(n) \le c_2g(n) \rbrace$$</p>
<blockquote>
<ul>
<li>此时，$f(n) \in \Theta(g(n))$也可以表示成$f(n) = \Theta(g(n))$</li>
<li>此时，我们称$g(n)$是$f(n)$的一个渐近紧确界</li>
<li>$g(n)$是$f(n)$的一个渐近紧确界 等价于 $g(n)$是$f(n)$的一个渐近上界（紧确上界）且$g(n)$是$f(n)$的一个渐近下界（紧确下界）</li>
</ul>
<p>渐近紧确具有自反、传递、对称性</p>
</blockquote>
<h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><blockquote>
<ul>
<li>算法实际执行时间$f(n)$与执行世纪情况有关</li>
<li>分析所得限界函数$g(n)$是一个与机器无关的函数</li>
<li>一般地，对于任意多项式$p(n) = \sum_{i=0}^da_in^i,a_d &gt; 0$有$p(n)=\Theta(n^d)$</li>
<li>并非所有函数之间都是渐近可比较的，如$n$和$n^{1+sin(n)}$</li>
</ul>
</blockquote>
<p>当等式或不等式中出现渐近记号</p>
<blockquote>
<ul>
<li>等式中的渐近记号表示另一边的函数属于某一个函数集合</li>
<li>渐近记号可以替代公式中的一些无关紧要的细节，我们将其解释为匿名函数</li>
</ul>
</blockquote>
<h2 id="3-2-算法时间复杂度分类"><a href="#3-2-算法时间复杂度分类" class="headerlink" title="3.2 算法时间复杂度分类"></a>3.2 算法时间复杂度分类</h2><h1 id="四、分治策略"><a href="#四、分治策略" class="headerlink" title="四、分治策略"></a>四、分治策略</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><h3 id="递归式求解方法"><a href="#递归式求解方法" class="headerlink" title="递归式求解方法"></a>递归式求解方法</h3><blockquote>
<ul>
<li>代入法</li>
<li>递归树法</li>
<li>主方法</li>
</ul>
</blockquote>
<h2 id="4-1-最大子数组问题"><a href="#4-1-最大子数组问题" class="headerlink" title="4.1 最大子数组问题"></a>4.1 最大子数组问题</h2><p>炒股问题：最大子数组问题</p>
<blockquote>
<ul>
<li>即，已知数组A，需要寻找A的和最大的非空连续子数组</li>
</ul>
</blockquote>
<p>跨界问题</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/09/08/algorithm0/" data-id="ckf5ehrba0008p0vndbs39pj3"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-operating-system0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/08/operating-system0/"
    >操作系统原理概论</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/08/operating-system0/" class="article-date">
  <time datetime="2020-09-08T00:55:17.000Z" itemprop="datePublished">2020-09-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>李培峰：<a href="mailto:pfli_suda@126.com">pfli_suda@126.com</a>; 13606216291</p>
<p>课程内容和要求：</p>
<blockquote>
<ul>
<li>掌握操作系统的基本原理和组成结构</li>
<li>掌握基本概念和相关新概念、名词及术语</li>
<li>理解各组成部分之间的关系、结构和综合工作原理</li>
<li>分析、修改和设计操作系统的功能</li>
<li>使用基本的操作系统</li>
<li>学习内容：导论、进程管理、内存管理、存储管理；会穿插案例研究内容</li>
</ul>
</blockquote>
<p>广义上，操作系统是数据结构的衍生，涵盖数据结构、算法和编程</p>
<blockquote>
<ul>
<li>先修课程：汇编语言程序设计、c和java、计算机组成、数据结构、面向对象程序设计</li>
</ul>
</blockquote>
<p>参考书目：《现代操作系统Andrew.S》（偏向实例）、《操作系统精髓与设计原理》（更偏向实例系统）</p>
<p>一个视频<a href="https://vo.youku.com/v_show/id_XMTAwNTg5MzA0.html" target="_blank" rel="noopener">https://vo.youku.com/v_show/id_XMTAwNTg5MzA0.html</a></p>
<p>平时成绩20%、期中考试20%、期末考试60%</p>
<h2 id="主流操作系统介绍"><a href="#主流操作系统介绍" class="headerlink" title="主流操作系统介绍"></a>主流操作系统介绍</h2><p>主流PC操作系统：</p>
<blockquote>
<ul>
<li>1969 UNIX：C和汇编语言编写，世界上用途最广泛的操作系统</li>
<li>1974 CP/M：第一个微机操作系统</li>
<li>1981 MS－DOS：为用户上机操作和应用软件开发提供良好的用户外部环境</li>
<li>1984 MAC OS：第一款成功的含有图形化用户界面的操作系统</li>
<li>1985 Windows：最成功的个人微机操作系统</li>
<li>1991 LINUX：未来最有前途的操作系统之一</li>
</ul>
</blockquote>
<p>主流手机操作系统：</p>
<blockquote>
<ul>
<li>1999 SYMBIAN：实时的，多任务的纯32位操作系统；智能手机开创者</li>
<li>2007.11.5 ANDROID: 开放的操作系统</li>
<li>2007 IOS：优秀的封闭的操作系统</li>
<li>2008 BLACKBERRY：加密性更强，更安全；融入了办公商务功能</li>
<li>Windows Phone：从Pocket PC到Windows Mobile到Windows Phone;和Windows兼容性好</li>
</ul>
</blockquote>
<h1 id="一、导论"><a href="#一、导论" class="headerlink" title="一、导论"></a>一、导论</h1><h2 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><p>操作系统是沟通计算机硬件和系统程序与应用程序的桥梁</p>
<p>操作系统的目标：</p>
<blockquote>
<ul>
<li>核心目标：运行用户程序</li>
<li>面相用户：更方便使用计算机（方便性）</li>
<li>面相系统：更高效使用计算机（高效性）</li>
</ul>
</blockquote>
<h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>操作系统没有一个清晰的定义</p>
<blockquote>
<ul>
<li>极大化：当你预定一个操作系统时零售商所装的所有东西</li>
<li>极小化：内核是操作系统（一直运行在计算机上的程序）</li>
</ul>
</blockquote>
<p>内核Kernel：</p>
<blockquote>
<ul>
<li>内核是一个一直运行在计算机上的程序</li>
<li>内核是计算机运行必不可少的组成部分</li>
</ul>
</blockquote>
<h3 id="操作系统的硬件结构"><a href="#操作系统的硬件结构" class="headerlink" title="操作系统的硬件结构"></a>操作系统的硬件结构</h3><blockquote>
<ul>
<li>一个或多个CPU和内存</li>
<li>若干通过总线相连的设备控制器及其设备</li>
<li>总线</li>
<li>CPU和设备控制器可并行工作，并竞争内存</li>
</ul>
</blockquote>
<h2 id="1-2-多道程序设计和分时"><a href="#1-2-多道程序设计和分时" class="headerlink" title="1.2 多道程序设计和分时"></a>1.2 多道程序设计和分时</h2><h3 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h3><p>从无操作系统（EANIC）到简单批处理系统</p>
<blockquote>
<ul>
<li>批处理：一批无需人机交互的作业批量运行</li>
<li>简单批处理系统的核心是一个常驻监控程序，以作业为单位自动调度程序执行</li>
</ul>
</blockquote>
<p>过程：</p>
<blockquote>
<ul>
<li>程序员在小型机上编程</li>
<li>操作员将程序装入大型机运行</li>
<li>操作员将结果取出</li>
<li>程序员将结果在小型机上打印出来</li>
</ul>
</blockquote>
<p>简单批处理系统大大提高了计算机运行的效率，但没有充分利用cpu的IO并行性</p>
<h3 id="多道程序系统"><a href="#多道程序系统" class="headerlink" title="多道程序系统"></a>多道程序系统</h3><blockquote>
<ul>
<li>单用户同城不能总使得CPU和设备在所有时间内都忙碌</li>
<li>多道程序在内存中同时存在多道作业，在管理程序控制下相互穿插运行</li>
</ul>
</blockquote>
<p>策略：</p>
<blockquote>
<ul>
<li>通过作业调度(Job Scheduling)选中一个作业并运行</li>
<li>当该作业必须等待时 (如等待I/O), 切换到另一个作业运行</li>
</ul>
</blockquote>
<p>目的：提高CPU利用率，充分发挥计算机系统部件的并行性</p>
<p>并行和并发：</p>
<blockquote>
<ul>
<li>并行：两个或多个作业在同一时刻运行</li>
<li>并发：两个或多个作业在同一时间间隔内依次运行，同一时间点只有一个作业在处理机上运行</li>
</ul>
<blockquote>
<ul>
<li>并发在微观上相当于串行，在宏观上相当于并行</li>
<li>随着多核处理器的出现，并行和并发两个概念并不严格区分</li>
</ul>
</blockquote>
</blockquote>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>分时系统(或多任务)是多道程序设计的延伸</p>
<p>作业分类：</p>
<blockquote>
<ul>
<li>批处理作业：不需要人为干预</li>
<li>交互作业：需要人为干预；交互作业要求较高的响应时间，需要使用多道程序设计技术</li>
<li>响应时间：用户提交操作到操作系统执行操作之间的时间</li>
</ul>
</blockquote>
<p>时间片：</p>
<blockquote>
<ul>
<li>把一段CPU时间按照固定单位进行分割，每个分割得到的时间段称为一个时间片</li>
<li>每个任务依次轮流使用时间片</li>
</ul>
</blockquote>
<p>分时系统是一种联机的多用户交互式操作系统：</p>
<blockquote>
<ul>
<li>一般采用时间片轮转的方式使一台计算机为多个用户服务；在单位时间内，每个用户获得一个时间片运行</li>
<li>若某个作业在分配的时间片用完之前计算还未完成，该作业就暂时中断，等待下一轮；此时，处理机让给另一个作业使用。</li>
<li>这样能保证用于获得足够小的响应时间，并提供交互能力；此时，每个用户好像独占一台计算机</li>
</ul>
</blockquote>
<p>分时系统开销较大，需要一定的资源来管理和切换用户程序；一般来说，（时间）开销应当小于时间片的1/10</p>
<h2 id="1-3-操作系统的类型"><a href="#1-3-操作系统的类型" class="headerlink" title="1.3 操作系统的类型"></a>1.3 操作系统的类型</h2><blockquote>
<ul>
<li>大型机系统：前面所述的简单批处理系统、多道程序系统以及分时系统最早都应用于大型机上</li>
<li>桌面系统：应用于个人计算机PC上</li>
<li>手持（移动）系统：资源有限、具有导航等扩展功能</li>
<li>嵌入式系统：完全潜入受控器件内部；内核较小、专用性强、系统精简、高实时性</li>
<li>分布式系统：松耦合系统，通过网络操作系统；较难实现，目前多为数据分布式系统</li>
<li>多处理器系统：紧耦合系统，有多个紧密通信的处理器的系统，处理器之间共享内存</li>
<li>多核处理器系统：一个芯片多个核，现在一般不与多处理器系统区分<blockquote>
<ul>
<li>对称多处理器SMP：桌面PC处理器</li>
<li>非对称多处理器系统ASMP：高通骁龙</li>
</ul>
</blockquote>
</li>
<li>集群系统：面相超级计算，通过专用网络连接一群计算机，将它们虚拟化为一台有超强能力的计算机给用户使用</li>
<li>实时系统：实时性很高的系统（5G网络设备）</li>
</ul>
</blockquote>
<h2 id="1-4-操作系统的操作和功能"><a href="#1-4-操作系统的操作和功能" class="headerlink" title="1.4 操作系统的操作和功能"></a>1.4 操作系统的操作和功能</h2><h3 id="双模式"><a href="#双模式" class="headerlink" title="双模式"></a>双模式</h3><p>目的：防止程序崩溃或死循环造成整个操作系统崩溃</p>
<p>解决方式：双模式，即用户模式和内核模式</p>
<blockquote>
<ul>
<li>双模式需要CPU硬件支持</li>
<li>允许系统保护自身和其他系统部件</li>
<li>设置特权指令，这些指令只能在内核模式下运行；这些指令通常可能会造成系统崩溃</li>
<li>当用户程序需要使用特权指令特权指令时，可以进行系统调用（一种软件中断）</li>
</ul>
</blockquote>
<p>系统调用过程：</p>
<blockquote>
<ul>
<li>用户程序挂起，申请系统调用</li>
<li>CPU从用户模式切换到内核模式，执行特权指令</li>
<li>CPU从内核模式切换成用户模式，用户程序继续执行</li>
</ul>
</blockquote>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>保护有I/O操作保护和内存保护</p>
<blockquote>
<ul>
<li>I/O保护防止用户程序执行非法I/O；内存保护防止内存的非法访问</li>
<li>IO保护策略：所有IO指令都是特权指令</li>
<li>内存保护策略：建立存储保护机制（硬件支持）</li>
</ul>
</blockquote>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>目的：使得操作系统能够随时获得CPU控制权，从而对系统进行管理</p>
<blockquote>
<ul>
<li>用户程序死循环会造成CPU控制权不能回到操作系统手中</li>
<li>用户程序不调用系统调用也会造成操作系统不能获得CPU控制器</li>
</ul>
</blockquote>
<p>解决方法：定时器</p>
<blockquote>
<ul>
<li>在用户程序运行一段时间后发生中断，CPU控制权返回到操作系统手中</li>
<li>定时器利用时钟和计数器实现，有固定时间和可变时间定时器</li>
</ul>
</blockquote>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>操作系统的核心目标：运行程序<br>进程：运行中的程序<br>CPU/进程管理：对CPU进行管理<br>具体内容<br>创建和删除用户和系统进程<br>暂停和恢复进程<br>提供进程同步机制<br>提供进程通信机制<br>提供死锁处理机制</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>程序运行必须的存储设备<br>CPU只能直接访问寄存器、高速缓存和内存<br>处理前和处理后的所有数据都在内存<br>执行的指令都在内存<br>内存管理：提供内存的分配、回收、地址转换、共享和保护等功能<br>提高内存利用率<br>提高内存访问速度<br>从而提高计算机运行效率</p>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>解决信息在计算机中存储问题<br>以文件为单位，以目录为组织方式构建文件系统<br>内容<br>文件逻辑结构<br>文件物理结构<br>目录<br>文件检索方法<br>文件操作<br>空闲空间管理<br>存储设备管理</p>
<h3 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I/O设备管理"></a>I/O设备管理</h3><p>管理种类繁多的各种I/O设备，解决计算机中信息的输入和输出问题<br>关键：设备无关性(独立性)<br>所有物理设备按照物理特性抽象为逻辑设备<br>应用程序针对逻辑设备编程<br>应用程序和物理设备无关<br>内容<br>设备管理<br>设备驱动</p>
<h1 id="二、操作系统结构"><a href="#二、操作系统结构" class="headerlink" title="二、操作系统结构"></a>二、操作系统结构</h1><h2 id="2-1-操作系统的服务和接口"><a href="#2-1-操作系统的服务和接口" class="headerlink" title="2.1 操作系统的服务和接口"></a>2.1 操作系统的服务和接口</h2><h3 id="操作系统服务"><a href="#操作系统服务" class="headerlink" title="操作系统服务"></a>操作系统服务</h3><p>操作系统以服务的形式向程序和用户提供环境执行程序</p>
<blockquote>
<ul>
<li>基本服务：如用户界面、程序执行、I/O操作等</li>
<li>增值服务：资源分配、统计、保护和安全等</li>
</ul>
</blockquote>
<p>操作系统服务形式：</p>
<blockquote>
<ul>
<li>系统调用</li>
<li>用户接口</li>
<li>系统程序</li>
</ul>
</blockquote>
<h3 id="操作系统程序接口：系统调用"><a href="#操作系统程序接口：系统调用" class="headerlink" title="操作系统程序接口：系统调用"></a>操作系统程序接口：系统调用</h3><p>系统调用是操作系统服务面相程序的接口</p>
<blockquote>
<ul>
<li>它们通常由高级语言编写</li>
<li>程序通过应用程序接口API访问</li>
</ul>
</blockquote>
<p>常见APIs：</p>
<blockquote>
<ul>
<li>Windows中的Win32 API</li>
<li>POSIX系统中断POSIX API</li>
<li>Java虚拟机JVM的Java API</li>
</ul>
</blockquote>
<h3 id="操作系统用户界面"><a href="#操作系统用户界面" class="headerlink" title="操作系统用户界面"></a>操作系统用户界面</h3><p>命令行接口CLI：</p>
<blockquote>
<ul>
<li>字符模式</li>
</ul>
</blockquote>
<p>图形化接口GUI：</p>
<blockquote>
<ul>
<li>用户界面友好的桌面接口</li>
<li>现在还有触摸屏GUI</li>
</ul>
</blockquote>
<p>未来人机接口：</p>
<blockquote>
<ul>
<li>语音操控</li>
<li>体感操控</li>
<li>…</li>
</ul>
</blockquote>
<h3 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h3>
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/09/08/operating-system0/" data-id="ckf5ehrck0024p0vn2dwve89o"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-computer-network0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/09/06/computer-network0/"
    >计算机网络</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/06/computer-network0/" class="article-date">
  <time datetime="2020-09-06T14:33:43.000Z" itemprop="datePublished">2020-09-06</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>钱龙华：<a href="mailto:qianglonghua@suda.edu.cn">qianglonghua@suda.edu.cn</a></p>
<p><a href="http://nlp.suda.edu.cn/˜qianlonghua" target="_blank" rel="noopener">http://nlp.suda.edu.cn/˜qianlonghua</a></p>
<p>课程目标：理解网络工作的原理以及实现</p>
<p>没有多少理论，但课程课程的实践性很强</p>
<p>参考教材：《数据通信与网络》、《计算机网络技术Andrew S.》、《计算机网络自顶向下方法（从宏观到微观的设计）》</p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-计算机网络的发展过程"><a href="#1-1-计算机网络的发展过程" class="headerlink" title="1.1 计算机网络的发展过程"></a>1.1 计算机网络的发展过程</h2><h3 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h3><p>ENAIC - TSS分时系统 - 计算机网络</p>
<p>从以主机为中心到以分组交换网为中心</p>
<p>萌芽：1969第一个分组交换网络ARPANET</p>
<blockquote>
<ul>
<li>路径选择（路由）</li>
<li>信息的发送和接收：通讯协议NCP（网络通讯协议）</li>
<li>基本思想：分组交换</li>
<li>原理：将报文分组进行传送</li>
<li>目的：提高传输效率和减小延迟</li>
</ul>
</blockquote>
<p>从NCP到TCP/IP：</p>
<blockquote>
<ul>
<li>1974年TCP/IP参考模型，1983年TCP/IP模型</li>
</ul>
</blockquote>
<p>LAN（局域网）的兴起</p>
<p>发展：公共网络的繁衍</p>
<blockquote>
<ul>
<li>从军事网络到民用科研网络</li>
<li>1986年，ARPANET改名为Internet</li>
</ul>
</blockquote>
<p>繁荣：网络商业化</p>
<blockquote>
<ul>
<li>通讯公司开始投入构建主干网络ISP</li>
<li>网络应用发展和推广（www、即时通讯、邮件、MOBA游戏）</li>
</ul>
<p>关于计算模式的演变：HOST模式（主机模式）；C/S模式（主机客户端模式）；P2P模式（双端计算任务平等）；网格计算模式-云计算模式</p>
</blockquote>
<h3 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h3><p>互联网工程部IETF、互联网研究部IRTF</p>
<p>互联网标准的形式：RFC文档</p>
<p>互联网正式标准的制定：</p>
<blockquote>
<ul>
<li>互联网草案</li>
<li>建议标准</li>
<li>互联网标准</li>
</ul>
</blockquote>
<h2 id="1-2-计算机网络的分类"><a href="#1-2-计算机网络的分类" class="headerlink" title="1.2 计算机网络的分类"></a>1.2 计算机网络的分类</h2><h3 id="计算机网络的不同定义"><a href="#计算机网络的不同定义" class="headerlink" title="计算机网络的不同定义"></a>计算机网络的不同定义</h3><blockquote>
<ul>
<li>具有独立功能的计算机、终端、设备用通信线路连接起来，按一定方式进行通信并实现资源共享的系统</li>
<li>简单定义：一些相互连接、自治的计算机的集合</li>
<li>因特网是“网络的网络”</li>
</ul>
</blockquote>
<h3 id="信息的交换"><a href="#信息的交换" class="headerlink" title="信息的交换"></a>信息的交换</h3><p>电路交换：从人工控制到程序交换</p>
<blockquote>
<ul>
<li>这种连接是一条专用的物理通路</li>
<li>步骤：建立连接（占用通信资源）、通话（一直占用资源）、释放连接（归还通信资源）</li>
</ul>
</blockquote>
<p>报文交换：存储转发技术</p>
<blockquote>
<ul>
<li>过程：报文整体通过结点的转发达到目标主机</li>
<li>延迟较长</li>
</ul>
</blockquote>
<p>分组交换：将报文整体切割传输</p>
<blockquote>
<ul>
<li>步骤：报文进行切割并发传输，到目标主机再进行组合</li>
<li>主机发送的数据不是独占的，一个用户可以并发的发送或接受数据</li>
<li>可靠性好，网络中结点的损坏对整个网络影响很小</li>
</ul>
</blockquote>
<h3 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h3><p>网络的覆盖范围：</p>
<blockquote>
<ul>
<li>局域网LAN</li>
<li>城域网MAN：有线电视网络</li>
<li>广域网WAN</li>
</ul>
</blockquote>
<p>网络的使用者</p>
<blockquote>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</blockquote>
<p>传输技术</p>
<blockquote>
<ul>
<li>点对点网络</li>
<li>广播网络：涉及寻址、冲突问题</li>
</ul>
</blockquote>
<h2 id="1-3-计算机网络主要性能指标"><a href="#1-3-计算机网络主要性能指标" class="headerlink" title="1.3 计算机网络主要性能指标"></a>1.3 计算机网络主要性能指标</h2><h3 id="带宽和速率"><a href="#带宽和速率" class="headerlink" title="带宽和速率"></a>带宽和速率</h3><p>带宽：原指信号具有的频带宽度（差值）；在数字信号中，带宽是最高数据传输速率，单位是比特每秒</p>
<p>速率：数据的传送速率</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>发送时延（传输时延）：主机或路由器发送数据帧所需要的时间</p>
<blockquote>
<ul>
<li>发送时延 = 数据快长度/带宽</li>
</ul>
</blockquote>
<p>传播时延：电磁波在信道中传播一定的距离需要花费的时间</p>
<blockquote>
<ul>
<li>传播时延 = 信道长度/信号在信道上的传播速率</li>
</ul>
</blockquote>
<p>四种时延产生的地方：</p>
<blockquote>
<ul>
<li>发送结点中的处理时延和排队时延</li>
<li>数据的发送时延和传播时延</li>
</ul>
</blockquote>
<p>往返时延RTT：从发送端发送数据开始，到发送端收到来自接收端的确认信息，总经历的时延</p>
<p>时延带宽积：表示管道中能同时容纳的数据量</p>
<blockquote>
<ul>
<li>时延带宽积 = 传播时延*带宽</li>
</ul>
</blockquote>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率：某信道在某段时间内有百分之几的时间是被利用的（有数据通过）</p>
<p>网络利用率：全网络的信道利用率的加权平均值</p>
<p>信道或网络利用率过高会产生非常大的时延，且随着利用率的升高时延</p>
<h2 id="1-4-计算机网络的体系结构"><a href="#1-4-计算机网络的体系结构" class="headerlink" title="1.4 计算机网络的体系结构"></a>1.4 计算机网络的体系结构</h2><h3 id="网络通信的分层"><a href="#网络通信的分层" class="headerlink" title="网络通信的分层"></a>网络通信的分层</h3><p>网络通信过程十分复杂：</p>
<blockquote>
<ul>
<li>需要简化网络设计</li>
<li>采用结构化的设计方法</li>
<li>使用层次化的分而治之的策略</li>
</ul>
<p>需要提高网络互联的标准化程度</p>
</blockquote>
<p>原理：</p>
<blockquote>
<ul>
<li>网络按功能分成一系列层次，每一层完成一个特定的功能</li>
<li>相邻层中较高层直接使用较低层的服务实现本层功能，然后向更高层提供服务</li>
<li>层之间的通信用接口实现</li>
</ul>
</blockquote>
<p>服务、接口和协议：</p>
<blockquote>
<ul>
<li>实体：一个特定的网络模块、软件</li>
<li>对等实体：不同计算机上同一层的实体</li>
<li>协议：为进行计算机网络中的数据交换而建立的规则、标准或约定的集合</li>
<li>接口：相邻两层之间的边界；规定了下层向上层提供的服务</li>
<li>服务：某一层向上层提供的功能</li>
<li>网络体系结构：计算机网络各层级及其协议的集合</li>
<li>协议栈：网络各层协议按照层次顺序排列而形成的协议序列</li>
</ul>
</blockquote>
<p>多层通信的实质：</p>
<blockquote>
<ul>
<li>发送段将数据一层一层向下封装（直到实体通信层）</li>
<li>接收端将数据一层一层向上解封</li>
<li>这样，对等实体层之间形成虚拟通信</li>
</ul>
</blockquote>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>网络协议的三个要素：</p>
<blockquote>
<ul>
<li>语义：设计需要发出何种控制信息，以及如何回应的规范</li>
<li>语法：设计数据与控制信息的结构与格式</li>
<li>时序：设计速度匹配与事件顺序</li>
</ul>
</blockquote>
<p>协议的困惑：无法设计一个100%可靠的协议（山头进攻问题）</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>面相连接的服务：面向连接服务具有连接建立、数据传输和连接释放三个阶段</p>
<p>无连接服务：两个实体之间通信不需要先建立好连接</p>
<h3 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h3><p>OSI参考模型：开放系统互联模型</p>
<blockquote>
<ul>
<li><p>从下到上分为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层</p>
</li>
<li><p>前三层为网络支持层，解决数据如何传输的问题</p>
</li>
<li><p>第四层解决可靠性问题</p>
</li>
<li><p>后三层为用户子网络，决定传输什么数据</p>
</li>
<li><p>物理层：在<strong>物理媒体</strong>上传输原始数据的<strong>比特流</strong></p>
</li>
<li><p>数据链路层：在<strong>相邻节点</strong>间无差错地传输一<strong>帧</strong>数据</p>
</li>
<li><p>网络层：将<strong>分组</strong>穿过<strong>通信子网</strong>从信源传输到信宿，包括路由选择等；这一层的通讯不一定可靠</p>
</li>
<li><p>传输层：提供端到端的数据传输服务，强调可靠性，往往采用面相连接的传输服务，进行差错控制（开始面相用户）</p>
</li>
<li><p>会话层：在两个互相通信的进程之间建立、组织和同步会话以及会话管理和控制</p>
</li>
<li><p>表示层：提供数据或信息语法的表示变换，以确保不同表示方法（加密算法等）之间的计算机能够相互通讯</p>
</li>
<li><p>应用层：直接面相用户（或应用进程，如DNS）提供服务</p>
</li>
</ul>
</blockquote>
<p>缺点：层次过多传送少量数据时效率极其低下</p>
<p>TCP/IP参考模型：</p>
<blockquote>
<ul>
<li>从下到上分为网络接口层、网络互联层（网际层）、传输层、应用层</li>
<li>网络接口层：负责传输数据帧，类似物理层和数据链路层</li>
<li>网际层（IP）：相当于网络层</li>
<li>传输层（TCP或UDP）：相当于OSI中的传输层</li>
<li>应用层：各种应用服务，相当于会话层、表示层和应用层</li>
</ul>
</blockquote>
<p>IP体系的沙漏模型：核心是IP网际层</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/09/06/computer-network0/" data-id="ckf5ehrbq000op0vn7fzabxmf"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-object-oriented0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/21/object-oriented0/"
    >面向对象分析与设计</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/21/object-oriented0/" class="article-date">
  <time datetime="2020-06-21T08:02:53.000Z" itemprop="datePublished">2020-06-21</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>课程定义:</p>
<blockquote>
<ul>
<li>面向对象分析与设计是一种思维方式</li>
<li>面向对象分析与设计是一种思考如何用面向对象方法去思考的课程</li>
</ul>
</blockquote>
<p>关于思维方式: 思维方式有无数种,而本课程要学习面向对象思维方式;并利用它去思考实际问题</p>
<p>前导知识:</p>
<blockquote>
<ul>
<li>UML统一建模语言</li>
<li>面向对象的编程语言</li>
<li>设计模式: 用于解决实际问题的一些框架</li>
<li>分析系统</li>
</ul>
</blockquote>
<p>思考的问题:</p>
<blockquote>
<ul>
<li>为何要设计,什么是好的设计,什么是面向对象设计,它有何优势,如何去设计</li>
</ul>
</blockquote>
<p>要细致分析问题: 先有问题后有解决方案</p>
<h1 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1 面向对象"></a>1 面向对象</h1><h2 id="1-1-面向对象思想的起源"><a href="#1-1-面向对象思想的起源" class="headerlink" title="1.1 面向对象思想的起源"></a>1.1 面向对象思想的起源</h2><ul>
<li>Alan.Kay: 所有对事物的认识都始源于我们不愿盲目地接受(相信)这个世界<blockquote>
<ul>
<li>Smalltalk: 第一个面向对象编程语言,1971年<br>在Smalltalk中,相互独立的个体通过发送讯息彼此交流; 每一条讯息都包含了数据,发送者地址,接收者地址,以及有关接收者如何对数据实施操作的指令</li>
</ul>
</blockquote>
</li>
</ul>
<p>将数据和过程捆绑到一起发送为面向对象设计打下了基础</p>
<p>生物学启发:</p>
<blockquote>
<ul>
<li>每个细胞都有一些共同的基本行为</li>
<li>每个细胞都能独立运作,它们之间能通过化学信号进行通信</li>
<li>细胞会分化</li>
</ul>
</blockquote>
<p>Alan Kay的思考:</p>
<blockquote>
<ul>
<li>关注消息机制和模块间的松耦合和交互,而非模块内部的对象组成</li>
<li>好的系统应设计好模块之间如何通讯,而不是模块应具有什么样的内部属性和行为方法</li>
</ul>
</blockquote>
<p>面向对象举例:打车去机场</p>
<blockquote>
<ul>
<li>面向对象: 去机场</li>
<li>面向过程: 直走,左拐,过桥,靠边…</li>
</ul>
</blockquote>
<h2 id="1-2-面向对象基本概念"><a href="#1-2-面向对象基本概念" class="headerlink" title="1.2 面向对象基本概念"></a>1.2 面向对象基本概念</h2><ul>
<li>类</li>
<li>对象</li>
</ul>
<p>在面向对象思维中:</p>
<blockquote>
<ul>
<li>每一样东西都是对象</li>
<li>一个程序就是一大群对象,通过消息要求对方做点事情</li>
<li>每个对象都有自己的内存空间,里面存放了许多其他对象</li>
<li>每个对象都是一个类的实例</li>
<li>某一类型的所有对象都能接受相同的消息</li>
</ul>
</blockquote>
<h2 id="1-3-什么是面向对象的思考方式"><a href="#1-3-什么是面向对象的思考方式" class="headerlink" title="1.3 什么是面向对象的思考方式"></a>1.3 什么是面向对象的思考方式</h2><ul>
<li>软件工程是与人打交道的,是为人提供服务的<blockquote>
<ul>
<li>问题是什么</li>
<li>谁遇到了问题</li>
<li>本质是什么</li>
<li>问题该如何解决</li>
</ul>
<p>将单一的思维模式转换成多重的思维模式</p>
</blockquote>
</li>
</ul>
<p>定义: 在对世界/系统进行观察/建模的时候,将它们看成一系列相互交流 互相影响的对象集合</p>
<blockquote>
<ul>
<li>世界是由相互作用的对象组成的</li>
<li>面向对象描述与构建由对象组成系统</li>
</ul>
</blockquote>
<p>面向对象与面向过程:</p>
<blockquote>
<ul>
<li>面向对象适合解决不确定的事件和创新性的事件</li>
<li>面向过程适合处理已知的事实,重要条件都已知的场景</li>
</ul>
</blockquote>
<h2 id="1-4-面向对象核心特征"><a href="#1-4-面向对象核心特征" class="headerlink" title="1.4 面向对象核心特征"></a>1.4 面向对象核心特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<ul>
<li>封装隐藏了对象的实现细节</li>
<li>内部状态不能被访问</li>
<li>对象数据只能通过接口进行访问</li>
</ul>
</blockquote>
<p>封装可以</p>
<blockquote>
<ul>
<li>保护隐私和数据安全</li>
<li>隔离复杂度</li>
</ul>
</blockquote>
<p>封装的内容:</p>
<blockquote>
<ul>
<li>内部信息</li>
<li>类的属性</li>
<li>类的方法</li>
</ul>
</blockquote>
<p>封装的可见性</p>
<blockquote>
<ul>
<li>Public</li>
<li>Private</li>
<li>Protected</li>
<li>Package</li>
</ul>
</blockquote>
<p>封装原则:</p>
<blockquote>
<ul>
<li>非必要信息都进行封装</li>
<li>只提供必要的接口</li>
</ul>
</blockquote>
<h3 id="继承Inheritance"><a href="#继承Inheritance" class="headerlink" title="继承Inheritance"></a>继承Inheritance</h3><p>子类继承父类所有的属性和方法,并添加了自己的属性和方法</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>子类对父类的同一个方法有不同的表达方式</p>
<h3 id="聚合Aggregation-组合Composition"><a href="#聚合Aggregation-组合Composition" class="headerlink" title="聚合Aggregation,组合Composition"></a>聚合Aggregation,组合Composition</h3><p>聚合是一种描述整体和部分的关系(包含关系)</p>
<blockquote>
<ul>
<li>继承是一种”is a”关系,聚合是一种”has a”关系(学校与学生)</li>
<li>聚合是传递的</li>
<li>聚合是不对称的</li>
</ul>
</blockquote>
<p>组合是一种特殊的聚合,它强调整体对部分的控制</p>
<blockquote>
<ul>
<li>部分对象只能存在于整体对象之中,整体对象控制着部分对象的生命周期</li>
<li>如果整体消失,那么部分也将不复存在(手掌与手指的关系)</li>
<li>在某些时候,聚合与组合关系不是很明确,此时多用聚合</li>
</ul>
</blockquote>
<h3 id="接口Interface-实现Implementation"><a href="#接口Interface-实现Implementation" class="headerlink" title="接口Interface,实现Implementation"></a>接口Interface,实现Implementation</h3><p>接口用于描述一个类的用户如何与这个类交互</p>
<blockquote>
<ul>
<li>接口只定义功能,不具有功能,不提供实现</li>
</ul>
</blockquote>
<p>接口对于软件系统的意义:</p>
<blockquote>
<ul>
<li>软件系统中有大量互相关联的类互相通信</li>
<li>接口能够使得对某一个类的局部修改不会影响其他类</li>
</ul>
</blockquote>
<p>实现是完成接口所定义的功能的一种操作</p>
<blockquote>
<ul>
<li>如: 电视机是用户,插座是接口,发电厂是实现</li>
</ul>
</blockquote>
<h3 id="抽象Abstraction"><a href="#抽象Abstraction" class="headerlink" title="抽象Abstraction"></a>抽象Abstraction</h3><p>抽象表示一个对象与其他所有对象区别的基本特征</p>
<blockquote>
<ul>
<li>类是具体对象的抽象,父类是对其子类的抽象</li>
<li>继承的强大之处就在于它的抽象和组织技术</li>
</ul>
</blockquote>
<h1 id="2-UML"><a href="#2-UML" class="headerlink" title="2 UML"></a>2 UML</h1><h2 id="2-1-建模工具UML"><a href="#2-1-建模工具UML" class="headerlink" title="2.1 建模工具UML"></a>2.1 建模工具UML</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>建模: 将未知事物与一些类似的已知事物进行比较来理解这些未知事物的过程</p>
<blockquote>
<ul>
<li>重要的研发成果常常产自类比</li>
<li>模型: 建模产生的结果,它是对现实世界的简化,是对事物的一种抽象</li>
<li>在模型中剔除一些与问题无关的事物,简化模型,可以帮助人们更好地了解事物本质,抓住问题的要害</li>
</ul>
</blockquote>
<p>建模的意义:</p>
<blockquote>
<ul>
<li>完整地理解一个复杂系统是困难的,建模可以最系统进行更好地理解</li>
<li>将目标系统可视化</li>
<li>提供详细描述系统的结构和行为的思路</li>
<li>给出指导我们构造系统的一个模板</li>
<li>对我们所做出的决策进行模板化</li>
</ul>
</blockquote>
<p>建模的基本原理</p>
<blockquote>
<ol>
<li>要选择建立什么模型: 同一事物可以用不同的模型来描述,对解决问题的帮助也是不一样的</li>
<li>模型的精度: 同一模型可以在不同的精度级别上表示(纸飞机和飞机模型)</li>
<li>模型与现实的关联性: 好的模型应当是与现实相关联的,可简化但不能掩盖掉任何重要的细节</li>
<li>可选择多个模型来描述同一系统: 单个模型通常是不充分的,对每一个重要的系统最好用一组几乎独立的模型去处理(盲人摸象,三视图)</li>
</ol>
</blockquote>
<h3 id="统一建模语言UML"><a href="#统一建模语言UML" class="headerlink" title="统一建模语言UML"></a>统一建模语言UML</h3><p>UML:Unified Modeling Language</p>
<blockquote>
<ul>
<li>UML是软件分析师,设计师的工具包; 是用于建模的工具</li>
<li>UML由事物,关系,图三个部分构成<br><img src="/2020/06/21/object-oriented0/UML0.jpg" alt="UML"></li>
</ul>
</blockquote>
<p>UML中的常用符号<br><img src="/2020/06/21/object-oriented0/UML1.jpg" alt="UML"></p>
<h2 id="2-2-用例模型"><a href="#2-2-用例模型" class="headerlink" title="2.2 用例模型"></a>2.2 用例模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>用例模型包含系统边界,参与者,用例,用例图,用例描述</p>
<p>用例模型是系统分析的结果,是系统设计的输入,是开发部门与顾客之间的合同,是软件设计部门和软件工程师之间的合同</p>
<p>用例模型是非直接开发人员,了解系统的主要信息来源</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p>参与者(执行者)Actor: 是位于系统之外和系统进行交互的一类事物(人,物或其他软件子系统)</p>
<blockquote>
<ul>
<li>通过参与者可以对软件系统与外界发生的交互进行分析和描述</li>
<li>通过参与者可以了解客户希望的软件系统所具有的功能</li>
</ul>
<p>参与者用小人图(参与者为人)或构造型方框图(参与者为系统)表示</p>
</blockquote>
<p>系统参与者的寻找方式:</p>
<blockquote>
<ul>
<li>系统使用者</li>
<li>系统安装,维护者</li>
<li>系统启功,关闭者</li>
<li>系统获取的信息来源,系统提供信息的去向</li>
<li>系统交互中的角色扮演者</li>
<li>其他相关联系统</li>
<li>内/外部定时器(于特定时间发生的事件)</li>
</ul>
<p>对每一类参与者要有简短的描述</p>
</blockquote>
<p>找出系统中所有的参与者,并与其交流,得到他们所希望的系统具有的功能,并进行整合</p>
<h3 id="用例和用例图"><a href="#用例和用例图" class="headerlink" title="用例和用例图"></a>用例和用例图</h3><p>用例(用况)Usecase: 系统为响应参与者引发的事件而执行的一系列能够为其(参与者)产生有价值的结果的处理/动作</p>
<blockquote>
<ul>
<li>这些动作不但应包含正常情况的动作序列,还应包含对非正常状况时的动作描述</li>
</ul>
</blockquote>
<p>用例图是由边界,参与者,用例和关系组成<br><img src="/2020/06/21/object-oriented0/Usercase0.jpg" alt="Usercase0.jpg"></p>
<p>用例图中的关系:</p>
<blockquote>
<p><img src="/2020/06/21/object-oriented0/Usercase1.jpg" alt="Usercase1.jpg"></p>
<ul>
<li>参与者与用例之间: 关联关系,实线</li>
<li>参与者与参与者之间的关系: 可以为泛化关系,实线+空心箭头</li>
<li>用例之间的关系: 泛化,包含(include)或扩展(extend)关系</li>
</ul>
</blockquote>
<p>用例的寻找:</p>
<blockquote>
<ul>
<li>参与者希望系统提供什么功能</li>
<li>系统是否存储和检索信息</li>
<li>当系统状态改变时是否通知参与者</li>
<li>是否存在影响系统的外部事件,这些事件由哪些参与者通知系统</li>
<li>哪个参与者触发了活动</li>
</ul>
</blockquote>
<p>用例的名称</p>
<blockquote>
<ul>
<li>每个用例都有一个名称</li>
<li>名称不需要太长,可用短小精悍的动名词</li>
</ul>
</blockquote>
<h3 id="用例描述"><a href="#用例描述" class="headerlink" title="用例描述"></a>用例描述</h3><p>用例描述(Usecase Description)是对用例的一种详尽的文字描述<br><img src="/2020/06/21/object-oriented0/UseDes0.jpg" alt="UseDes"></p>
<p>用例描述格式:</p>
<blockquote>
<ul>
<li>总括</li>
<li>参与者列表</li>
<li>先决条件描述</li>
<li>用例执行描述</li>
<li>后置条件描述(用例执行完之后系统应当处于什么状态)</li>
<li>异常描述</li>
</ul>
</blockquote>
<h2 id="2-3-活动图"><a href="#2-3-活动图" class="headerlink" title="2.3 活动图"></a>2.3 活动图</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>活动图描述了在一个过程中,顺序/并行的活动及其之间的关系</p>
<blockquote>
<ul>
<li>其应用于商业过程,工作流(业务过程),复杂算法的建模</li>
<li>从形式上看,活动图是顶点和弧的集合</li>
</ul>
</blockquote>
<h3 id="活动基本元素"><a href="#活动基本元素" class="headerlink" title="活动基本元素"></a>活动基本元素</h3><p><img src="/2020/06/21/object-oriented0/Action0.jpg" alt="Action"></p>
<ul>
<li>活动图的开始,结束,对象</li>
</ul>
<p><img src="/2020/06/21/object-oriented0/Action1.jpg" alt="Action"></p>
<ul>
<li>活动节点: 一个活动是一个过程的非原子的执行单元,活动的执行最终延伸为一些独立动作(Action)的执行</li>
</ul>
<p><img src="/2020/06/21/object-oriented0/Action2.jpg" alt="Action"></p>
<ul>
<li>活动分支: 一个进入流,多个离去流; 每个分支都有唯一的条件; 多个控制路径可以无条件合并</li>
</ul>
<p><img src="/2020/06/21/object-oriented0/Action3.jpg" alt="Action"></p>
<ul>
<li><p>分岔和汇合(同步棒):表示多个动作可同时进行</p>
</li>
<li><p>泳道: 将活动按实际需要分组,每个组完成一些特定的活动,用竖线隔开</p>
<blockquote>
<ul>
<li>每个活动只属于一个组,但同步棒可以跨过泳道</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="2-4-类图"><a href="#2-4-类图" class="headerlink" title="2.4 类图"></a>2.4 类图</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>类图将软件设计中与类相关的元素以图的方式展现出来</p>
<blockquote>
<ul>
<li>类图是一种静态视图,是软件设计强有力的武器</li>
</ul>
</blockquote>
<p>类图能够表示的信息(创建类图需要思考的问题):</p>
<blockquote>
<ul>
<li>有多少个类</li>
<li>每个类需要定义多少个属性</li>
<li>每个类需要多少个方法</li>
<li>类之间的关系</li>
<li>类之间的信息交互及功能的完成</li>
</ul>
</blockquote>
<h3 id="类图中的常用UML元素"><a href="#类图中的常用UML元素" class="headerlink" title="类图中的常用UML元素"></a>类图中的常用UML元素</h3><p><img src="/2020/06/21/object-oriented0/Class0.jpg" alt="Class"></p>
<h3 id="类元素的命名"><a href="#类元素的命名" class="headerlink" title="类元素的命名"></a>类元素的命名</h3><blockquote>
<ul>
<li>类名中每个词的第一个字母通常大写</li>
<li>操作和属性名命名遵循驼峰法则</li>
</ul>
</blockquote>
<h3 id="关联关系的修饰"><a href="#关联关系的修饰" class="headerlink" title="关联关系的修饰"></a>关联关系的修饰</h3><p><img src="/2020/06/21/object-oriented0/Association0.jpg" alt></p>
<p><img src="/2020/06/21/object-oriented0/Association1.jpg" alt></p>
<p><img src="/2020/06/21/object-oriented0/Association2.jpg" alt></p>
<p><img src="/2020/06/21/object-oriented0/Association3.jpg" alt></p>
<h2 id="2-5-顺序图"><a href="#2-5-顺序图" class="headerlink" title="2.5 顺序图"></a>2.5 顺序图</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>顺序图从时间方面反映程序运行时不同对象之间的交互情况</p>
<blockquote>
<ul>
<li>顺序图是一种动态视图,是软件设计强有力的武器</li>
<li>顺序图可以动态验证类模型的可行性</li>
<li>顺序验证的某一功能应当属于某个用例描述的功能中的一部分(顺序图又称用例实现)</li>
<li>顺序图从上到下反映了对象间相互协作的时间顺序</li>
</ul>
</blockquote>
<h3 id="顺序图的元素"><a href="#顺序图的元素" class="headerlink" title="顺序图的元素"></a>顺序图的元素</h3><p>概念:</p>
<blockquote>
<ul>
<li>交互: 对象之间为实现某一功能而实施的协作过程</li>
<li>消息: 对象之间的协作和交流表现为一个对象以某种方式启动另一个对象(一个对象调用另外一个对象的方法)</li>
</ul>
</blockquote>
<p>建模元素:</p>
<blockquote>
<ul>
<li>对象(角色)</li>
<li>参与者</li>
<li>消息</li>
</ul>
<p>顺序图是一种交互图(通信图也是),是用于描述交互的过程</p>
</blockquote>
<h3 id="消息-交互的基本概念"><a href="#消息-交互的基本概念" class="headerlink" title="消息: 交互的基本概念"></a>消息: 交互的基本概念</h3><p>同步消息: 源对象直接发送消息给目标对象并阻塞,待接到目标对象的回应后继续执行</p>
<p>异步消息: 源对象将消息发到目标对象的消息接收队列中,然后继续执行,并定时检查自己的消息接收队列是否接到目标对象的回复</p>
<h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p><img src="/2020/06/21/object-oriented0/Order0.jpg" alt></p>
<blockquote>
<ul>
<li>纵向是时间线,横向是对象列表</li>
<li>对象生存线用虚线表示</li>
<li>控制焦点用长矩形表示(控制焦点可以嵌套)</li>
<li>方法调用以箭头表示</li>
<li>可以对消息进行消息序号的标注</li>
</ul>
</blockquote>
<p>顺序图的流程控制:<br><img src="/2020/06/21/object-oriented0/Order1.jpg" alt></p>
<blockquote>
<ul>
<li>可选执行(if): opt</li>
<li>条件执行(switch): alt</li>
<li>并行执行: par</li>
<li>循环执行: loop</li>
</ul>
</blockquote>
<h2 id="2-6-通信图"><a href="#2-6-通信图" class="headerlink" title="2.6 通信图"></a>2.6 通信图</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>通信图从对象之间的结构关系反映程序运行时不同对象之间的交互情况</p>
<blockquote>
<ul>
<li>通信图与顺序图本质上是一样的,只是建模角度不同</li>
</ul>
</blockquote>
<h3 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h3><p>通信图由对象,链接,在链接上传递的消息构成<br><img src="/2020/06/21/object-oriented0/Message0.jpg" alt></p>
<blockquote>
<ul>
<li>对象之间的关联关系用链接线(实线)表示</li>
<li>通过链接线上加标签来显示对象间的交互情况</li>
</ul>
</blockquote>
<h2 id="2-7-状态图"><a href="#2-7-状态图" class="headerlink" title="2.7 状态图"></a>2.7 状态图</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>状态图用于描述单个对象的动态行为</p>
<blockquote>
<ul>
<li>单个对象可以是系统,模块或构件</li>
<li>这个对象应该是系统中的核心,需要进行详细分析</li>
<li>选择对象应作为一个整体考察</li>
</ul>
</blockquote>
<h3 id="状态和状态机"><a href="#状态和状态机" class="headerlink" title="状态和状态机"></a>状态和状态机</h3><p>状态是对象生命周期中的一个条件或状况</p>
<blockquote>
<ul>
<li>在此期间,对象可以响应事件,执行活动等</li>
</ul>
</blockquote>
<p>状态的组成部分:</p>
<blockquote>
<ul>
<li>名称</li>
<li>进入/退出动作</li>
<li>内部迁移(内部迁移不改变整体的状态)</li>
<li>子状态</li>
<li>延迟事件</li>
</ul>
</blockquote>
<p>状态机:</p>
<blockquote>
<ul>
<li>状态机是一种对象行为</li>
<li>状态机反映对象在生命周期中所经历的状态序列以及对每个接收事件的响应情况</li>
</ul>
</blockquote>
<p>状态图用于将状态机可视化,它强调从状态到其他状态的控制流</p>
<h3 id="事件和迁移"><a href="#事件和迁移" class="headerlink" title="事件和迁移"></a>事件和迁移</h3><p>事件是一个在时间和空间上对对象有意义的事情的描述</p>
<blockquote>
<ul>
<li>在状态机中,一个事件能够触发一个状态迁移</li>
</ul>
</blockquote>
<p>UML对以下事件进行建模:</p>
<blockquote>
<ul>
<li>参量变化: 内部事件导致参数的变化</li>
<li>信号(异步)</li>
<li>调用(同步)</li>
<li>时间事件</li>
</ul>
</blockquote>
<p>迁移是指对象在事件发生时状态的转移,由如下几个部分组成</p>
<blockquote>
<ul>
<li>源状态</li>
<li>事件触发器(触发器名称)</li>
<li>触发条件</li>
<li>效应(迁移过程中的动作)</li>
<li>目标状态</li>
</ul>
</blockquote>
<p>一些特殊迁移:</p>
<blockquote>
<ul>
<li>自身迁移: 从状态A迁移到状态A</li>
<li>内部迁移: 在状态A内部进行一些行为</li>
</ul>
</blockquote>
<h3 id="状态图元素"><a href="#状态图元素" class="headerlink" title="状态图元素"></a>状态图元素</h3><p><img src="/2020/06/21/object-oriented0/State0.jpg" alt></p>
<h3 id="状态图建模"><a href="#状态图建模" class="headerlink" title="状态图建模"></a>状态图建模</h3><blockquote>
<ol>
<li>选择对象及视点: 可以是类的实例,也可以是构件或系统</li>
<li>定义对象在生命期内可能存在的状态: 状态要有意义,要有一定的持续时间</li>
<li>定义在每种状态下可以接收的事件以及将要转去的新的状态</li>
</ol>
</blockquote>
<p>注意:</p>
<blockquote>
<ul>
<li>不能有孤立状态存在</li>
<li>除了终结状态,不能有只进不出的状态(黑洞状态)</li>
<li>除了初始状态,不能有只出不进的状态(奇迹状态)</li>
<li>不允许无条件状态转移</li>
</ul>
</blockquote>
<h1 id="3-面向对象分析与设计"><a href="#3-面向对象分析与设计" class="headerlink" title="3 面向对象分析与设计"></a>3 面向对象分析与设计</h1><h2 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h2><h3 id="什么是良好的对象设计"><a href="#什么是良好的对象设计" class="headerlink" title="什么是良好的对象设计"></a>什么是良好的对象设计</h3><p>良好的对象设计是构建高质量软件系统的基本要求:</p>
<blockquote>
<ul>
<li>架构性的内聚</li>
<li>可重用性</li>
<li>可维护性</li>
<li>可扩展性</li>
<li>灵活性</li>
</ul>
</blockquote>
<h3 id="系统设计中的关键问题"><a href="#系统设计中的关键问题" class="headerlink" title="系统设计中的关键问题"></a>系统设计中的关键问题</h3><p>这是面向对象设计课程的要点:</p>
<blockquote>
<ul>
<li>如何为对象类分配职责: 职责驱动的设计,在设计的过程中完成职责分配(使用GRASP原则)</li>
<li>对象之间应当如何协作</li>
<li>什么样的类应当做什么样的事情</li>
<li>如何使用某些经验法则(解决方案)或自创方案来解决问题</li>
</ul>
</blockquote>
<p>软件开发过程模型: 指示软件开发的步骤</p>
<blockquote>
<ul>
<li>瀑布模型</li>
<li>螺旋模型</li>
<li>增量模型</li>
<li>迭代模型(本课程使用)</li>
<li>喷泉模型</li>
<li>敏捷模型</li>
<li>SMF,RUP等</li>
</ul>
</blockquote>
<h3 id="分析-设计-实现-部署"><a href="#分析-设计-实现-部署" class="headerlink" title="分析,设计,实现,部署"></a>分析,设计,实现,部署</h3><blockquote>
<ul>
<li>分析analysis: 对问题和要求进行分析,而不是直接给出解决方案</li>
<li>设计design: 设计一个概念性的,满足需求的解决方案</li>
<li>实现implement: 将方案进行代码层面的解释</li>
<li>部署deployment: 将软件安装在宿主环境中</li>
</ul>
</blockquote>
<p>分析:做正确的事情; 设计:正确地做事情</p>
<h3 id="面向对象分析和设计"><a href="#面向对象分析和设计" class="headerlink" title="面向对象分析和设计"></a>面向对象分析和设计</h3><blockquote>
<ul>
<li>面向对象分析: 发现并描述问题领域里的对象或概念(概念类)</li>
<li>面向对象设计: 定义软件对象以及它们之间如何协作完成功能(设计类)</li>
</ul>
</blockquote>
<p>分析设计过程:</p>
<blockquote>
<ol>
<li>定义用例</li>
<li>定义领域模型(概念模型): 领域模型是面向对象分析的结果,是问题领域的概念类以及真实对象的可视化表示</li>
<li>定义交互图</li>
<li>定义设计类图</li>
</ol>
</blockquote>
<h2 id="3-2-面向对象分析-名称法"><a href="#3-2-面向对象分析-名称法" class="headerlink" title="3.2 面向对象分析:名称法"></a>3.2 面向对象分析:名称法</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>软件工程中,分析是一种奖用户需求转化为系统需求的过程</p>
<p>复杂系统的分析方法:</p>
<blockquote>
<ul>
<li>面向功能分析</li>
<li>面向对象分析</li>
</ul>
<p>通常软件系统中,在抽象层面面向功能分析,划分模块;每个模块内部面向对象分析</p>
</blockquote>
<p>面向对象分析主要步骤:</p>
<blockquote>
<ol>
<li>识别对象</li>
<li>组织对象</li>
<li>定义对象之间的关系</li>
<li>定义对象的操作: 这一步主要在设计阶段完成</li>
<li>定义对象的内部细节</li>
</ol>
<p>这几步是一个不断反复的过程</p>
</blockquote>
<p>面向对象分析的几种方法:</p>
<blockquote>
<ul>
<li>概念模型(名词法)</li>
<li>分析模型</li>
<li>CRC法:类/职责/协作法</li>
</ul>
<p>一个好的分析不应当局限于上述几种方法,需要灵活应用; 目标只有一个,即发现对象和定义对象之间的管线</p>
</blockquote>
<p>概念模型在UML中表示为没有操作的类图</p>
<h3 id="名词法定义概念类"><a href="#名词法定义概念类" class="headerlink" title="名词法定义概念类"></a>名词法定义概念类</h3><p>策略:</p>
<blockquote>
<ul>
<li>重用或修改已有模型</li>
<li>参考行业,公司内部的”概念类列表”(checklist)</li>
<li>在需求描述中寻找名词(短语)</li>
</ul>
</blockquote>
<p>具体方法:</p>
<blockquote>
<ul>
<li>在问题领域的文本描述中,标识出名词(短语),将它们作为候选的概念类或属性</li>
<li>对发现的名称(短语)进行分析,辨别概念是否能合并</li>
<li>定义概念类之间的关系</li>
<li>定义概念类的属性</li>
</ul>
</blockquote>
<p>注意:</p>
<blockquote>
<ul>
<li>不能机械地将名称直接转换成概念类</li>
<li>对自然语言描述的歧义,重复要仔细分析</li>
</ul>
</blockquote>
<h2 id="3-3-分析模型法"><a href="#3-3-分析模型法" class="headerlink" title="3.3 分析模型法"></a>3.3 分析模型法</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>分析模型法用于描述系统规格的说明;从系统的信息,行为,输入输出的方面入手分析问题</p>
<blockquote>
<ul>
<li>一个健壮,稳定的模型必须与实现环境无关</li>
<li>实现环境的任何变化,不会影响到系统的逻辑结构</li>
<li>分析模型能够关注到系统的信息,行为,展示(输入输出)等特性</li>
</ul>
</blockquote>
<h3 id="分析模型的表示符号"><a href="#分析模型的表示符号" class="headerlink" title="分析模型的表示符号"></a>分析模型的表示符号</h3><p><img src="/2020/06/21/object-oriented0/analysis0.jpg" alt>  </p>
<blockquote>
<ul>
<li>实体类: 圆下一切线;主要表示系统内的信息</li>
<li>边界类: 圆外一边界;主要表示系统的展示</li>
<li>控制类: 圆上一箭头;主要表示系统的行为</li>
</ul>
</blockquote>
<h3 id="分析模型类的标识和类间关系识别"><a href="#分析模型类的标识和类间关系识别" class="headerlink" title="分析模型类的标识和类间关系识别"></a>分析模型类的标识和类间关系识别</h3><p>关注三个维度: 系统信息,系统接口(展示),系统行为(控制)</p>
<blockquote>
<ul>
<li>识别系统内部实体对象: 实体类</li>
<li>识别和接口相关的对象: 边界类</li>
<li>识别调度相关的对象: 控制类</li>
</ul>
</blockquote>
<p>类间关系的表示:<br><img src="/2020/06/21/object-oriented0/analysis1.jpg" alt></p>
<h2 id="3-4-面向对象设计-初步"><a href="#3-4-面向对象设计-初步" class="headerlink" title="3.4 面向对象设计(初步)"></a>3.4 面向对象设计(初步)</h2><p>面向对象设计是在概念模型的基础上进行设计</p>
<h3 id="一般原则"><a href="#一般原则" class="headerlink" title="一般原则"></a>一般原则</h3><blockquote>
<ul>
<li>一个面向对象系统是由相互发送消息的对象组成的</li>
<li>一个软件系统的质量如何取决于各对象是否能够各司其职</li>
</ul>
</blockquote>
<h3 id="职责驱动的设计"><a href="#职责驱动的设计" class="headerlink" title="职责驱动的设计"></a>职责驱动的设计</h3><p>职责: 职责是一个对象的行为,而其他对象依赖这种行为</p>
<blockquote>
<ul>
<li>职责是外界对该对象的一种期待</li>
<li>该对象不履行职责将会对其他对象产生(负面)影响</li>
</ul>
</blockquote>
<p>对象职责的分类(老师和同学的关系):</p>
<blockquote>
<ul>
<li>认知职责: <blockquote>
<ul>
<li>该对象的私有信息: 老师的个人信息</li>
<li>该对象和其他对象相关的一些信息: 老师有学生名单</li>
<li>能通过该对象已知信息推导出来的信息</li>
</ul>
</blockquote>
</li>
<li>行为职责<blockquote>
<ul>
<li>该对象自己的行为: 老师讲课</li>
<li>该对象初始化其他的对象行为: 老师让同学回答问题 </li>
<li>该对象控制协调其他对象的行为: 老师让同学们小组合作</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>策略: 考虑每个类的职责</p>
<blockquote>
<ul>
<li>设计时考虑对象做什么或知道什么</li>
<li>设计时考虑一个对象对其他对象承担的义务或合约</li>
</ul>
</blockquote>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/06/21/object-oriented0/" data-id="ckf5ehrch001yp0vn3hmog65c"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-compilers0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/07/compilers0/"
    >编译原理相关知识</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/07/compilers0/" class="article-date">
  <time datetime="2020-06-07T08:32:03.000Z" itemprop="datePublished">2020-06-07</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><del>未完结,持续更新</del>完结</p>
<hr>
<p>课程内容:</p>
<ul>
<li>编译器构造的一般原理和基本实现方法</li>
<li>理论知识: 形式语言和自动机理论,语法制导的定义和属性方法,程序分析原理</li>
<li>强调形式描述技术和自动生成技术</li>
<li>强调对编译原理和技术的宏观理解,不把注意力分散到枝节算法,不偏向于任何源语言或目标机器</li>
</ul>
      
      <a class="article-more-link" href="/2020/06/07/compilers0/">more...</a>
      
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/06/07/compilers0/" data-id="ckf5ehrbe000cp0vnhn5h9065"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-computer-composition1" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/01/computer-composition1/"
    >computer-composition1</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/01/computer-composition1/" class="article-date">
  <time datetime="2020-06-01T02:21:46.000Z" itemprop="datePublished">2020-06-01</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/default/">default</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h2><ul>
<li>ENIAC:1946年</li>
<li>冯诺依曼结构特点,结构图</li>
<li>计算机发展阶段</li>
<li>计算机语言: 机器-&gt;汇编-&gt;高级</li>
<li>计算机多级层次结构</li>
</ul>
      
      <a class="article-more-link" href="/2020/06/01/computer-composition1/">more...</a>
      
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/06/01/computer-composition1/" data-id="ckf5ehrbn000mp0vnhzkjbz2l"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/default/" rel="tag">default</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-mysql0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/24/mysql0/"
    >sql使用</a
  >
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/24/mysql0/" class="article-date">
  <time datetime="2020-05-24T12:46:00.000Z" itemprop="datePublished">2020-05-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>mysql的使用大全可以参考<a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">http://c.biancheng.net/mysql/</a></p>
<p>本文主要根据笔记<a href="http://georgechen.top/2020/02/27/data-base0/" target="_blank" rel="noopener">http://georgechen.top/2020/02/27/data-base0/</a>精简整理,保留常用语句用法</p>
      
      <a class="article-more-link" href="/2020/05/24/mysql0/">more...</a>
      
      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/05/24/mysql0/" data-id="ckf5ehrcd001tp0vnh5hz87el"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        George Chen
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="George"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HOME</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives/">ARCHIVE</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">CATE.</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">TAGS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://github.com/georgechen1827/" target="_blank" rel="noopener">about me</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/coming_soon.html" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>







<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>