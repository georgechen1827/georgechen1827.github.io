<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="this is George Chen&#39;s blog!" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    操作系统原理概论 |  George
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-operating-system0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  操作系统原理概论
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/08/operating-system0/" class="article-date">
  <time datetime="2020-09-08T00:55:17.000Z" itemprop="datePublished">2020-09-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> about </span>
            <span class="post-count">9.3k words</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> costs </span>
            <span class="post-count">32 minutes</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>李培峰：<a href="mailto:pfli_suda@126.com">pfli_suda@126.com</a>; 13606216291</p>
<p>课程内容和要求：</p>
<blockquote>
<ul>
<li>掌握操作系统的基本原理和组成结构</li>
<li>掌握基本概念和相关新概念、名词及术语</li>
<li>理解各组成部分之间的关系、结构和综合工作原理</li>
<li>分析、修改和设计操作系统的功能</li>
<li>使用基本的操作系统</li>
<li>学习内容：导论、进程管理、内存管理、存储管理；会穿插案例研究内容</li>
</ul>
</blockquote>
<p>广义上，操作系统是数据结构的衍生，涵盖数据结构、算法和编程</p>
<blockquote>
<ul>
<li>先修课程：汇编语言程序设计、c和java、计算机组成、数据结构、面向对象程序设计</li>
</ul>
</blockquote>
<p>参考书目：《现代操作系统Andrew.S》（偏向实例）、《操作系统精髓与设计原理》（更偏向实例系统）</p>
<p>一个视频<a href="https://vo.youku.com/v_show/id_XMTAwNTg5MzA0.html" target="_blank" rel="noopener">https://vo.youku.com/v_show/id_XMTAwNTg5MzA0.html</a></p>
<p>平时成绩20%、期中考试20%、期末考试60%</p>
<a id="more"></a>

<h2 id="主流操作系统介绍"><a href="#主流操作系统介绍" class="headerlink" title="主流操作系统介绍"></a>主流操作系统介绍</h2><p>主流PC操作系统：</p>
<blockquote>
<ul>
<li>1969 UNIX：C和汇编语言编写，世界上用途最广泛的操作系统</li>
<li>1974 CP/M：第一个微机操作系统</li>
<li>1981 MS－DOS：为用户上机操作和应用软件开发提供良好的用户外部环境</li>
<li>1984 MAC OS：第一款成功的含有图形化用户界面的操作系统</li>
<li>1985 Windows：最成功的个人微机操作系统</li>
<li>1991 LINUX：未来最有前途的操作系统之一</li>
</ul>
</blockquote>
<p>主流手机操作系统：</p>
<blockquote>
<ul>
<li>1999 SYMBIAN：实时的，多任务的纯32位操作系统；智能手机开创者</li>
<li>2007.11.5 ANDROID: 开放的操作系统</li>
<li>2007 IOS：优秀的封闭的操作系统</li>
<li>2008 BLACKBERRY：加密性更强，更安全；融入了办公商务功能</li>
<li>Windows Phone：从Pocket PC到Windows Mobile到Windows Phone;和Windows兼容性好</li>
</ul>
</blockquote>
<h1 id="一、导论"><a href="#一、导论" class="headerlink" title="一、导论"></a>一、导论</h1><h2 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><p>操作系统是沟通计算机硬件和系统程序与应用程序的桥梁</p>
<p>操作系统的目标：</p>
<blockquote>
<ul>
<li>核心目标：运行用户程序</li>
<li>面相用户：更方便使用计算机（方便性）</li>
<li>面相系统：更高效使用计算机（高效性）</li>
</ul>
</blockquote>
<h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>操作系统没有一个清晰的定义</p>
<blockquote>
<ul>
<li>极大化：当你预定一个操作系统时零售商所装的所有东西</li>
<li>极小化：内核是操作系统（一直运行在计算机上的程序）</li>
</ul>
</blockquote>
<p>内核Kernel：</p>
<blockquote>
<ul>
<li>内核是一个一直运行在计算机上的程序</li>
<li>内核是计算机运行必不可少的组成部分</li>
</ul>
</blockquote>
<h3 id="操作系统的硬件结构"><a href="#操作系统的硬件结构" class="headerlink" title="操作系统的硬件结构"></a>操作系统的硬件结构</h3><blockquote>
<ul>
<li>一个或多个CPU和内存</li>
<li>若干通过总线相连的设备控制器及其设备</li>
<li>总线</li>
<li>CPU和设备控制器可并行工作，并竞争内存</li>
</ul>
</blockquote>
<h2 id="1-2-多道程序设计和分时"><a href="#1-2-多道程序设计和分时" class="headerlink" title="1.2 多道程序设计和分时"></a>1.2 多道程序设计和分时</h2><h3 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h3><p>从无操作系统（EANIC）到简单批处理系统</p>
<blockquote>
<ul>
<li>批处理：一批无需人机交互的作业批量运行</li>
<li>简单批处理系统的核心是一个常驻监控程序，以作业为单位自动调度程序执行</li>
</ul>
</blockquote>
<p>过程：</p>
<blockquote>
<ul>
<li>程序员在小型机上编程</li>
<li>操作员将程序装入大型机运行</li>
<li>操作员将结果取出</li>
<li>程序员将结果在小型机上打印出来</li>
</ul>
</blockquote>
<p>简单批处理系统大大提高了计算机运行的效率，但没有充分利用cpu的IO并行性</p>
<h3 id="多道程序系统"><a href="#多道程序系统" class="headerlink" title="多道程序系统"></a>多道程序系统</h3><blockquote>
<ul>
<li>单用户同城不能总使得CPU和设备在所有时间内都忙碌</li>
<li>多道程序在内存中同时存在多道作业，在管理程序控制下相互穿插运行</li>
</ul>
</blockquote>
<p>策略：</p>
<blockquote>
<ul>
<li>通过作业调度(Job Scheduling)选中一个作业并运行</li>
<li>当该作业必须等待时 (如等待I/O), 切换到另一个作业运行</li>
</ul>
</blockquote>
<p>目的：提高CPU利用率，充分发挥计算机系统部件的并行性</p>
<p>并行和并发：</p>
<blockquote>
<ul>
<li>并行：两个或多个作业在同一时刻运行</li>
<li>并发：两个或多个作业在同一时间间隔内依次运行，同一时间点只有一个作业在处理机上运行</li>
</ul>
<blockquote>
<ul>
<li>并发在微观上相当于串行，在宏观上相当于并行</li>
<li>随着多核处理器的出现，并行和并发两个概念并不严格区分</li>
</ul>
</blockquote>
</blockquote>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>分时系统(或多任务)是多道程序设计的延伸</p>
<p>作业分类：</p>
<blockquote>
<ul>
<li>批处理作业：不需要人为干预</li>
<li>交互作业：需要人为干预；交互作业要求较高的响应时间，需要使用多道程序设计技术</li>
<li>响应时间：用户提交操作到操作系统执行操作之间的时间</li>
</ul>
</blockquote>
<p>时间片：</p>
<blockquote>
<ul>
<li>把一段CPU时间按照固定单位进行分割，每个分割得到的时间段称为一个时间片</li>
<li>每个任务依次轮流使用时间片</li>
</ul>
</blockquote>
<p>分时系统是一种联机的多用户交互式操作系统：</p>
<blockquote>
<ul>
<li>一般采用时间片轮转的方式使一台计算机为多个用户服务；在单位时间内，每个用户获得一个时间片运行</li>
<li>若某个作业在分配的时间片用完之前计算还未完成，该作业就暂时中断，等待下一轮；此时，处理机让给另一个作业使用。</li>
<li>这样能保证用于获得足够小的响应时间，并提供交互能力；此时，每个用户好像独占一台计算机</li>
</ul>
</blockquote>
<p>分时系统开销较大，需要一定的资源来管理和切换用户程序；一般来说，（时间）开销应当小于时间片的1/10</p>
<h2 id="1-3-操作系统的类型"><a href="#1-3-操作系统的类型" class="headerlink" title="1.3 操作系统的类型"></a>1.3 操作系统的类型</h2><blockquote>
<ul>
<li>大型机系统：前面所述的简单批处理系统、多道程序系统以及分时系统最早都应用于大型机上</li>
<li>桌面系统：应用于个人计算机PC上</li>
<li>手持（移动）系统：资源有限、具有导航等扩展功能</li>
<li>嵌入式系统：完全潜入受控器件内部；内核较小、专用性强、系统精简、高实时性</li>
<li>分布式系统：松耦合系统，通过网络操作系统；较难实现，目前多为数据分布式系统</li>
<li>多处理器系统：紧耦合系统，有多个紧密通信的处理器的系统，处理器之间共享内存</li>
<li>多核处理器系统：一个芯片多个核，现在一般不与多处理器系统区分<blockquote>
<ul>
<li>对称多处理器SMP：桌面PC处理器</li>
<li>非对称多处理器系统ASMP：高通骁龙</li>
</ul>
</blockquote>
</li>
<li>集群系统：面相超级计算，通过专用网络连接一群计算机，将它们虚拟化为一台有超强能力的计算机给用户使用</li>
<li>实时系统：实时性很高的系统（5G网络设备）</li>
</ul>
</blockquote>
<h2 id="1-4-操作系统的操作和功能"><a href="#1-4-操作系统的操作和功能" class="headerlink" title="1.4 操作系统的操作和功能"></a>1.4 操作系统的操作和功能</h2><h3 id="双模式"><a href="#双模式" class="headerlink" title="双模式"></a>双模式</h3><p>目的：防止程序崩溃或死循环造成整个操作系统崩溃</p>
<p>解决方式：双模式，即用户模式和内核模式</p>
<blockquote>
<ul>
<li>双模式需要CPU硬件支持</li>
<li>允许系统保护自身和其他系统部件</li>
<li>设置特权指令，这些指令只能在内核模式下运行；这些指令通常可能会造成系统崩溃</li>
<li>当用户程序需要使用特权指令特权指令时，可以进行系统调用（一种软件中断）</li>
</ul>
</blockquote>
<p>系统调用过程：</p>
<blockquote>
<ul>
<li>用户程序挂起，申请系统调用</li>
<li>CPU从用户模式切换到内核模式，执行特权指令</li>
<li>CPU从内核模式切换成用户模式，用户程序继续执行</li>
</ul>
</blockquote>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>保护有I/O操作保护和内存保护</p>
<blockquote>
<ul>
<li>I/O保护防止用户程序执行非法I/O；内存保护防止内存的非法访问</li>
<li>IO保护策略：所有IO指令都是特权指令</li>
<li>内存保护策略：建立存储保护机制（硬件支持）</li>
</ul>
</blockquote>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>目的：使得操作系统能够随时获得CPU控制权，从而对系统进行管理</p>
<blockquote>
<ul>
<li>用户程序死循环会造成CPU控制权不能回到操作系统手中</li>
<li>用户程序不调用系统调用也会造成操作系统不能获得CPU控制器</li>
</ul>
</blockquote>
<p>解决方法：定时器</p>
<blockquote>
<ul>
<li>在用户程序运行一段时间后发生中断，CPU控制权返回到操作系统手中</li>
<li>定时器利用时钟和计数器实现，有固定时间和可变时间定时器</li>
</ul>
</blockquote>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程：运行中的程序</p>
<p>操作系统的核心目标：运行程序</p>
<p>CPU/进程管理：对CPU进行管理</p>
<blockquote>
<ul>
<li>创建和删除用户和系统进程</li>
<li>暂停和恢复进程</li>
<li>提供进程同步机制</li>
<li>提供进程通信机制</li>
<li>提供死锁处理机制</li>
</ul>
</blockquote>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>内存管理：提供内存的分配、回收、地址转换、共享和保护等功能，从而提高计算机运行效率</p>
<blockquote>
<ul>
<li>提高内存利用率</li>
<li>提高内存访问速度</li>
</ul>
</blockquote>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>解决信息在计算机中存储问题</p>
<p>以文件为单位，以目录为组织方式构建文件系统</p>
<p>对文件内容管理：</p>
<blockquote>
<ul>
<li>文件逻辑结构</li>
<li>文件物理结构</li>
</ul>
</blockquote>
<p>对文件目录管理：</p>
<blockquote>
<ul>
<li>文件检索方法</li>
<li>文件操作</li>
<li>空闲空间管理</li>
<li>存储设备管理</li>
</ul>
</blockquote>
<h3 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I/O设备管理"></a>I/O设备管理</h3><p>管理种类繁多的各种I/O设备，解决计算机中信息的输入和输出问题</p>
<p>关键：设备无关性(独立性)</p>
<blockquote>
<ul>
<li>所有物理设备按照物理特性抽象为逻辑设备</li>
<li>应用程序针对逻辑设备编程</li>
<li>应用程序和物理设备无关</li>
</ul>
</blockquote>
<p>内容</p>
<blockquote>
<ul>
<li>设备管理</li>
<li>设备驱动</li>
</ul>
</blockquote>
<h1 id="二、操作系统结构"><a href="#二、操作系统结构" class="headerlink" title="二、操作系统结构"></a>二、操作系统结构</h1><h2 id="2-1-操作系统的服务和接口"><a href="#2-1-操作系统的服务和接口" class="headerlink" title="2.1 操作系统的服务和接口"></a>2.1 操作系统的服务和接口</h2><h3 id="操作系统服务"><a href="#操作系统服务" class="headerlink" title="操作系统服务"></a>操作系统服务</h3><p>操作系统以服务的形式向程序和用户提供环境执行程序</p>
<blockquote>
<ul>
<li>基本服务：如用户界面、程序执行、I/O操作等</li>
<li>增值服务：资源分配、统计、保护和安全等</li>
</ul>
</blockquote>
<p>操作系统服务形式：</p>
<blockquote>
<ul>
<li>系统调用</li>
<li>用户接口</li>
<li>系统程序</li>
</ul>
</blockquote>
<h3 id="操作系统程序接口：系统调用"><a href="#操作系统程序接口：系统调用" class="headerlink" title="操作系统程序接口：系统调用"></a>操作系统程序接口：系统调用</h3><p>系统调用是操作系统服务面相程序的接口</p>
<blockquote>
<ul>
<li>它们通常由高级语言编写</li>
<li>程序通过应用程序接口API访问</li>
</ul>
</blockquote>
<p>系统调用的参数传递：通过寄存器传递</p>
<p>常见APIs：</p>
<blockquote>
<ul>
<li>Windows中的Win32 API</li>
<li>POSIX系统中断POSIX API</li>
<li>Java虚拟机JVM的Java API</li>
</ul>
</blockquote>
<h3 id="操作系统用户界面"><a href="#操作系统用户界面" class="headerlink" title="操作系统用户界面"></a>操作系统用户界面</h3><p>命令行接口CLI：</p>
<blockquote>
<ul>
<li>字符模式</li>
</ul>
</blockquote>
<p>图形化接口GUI：</p>
<blockquote>
<ul>
<li>用户界面友好的桌面接口</li>
<li>现在还有触摸屏GUI</li>
</ul>
</blockquote>
<p>未来人机接口：</p>
<blockquote>
<ul>
<li>语音操控</li>
<li>体感操控</li>
<li>…</li>
</ul>
</blockquote>
<h3 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h3><p>用于管理、维护操作系统</p>
<p>为用户使用操作系统服务</p>
<p>功能：</p>
<blockquote>
<ul>
<li>文件管理</li>
<li>状态信息</li>
<li>文件处理</li>
<li>程序语言支持</li>
<li>程序装入和执行</li>
<li>通信</li>
</ul>
</blockquote>
<h2 id="2-2-操作系统的结构"><a href="#2-2-操作系统的结构" class="headerlink" title="2.2 操作系统的结构"></a>2.2 操作系统的结构</h2><h3 id="简单结构（无结构）"><a href="#简单结构（无结构）" class="headerlink" title="简单结构（无结构）"></a>简单结构（无结构）</h3><blockquote>
<ul>
<li>规模小、简单、功能有限</li>
<li>混乱、不易维护和更新、不适合大规模开发</li>
</ul>
</blockquote>
<p>MS-DOS：不划分模块</p>
<p>早期UNIX：分为系统程序和内核</p>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>操作系统划分为若干层</p>
<blockquote>
<ul>
<li>在低层上构建高层</li>
<li>底层（0层）为硬件</li>
<li>最高层（N层）为用户层</li>
<li>每层只使用低层次的功能和服务</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<p>简化系统设计和实现，便于调试和升级系统</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>层定义困难</li>
<li>效率差</li>
</ul>
</blockquote>
<p>例子：WindowsNT，iOS</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>问题：内核越来越大，越来越难管理</p>
<p>内核微型化：核内移出尽可能多功能到用户空间</p>
<p>好处:</p>
<blockquote>
<ul>
<li>便于扩充微内核</li>
<li>便于移植操作系统到新架构系统上</li>
<li>更稳定 (更少的代码运行在核心态)</li>
<li>更安全</li>
</ul>
</blockquote>
<p>坏处:</p>
<blockquote>
<ul>
<li>用户空间和内核空间通信的系统开销增加</li>
<li>解决方法：提出消息传递机制</li>
</ul>
</blockquote>
<h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>大部分现代操作系统采用模块结构</p>
<blockquote>
<ul>
<li>使用面向对象方法</li>
<li>每个核心部件分开</li>
<li>每个与其他模块的会话被称为接口</li>
<li>每个模块在需要时被加载到内核</li>
</ul>
</blockquote>
<p>总体而言，类似于分层方法，但更灵活</p>
<blockquote>
<ul>
<li>任两个模块之间都能相互调用</li>
<li>层次结构只能相邻两层之间调用</li>
</ul>
</blockquote>
<p>当然，现代操作系统不是单一结构的，它会采取多种混合结构来获取性能、安全、使用等方面的需求（Mac OS X）</p>
<h2 id="2-3-虚拟机"><a href="#2-3-虚拟机" class="headerlink" title="2.3 虚拟机"></a>2.3 虚拟机</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>虚拟机：一种通过软件模拟实现，具有完整硬件系统功能，并运行在一个完全隔离环境中的完整计算机系统</p>
<blockquote>
<ul>
<li>物理计算机资源共享以创建虚拟机</li>
<li>每个虚拟机同其他虚拟机隔离</li>
<li>由于需要对物理机器进行精确复制，虚拟机实现困难</li>
<li>上个世纪60年代，虚拟机用于大型机（IBM VM系统）</li>
</ul>
</blockquote>
<p>分类：</p>
<blockquote>
<ul>
<li>高级语言虚拟机</li>
<li>工作站虚拟机</li>
<li>服务器虚拟机</li>
</ul>
</blockquote>
<h3 id="JAVA虚拟机"><a href="#JAVA虚拟机" class="headerlink" title="JAVA虚拟机"></a>JAVA虚拟机</h3><p>JVM：JAVA语言的解释器</p>
<blockquote>
<ul>
<li>可运行Java代码的假想计算机</li>
<li>只要根据JVM规格将解释器移植到特定的操作系统上，就能运行经过编译的任何Java代码</li>
<li>特点：平台无关性，是运行在操作系统上的虚拟机</li>
</ul>
</blockquote>
<h3 id="工作站虚拟机"><a href="#工作站虚拟机" class="headerlink" title="工作站虚拟机"></a>工作站虚拟机</h3><p>工作站虚拟机：操作系统上的虚拟机</p>
<blockquote>
<ul>
<li>宿主操作系统（Host OS）：安装在硬件上的OS</li>
<li>客户操作系统（Guest OS）安装在操作系统上的操作系统</li>
<li>工作站虚拟机安装在宿主操作系统上，在工作站虚拟机中可以安装客户操作系统</li>
</ul>
</blockquote>
<p>好处：</p>
<blockquote>
<ul>
<li>同时在一个计算机上使用多个操作系统</li>
<li>一个宿主操作系统，若干个客户操作系统</li>
</ul>
</blockquote>
<h3 id="服务器虚拟机"><a href="#服务器虚拟机" class="headerlink" title="服务器虚拟机"></a>服务器虚拟机</h3><p>服务器虚拟化：将服务器物理资源抽象成逻辑资源，让一台服务器变成几台甚至上百台相互隔离的虚拟服务器</p>
<p>常用模式：</p>
<blockquote>
<ul>
<li>一虚多：一台服务器虚拟成多台服务器虚拟机</li>
<li>多虚一：多个独立物理服务器虚拟为一个服务器虚拟机</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>安全性好</li>
<li>资源共享</li>
<li>可扩展性好</li>
<li>便于隔离</li>
</ul>
</blockquote>
<p>和工作站虚拟机区别：没有宿主操作系统</p>
<h3 id="连接模式"><a href="#连接模式" class="headerlink" title="连接模式"></a>连接模式</h3><blockquote>
<ul>
<li>软件模式：远程桌面、ssh等</li>
<li>硬件模式：虚拟机终端（硬件）等</li>
</ul>
</blockquote>
<h1 id="三、进程"><a href="#三、进程" class="headerlink" title="三、进程"></a>三、进程</h1><h2 id="3-1-进程概念"><a href="#3-1-进程概念" class="headerlink" title="3.1 进程概念"></a>3.1 进程概念</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程：</p>
<blockquote>
<ul>
<li>执行中的程序；进程的执行必须以顺序方式执行</li>
<li>一个程序在一个数据集上的一次运行</li>
</ul>
</blockquote>
<p>进程、作业和任务：</p>
<blockquote>
<ul>
<li>作业：狭义上认为是被组装成一个整体运行的一组计算步骤</li>
<li>任务：狭义上认为进程或线程</li>
</ul>
</blockquote>
<h3 id="内存中的进程"><a href="#内存中的进程" class="headerlink" title="内存中的进程"></a>内存中的进程</h3><p>进程的组成部分：</p>
<blockquote>
<ul>
<li>程序代码</li>
<li>当前活动（以下举例）</li>
<li>程序计数器</li>
<li>堆栈：存放函数参数、临时变量等</li>
<li>数据：全局变量</li>
<li>堆：动态内存分配</li>
</ul>
</blockquote>
<h3 id="进程和程序到关系"><a href="#进程和程序到关系" class="headerlink" title="进程和程序到关系"></a>进程和程序到关系</h3><blockquote>
<ul>
<li>进程是程序的一个实例，是程序的一次执行</li>
<li>一个程序可对应一个或多个进程，同样一个进程可对应一个或多个程序</li>
<li>程序是进程的代码部分</li>
<li>进程是活动实体，程序静止（被动）实体</li>
<li>进程在内存，程序在外存</li>
</ul>
</blockquote>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程执行时，有如下几个状态：</p>
<blockquote>
<ul>
<li>新建态：在创建进程 </li>
<li>运行态：指令在执行</li>
<li>等待态：进程等待某些事件发生 </li>
<li>就绪：进程等待分配处理器 </li>
<li>终止：进程执行完毕</li>
</ul>
</blockquote>
<p>进程状态的转换：<br><img src="/2020/09/08/operating-system0/process0.jpg" alt="Process"></p>
<blockquote>
<ul>
<li>新建-就绪：操作系统能够同时执行的进程是有限的，新进程需要被允许才能就绪</li>
<li>就绪-运行：通过调度程序控制</li>
<li>运行-就绪：中断发生，如分时系统中切换任务；而多道程序中这个状态转换通常是程序自愿发生的</li>
<li>运行-等待：进程需要等待某个操作（如按下任意键继续）才能继续执行</li>
<li>等待-就绪：事件发生，进程可以（在调度程序的控制下）继续执行了（就绪）<br>注意区分等待和就绪两种状态</li>
</ul>
</blockquote>
<h3 id="进程控制快PCB"><a href="#进程控制快PCB" class="headerlink" title="进程控制快PCB"></a>进程控制快PCB</h3><p>PCB包含同进程有关的信息，包括：</p>
<blockquote>
<ul>
<li>进程状态</li>
<li>程序计数器</li>
<li>CPU寄存器</li>
<li>CPU调度信息</li>
<li>内存管理信息</li>
<li>计账信息</li>
<li>I/O状态信息</li>
</ul>
</blockquote>
<h3 id="CPU在进程之间切换"><a href="#CPU在进程之间切换" class="headerlink" title="CPU在进程之间切换"></a>CPU在进程之间切换</h3><p>进程的并发执行需要PCB保存和恢复现场</p>
<h2 id="3-2-进程操作"><a href="#3-2-进程操作" class="headerlink" title="3.2 进程操作"></a>3.2 进程操作</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>父进程创建子进程，如此轮流创建进程下去，构成一棵进程树</p>
<p>父子进程之间的关系：</p>
<ul>
<li><p>资源共享：</p>
<blockquote>
<ul>
<li>父进程子进程共享所有的资源：并行计算</li>
<li>子进程共享父进程资源的子集（部分共享）：windows创建的进程</li>
<li>父进程和子进程无资源共享</li>
</ul>
</blockquote>
</li>
<li><p>执行：</p>
<blockquote>
<ul>
<li>父进程和子进程并发执行，两者不相干（操作系统默认模式）</li>
<li>父进程等待，直到子进程终止（需要程序员控制）</li>
</ul>
</blockquote>
</li>
<li><p>地址空间：</p>
<blockquote>
<ul>
<li>子女复制双亲</li>
<li>子女执行一个外部程序</li>
</ul>
</blockquote>
</li>
</ul>
<p>进程的创建是一个原子操作：</p>
<blockquote>
<ul>
<li>执行这种原子操作的语句也被称为原语</li>
<li>这是一个不会被打断的操作</li>
<li>一旦开始就一直运行到结束，中间不会有任何上下文切换</li>
<li>该特性需要硬件支持：总线加锁（x86）</li>
</ul>
</blockquote>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ul>
<li><p>进程执行最后一项并退出</p>
<blockquote>
<ul>
<li>子进程通过wait向父进程输出数据，处于终止状态</li>
<li>父进程处理子进程的终止状态（区分需要回收的资源等）</li>
<li>操作系统回收进程的资源</li>
</ul>
</blockquote>
</li>
<li><p>父进程终止子进程执行</p>
<blockquote>
<ul>
<li>子进程超量分配资源</li>
<li>赋予子进程的任务不再需要</li>
<li>父进程结束导致的级联操作；当然，父进程结束后子进程也可以链到更上级进程下面</li>
<li>父进程可以通过wait()系统调用等待子进程结束</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="进程调用举例"><a href="#进程调用举例" class="headerlink" title="进程调用举例"></a>进程调用举例</h3><h4 id="Linux的fork"><a href="#Linux的fork" class="headerlink" title="Linux的fork()"></a>Linux的fork()</h4><p>策略：</p>
<blockquote>
<ul>
<li>fork()的子进程和父进程几乎一模一样</li>
<li>进程创建时两者代码和数据空间一样，但pid不一样</li>
<li>当子进程修改数据空间时，将该空间拷贝并进行修改（写时复制策略）</li>
</ul>
</blockquote>
<p>区分父子进程：</p>
<blockquote>
<ul>
<li>父进程调用fork()的返回值是子进程的ID（并创建子进程）</li>
<li>子进程调用fork()的返回值是-1（不会创建其他进程）</li>
<li>可以在同一个代码中插入fork()值的判断来使父子进程运行不同的代码</li>
</ul>
</blockquote>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>exec用于执行其他程序，子进程和父进程不共享任何资源</p>
<h4 id="创建进程的模式"><a href="#创建进程的模式" class="headerlink" title="创建进程的模式"></a>创建进程的模式</h4><blockquote>
<ul>
<li>先用fork创建一个镜像</li>
<li>执行exec覆盖这个镜像</li>
</ul>
</blockquote>
<h2 id="3-3-进程间的通信"><a href="#3-3-进程间的通信" class="headerlink" title="3.3 进程间的通信"></a>3.3 进程间的通信</h2><h3 id="进程间的关系"><a href="#进程间的关系" class="headerlink" title="进程间的关系"></a>进程间的关系</h3><p>独立进程：进程之间的执行不会互相影响<br>协同进程：进程间的执行可能会相互影响</p>
<p>目前，大多数进程都是协同进程</p>
<p>协同进程优点：</p>
<blockquote>
<ul>
<li>信息共享</li>
<li>加速运算</li>
<li>模块化</li>
<li>方便：单个用户也可以执行多个任务</li>
</ul>
</blockquote>
<p>进程间的通信方式：</p>
<blockquote>
<ul>
<li>共享内存</li>
<li>消息传递</li>
</ul>
</blockquote>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>生产者-消费者模型：</p>
<blockquote>
<ul>
<li>生产者进程生产供消费者消费的信息</li>
<li>无界缓冲(Unbounded-buffer)没有对缓冲区大小的限制</li>
<li>有界缓冲(Bounded-buffer)对缓冲区大小作了限定</li>
</ul>
</blockquote>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>消息传递是通信模式中的常用机制</p>
<blockquote>
<ul>
<li>适合用于传递少量的信息</li>
<li>远程通信无法采用共享内存</li>
</ul>
</blockquote>
<p>直接通信：两个进程之间建立一个直接通信的链路</p>
<blockquote>
<ul>
<li>每个链路只有两个进程相关</li>
<li>信息发送必须明确指定接收者</li>
<li>共享内存实际上也是一种直接通信</li>
</ul>
</blockquote>
<p>间接通信：消息被导向至信箱并从信箱接受</p>
<blockquote>
<ul>
<li>每个信箱有一个唯一的id</li>
<li>仅当共享一个信箱时进程才能通信</li>
<li>信息的发送者可以无需指定接收者（广播）</li>
<li>其他有第三方参与（如剪贴板）的通信也是一种简介通信</li>
</ul>
</blockquote>
<p>消息传递的同步性：</p>
<blockquote>
<ul>
<li>阻塞发送</li>
<li>阻塞接收</li>
<li>非阻塞发送</li>
<li>非阻塞接收：接收者收到一个有效消息或无效消息</li>
<li>一般默认非阻塞发送和阻塞接收</li>
</ul>
</blockquote>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="Windows进程通信"><a href="#Windows进程通信" class="headerlink" title="Windows进程通信"></a>Windows进程通信</h4><ul>
<li>网络通信：命名管道等</li>
<li>本地通信：剪贴板等</li>
</ul>
<p>Windows消息传递的主体是窗口</p>
<h4 id="Linux进程通信"><a href="#Linux进程通信" class="headerlink" title="Linux进程通信"></a>Linux进程通信</h4><ul>
<li>管道</li>
<li>信号</li>
<li>消息</li>
<li>…</li>
</ul>
<h1 id="四、线程"><a href="#四、线程" class="headerlink" title="四、线程"></a>四、线程</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>线程的合理性：</p>
<blockquote>
<ul>
<li>性能要求：进程是重量级的，进程操作开销大</li>
<li>应用要求：进程内也有代码并行执行的需求</li>
<li>硬件要求：多核处理器已经是主流硬件，能加速进程的运行</li>
</ul>
</blockquote>
<p>线程：</p>
<blockquote>
<ul>
<li>线程是一个轻量级的进程，切换代价小</li>
<li>进程内的一个代码片段可以被创建为一个线程</li>
<li>线程状态：就绪、运行、等待等</li>
<li>进程依旧是资源分配的基本单位；线程撤销不会影响进程，但进程撤销会导致所有线程的撤销</li>
<li>线程自己不拥有完整的系统资源，需要通过进程来申请资源</li>
</ul>
</blockquote>
<h2 id="4-2-线程结构"><a href="#4-2-线程结构" class="headerlink" title="4.2 线程结构"></a>4.2 线程结构</h2><p>线程控制块TCB</p>
<blockquote>
<ul>
<li>线程ID</li>
<li>线程计数器PC</li>
<li>寄存器集合</li>
<li>栈空间</li>
</ul>
</blockquote>
<h2 id="4-3-单线程和多线程"><a href="#4-3-单线程和多线程" class="headerlink" title="4.3 单线程和多线程"></a>4.3 单线程和多线程</h2><p>单线程：</p>
<blockquote>
<ul>
<li>单线程：一个进程只有一个线程</li>
<li>多线程：一个进程可以有多个线程</li>
</ul>
</blockquote>
<p>线程优点：</p>
<blockquote>
<ul>
<li>创建、上下文切换开销小，速度快</li>
<li>资源共享</li>
<li>充分利用硬件资源</li>
</ul>
</blockquote>
<h2 id="4-4-多线程模型"><a href="#4-4-多线程模型" class="headerlink" title="4.4 多线程模型"></a>4.4 多线程模型</h2><p>用户线程：</p>
<blockquote>
<ul>
<li>用户线程为用户自己管理的线程</li>
<li>用户线程的创建和调度在用户空间中，无需内核干预</li>
<li>应用于只支持进程的操作系统</li>
</ul>
</blockquote>
<p>内核线程</p>
<blockquote>
<ul>
<li>内核线程为由内核管理的线程</li>
<li>由内核完成线程调度、创建和撤销</li>
</ul>
</blockquote>
<h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>映射多个用户线程到一个内核线程：</p>
<blockquote>
<ul>
<li>内核中实际上只有进程，内核能够看到的只有一个进程</li>
<li>此时多线程不能运行在多个处理器上（因此该模型目前不常使用）</li>
<li>用户线程由进程自己管理</li>
</ul>
</blockquote>
<h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><p>每个用户线程都映射到内核线程中：</p>
<blockquote>
<ul>
<li>用于支持线程的操作系统</li>
<li>操作系统来管理这些线程</li>
<li>可以并行运行在多个处理器上，并发性好</li>
<li>内核开销大</li>
</ul>
</blockquote>
<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p>多个用户线程映射为相等或更小数码的内核线程：</p>
<blockquote>
<ul>
<li>兼顾并发性和效率（实际上多对多指的是多个用户线程运行在多个核上）</li>
<li>用户线程和内核线程之间需要添加一个映射层，增加了系统复杂度（该模型不常使用）</li>
</ul>
</blockquote>
<p>两级模型：将多对一模型和一对一模型混合使用</p>
<h3 id="4-4-线程库"><a href="#4-4-线程库" class="headerlink" title="4.4 线程库"></a>4.4 线程库</h3><p>用户库和内核库</p>
<p>线程库：为程序员提供创建和管理线程的API</p>
<blockquote>
<ul>
<li>无内和支持线程库：java线程库</li>
<li>内核支持线程库：Windows线程库</li>
</ul>
</blockquote>
<h3 id="4-5-隐式多线程"><a href="#4-5-隐式多线程" class="headerlink" title="4.5 隐式多线程"></a>4.5 隐式多线程</h3><p>线程池：</p>
<blockquote>
<ul>
<li>从池中创建一批线程，任务来临时，从线程池中取出线程进行处理，处理完后在将线程放回池中</li>
<li>若池中没有可以使用等线程，则任务进入等待状态</li>
</ul>
</blockquote>
<h3 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h3><p>利用Pthreads线程库（第三方线程库）一种用户线程库</p>
<p>Pthreads：</p>
<blockquote>
<ul>
<li>pthread_exit()结束线程运行</li>
<li>pthread_cancel(thread)利用消息终止其他线程</li>
</ul>
</blockquote>
<h1 id="五、进程调度"><a href="#五、进程调度" class="headerlink" title="五、进程调度"></a>五、进程调度</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>调度分类：</p>
<blockquote>
<ul>
<li>长程调度（作业/高级调度）：道（内存中可以同时运行的最大进程数）不够时，选择哪些进程可以新建进入等待状态</li>
<li>中程调度：严格来说属于内存管理，负责将内存中长时间不运行的进程调出到外存中（内存交换）</li>
<li>短程调度（CPU/低级调度）：CPU空闲时，从就绪队列中选择一个进程让其运行</li>
</ul>
</blockquote>
<p>区别：</p>
<blockquote>
<ul>
<li>长程调度在每个进程的生命周期中只出现一次，频率低、速度慢；有些操作系统没有长程调度</li>
<li>短程调度可能出现成千上万次，开销小；操作系统必须有短程调度，一般进程调度指短程调度</li>
</ul>
</blockquote>
<p>进程调度队列：</p>
<blockquote>
<ul>
<li>作业队列：系统中所有进程的队列集合</li>
<li>就绪队列：在主内存中就绪请等待执行的所有进程的队列集合</li>
<li>设备队列：等待某一IO设备的进程队列集合</li>
</ul>
</blockquote>
<p>调度过程：</p>
<blockquote>
<ul>
<li>调度程序：选择进程来执行</li>
<li>分派程序：做进程的上下文切换</li>
</ul>
</blockquote>
<p>调度方式：</p>
<blockquote>
<ul>
<li>非抢占式调度：系统不能抢占已分配进程的CPU（批处理）</li>
<li>抢占式调度：调度程序可以根据某种原则暂停某个正在执行的进程</li>
</ul>
</blockquote>
<p>调度时机：</p>
<blockquote>
<ul>
<li>进程等待（非抢占）</li>
<li>进程就绪（抢占）</li>
<li>进程终止运行（非抢占）</li>
</ul>
</blockquote>
<h2 id="5-2-调度准则"><a href="#5-2-调度准则" class="headerlink" title="5.2 调度准则"></a>5.2 调度准则</h2><p>基本指标：</p>
<blockquote>
<ul>
<li>CPU利用率：固定时间CPU运行时间的比例</li>
<li>吞吐量：单位时间运行完的进程数</li>
<li>周转时间：进程从提交到运行结束需要的全部时间；</li>
<li>等待时间：进程等待调度（不在运行）的时间片总和</li>
<li>响应时间：从进程提出请求到第一次响应（运行）的时间</li>
<li>周转时间=运行时间+等待时间；带权周转时间=周转时间/运行时间</li>
</ul>
</blockquote>
<h2 id="5-3-调度算法"><a href="#5-3-调度算法" class="headerlink" title="5.3 调度算法"></a>5.3 调度算法</h2><h3 id="FCFS先来先服务"><a href="#FCFS先来先服务" class="headerlink" title="FCFS先来先服务"></a>FCFS先来先服务</h3><p>First-Come First-Served：非抢占式</p>
<blockquote>
<ul>
<li>策略：按照进程请求CPU的先后顺序来使用CPU</li>
<li>依据：进入就绪队列的时间</li>
<li>方法：选取队头进程执行</li>
</ul>
</blockquote>
<p>优点：策略简单，理解容易</p>
<p>缺点：平均等待时间往往很长</p>
<h3 id="SJF短作业优先"><a href="#SJF短作业优先" class="headerlink" title="SJF短作业优先"></a>SJF短作业优先</h3><p>Shortest-Job-First：</p>
<blockquote>
<ul>
<li>策略：关联到每个进程下次运行的CPU脉冲长度，调度最短的进程</li>
<li>依据：每个进程下次运行的CPU脉冲长度</li>
<li>方法：选择最短的进程运行</li>
</ul>
</blockquote>
<p>SJF有抢占式调度和非抢占式调度两种：新来的进程比当前执行的进程短</p>
<p>抢占式SJF适合交互式系统，切换开销较大，但会出现饥饿现象</p>
<blockquote>
<p>饥饿：长作业一直得不到运行</p>
</blockquote>
<p>问题：无法准确得到程序将要运行的时间，算法难以实现</p>
<blockquote>
<ul>
<li>使用过往CPU运行时间的指数平均来预测下一次CPU运行时间</li>
</ul>
</blockquote>
<h3 id="PS优先级调度"><a href="#PS优先级调度" class="headerlink" title="PS优先级调度"></a>PS优先级调度</h3><p>优先级高的进程先运行</p>
<p>PS有抢占式调度和非抢占式调度</p>
<p>抢占式PS会出现饥饿问题</p>
<blockquote>
<p>解决方案：老化，即逐渐增加等待时间长的进程优先级</p>
</blockquote>
<p>优先级可以自定义</p>
<h3 id="RR时间片轮转算法"><a href="#RR时间片轮转算法" class="headerlink" title="RR时间片轮转算法"></a>RR时间片轮转算法</h3><p>Rount-Robin：</p>
<blockquote>
<ul>
<li>原理：将一段时间分割成若干个小时间片，每个需要运行的进程获得一个碎片执行</li>
<li>策略：每个进程获得不超过p的时间来运行，执行完或时间用完时切换下一个进程</li>
<li>若进程在时间片结束之前运行完，立刻运行下一个进程</li>
</ul>
</blockquote>
<h3 id="MLQ多级队列调度"><a href="#MLQ多级队列调度" class="headerlink" title="MLQ多级队列调度"></a>MLQ多级队列调度</h3><p>对于不同类型的进程需要不同的调度策略：</p>
<blockquote>
<ul>
<li>交互进程需要短的响应时间</li>
<li>批处理进程需要短的等待时间</li>
</ul>
</blockquote>
<p>多级队列调度：系统中存在多个就绪队列，每个队列有自己的调度算法</p>
<blockquote>
<ul>
<li>队列个数</li>
<li>各队列的调度算法</li>
<li>决定新进程进入哪个队列</li>
</ul>
</blockquote>
<p>例子：前台RR，后台FCFS</p>
<p>优先调度哪个队列中的进程：</p>
<blockquote>
<ul>
<li>固定优先级：前台运行完再运行后台，有可能产生饥饿</li>
<li>给定时间片</li>
</ul>
</blockquote>
<h3 id="MLFQ多级反馈队列调度"><a href="#MLFQ多级反馈队列调度" class="headerlink" title="MLFQ多级反馈队列调度"></a>MLFQ多级反馈队列调度</h3><p>多级反馈队列：进程能在不同队列中移动</p>
<blockquote>
<ul>
<li>多级队列调度算法</li>
<li>进程升级的方法</li>
<li>进程降级的方法</li>
</ul>
</blockquote>
<h2 id="5-4-多处理器调度"><a href="#5-4-多处理器调度" class="headerlink" title="5.4 多处理器调度"></a>5.4 多处理器调度</h2><blockquote>
<ul>
<li>SMP：每个处理器决定自己的调度方案</li>
<li>ASMP：仅一个处理器能处理系统数据结</li>
</ul>
</blockquote>
<p>多处理器调度算法和单处理器相似</p>
<blockquote>
<ul>
<li>负载平衡：将任务平均分配给各个处理器</li>
<li>亲和性：进程在某个CPU上运行尽量长的时间而不被迁移</li>
</ul>
</blockquote>
<h3 id="SQMP单队列多核调度算法"><a href="#SQMP单队列多核调度算法" class="headerlink" title="SQMP单队列多核调度算法"></a>SQMP单队列多核调度算法</h3><p>系统有一个就绪队列，当任意一个CPU空闲时，就从就绪队列中选择一个进程到该CPU上运行</p>
<blockquote>
<ul>
<li>实现简单，负载均衡</li>
<li>不具有亲和性</li>
<li>加锁问题</li>
</ul>
</blockquote>
<h4 id="MQMP多队列调度方法"><a href="#MQMP多队列调度方法" class="headerlink" title="MQMP多队列调度方法"></a>MQMP多队列调度方法</h4><p>系统有多个就绪队列，一般每个CPU一个。每个就绪队列相对独立，有自己的调度算法</p>
<blockquote>
<ul>
<li>亲和性好，不需要加锁</li>
<li>负载不均衡，策略是偷进程</li>
</ul>
</blockquote>
<h1 id="六、同步"><a href="#六、同步" class="headerlink" title="六、同步"></a>六、同步</h1><h2 id="竞争条件和临界区"><a href="#竞争条件和临界区" class="headerlink" title="竞争条件和临界区"></a>竞争条件和临界区</h2><p>多个进程并发或并行执行会导致数据不一致：</p>
<blockquote>
<ul>
<li>不可再现性：同一进程在同一批数据上多次运行结果不一样</li>
<li>原因：进程的并发或并行执行（并且之间有协作）</li>
<li>解决方案：同步（互斥）机制</li>
</ul>
</blockquote>
<p>原子操作：</p>
<blockquote>
<p>一个在执行期间不能被中断的操作</p>
</blockquote>
<p>竞争条件：</p>
<blockquote>
<ul>
<li>多个进程并发访问同一共享数据</li>
<li>共享数据的最终结果取决于最后操作的进程（写覆盖）</li>
</ul>
</blockquote>
<h3 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h3><p>同步：</p>
<blockquote>
<ul>
<li>协调进程的执行次序，使并发进程间能有效地共享资源和相互合作，保证数据一致性</li>
<li>同步用于协调执行次序</li>
</ul>
</blockquote>
<p>互斥：</p>
<blockquote>
<ul>
<li>进程排他性地运行某段代码，任何时候只有一个进程能够运行</li>
<li>互斥可以访问独占资源</li>
</ul>
</blockquote>
<p>互斥是同步的一种特例</p>
<h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>临界资源是一次只允许一个进程使用的资源</p>
<blockquote>
<ul>
<li>又称互斥资源、独占资源或共享变量</li>
<li>反义词：共享资源，一次允许多个进程使用等资源</li>
</ul>
</blockquote>
<p>例子：输入机、打印机、磁带机等</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区是涉及临界资源的代码段</p>
<blockquote>
<ul>
<li>临界区是代码片段，是进程内的代码</li>
<li>每个进程有一个或多个临界区</li>
<li>临界区的设置方法由程序员来确定</li>
</ul>
</blockquote>
<p>对临界资源的互斥访问可以保证进程互斥地进入关联到临界区</p>
<p>临界区使用准则：</p>
<blockquote>
<ul>
<li>互斥：有相同临界资源的临界区需要互斥；无相同临界资源的临界区不需要互斥</li>
<li>有空让进：临界区内无进程执行时，不能无限期延长下一个要进入临界区进程的等待时间</li>
<li>有限等待：每个进程进入临界区前的等待时间必须有限</li>
</ul>
</blockquote>
<p>访问临界区的过程：</p>
<blockquote>
<ul>
<li>进入区：互斥准则</li>
<li>临界区：有限等待准则（临界区不能过大）</li>
<li>退出区：有空让进准则</li>
<li>其他区</li>
</ul>
</blockquote>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>早期同步和互斥采用硬件解决方案，设计起来十分复杂</p>
<p>信号量是同步和互斥的一种软件解决方案</p>
<blockquote>
<ul>
<li>保证两个或多个代码段不被并发调用</li>
<li>在进入关键代码段前，进程必须获取一个信号量，否则不能运行</li>
<li>执行完该关键代码段，必须释放信号量</li>
<li>信号量有值，为正说明它空闲，为负说明其忙碌</li>
</ul>
</blockquote>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>信号量S是一个整型变量，它有两个原子操作</p>
<blockquote>
<ul>
<li>wait(S)：P(S)，通过while等待S大于等于0，然后令S–</li>
<li>signal(S)：V(S)，S++</li>
<li>会出现wait忙等问题</li>
</ul>
</blockquote>
<p>改进：记录型信号量，使用原子操作将等待进程加入队列</p>
<blockquote>
<ul>
<li>记录型信号量可以为负数，绝对值表示等待信号量的进程个数</li>
<li>执行原子操作本身其实也有忙等待问题</li>
</ul>
</blockquote>
<h3 id="信号量类型"><a href="#信号量类型" class="headerlink" title="信号量类型"></a>信号量类型</h3><p>计数信号量：</p>
<blockquote>
<ul>
<li>没有限制的整型值</li>
<li>计数信号量为同步信号量</li>
</ul>
</blockquote>
<p>二值信号:</p>
<blockquote>
<ul>
<li>变化范围为0和1（整型）</li>
<li>二值信号量为互斥信号量</li>
<li>记录型二进制信号量可以为负</li>
</ul>
</blockquote>
<p>信号量S的使用：</p>
<blockquote>
<ul>
<li>S仅且只能设置一次初始值</li>
<li>S的初始值不能为负数</li>
<li>除了初始化，只能通过PV操作来访问S</li>
</ul>
</blockquote>
<h3 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h3><p>互斥信号量的使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore *S; &#x2F;&#x2F;S&#x3D;1</span><br><span class="line">wait(S);</span><br><span class="line">CriticalSection();</span><br><span class="line">signal(S);</span><br></pre></td></tr></table></figure>

<p>同步信号量的使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Semaphore S &#x3D; 0;</span><br><span class="line">P1: &#x2F;&#x2F; process 1</span><br><span class="line">	C1;</span><br><span class="line">    signal(S);</span><br><span class="line">P2: &#x2F;&#x2F; process 2</span><br><span class="line">    wait(S);</span><br><span class="line">    C2;</span><br></pre></td></tr></table></figure>

<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>本质：协同进程共享有限缓冲区</p>
<blockquote>
<ul>
<li>M个生产产品放入固定大小的缓冲区</li>
<li>N个消费者从缓冲区中取出产品进行消费</li>
</ul>
</blockquote>
<p>两个指针：in和out；in&gt;out</p>
<p>一个计数值：count，用于记录缓冲区中点产品个数</p>
<h3 id="互斥分析"><a href="#互斥分析" class="headerlink" title="互斥分析"></a>互斥分析</h3><p>临界资源：</p>
<blockquote>
<ul>
<li>所有生产者对in指正互斥</li>
<li>所有消费者对out指正互斥</li>
<li>生产者和消费者多count互斥</li>
</ul>
</blockquote>
<p>临界区：</p>
<blockquote>
<ul>
<li>将产品放入缓冲区</li>
<li>从缓冲区中取出产品</li>
</ul>
</blockquote>
<p>互斥机制：此时可以只设置一个信号量，比较简单，但稍微拉长了临界区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Semaphore *buffer &#x3D; new Semaphore(1); &#x2F;&#x2F; 互斥信号量</span><br><span class="line"></span><br><span class="line">Producer&#123;</span><br><span class="line">	producing;</span><br><span class="line">    </span><br><span class="line">    wait(buffer);</span><br><span class="line">    putting production;</span><br><span class="line">    signal(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer&#123;</span><br><span class="line">	wait(buffer);</span><br><span class="line">    feching production;</span><br><span class="line">    signal(buffer);</span><br><span class="line">    </span><br><span class="line">    consuming production;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p>查找需要按次序运行的代码和其执行顺序</p>
<blockquote>
<ul>
<li>缓冲区为空，消费者进行消费，此时消费者阻塞直到生产者生产</li>
<li>缓冲区为满，生产者进行生产，此时生产者阻塞直到消费者消费</li>
</ul>
</blockquote>
<p>同步机制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Semaphore *buffer &#x3D; new Semaphore(1);</span><br><span class="line">Semaphore *full &#x3D; new Semaphore(0); &#x2F;&#x2F; 有0个已填充</span><br><span class="line">Semaphore *empty &#x3D; new Semaphore(N); &#x2F;&#x2F; 有N个空位</span><br><span class="line"></span><br><span class="line">Producer&#123;</span><br><span class="line">	producing;</span><br><span class="line">    </span><br><span class="line">    wait(empty); &#x2F;&#x2F; 等待空位</span><br><span class="line">    wait(buffer);</span><br><span class="line">    puting production;</span><br><span class="line">    signal(buffer);</span><br><span class="line">    signal(full); &#x2F;&#x2F; 进行填充</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer&#123;</span><br><span class="line">	wait(full); &#x2F;&#x2F; 等待填充</span><br><span class="line">    wait(buffer);</span><br><span class="line">    feching production;</span><br><span class="line">    signal(buffer);</span><br><span class="line">    signal(empty); &#x2F;&#x2F;给出空位</span><br><span class="line">    </span><br><span class="line">    consuming production;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>读者和写者共享一组数据区进行读写：</p>
<blockquote>
<ul>
<li>允许多个读者同时读</li>
<li>不允许读者和写者同时读写</li>
<li>不允许多个写者同时写</li>
</ul>
</blockquote>
<h3 id="读者优先模式"><a href="#读者优先模式" class="headerlink" title="读者优先模式"></a>读者优先模式</h3><p>极端情况：设置一个互斥锁：</p>
<blockquote>
<p>违背了读者共享读的功能</p>
</blockquote>
<p>进行修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Semaphore M&#x3D;1；</span><br><span class="line">Semaphore W&#x3D;1;</span><br><span class="line">int rc&#x3D;0;</span><br><span class="line"></span><br><span class="line">Readers&#123;</span><br><span class="line">	P(M);</span><br><span class="line">    rc++;</span><br><span class="line">    if(rc&#x3D;&#x3D;1) P(W);</span><br><span class="line">    V(M);</span><br><span class="line">    reading;</span><br><span class="line">    P(M);</span><br><span class="line">    rc--;</span><br><span class="line">    if(rc&#x3D;&#x3D;0) V(W);</span><br><span class="line">    V(M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Writers&#123;</span><br><span class="line">	P(W);</span><br><span class="line">    writing;</span><br><span class="line">    V(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：一直有读者进行读的话，写者可能会长期饥饿</p>
<h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>共享资源竞争问题：</p>
<blockquote>
<ul>
<li>5根筷子和5个哲学家间隔排成环</li>
<li>每个哲学家左右各有一根筷子</li>
<li>每个哲学家只有拿起左右两个筷子才能吃饭</li>
</ul>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>为每个筷子设置一个互斥信号量：死锁问题</p>
<p>防止死锁发生：</p>
<blockquote>
<ul>
<li>最多允许4个哲学家同时坐在桌子周围</li>
<li>一次封锁法：当且仅当哲学家左右两边筷子都可用时，才允许拿筷子（较好）</li>
<li>顺序封锁法：给哲学家编号，奇数号哲学家必须首先拿左边筷子，偶数号反之</li>
</ul>
</blockquote>
<h3 id="最多4个哲学家入座"><a href="#最多4个哲学家入座" class="headerlink" title="最多4个哲学家入座"></a>最多4个哲学家入座</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Semaphore *chopstick[5]</span><br></pre></td></tr></table></figure>

<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>信号量灵活，但维护困难，容易出错</p>
<p>管程：</p>
<blockquote>
<ul>
<li>管程定义了一个数据结构和一组能在该数据结构上并发执行的一组操作</li>
<li>该操作能同步进程和改变管程中点数据</li>
</ul>
</blockquote>
<p>管程功能：</p>
<blockquote>
<ul>
<li>（互斥）管程中的变量只能被管程中的操作访问</li>
<li>任何时候只有一个进程在管程中操作</li>
<li>类似临界区</li>
<li>由编译器完成</li>
<li>（同步）条件变量</li>
<li>唤醒和阻塞操作</li>
</ul>
</blockquote>
<h2 id="Linux同步机制"><a href="#Linux同步机制" class="headerlink" title="Linux同步机制"></a>Linux同步机制</h2><ul>
<li>短临界区：禁止中断</li>
<li>自旋锁</li>
<li>互斥锁</li>
<li>条件变量</li>
<li>信号量</li>
</ul>
<h2 id="Windows同步机制"><a href="#Windows同步机制" class="headerlink" title="Windows同步机制"></a>Windows同步机制</h2><ul>
<li>事件</li>
<li>临界区</li>
<li>互斥锁</li>
<li>自旋锁</li>
<li>信号量</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/09/08/operating-system0/" data-id="ckh1rlca1001vkovn91fi6nzv"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/09/08/algorithm0/" class="article-nav-link">
        <strong class="article-nav-caption">Prev Post</strong>
        <div class="article-nav-title">
          
            算法设计与分析基础知识
          
        </div>
      </a>
    
    
      <a href="/2020/09/06/computer-network0/" class="article-nav-link">
        <strong class="article-nav-caption">Next Post</strong>
        <div class="article-nav-title">计算机网络</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: 'ze0YzGUMUrLXgdRQpKyDCEEm-gzGzoHsz',
        app_key: 'NnhAiNVNGXwbCD1sMGNRjA8B',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: 'Leave your comments here ~',
        recordIP: true,
        lang: 'en'
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        George Chen
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="George"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HOME</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives/">ARCHIVE</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">CATE.</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">TAGS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://github.com/georgechen1827/" target="_blank" rel="noopener">about me</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/coming_soon.html" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>







<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>