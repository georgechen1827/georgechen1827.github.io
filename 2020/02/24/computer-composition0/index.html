<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="this is George Chen&#39;s blog!" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    计算机组成相关知识 |  George
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-computer-composition0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  计算机组成相关知识
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/24/computer-composition0/" class="article-date">
  <time datetime="2020-02-24T02:32:00.000Z" itemprop="datePublished">2020-02-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> about </span>
            <span class="post-count">28.2k words</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> costs </span>
            <span class="post-count">98 minutes</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><del>未完结,持续更新</del>完结</p>
<hr>
<p>网课资源: (智慧树)长春师范大学计算机组成</p>
<p>参考教材: 清华大学出版社《计算机组成与结构(第5版)》</p>
<p>课程内容:</p>
<ul>
<li>讨论单机系统范围内计算机各部件和系统的组成原理以及内部工作机制</li>
</ul>
<p>课程目标:</p>
<ul>
<li>计算机个大部件的组成原理</li>
<li>计算机各大部件的逻辑实现</li>
<li>计算机各大部件的设计方法</li>
<li>计算机各大部件互联构成整体系统的技术</li>
<li>(为后继课程的学习打好基础)</li>
</ul>
<p>课程地位: 承上启下</p>
<ul>
<li>先导课程: 计算机导论,数字逻辑</li>
<li>后继课程: 微机原理,接口技术,计算机系统结构</li>
</ul>
<p>重点难点:</p>
<ul>
<li>掌握五大基本部件的原理及实现</li>
<li>掌握各部件互联构成整机系统的知识(整机概念的建立)</li>
</ul>
<p>课程要求:</p>
<ul>
<li>重点掌握: 多层次的存储器,中央处理器</li>
<li>掌握: 运算方法和运算器,指令系统,总线系统</li>
<li>理解: 外存与io设备</li>
<li>了解: 计算机系统概论,输入输出系统</li>
</ul>
<a id="more"></a>

<h1 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h1><p>计算机的定义,分类.发展史</p>
<h2 id="1-1-计算机发展简史"><a href="#1-1-计算机发展简史" class="headerlink" title="1.1 计算机发展简史"></a>1.1 计算机发展简史</h2><p>计算机: 能够连续自动进行数值和逻辑运算的机器</p>
<p>分类:</p>
<ul>
<li>原理角度: 数字计算机,模拟计算机</li>
<li>性能指标: 巨型机,大型机,小型机,微型机</li>
<li>用途角度: 专用机,通用机</li>
</ul>
<p>计算机发展阶段:</p>
<ul>
<li>1946-1957: 电子管时代,ENIAC(1946)</li>
<li>1958-1964: 晶体管时代,整体性能大幅度提高,TRADIC(增加浮点运算)</li>
<li>1965-1971: 中小规模集成电路,进入文字处理和图形图像处理</li>
<li>1972-: 大和超大规模集成电路,出现微处理器</li>
</ul>
<h2 id="1-2-计算机硬件"><a href="#1-2-计算机硬件" class="headerlink" title="1.2 计算机硬件"></a>1.2 计算机硬件</h2><p>硬件系统的组成: 冯诺依曼结构,以存储器为中心</p>
<p>特点:</p>
<ul>
<li>计算机(硬件)应由运算器,存储器,控制器,输入设备,输出设备组成</li>
<li>计算机内部采用二进制来表示指令和数据</li>
<li>将编好的程序和原始数据实现存入存储器中然后再启动计算机工作</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/compo0.jpg" alt="composition">  </p>
<ul>
<li>运算器: 数据的加工处理  </li>
<li>控制器: 指令控制,操作控制,时序控制  </li>
<li>存储器: 存放数据和程序  </li>
<li>输入设备: 将外部数据送给计算机并转换成计算机能够识别的形式  </li>
<li>输出设备: 将计算机处理结果送出给外界并转换成外界能够识别的形式<blockquote>
<ul>
<li>运算器,控制器一般为cpu  </li>
<li>存储器一般由主存(内存)和辅存组成  </li>
<li>cpu和主存一般构成主机</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>以运算器为核心构造时,输入设备的数据得通过运算器才能进入存储器中;因此以存储器为核心的构造可以提高计算机系统运行的效率</p>
</blockquote>
<p>个计算结构时以总线连接起来的: 总线上有地址,数据,控制三种信号线,结构如下:<br><img src="/2020/02/24/computer-composition0/bus0.jpg" alt="bus"></p>
<h2 id="1-3-计算机软件"><a href="#1-3-计算机软件" class="headerlink" title="1.3 计算机软件"></a>1.3 计算机软件</h2><p>软件和硬件之间存在着逻辑等价关系</p>
<p>语言: 计算机语言经历了由机器语言-&gt;汇编语言-&gt;高级语言的发展过程</p>
<p>计算机系统的多级层次结构(由低到高):</p>
<ul>
<li>硬件(机器语言级)-&gt;操作系统级-&gt;中间件/平台级-&gt;应用程序级(高级语言)</li>
</ul>
<h1 id="二、计算机中常用的组合逻辑电路"><a href="#二、计算机中常用的组合逻辑电路" class="headerlink" title="二、计算机中常用的组合逻辑电路"></a>二、计算机中常用的组合逻辑电路</h1><h2 id="2-1-计算机种常用的组合逻辑电路"><a href="#2-1-计算机种常用的组合逻辑电路" class="headerlink" title="2.1 计算机种常用的组合逻辑电路"></a>2.1 计算机种常用的组合逻辑电路</h2><h3 id="三态门"><a href="#三态门" class="headerlink" title="三态门"></a>三态门</h3><p>三态: 0,1,高阻态Z<br><img src="/2020/02/24/computer-composition0/compo1.jpg" alt="composition"></p>
<p>三态门通常用于驱动总线,当控制端G=1时,数据线A和总线接通,G=0时,该数据线和总线断开</p>
<blockquote>
<p>当总线传输数据时,应当只有一个三态门是正常工作的</p>
</blockquote>
<h3 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h3><p>异或门是计算单元中常用的逻辑电路<br><img src="/2020/02/24/computer-composition0/compo2.jpg" alt="composition"></p>
<p>常见异或门应用:</p>
<ul>
<li>数码比较器 </li>
<li>原码/反码输出电路  </li>
<li>奇偶检测电路</li>
</ul>
<h3 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h3><p>加法器是计算机的基本运算部件之一</p>
<p>半加器不考虑前一位的进位输入:<br><img src="/2020/02/24/computer-composition0/compo3.jpg" alt="composition"></p>
<p>全加器考虑前一位的进位输入:<br><img src="/2020/02/24/computer-composition0/compo4.jpg" alt="composition"></p>
<h4 id="串行进位加法器"><a href="#串行进位加法器" class="headerlink" title="串行进位加法器"></a>串行进位加法器</h4><p>将多个全加器串联,可以得到多位的加法器,但后一位的计算需要等前一位计算完成后才能开始,导致加法效率较低  </p>
<h4 id="超前进位加法器"><a href="#超前进位加法器" class="headerlink" title="超前进位加法器"></a>超前进位加法器</h4><p>超前进位产生电路通过迭代各位进位的产生式,得到直接产生各位进位的表达式来实现的;后一位的进位无需等待前一位的进位就可以产生,高效但需要使用更多的组合逻辑单元</p>
<p>原理如下:</p>
<ol>
<li>考虑第每一位进位ci的产生条件:<br>$X_i,Y_i$均为1,或$X_i,Y_i$有一个为1且$C_{i-1}$为1,即<br>$C_i=X_iY_i+(X_i+Y_i)C_{i-1}$</li>
<li>由$C_1=X_1Y_1+(X_1+Y_1)C_0$不停对$C_i$进行迭代化简,得到:<br>$$C_i=X_iY_i+\sum_{n=i-1}^1(X_nY_n\prod_{k=i}^{n}(X_k+Y_k))+C_0\prod_{k=i}^{1}(X_k+Y_k)$$<br>如:$C_4=X_4Y_4+(X_4+Y_4)X_3Y_3+(X_4+Y_4)(X_3+Y_3)X_2Y_2+…+..C_0$</li>
<li>定义进位传递函数$P_i=X_i+Y_i$,表明$X_i,Y_i$有一个为1时,将前一位进位传给下一位,达到一种进位传递的效果<br>定义进位产生函数$G_i=X_iY_i$,表明$X_i,Y_i$都为1时,无论$P_i$如何必定向高位产生进位<br>如,此时$C_3=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0$</li>
<li>将各进位改成与非式,画出电路图,如下<br> <img src="/2020/02/24/computer-composition0/compo5.jpg" alt="composition"></li>
</ol>
<h4 id="ALU算数逻辑单元"><a href="#ALU算数逻辑单元" class="headerlink" title="ALU算数逻辑单元"></a>ALU算数逻辑单元</h4><p>考虑到超前进位电路的复杂程度是随着位数呈指数增加,一般可以将4位超前进位电路封装成算数逻辑单元,然后再通过组间的串行或超前进位组成16位的ALU</p>
<p>16位快速ALU:组间快速进位<br><img src="/2020/02/24/computer-composition0/compo6.jpg" alt="composition"></p>
<ul>
<li>$G_n=(片内)G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0$</li>
<li>$P_n=(片内)P_3P_2P_1P_0$</li>
<li>$C_11=G_{N_2}+P_{N_2}G_{N_1}+P_{N_2}P_{N_1}G_{N_0}+P_{N_2}P_{N_1}P_{N_0}C_n$,依次类推</li>
</ul>
<p>相比于组间串行进位,最高位进位需要等待前三次进位;16位快速ALU只需要等待一次片内的进位即可;ALU在保证一定运行速度间的同时使得电路规模没有过大</p>
<h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>由n个输入,最多$2^n$个输出组合而成的逻辑电路,包含:</p>
<ul>
<li>$\overline E$:使能端,一般低有效</li>
<li>$A,B,C(A_1,A_2,A_3)…$:输入端,高有效</li>
<li>$Y_1,Y_2,…,Y_8,…$:输出端,一般低有效</li>
</ul>
<p>通常将使能端连接另一个译码器的输出(CS:芯片选择功能),可以将译码器的译码范围进行扩展</p>
<h3 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h3><p>由$2^n$个输入,n个输出组合而成的逻辑电路,包含:</p>
<ul>
<li>$\overline G_1,\overline G_2$(双数据选择器):使能信号,由一个三态门控制,一般低有效</li>
<li>$S_0,S_1$:通道选择端,高有效</li>
<li>$D_0,D_1,D_2,D_3,…,D_7$(双4选1):通道输入端</li>
<li>$Y_1,Y_2$:输出端,输出所选择通道的电位</li>
</ul>
<p>在保证$\overline G_1,\overline G_2$反相的情况下,可以连接$Y_1,Y_2$来扩展选择通道数</p>
<h2 id="2-2-时序逻辑电路"><a href="#2-2-时序逻辑电路" class="headerlink" title="2.2 时序逻辑电路"></a>2.2 时序逻辑电路</h2><p>如果逻辑电路的输出状态不但和当时的输入状态有关，而且还与电路在此以前的输入状态有关，称这种电路为时序逻辑电路。</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="电位触发器"><a href="#电位触发器" class="headerlink" title="电位触发器"></a>电位触发器</h4><p><img src="/2020/02/24/computer-composition0/compo7.jpg" alt="composition"></p>
<p>普通触发器存在触发不能被同步的问题</p>
<h4 id="边沿D触发器"><a href="#边沿D触发器" class="headerlink" title="边沿D触发器"></a>边沿D触发器</h4><p>每当经过一个时钟周期时(CP上升沿或下降沿):<br>$Q^n=D$</p>
<p>边沿触发器存在空翻问题</p>
<h4 id="主从JK触发器"><a href="#主从JK触发器" class="headerlink" title="主从JK触发器"></a>主从JK触发器</h4><p>$Q^n=J \overline Q + \overline K Q$</p>
<h3 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h3><p><img src="/2020/02/24/computer-composition0/compo8.jpg" alt="composition"></p>
<p>每当经过一个时钟周期时,移位寄存器向最低位读取数据,将最高位数据输出,并进行移位</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>每当经过一个时钟周期,将计数加1,计数满则清零并输出进位信息</p>
<ul>
<li>$\overline R_D$:异步清零信号,一般低有效</li>
<li>$L$:同步置数信号,高有效</li>
<li>$Q_1,Q_2,…$:同步置数端</li>
<li>$P,T$:计数使能信号,均高有效,否则为保持状态</li>
<li>$CK$:时钟信号</li>
<li>$RC$:进位信号</li>
</ul>
<h2 id="2-3-阵列逻辑电路"><a href="#2-3-阵列逻辑电路" class="headerlink" title="2.3 阵列逻辑电路"></a>2.3 阵列逻辑电路</h2><p>阵列逻辑电路表明逻辑元件以阵列的形式在硅芯片上排列</p>
<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p>存储器:</p>
<ul>
<li>字:放置信息的单元,由多个位组成</li>
<li>位:一个二进制信息</li>
<li>地址(码):存储器中每个字的编号,用于寻找存入存储器的字</li>
</ul>
<p>ROM主要由地址译码器和存储单元体构成,通过在每个位置设置或不设置三极管、二极管、熔丝等元件来表示存入的二进制信息<br><img src="/2020/02/24/computer-composition0/rom0.jpg" alt="rom"><br><img src="/2020/02/24/computer-composition0/rom1.jpg" alt="rom"><br>由上图可以看出,ROM存储的是一种主析取范式的表达式</p>
<p>ROM主要有如下两个缺陷:</p>
<ul>
<li>ROM实际存储的字数常少于它所能提供的字数,造成存储单元的闲置和芯片面积的浪费</li>
<li>ROM中的地址和字之间有一一对应的关系,在存储大量重复内容时不能灵活节省空间</li>
</ul>
<h3 id="可编程序逻辑阵列PLA"><a href="#可编程序逻辑阵列PLA" class="headerlink" title="可编程序逻辑阵列PLA"></a>可编程序逻辑阵列PLA</h3><ul>
<li>相比于ROM,PLA能用较少的存储单元存储大量的信息</li>
<li>ROM存储的是一种主析取范式的表达式,而PLA可以存储最简的与或式,因此可以节省一些存储资源的消耗<br><img src="/2020/02/24/computer-composition0/rom2.jpg" alt="rom"> </li>
</ul>
<h3 id="可编程序阵列逻辑PAL"><a href="#可编程序阵列逻辑PAL" class="headerlink" title="可编程序阵列逻辑PAL"></a>可编程序阵列逻辑PAL</h3><ul>
<li>PAL中的与阵列是可编程的,但或阵列不可编程;而在PAL中,两者都可以编程,还有一些PAL中带有记忆元件或反馈电路</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/pal0.jpg" alt="pal"></p>
<h3 id="通用阵列逻辑GAL"><a href="#通用阵列逻辑GAL" class="headerlink" title="通用阵列逻辑GAL"></a>通用阵列逻辑GAL</h3><ul>
<li>ROM,PLA,PAL是一次性编程的,编程后不能修改</li>
<li>GAL是一种可用电擦除的,可重复编程的高速PLD(可编程逻辑电路)</li>
<li>可重复擦写100次以上,数据可保存20年以上,数秒内即可完成擦除和编程的过程</li>
</ul>
<h3 id="门阵列GA-宏单元阵列MCA，标准单元阵列SCA"><a href="#门阵列GA-宏单元阵列MCA，标准单元阵列SCA" class="headerlink" title="门阵列GA,宏单元阵列MCA，标准单元阵列SCA"></a>门阵列GA,宏单元阵列MCA，标准单元阵列SCA</h3><ul>
<li>这些芯片是用来实现批量较大的专用集成电路的</li>
<li>这三种芯片内部的单元都是以阵列形式排列的</li>
</ul>
<h4 id="门阵列"><a href="#门阵列" class="headerlink" title="门阵列"></a>门阵列</h4><p>门阵列设计利用预先制造好的“母片”来进行布图设计;母片上通常以一定的间距成行成列的排列着基本单元电路。</p>
<ul>
<li>这样可以降低设计成本,缩短设计周期:因为母片已完成了整个集成电路制造工艺的大部分流程,剩下只要进行布线连接,就可以实现各种逻辑需求</li>
<li>门阵列器件是一种半用户器件或半定制器件</li>
</ul>
<h4 id="宏单元阵列"><a href="#宏单元阵列" class="headerlink" title="宏单元阵列"></a>宏单元阵列</h4><p>宏单元阵列是一种对门阵列的改进,逻辑功能更强,布图密度更高,制造周期更短</p>
<h4 id="标准单元阵列"><a href="#标准单元阵列" class="headerlink" title="标准单元阵列"></a>标准单元阵列</h4><p>标准单元以预先设计好的功能单元(如门,触发器,加法器等)为基础进行设计生产</p>
<ul>
<li>不同于门阵列那样事先生产半成品芯片;在标准单元阵列中,所有单元都是根据用户逻辑图的需要安排在芯片上。</li>
<li>标准单元阵列是定制器件而非半定制器件,但布局布线更易于实现</li>
</ul>
<h3 id="现场可编程序门阵列FPGA"><a href="#现场可编程序门阵列FPGA" class="headerlink" title="现场可编程序门阵列FPGA"></a>现场可编程序门阵列FPGA</h3><ul>
<li>FPGA由大规模集成电路构成，门电路数达到几万个到几百万个</li>
<li>它主要由四个部分组成：<blockquote>
<ul>
<li>可编程序逻辑宏单元(CLB)</li>
<li>可编程序输入输出宏单元(IOB)</li>
<li>互连资源</li>
<li>重构逻辑的程序存储器: 可以允许多次逻辑的修改,适合在在产品试验或生产批蜇不大时使用</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="三、运算方法和运算部件"><a href="#三、运算方法和运算部件" class="headerlink" title="三、运算方法和运算部件"></a>三、运算方法和运算部件</h1><h2 id="3-1-数值型数据的表示方法和转换"><a href="#3-1-数值型数据的表示方法和转换" class="headerlink" title="3.1 数值型数据的表示方法和转换"></a>3.1 数值型数据的表示方法和转换</h2><ul>
<li>数制: $ (D_m…D_0.D_{-1} .. D_{-k})i $ 是一个i进制数,可以表示成 $ \sum_{n=-k}^mD_n*i^n $,其中i称为基数或底</li>
</ul>
<h3 id="不同数制之间的数据转换"><a href="#不同数制之间的数据转换" class="headerlink" title="不同数制之间的数据转换"></a>不同数制之间的数据转换</h3><h4 id="二进制-八进制-和十六进制转换"><a href="#二进制-八进制-和十六进制转换" class="headerlink" title="二进制,八进制,和十六进制转换"></a>二进制,八进制,和十六进制转换</h4><ul>
<li>二进制转八进制: 从小数点向两边三位成一组转换</li>
<li>二进制转十六进制: 从小数点向两边四位成一组转换</li>
</ul>
<h4 id="二进制-十进制的转换"><a href="#二进制-十进制的转换" class="headerlink" title="二进制,十进制的转换"></a>二进制,十进制的转换</h4><ul>
<li>二进制转十进制用公式$ \sum_{n=-k}^mD_n*2^n $</li>
<li>十进制转二进制用除2取余法(整数部分)和乘2取整法(小数部分)</li>
</ul>
<h3 id="十进制数的编码与运算"><a href="#十进制数的编码与运算" class="headerlink" title="十进制数的编码与运算"></a>十进制数的编码与运算</h3><h4 id="有权码"><a href="#有权码" class="headerlink" title="有权码"></a>有权码</h4><p>如8421,5421,2421BCD编码</p>
<ul>
<li>注意,这种编码是对十进制的每一位进行编码运算,而不是对整个十进制数的运算</li>
</ul>
<h4 id="无权码"><a href="#无权码" class="headerlink" title="无权码"></a>无权码</h4><p>如余3码,格雷码(循环码)</p>
<h2 id="3-2-带符号的二进制数在计算机中的表示方法及加减运算"><a href="#3-2-带符号的二进制数在计算机中的表示方法及加减运算" class="headerlink" title="3.2 带符号的二进制数在计算机中的表示方法及加减运算"></a>3.2 带符号的二进制数在计算机中的表示方法及加减运算</h2><ul>
<li>计算机中表示的带符号的二进制数称为机器数</li>
<li>机器数有原码,补码,反码三种表示方式</li>
<li>这里,假设机器数的真值为[-1,1]的小数,小数部分为数值,整数部分为符号<blockquote>
<p>如:1.0100=10100</p>
</blockquote>
</li>
</ul>
<h3 id="原码-反码-补码及其加减运算"><a href="#原码-反码-补码及其加减运算" class="headerlink" title="原码,反码,补码及其加减运算"></a>原码,反码,补码及其加减运算</h3><h4 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h4><ul>
<li>原码最高位是符号位,0表示正数,1表示负数</li>
<li>其他位是数值位,以绝对值的方式给出</li>
<li>数值0有+0和-0两种原码表示,即0.0000和1.0000</li>
</ul>
<p>原码的加减法需要判断正负号,比较麻烦</p>
<h4 id="反码表示"><a href="#反码表示" class="headerlink" title="反码表示"></a>反码表示</h4><p>正数不变;负数反码在原码的基础上,符号位不变,其他位取反</p>
<ul>
<li>反码的反码是原码</li>
<li>运算时，当最高位有进位而丢掉进位时,要在最低位加1(循环进位)。</li>
</ul>
<h4 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h4><p>正数不变;负数补码在反码的基础上,数值加1</p>
<ul>
<li>数值0的补码形式是唯一的,为0.0000</li>
<li>补码的补码是原码</li>
</ul>
<p>补码在运算中有如下性质:</p>
<ul>
<li>符号位与数值位一样参与运算</li>
<li>补码运算的结果仍为补码</li>
<li>[X]补+[Y]补=[X+Y]补</li>
<li>[X]补-[Y]补=[X]补+[-Y]补</li>
<li>注意,Y与-Y正负号不同,求补码的策略也不同</li>
<li>补码运算时最高位产生的进位直接舍去即可</li>
</ul>
<h3 id="加减运算的溢出处理"><a href="#加减运算的溢出处理" class="headerlink" title="加减运算的溢出处理"></a>加减运算的溢出处理</h3><p>溢出:运算结果超出机器数所能表示的范围</p>
<ul>
<li>异号相加或同号相减结果是不会溢出的,只考虑同号相加或异号相减的情况</li>
<li>注意,最高位是否产生进位和运算结果是否溢出没有关系</li>
</ul>
<p>溢出判断有如下几种方法:</p>
<ul>
<li>同号两数相加,结果符号与两加数不相同,则溢出<blockquote>
<p>$\overline f_A \overline f_B f_S + f_A f_B \overline f_S = 1,其中,f_A f_B f_S$分别为两运算数的符号和结果的符号</p>
</blockquote>
</li>
<li>最高位进位和符号位进位不相同,则溢出<ul>
<li>即,运算正确的情况下,最高位(符号位的前一位)的进位一定要导致符号位进<blockquote>
<p>$C \overline C_f +\overline  C C_f = 1; 其中C,C_f$分别是最高位的进位和符号位的进位</p>
</blockquote>
</li>
</ul>
</li>
<li>采用双符号位运算,正数符号为00,负数为11,此时当结果的两个符号位不同时,溢出<blockquote>
<p>$\overline f_{S2} f_{S1} + f_{S2} \overline f_{S1} = 1,其中f_{S2},f_{S1}$分别是两位符号位</p>
</blockquote>
</li>
</ul>
<h3 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h3><p>在计算机中的数据有定点数和浮点数两种表示方式</p>
<h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>定点数指小数点固定在某个位置上的数据,前面加减法中讨论的为定点数</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数指小数点位置可以浮动的数据,可以用$N = M*R^E$表示</p>
<ul>
<li>N为浮点数,M为尾数,E为阶码,R为阶的基数;一般情况下一个计算机中的R都是相同的,无需存储</li>
</ul>
<p>浮点数在计算机中一般以这样的形式显示:$M_S$–$E$–$M$</p>
<ul>
<li>$M_S$: 尾数的符号位(一般为一位),设置在最高位</li>
<li>$E$: 阶码,有n+1位,一般为整数,第一位为符号位</li>
<li>$M$: 尾数,有m位,和前面的$M_S$一同组成一个定点小数<blockquote>
<ul>
<li><p>规格化尾数:当R=2(二进制数)且尾数不为0时,其绝对值应大于或等于十进制的0.5(即最高位应当为1);对非规格化浮点数,需要将尾数左移或右移,并改变阶码使其满足规格化要求  </p>
<blockquote>
<p>如:0.0011 -&gt; (0.11)*2^(0010)</p>
</blockquote>
</li>
<li><p>机器零值:表示比机器数能表示的最小数还要小的值</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>浮点数国际标准: IEEE 754</p>
<ul>
<li>单精度浮点数(32位):阶码8位,尾数24位(含一位符号位)</li>
<li>双精度浮点数(64位):阶码11位,尾数53位(含一位符号位)</li>
<li>浮点数基数为2,阶码采用增码(移码),尾数采用原码</li>
<li>而在多数通用机中，浮点数的尾数用原码或补码表示，阶码用补码或移码表示。</li>
<li>注意,由于规格化后的原码最高位恒为1,存储时自动省略,需要在计算时自己加上去<blockquote>
<ul>
<li>移码:在补码基础上,将符号位取反;在阶码上的移码只执行加减运算,且需要对结果进行修正</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="数值范围和精度"><a href="#数值范围和精度" class="headerlink" title="数值范围和精度"></a>数值范围和精度</h3><p>数值范围指机器所能表示的一个数的最大值和最小值;精度是指一个数的有效位数</p>
<ul>
<li>32位定点小数(补码):$-1$(1000…)~$1-2^{-31}$(0111…)</li>
<li>32位定点整数(补码):$-2^{31}$(1000…)~$2^{31}-1$(0111…)</li>
<li>32位单精度浮点数:$-2^{127}$~$(1-2^{-23})*2^{127}$,精度为24位</li>
</ul>
<h2 id="3-3-二进制乘法运算"><a href="#3-3-二进制乘法运算" class="headerlink" title="3.3 二进制乘法运算"></a>3.3 二进制乘法运算</h2><h3 id="定点数一位乘法"><a href="#定点数一位乘法" class="headerlink" title="定点数一位乘法"></a>定点数一位乘法</h3><h4 id="定点原码一位乘"><a href="#定点原码一位乘" class="headerlink" title="定点原码一位乘"></a>定点原码一位乘</h4><p>人工算法:<br><img src="/2020/02/24/computer-composition0/multi0.jpg" alt="multipy"></p>
<p>机器算法:<br><img src="/2020/02/24/computer-composition0/multi1.jpg" alt="multipy"></p>
<ul>
<li>在机器中,有3个寄存器ABC,分别存放部分积,被乘数和乘数的绝对值,其中部分积和被乘数都以双符号位表示;具体过程如下:</li>
</ul>
<ol>
<li>初始化:A寄存器清零,被乘数X放在B中,n位乘数Y放在C中,Cd初始值设为n(用于判断C是否被乘完)</li>
<li>判断C的最低为是否为1,是则将A+B赋给A</li>
<li>将{A,C}向右移一位(A高位补符号位),此时A的最低位进入C的最高位,C的最低位丢失</li>
<li>Cd减1,若减1后Cd仍不为0,转2.继续进行循环</li>
<li>计算A的最高符号位,其为被乘数和乘数符号位的异或</li>
<li>得出结果,此时结果的高位在A中,低位在C中</li>
</ol>
<p>示意图如下,其中被乘数X=0.1101,乘数Y=0.1011<br><img src="/2020/02/24/computer-composition0/multi2.jpg" alt="multipy"><br>得到X*Y=0.10001111</p>
<h4 id="定点补码一位乘"><a href="#定点补码一位乘" class="headerlink" title="定点补码一位乘"></a>定点补码一位乘</h4><p>由于计算机中机器数常以补码形式存在,可以直接使用补码相乘</p>
<p>补码相乘规则如下:</p>
<blockquote>
<p>设被乘数$[X]_补=X_0.X_1X_2…X_n$,乘数$[Y]_补=Y_0.Y_1Y_2…Y_n$,则有:<br>$$ [X*Y]_补=[X]_补*(0.Y_1Y_2…Y_n)-[X]_补*Y_0 $$<br>可见,如果$Y$为负数,需要补充进行$-[X]_补$操作</p>
</blockquote>
<p>布斯补码乘法规则如下:</p>
<blockquote>
<p>考虑相邻的两位$Y_{i+1}$和$Y_i$(乘数的最后一位和倒数第二位),将定点原码一位乘中的2.3.策略改成如下</p>
<ul>
<li>最后两位为00或11,{A,C}右移一位</li>
<li>最后两位为01,将部分积A增加$[X]_补$,{A,C}右移一位</li>
<li>最后两位为10,将部分积A增加$[-X]_补$,{A,C}右移一位</li>
<li>最后一步运算结束后不需要移位<br>计算时,乘数末位需要添加附加位$Y_{n+1}=0$</li>
</ul>
</blockquote>
<p>示意图如下,其中被乘数X=-0.1101,乘数Y=0.1011,即[X]补=11.0011,[Y]补=0.1011,[-X]补=00.1101:<br><img src="/2020/02/24/computer-composition0/multi3.jpg" alt="multipy"> </p>
<h3 id="定点数二位乘"><a href="#定点数二位乘" class="headerlink" title="定点数二位乘"></a>定点数二位乘</h3><p>相比于定点一位乘法,定点数二位乘按乘数每两位的取值情况，一次求出对应于该两位的部分积。此时，只要增加少拭逻辑电路，就可使乘法速度提高一倍。 </p>
<h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><p>为了进一步提高乘法运算速度，可采用类似于人了计算的方法，用一个阵列乘法器完成乘法运算</p>
<h2 id="3-4-二进制除法运算"><a href="#3-4-二进制除法运算" class="headerlink" title="3.4 二进制除法运算"></a>3.4 二进制除法运算</h2><h3 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><p>人工算法:<br><img src="/2020/02/24/computer-composition0/div0.jpg" alt="div"> </p>
<p>机器算法:(要求被除数小于除数,即除法结果应小于1)</p>
<ul>
<li>使用3个寄存器ABC,存放余数(被除数),除数和商的绝对值,商的符号独立计算</li>
</ul>
<ol>
<li>初始化:被除数X放在A中,n位除数Y放在B中,C寄存器清零,计数器i=n+1,若X&gt;Y,则溢出</li>
<li>将A减去B;若余数大于等于0,则商C中的最低位上1,否则上0并恢复余数</li>
<li>i减1,若减1后i仍不为0,将A,C左移一位,重复2.过程</li>
<li>计算C的最高符号位,其为被除数和除数符号位的异或</li>
<li>得出结果,此时商在C中,余数在A中</li>
</ol>
<p>示意图如下,其中被除数X=0.1011,Y=0.1101,即[Y]补=00.1101, [-Y]补=11.0011:<br><img src="/2020/02/24/computer-composition0/div1.jpg" alt="div"><br>得到结果X/Y=0.1101,余数位0.0111</p>
<h4 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h4><p>加减交替法省略了恢复余数的操作,将恢复余数法中的2.策略改成如下</p>
<blockquote>
<ul>
<li>若A&gt;0,则将A减去B;结果余数A&gt;0,则商C中的最低位上1,否则上0(此时下一步就会执行减法操作)</li>
<li>若A&lt;0,则将A加上B;若余数A&gt;0,则商C中的最低位上1,否则上0<br>此时若最后一次上商为0,在计算余数时,依然需要为最后一步恢复余数</li>
</ul>
</blockquote>
<p>示意图如下,其中被除数X=0.1011,Y=0.1101,即[-Y]补=11.0011:<br><img src="/2020/02/24/computer-composition0/div2.jpg" alt="div">  </p>
<ul>
<li>实际上在上述除法运算策略中,被除数的位数可以是除数的两倍,初始化时其高位放在A中,低位在C中,在左移操作时将C中的高位移入A中的低位</li>
</ul>
<h3 id="提高除法运算速度的方法"><a href="#提高除法运算速度的方法" class="headerlink" title="提高除法运算速度的方法"></a>提高除法运算速度的方法</h3><ul>
<li>跳0跳1除法</li>
<li>除法运算通过乘法操作来实现</li>
</ul>
<h2 id="3-5-浮点数的运算方法"><a href="#3-5-浮点数的运算方法" class="headerlink" title="3.5 浮点数的运算方法"></a>3.5 浮点数的运算方法</h2><h3 id="浮点数的加减法运算"><a href="#浮点数的加减法运算" class="headerlink" title="浮点数的加减法运算"></a>浮点数的加减法运算</h3><p>考虑两个浮点数$X = M_X*2^E_X, Y = X = M_Y*2^E_Y$的运算</p>
<p>浮点数加减法运算需要如下五个过程:</p>
<ol>
<li>对阶操作,使得两个浮点数阶码相等(注意阶码是移码)<blockquote>
<ul>
<li>小阶向大阶对齐,将阶码小的数位数右移$\Delta$E位,使其阶码变成E(一般对于补码尾数,符号位参加移位,高位补符号位;但对于原码尾数对阶,符号位不参加移位,高位补0),右移所丢失的位可以保留下来以供舍入操作</li>
</ul>
</blockquote>
</li>
<li>尾数加减,即通常的尾数加减(两个符号位)</li>
<li>(补码)结果规格化操作<blockquote>
<ul>
<li>右规: 运算结果两个符号位的值不同,即运算尾数向上溢出,需要将尾数结果右移一位(高位补符号位),阶码E+1</li>
<li>左规: 运算结果最高数值位与符号位相同(补码),应将尾数连续左移直到最高位数值与符号位不同,并减去相应阶码</li>
</ul>
</blockquote>
</li>
<li>舍入操作: 用于右规和对阶操作时低位舍去的处理<blockquote>
<ul>
<li>截断法: 直接丢掉低位</li>
<li>置1法: 舍去后最低位直接置1</li>
<li>0舍1入法: 若舍去的最高位为1,则它前面的最低为加1,这是常用方法</li>
</ul>
</blockquote>
</li>
<li>检查阶码是否溢出: 在规格化和舍入时阶码可能发生溢出情况<blockquote>
<ul>
<li>阶码向下溢出: 运算结果为机器零</li>
<li>阶码向上溢出: 置溢出标记</li>
</ul>
</blockquote>
</li>
</ol>
<p>具体流程图如下:<br><img src="/2020/02/24/computer-composition0/float0.jpg" alt="float"></p>
<h3 id="浮点数的乘除法运算"><a href="#浮点数的乘除法运算" class="headerlink" title="浮点数的乘除法运算"></a>浮点数的乘除法运算</h3><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><ol>
<li>检测操作数是否为0，若其中有一个操作数为0，则置结果为0；</li>
<li>阶码相加，阶符相同的加可能会溢出，若溢出，则作溢出处理；(阶码一般是移码)</li>
<li>尾数相乘；</li>
<li>尾数乘积规格化,只有左规.</li>
<li>舍入</li>
<li>截断处理:无条件地丢掉正常尾数最低位之后的全部数值</li>
<li>舍入处理:运算过程中保留右移中移出的若干高位的值,然而再按某种规则用这些位上的值修正尾数</li>
<li>判溢出</li>
</ol>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>浮点数除法运算与乘法运算类似,也分求商的阶码、尾数相除、规格化、舍入和判溢这几个步骤</p>
<h2 id="3-6-运算部件"><a href="#3-6-运算部件" class="headerlink" title="3.6 运算部件"></a>3.6 运算部件</h2><h3 id="定点运算部件"><a href="#定点运算部件" class="headerlink" title="定点运算部件"></a>定点运算部件</h3><p>定点运算部件由算术逻辑运算部件ALU、多个寄存器、移位电路、计数器、门电路组成</p>
<ul>
<li>一般定点运算部件中有3个寄存器A、B、C,在不同运算中作用如下:<blockquote>
<ul>
<li>加法:A为被加数-&gt;运算结果,B为加数</li>
<li>减法:A为被减数-&gt;运算结果,B为减数</li>
<li>乘法:A为部分积-&gt;乘积高位,B为被乘数,C为乘数-&gt;乘积低位</li>
<li>除法:A为被除数-&gt;余数,B为除数,C为商</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="浮点运算部件"><a href="#浮点运算部件" class="headerlink" title="浮点运算部件"></a>浮点运算部件</h3><p>浮点运算部件通常由阶码运算部件和尾数运算部件组成</p>
<ul>
<li>阶码部分仅执行加减运算</li>
<li>尾数部分执行加减乘除运算</li>
</ul>
<h2 id="3-7-数据校验码"><a href="#3-7-数据校验码" class="headerlink" title="3.7 数据校验码"></a>3.7 数据校验码</h2><p>通过在数据为中加入一些冗余位,从而达到在数据传输过程中能自动发现错误和校正错误</p>
<ul>
<li>码距: 任意两个合法码之间至少由几个二进制位不同; 较大的码距能使得一个合法码变成另一个合法码的概率较小, 但会增加存储的代价</li>
</ul>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>方法: 在数据(开头)补充一个校验位,使得补充校验位后的数据编码中1值的个数为奇数(奇校验)或偶数(偶校验)</p>
<p><img src="/2020/02/24/computer-composition0/check0.jpg" alt="check"></p>
<ul>
<li>奇偶校验码只能发现一位或奇数个位的出错</li>
<li>奇偶校验码只能发现错误,不能校正错误</li>
<li>就校验码常用于存储器读写检查，或ASCII字符传送过程中的检查。</li>
</ul>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>方法: 在数据中加入多个校验位,将数据中的每一个二进制位分配在几个校验组中;当某一位出错时,就会导致多个校验组的数值发生变化,通过综合分析这些变化来发现出错的位置,为纠错提供依据</p>
<p>一位纠错海明码:</p>
<ul>
<li>设有r位校验位，则共有0到2^r-1个共2^r个组合。若用0表示无差错，则剩余2^r-1个值表示有差错，并指出错在第几位。由于差错可能发生在k个数据位中或r个校验位中，因此有: 2^r–1 &gt;= r+k<blockquote>
<ul>
<li>例如,5-11位数据可用4位校验位来校验</li>
</ul>
</blockquote>
</li>
<li>校验位的分布(下标从1开始):<blockquote>
<ul>
<li>将原数据按位从前向后标号,遇到第$2^{i-1}$个位时,插入第i个校验位$P_i$,得到海明码的数据排列</li>
</ul>
</blockquote>
</li>
<li>校验位的计算<blockquote>
<ul>
<li>按照上述的数据排列给每一位一个二进制编号(从1开始),则对于第i个校验位,它需要校验的是所有二进制编号中第i位为1的数<br>如,第二位校验码$P_2$就需要校验第2(010),3(011),6(110),7(111)位;注意,此时校验码本身也在这些校验位中</li>
<li>用上述方法按校验位进行分组,校验位计算是进行偶校验计算,它等于同组的其他数据的异或</li>
</ul>
</blockquote>
</li>
<li>还可以加入一个总校验位$P_{i+1}$,它等于前面所有位的异或,这时的校验码不仅能纠正一位错,还能发现两位错</li>
</ul>
<p>此时,原数据中每一位都至少由两位校验码校验,码距为4<br>检验方法: 对上述分组中的每一组进行异或检验(包括总校验位),所有检验结果都为0则无措,若有些组为1则可根据检验结果推理出哪一位出错(或者是两位错)</p>
<h3 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h3><p>CRC编码以模2运算为基础,可以发现并纠正多位错误</p>
<h1 id="四、主存储器"><a href="#四、主存储器" class="headerlink" title="四、主存储器"></a>四、主存储器</h1><p>主存储器(主存或内存)在现代计算机中处于中心地位</p>
<ul>
<li>计算机执行的程序和数据均放在存储器中</li>
<li>计算机系 统中输入输出设备数量增多,数据传送速度加快</li>
<li>共享存储器的多处理机的出现 </li>
</ul>
<h2 id="4-1-主存储器分类-技术指标和基本操作"><a href="#4-1-主存储器分类-技术指标和基本操作" class="headerlink" title="4.1 主存储器分类,技术指标和基本操作"></a>4.1 主存储器分类,技术指标和基本操作</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>随机存储器RAM<blockquote>
<ul>
<li>又称读写存储器,通过指令可以随机对各个存储单元进行访问的存储器;一般访问所需时间与存储单元的地址无关,但停电会造成信息丢失</li>
</ul>
</blockquote>
</li>
<li>非易失性存储器<blockquote>
<ul>
<li>停电仍能保持其内容</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h3><ul>
<li>容量<blockquote>
<ul>
<li>计算机可寻址的最小单位是一个存储字;一个存储字所包括的二进制位数称为字长</li>
<li>由于现代计算机中一个字节为8位,因此一个字的字长通常为8的倍数</li>
<li>以字节为单位来表示主存储器存储单元的总数就是主存储器的容量</li>
<li>指令中地址码的位数决定了主存储器可以直接寻址的最大空间,如32位微型机提供32位物理地址,支持对4G物理存储空间的访问</li>
</ul>
</blockquote>
</li>
<li>存取时间<blockquote>
<ul>
<li>存储器的存取时间又称存储器访问时间,是指启动一次存储器操作(读/写)到完成该操作所经历的时间<br>存储周期</li>
<li>存储周期指连续启动两次独立的存储器操作(例如连续两次读操作)所需间隔的最小时间</li>
<li>通常,存储周期略长于存取时间</li>
</ul>
</blockquote>
</li>
</ul>
<p>主存储器的速度和容址两项指标随着存储器件的发展得到了极大的提高。但是，具有 合适价格的主存储器能提供信息的速度总是跟不上CPU的处理指令和数据的速度。</p>
<h3 id="主存储器的基本操作"><a href="#主存储器的基本操作" class="headerlink" title="主存储器的基本操作"></a>主存储器的基本操作</h3><p>主存储器和CPU的连接是由总线支持的:<br><img src="/2020/02/24/computer-composition0/rw0.jpg" alt="rw"></p>
<ul>
<li>AR位地址寄存器</li>
<li>DR为数码寄存器</li>
</ul>
<h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p>读操作是将存储器的数据读取到CPU中:</p>
<ol>
<li>CPU把信息字的地址送到AR,经地址总线送往主存储器</li>
<li>CPU发读(Read)命令</li>
<li>CPU等待主存储器的Ready回答信号，Ready为 1，表示信息已读出经数据总线,送入DR</li>
</ol>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>写操作是将CPU中的数据写入存储器中</p>
<ol>
<li>CPU把信息字的地址送到AR，经地址总线送往主存储器,并将信息字送往DR</li>
<li>CPU发写(Write)命令</li>
<li>CPU等待主存储器的Ready回答信号，Ready为 1，表示信息已从DR经数据总线写入主存储器</li>
</ol>
<h2 id="4-2-读-写存储器-的发展"><a href="#4-2-读-写存储器-的发展" class="headerlink" title="4.2 读/写存储器(的发展)"></a>4.2 读/写存储器(的发展)</h2><h3 id="静态存储器SRAM"><a href="#静态存储器SRAM" class="headerlink" title="静态存储器SRAM"></a>静态存储器SRAM</h3><p>静态存储器利用触发器保存信息,只要不断电,信息就不会丢失</p>
<ul>
<li>集成度低,功耗较大</li>
</ul>
<h3 id="动态存储器DRAM"><a href="#动态存储器DRAM" class="headerlink" title="动态存储器DRAM"></a>动态存储器DRAM</h3><p>动态存储器利用MOS管存储电荷来保存信息,需要不断给电容充电使信息保存</p>
<ul>
<li>使用单管存储单元,通过电容充电来保存信息</li>
<li>再生: DRAM需要在电容的电荷漏掉之间进行充电,又称刷新,一般周期小于2ms</li>
<li>集成度高,功耗小,速度快;但读出是破坏性的,读出后需要立即对单元进行重写</li>
<li>单元读出信号很小,要求有高灵敏度的读出放大器</li>
<li>主要用于大容量存储器<blockquote>
<ul>
<li>相比SRAM,DRAM每片存储容量约是前者4倍,造价约为前者1/4,功率约为前者1/6</li>
</ul>
</blockquote>
</li>
</ul>
<p>DRAM发展:</p>
<ul>
<li>FPM快页式内存</li>
<li>EDO DRAM</li>
<li>同步DRAM(SDRAM):将RAM与CPU以相同的时钟频率进行控制,使RAM和CPU外频同步,取消等待时间</li>
<li>DDR SDRAM:双数据传送速率的SDRAM,在时钟的上升沿和下降沿都能读出数据(预取2位)</li>
<li>DDR 2:预读取能力为4位,降低电压和功耗,等效传输频率翻倍</li>
<li>DDR 3:预读取能力为8位</li>
</ul>
<h2 id="4-3-非易失性半导体存储器"><a href="#4-3-非易失性半导体存储器" class="headerlink" title="4.3 非易失性半导体存储器"></a>4.3 非易失性半导体存储器</h2><p>非易失性半导体存储器在停电时所存储的内容也不会丢失</p>
<ul>
<li><p>只读存储器ROM: 掩模式ROM由芯片制造商在制造时写入内容,以后只能读而不能再写入,前面叙述过它的存储原理</p>
</li>
<li><p>可编程序的只读存储器PROM: 一次性写入的存储器;如熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元的熔丝(写入)。</p>
</li>
<li><p>可擦除可编程序的只读存储器EPROM: 能多次修改数据的ROM;产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线照射后,浮置栅上的电子将逸散,即整体擦除</p>
</li>
<li><p>可电擦可编程序只读存储器E2PROM: 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写入周期要几毫秒,寿命为10万次。</p>
</li>
<li><p>快擦读写存储器Flash Memory: 用电擦除,但只能整体擦除或分区擦除; 可做成内存卡应用于各种电子产品</p>
</li>
</ul>
<h2 id="4-4-存储器的组成与控制"><a href="#4-4-存储器的组成与控制" class="headerlink" title="4.4 存储器的组成与控制"></a>4.4 存储器的组成与控制</h2><h3 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h3><p>一个存储器的芯片容量是有限的,要达到所需要的存储字数和存储字长,需要在字向和位向进行扩充; 这里展示静态存储器的位扩展和字扩展</p>
<p>静态存储芯片表示:</p>
<ul>
<li>芯片容量: 由字数*字长表示</li>
<li>地址线: 用于寻址,地址线的位数可由字数表示;如16K表示地址线有14条($16K=2^{14}$,其中1K的地址线是10条</li>
<li>数据线: 用于向芯片写入/读出数据,数据线的位数可由字长表示;如字长为4的芯片数据线有4条</li>
<li>使能(片选)端: 用于控制芯片是否能进行读写操作,一般低有效</li>
<li>读写控制端: 用于切换芯片的读/写操作,一般高位读取低位写入</li>
</ul>
<h4 id="位扩展-扩充数据线字长"><a href="#位扩展-扩充数据线字长" class="headerlink" title="位扩展(扩充数据线字长)"></a>位扩展(扩充数据线字长)</h4><ul>
<li>地址线,使能线(片选$\overline {CS}$),读写控制端$R/ \overline W$并联</li>
<li>数据线串联,分高低位分别引出<br>两片16K*4扩展成一片16K*8<br><img src="/2020/02/24/computer-composition0/sram0.jpg" alt="sram"></li>
</ul>
<h4 id="字扩展-扩充地址线字数"><a href="#字扩展-扩充地址线字数" class="headerlink" title="字扩展(扩充地址线字数)"></a>字扩展(扩充地址线字数)</h4><ul>
<li>地址线,读写控制线,使能线并联</li>
<li>片选连接译码器,用于区分各芯片的地址范围,地址高位通过译码器控制使能端来访问不同的芯片<br>四片16K*8扩展成一片64K*8<br><img src="/2020/02/24/computer-composition0/sram1.jpg" alt="sram"></li>
</ul>
<h4 id="字位扩展"><a href="#字位扩展" class="headerlink" title="字位扩展"></a>字位扩展</h4><p>同时对字向和位向进行扩展</p>
<ul>
<li>片内成组进行位扩展,然后组间进行字扩展</li>
<li>需要用MN/LK个芯片将L*K的存储器扩展成M*N的存储器<br><img src="/2020/02/24/computer-composition0/sram2.jpg" alt="sram"></li>
</ul>
<h3 id="存储控制"><a href="#存储控制" class="headerlink" title="存储控制"></a>存储控制</h3><p>在存储器中，往往需要增设附加电路。这些附加电路包括地址多路转换线路、地址选 通、刷新逻辑，以及读／写控制逻辑等。</p>
<ul>
<li>在大容量存储芯片中,为了减少芯片的地址线引出端的数目,将地址码分两次送到存储器芯片中,使得芯片地址线引出端减少一半</li>
<li>刷新逻辑: 通过定时刷新(读出)保证DRAM中的信息不丢失<blockquote>
<ul>
<li>刷新周期: 从上一次对整个存储器刷新结束到下一次刷新结束为止需要的时间,一般为2ms</li>
<li>分布式刷新:  在2ms内分散地将存储器的每一行刷新</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="存储校验线路"><a href="#存储校验线路" class="headerlink" title="存储校验线路"></a>存储校验线路</h3><ul>
<li>早期计算机多采用奇偶校验电路,只能发现一位错且不能纠正</li>
<li>由于大规模集成电路的发展，主存储器的位数可以做得更多，使多数计算机的存储器有纠正错误代码的功能(ECC)</li>
<li>一般采用的海明码校验线路可以纠正一位错</li>
</ul>
<h2 id="4-5-多体交叉存储器"><a href="#4-5-多体交叉存储器" class="headerlink" title="4.5 多体交叉存储器"></a>4.5 多体交叉存储器</h2><p>计算机中的大容量主存可由多个存储体构成,每个存储体都有自己的读写线路、地址寄存器和数据寄存器,称这种存储体为存储模块</p>
<ul>
<li>为了提高每个模块的使用率和总体的读取效率,对每个模块进行低位交叉编址,连续的地址分布在相邻的模块中<blockquote>
<p>M个交叉模块的使用率在$\sqrt M$和$M$之间</p>
</blockquote>
</li>
</ul>
<h1 id="五、存储系统"><a href="#五、存储系统" class="headerlink" title="五、存储系统"></a>五、存储系统</h1><p>(本章为原书第七章)</p>
<h2 id="5-1-存储系统的层次结构"><a href="#5-1-存储系统的层次结构" class="headerlink" title="5.1 存储系统的层次结构"></a>5.1 存储系统的层次结构</h2><h3 id="存储器类型"><a href="#存储器类型" class="headerlink" title="存储器类型"></a>存储器类型</h3><ul>
<li>主存储器:<blockquote>
<ul>
<li>一般为半导体存储器</li>
<li>存放当前正在执行的程序和数据</li>
<li>主存储器可以随机访问任一单元</li>
</ul>
</blockquote>
</li>
<li>辅助存储器(外存储器)<blockquote>
<ul>
<li>一般为磁盘,磁带,光盘等</li>
<li>存放当前不在运行的大量程序和数据</li>
<li>辅助存储器一般为串行访问存储器,需要顺序地按位进行访问,访问指定信息所需时间与信息所在位置有关   </li>
</ul>
<p>串行存储器:</p>
<ul>
<li>顺序存取存储器(磁带等): 磁带上的信息以顺序的方式存储在带上，读／写时要待磁带移动到合适位置后才能顺序读／写，需要耗费较多时间</li>
<li>直接存取存储器(磁盘等): 它对信息的存取包括移动磁头到信息所在区域(磁道)和从磁道的合适位置进行顺序读写;它比磁带快得多</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h3><p>操作系统和硬件结合,把主存和辅存统一在一起,形成了一个存储层次</p>
<ul>
<li>整体上看,其速度接近于主存</li>
<li>整体上看,其容量接近于辅存  </li>
<li>主存-辅存层次满足了存储器的大容量和低成本的需求<br>这种系统的发展和完善形成了现在广泛使用的虚拟存储系统</li>
</ul>
<p>cache-主存层次</p>
<ul>
<li>在速度方面,计算机的主存和CPU存在一个数量级的差距</li>
<li>高速缓冲存储器cache在速度上能满足CPU的要求</li>
<li>从CPU的角度看,cache-主存层次的速度接近于cache,容量与每位价格接近于主存</li>
<li>这个层次完全由硬件实现</li>
</ul>
<p>计算机的存储层次解决了速度与成本之间的矛盾</p>
<p>现代计算机同时采用上述两种存储层次,构成cache-主存-辅存三级存储层次</p>
<h2 id="5-2-高速缓冲存储器"><a href="#5-2-高速缓冲存储器" class="headerlink" title="5.2 高速缓冲存储器"></a>5.2 高速缓冲存储器</h2><h3 id="cache存在的合理性"><a href="#cache存在的合理性" class="headerlink" title="cache存在的合理性"></a>cache存在的合理性</h3><ul>
<li>程序访问的局部性原理: 在一个较短的时间间隔内,程序访问的地址往往集中在一个很小的范围内<blockquote>
<ul>
<li>程序指令地址本身就是连续分布的,且循环程序段和子程序段经常被反复执行</li>
<li>程序数据分布虽然不一定是集中的,但短时间内对数组的存储和访问以及对工作单元的选择也需要使用到局部范围的存储器地址</li>
</ul>
</blockquote>
</li>
</ul>
<p>根据局部性原理,在主存和CPU之间设置一个高速而容量相对较小的存储器,将当前执行的程序和数据存放在这个存储器中;当程序运行时,不需要再从主存储器中取指令和数据,访问cache即可</p>
<h3 id="cache的结构"><a href="#cache的结构" class="headerlink" title="cache的结构"></a>cache的结构</h3><p>cache一般由SRAM组成,它的工作速度数倍于主存,全部功能由硬件实现,并且对程序员是透明的</p>
<p>其基本结构如下:<br><img src="/2020/02/24/computer-composition0/cache0.jpg" alt="cache">  </p>
<ul>
<li>将n位的主存地址分块,前m位为主存块号,后b位为块内地址;将cache也分成同样大小的多个块,前c位为cache块号,后b位为块内地址(块内字节数与主存相同)</li>
<li>cache内每一个块外加一个标记地址,指明它是主存哪一块的副本,这个标记地址应该为m-c位</li>
<li>注意,cache的块号和它的标记地址不同</li>
</ul>
<p>当CPU发出读请求时,将主存地址m位(或m中的一部分)与cache某块的标记相比较,当结果相等时,说明需要的数据已经在cache中,直接访问cache即可,在CPU与cache之间,通常一次传送一个字块;当比较结果不相等时,说明需要的数据尚未调入cache,那么就要把该数据所在的整个字块从主存中调进来</p>
<ul>
<li>命中: CPU所要访问的信息在cache中,否则为不命中</li>
<li>命中率: CPU所要访问的信息在cache中的比率</li>
<li>失效率: 所要访问的信息不在cache中的比率</li>
</ul>
<p>具有cache的存储器的平均存取时间的计算:</p>
<ul>
<li>设cache本身的存取时间(周期)为tc,命中率为h,主存的存取时间为tm,则:<blockquote>
<p>平均存取时间t = h*tc+(1-h)(tc+tm) 或者估算为 h*tc+(1-h)tm</p>
</blockquote>
</li>
</ul>
<p>cache写策略:如何保证cache中的副本在更改后与主存一致</p>
<ul>
<li>标志交换或写回法: 暂时只修改cache中数据,待该字块被替换出去时写入主存</li>
<li>通过式写法或写通法: 每次修改cache的同时也修改主存</li>
<li>若被修改的单元根本不在cache中,也可以直接对主存进行写操作</li>
</ul>
<h3 id="cache映像"><a href="#cache映像" class="headerlink" title="cache映像"></a>cache映像</h3><h4 id="地址映射-映像-的概念"><a href="#地址映射-映像-的概念" class="headerlink" title="地址映射(映像)的概念"></a>地址映射(映像)的概念</h4><p>为了将信息存放到cache中,需要某种函数将主存的地址映射到cache中;执行程序时,需要通过地址变换将主存地址变换成cache地址,这种变换基于地址映像来实现</p>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><ul>
<li>特点: 主存中第$2^i+k$块只能映射到cache中第k块,其中,i&gt;c(c为cache字块地址位数)<blockquote>
<p>即: $cache字块号 = 主存字块号 mod 2^c$</p>
</blockquote>
</li>
</ul>
<p>从实现上,只需要将m位的主存分成t位主存字块标记和c位cache字块标记;cache中只需要t位进行标记,将其与t位主存字块标记对比即可判断是否命中</p>
<p><img src="/2020/02/24/computer-composition0/cache1.jpg" alt="cache"></p>
<p>由于cache块号与主存块号的部分相关连,因此标记只需要t位;实现简单,cache块的定位迅速(主存的块只能映射到一个cache块中),但不够灵活</p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><ul>
<li>特点: 主存中的每一块可以映射到cache中的任意一块<blockquote>
<p>cache中的标记需要m位,在定位cache块时需要将m位主存块号和所有的cache标记比对一次,才能判断是否”命中”</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/cache2.jpg" alt="cache"></p>
<p>这种方式最灵活,cache命中率最高,但成本也最高,开销大速度慢</p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><ul>
<li>特点: 是直接映射和全相联映射的一个折衷,主存中的每一块可以映射到cache中的$2^{c-r}$块<blockquote>
<ul>
<li>主存和cache分成r组,取主存块地址和cache块地址的后r位</li>
<li>组间为直接映射,组内为全相联映射</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/cache3.jpg" alt="cache"></p>
<p>上图中cache每一组(行)内都有多个全相联的块</p>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><p>新的主存字块需要调入cache而原可用位置已被占满时,就需要用替换算法来更新cache内容</p>
<h4 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h4><ul>
<li>按调入cache的先后顺序来决定需要被替换出去的cache块;最先被调入cache的块最先被替换成新的块<blockquote>
<ul>
<li>这种算法考虑了局部访问性原理</li>
<li>这种算法实现容易,开销小</li>
<li>但有些时候会使得命中率下降</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h4><ul>
<li>将近期长久未被访问过的块替换出去<blockquote>
<ul>
<li>这种算法按调用频繁程度来决定淘汰顺序,并没有考虑局部访问性原理,比较合理</li>
<li>这种算法的cache命中率较高</li>
<li>这种算法实现开销比FIFO稍大</li>
</ul>
</blockquote>
</li>
</ul>
<p>LRU+FIFO实现: 每次命中新块,都将它移动到队头;若未命中,则将队尾元素替换成新块,然后将它移动到队头</p>
<h4 id="cache地址的监听"><a href="#cache地址的监听" class="headerlink" title="cache地址的监听"></a>cache地址的监听</h4><p>在外部设备对存储器进行修改时,需要保证cache与主存对应快的内容一致,需要对地址进行监听</p>
<p>做法: 若某一IO设备直接对存储器而非cache写入数据时,将对应地址的cache(若有的话)标记有效的位清0,当CPU再次访问该cache时将产生不命中信号;保证CPU所取数据的正确性</p>
<h3 id="多层次cache"><a href="#多层次cache" class="headerlink" title="多层次cache"></a>多层次cache</h3><h4 id="指令cache和数据cache"><a href="#指令cache和数据cache" class="headerlink" title="指令cache和数据cache"></a>指令cache和数据cache</h4><p>将指令和数据放在同一cache中通常会使得存取数据操作和取指令操作发生冲突,延迟了指令的读取</p>
<p>哈佛结构: 将指令cache和数据cache独立分开来</p>
<h4 id="多层次cache-1"><a href="#多层次cache-1" class="headerlink" title="多层次cache"></a>多层次cache</h4><p>集成度高的芯片可用设计出高速的片内cache,与大容量的片外cache配合使用</p>
<p>一般一级cache和二级cache设计在片内,高性能处理器均已采用三级cache方案</p>
<h2 id="5-3-虚拟存储器"><a href="#5-3-虚拟存储器" class="headerlink" title="5.3 虚拟存储器"></a>5.3 虚拟存储器</h2><p>虚拟存储器指的是主存-辅存层次,程序员可以按虚存空间编址</p>
<p>几个单位: 段,页,段页</p>
<h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><p>段: 利用程序模块化性质,按照程序逻辑结构划分出的多个相对的独立部分</p>
<ul>
<li>如: 过程,子过程,数据表,阵列等</li>
<li>这些逻辑部分可以互相调用或者被外部程序调用,形成段间连接,产生规模较大的程序</li>
<li>一般用段表指明段在主存中的位置: 段号,段起点,装入位(表示段是否已经装入主存),段长等(段表本身也是由一个段存储)</li>
</ul>
<p>段式管理: 主存按段进行分配</p>
<ul>
<li>优点: 逻辑独立性好,与程序的自然分界相对应,易于编译、管理、修改和保护,也易于多道程序共享</li>
<li>缺点: 会在段间留下许多空余的零碎存储空间,造成存储资源的浪费</li>
</ul>
<h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>页面: 主存的物理空间被划分位等长的固定区域,称为页面</p>
<p>页式管理: 主存按页进行管理,信息传送单位是定长的页</p>
<ul>
<li>优点: 新页调入主存十分容易,,只要有空白页即可; 可能造成浪费的地方是程序最后一页的零头,它比段式管理系统的空间浪费要小得很多</li>
<li>缺点: 由于页不是逻辑上独立的实体,在处理、保护和共享都不及段式来得方便</li>
</ul>
<p>段页式管理: 将程序按模块分段,段内再分页; 出入主存仍以页为信息传送单位, 用段表和页表(每段一个页表)进行两级管理</p>
<p>####页式虚拟存储器</p>
<ul>
<li>逻辑页: 在页式虚拟存储器中,把虚拟空间分成页,称为虚页或逻辑页</li>
<li>物理页: 主存空间分成和虚存同样大小的页,称为实页或物理页</li>
<li>虚存地址: 虚拟地址由高低两个字段组成,高字段为逻辑页号,低字段为页内地址</li>
<li>实存地址: 主存实地址由高低两个字段组成, 高字段为物理页号,低字段为页内地址</li>
</ul>
<p>虚存地址到主存实地址的变换是由页表来实现的<br><img src="/2020/02/24/computer-composition0/page0.jpg" alt="page"></p>
<ul>
<li>对应每个虚页号有一个页表条目,该条目要包含虚页对应主存的物理页号</li>
<li>其他属性包含装入(有效)位,修改位(表示页面内容是否被修改),替换控制位(指出需要替换的页)和其他保护位等<blockquote>
<p>页表本身也在主存中,如果一次访问不命中,那么进行替换、修改再访问,需要和主存进行多次通讯,效率较低</p>
</blockquote>
</li>
</ul>
<p>快表TLB: 将频繁访问的页表信息存放在一个快速存储器中<br><img src="/2020/02/24/computer-composition0/TLB0.jpg" alt="tlb"></p>
<ul>
<li>首先按虚页号同时查询快表慢表</li>
<li>快表查到即访问,查不到即花费一个周期去主存中的慢表找</li>
<li>找到后用替换算法将该页号调入快表</li>
</ul>
<p>页式虚拟存储器优点:</p>
<ul>
<li>主存储器利用率较高</li>
<li>页表相对简单</li>
<li>地址变换速度较快</li>
<li>对磁盘管理比较容易</li>
</ul>
<p>缺点:</p>
<ul>
<li>程序模块化性能不好</li>
<li>页表很长,需要占用大量的存储空间</li>
</ul>
<p>内页表: 虚地址到主存物理地址的变换表<br>外页表: 虚地址和具体辅存地址之间的变换表</p>
<h3 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h3><p>在段页式管理的基础上,产生段页式虚拟存储器</p>
<ul>
<li>多道程序: 如果有多个用户在机器上运行,称为多道程序<blockquote>
<ul>
<li>每一道(每个用户)需要一个基号(用户标志号)</li>
<li>这个地址需要指明该道程序的段表起点(存放在基址寄存器中)</li>
</ul>
</blockquote>
</li>
<li>虚拟地址: 包括基号D,段号S,页号P,页内地址D</li>
</ul>
<p>段页式虚拟存储器地址变换过程见课本第174 175页<br><img src="/2020/02/24/computer-composition0/para0.jpg" alt="para"><br>查询过程:</p>
<ul>
<li>程序段起点+段号-&gt;页表起点</li>
<li>页表起点+页号+页内偏移量-&gt;实存地址</li>
</ul>
<h3 id="虚拟存储器工作过程"><a href="#虚拟存储器工作过程" class="headerlink" title="虚拟存储器工作过程"></a>虚拟存储器工作过程</h3><p><img src="/2020/02/24/computer-composition0/storage0.jpg" alt="storage"></p>
<h3 id="存储管理部件MMU"><a href="#存储管理部件MMU" class="headerlink" title="存储管理部件MMU"></a>存储管理部件MMU</h3><p>虚拟存储系统的特点:</p>
<ul>
<li>允许用户程序用比主存空间大得多的空间来访问主存</li>
<li>每次访存都要进行虚实地址的变换<br>整个虚拟存储器的管理是由存储管理部件MMU和操作系统共同完成的</li>
</ul>
<h2 id="5-4-相连存储器"><a href="#5-4-相连存储器" class="headerlink" title="5.4 相连存储器"></a>5.4 相连存储器</h2><p>在cache和虚拟存储器中,需要用到按内容寻址的相连存储器(页表查询等)</p>
<ul>
<li>相连存储器按照所存数据字的全部内容或部分内容进行查找(检索)访问<br><img src="/2020/02/24/computer-composition0/CR0.jpg" alt></li>
<li>CR是比较数寄存器</li>
<li>MR是屏蔽数寄存器,无需进行匹配的位置为0,置1的位为关键字段</li>
<li>WSR为字选择寄存器,对应位为0的字不参与查找(可以用这个进行二次或多次查找;将上一次的SRR放入WSR即可)</li>
<li>SRR为查找结果寄存器,满足要求的相应位为1</li>
<li>相联存储器能够进行比较操作(相等比较,大小比较,求最值)看,比较操作是并行的,时间复杂度为常数</li>
</ul>
<h2 id="5-5-存储保护"><a href="#5-5-存储保护" class="headerlink" title="5.5 存储保护"></a>5.5 存储保护</h2><p>多个用户对主存进行共享,需要防止由于一个用户程序出错导致其他用户程序和系统软件被破坏,也要防止一个用户程序不合法地访问其他的主存区域</p>
<h3 id="存储区域保护"><a href="#存储区域保护" class="headerlink" title="存储区域保护"></a>存储区域保护</h3><ul>
<li>在主存系统中由系统软件经特权指令设置上下界寄存器为每个程序划定存储区域,禁止越界访问</li>
</ul>
<p>虚拟存储系统中:</p>
<ul>
<li>页表保护: 每个程序都有自己的页表和段表,对它们进行保护; 除非地址变换出错,否则程序只能影响分配给它的几个主存页面</li>
<li>键保护: 为主存的每一页配一个由操作系统赋予的存储键,给相应的每个用户分配一个访问键,这个访问键赋予每道程序; 当访问键与存储键相符合时,这一页的数据才能被允许操作</li>
<li>环保护: 按系统程序和用户程序的重要性对整个系统正常运行的影响程度进行分层(环); 环号大小表示保护级别,环号越大等级越低; 某环内的程序只能转到环号大于等于它本身的页中去</li>
</ul>
<h3 id="访问方式保护"><a href="#访问方式保护" class="headerlink" title="访问方式保护"></a>访问方式保护</h3><p>对主存信息进行读R,写W和执行E(指将数据作为指令使用)保护</p>
<h3 id="管理状态和用户状态"><a href="#管理状态和用户状态" class="headerlink" title="管理状态和用户状态"></a>管理状态和用户状态</h3><p>大多数计算机在执行程序时把工作状态分成两种</p>
<ul>
<li>管理状态：执行操作系统或管理程序时所处的状态</li>
<li>用户状态：执行用户程序时所处的状态<br>为了防止因程序员编程出错而影响整个系统的工作，在机器中设置了一些特权指令(规定特权指令只有操作系统等系统程序才能使用，如在用户程序中出现特权指令)，则在执行到该指令时立即中止程序的执行并发出中断。</li>
</ul>
<h1 id="六、指令系统"><a href="#六、指令系统" class="headerlink" title="六、指令系统"></a>六、指令系统</h1><p>(原书第五章)</p>
<h2 id="6-1-指令系统的发展"><a href="#6-1-指令系统的发展" class="headerlink" title="6.1 指令系统的发展"></a>6.1 指令系统的发展</h2><h3 id="指令系统概念"><a href="#指令系统概念" class="headerlink" title="指令系统概念"></a>指令系统概念</h3><ul>
<li>指令: 计算机执行某种操作的命令</li>
<li>程序：程序是由一系列指令组成的</li>
</ul>
<p>指令分类:</p>
<ul>
<li>微指令: 微程序级的命令,属于硬件</li>
<li>宏指令: 由若干条机器指令组成的软件指令, 它属于软件级别</li>
<li>机器指令: 介于微指令和宏指令之间,每条指令可以完成一个独立的算数或逻辑运算</li>
</ul>
<p>指令系统: 一台计算机中所有机器指令的集合,指令系统是硬件和软件的分界面</p>
<ul>
<li>指令系统直接影响到机器的硬件结构</li>
<li>指令系统直接影响到系统软件</li>
<li>指令系统直接影响到机器的适用范围</li>
</ul>
<h3 id="指令系统的发展"><a href="#指令系统的发展" class="headerlink" title="指令系统的发展"></a>指令系统的发展</h3><ul>
<li>电子管和晶体管时代: 指令系统只有定点加减,逻辑运算,数据传送转移等几十条指令</li>
<li>晶体管和集成电路时代: 指令系统增加了乘除,浮点,十进制运算和字符串处理等指令; 寻址方式也趋于多样化<blockquote>
<p>系列计算机: 基本指令系统相同,基本体系结构相同的一系列计算机,这使得各机器软件能够得到兼容</p>
</blockquote>
</li>
<li>(大规模)集成电路计算机: 大多数计算机指令达到几百条,这时的计算机为复杂指令计算机CISC<blockquote>
<ul>
<li>复杂指令计算机指令系统负责庞大,指令数目多</li>
<li>指令格式多,字长不固定,寻址方式多</li>
<li>可访存指令不受限制</li>
<li>各种指令执行时间相差很大</li>
<li>采用微程序控制器</li>
</ul>
</blockquote>
</li>
<li>70年代后期: 精简指令系统计算机RISC<blockquote>
<ul>
<li>精简指令系统选取使用频率较高的简单指令</li>
<li>指令长度固定,指令格式少,寻址方式种类少</li>
<li>采用流水线技术</li>
<li>使用较多的通用寄存器,减少访存</li>
<li>控制器以组合逻辑控制为主</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="指令系统性能指标"><a href="#指令系统性能指标" class="headerlink" title="指令系统性能指标"></a>指令系统性能指标</h3><ul>
<li>完备性: 用汇编语言编写各种程序时,指令系统丰富,功能齐全,编程方便</li>
<li>有效性: 程序占用存储空间小,执行速度快</li>
<li>规整性: 指令格式和数据格式一致; 能够同等对待寄存器和存储单元; 不同寻址方法和各种数据类型能被指令支持</li>
<li>兼容性: 系列机之间具有相同的基本结构和共同的基本指令集,抵挡机上运行的软件也能在高档机上运行(向上兼容)</li>
</ul>
<h3 id="指令系统与硬件结构的关系"><a href="#指令系统与硬件结构的关系" class="headerlink" title="指令系统与硬件结构的关系"></a>指令系统与硬件结构的关系</h3><ul>
<li>高级语言: 面向人类的语言,与具体机器的指令系统无关</li>
<li>低级语言: 面向机器的语言,与具体机器的指令系统密切相关</li>
</ul>
<p>汇编语言:</p>
<ul>
<li>汇编语言通过指令助记符编写程序</li>
<li>指令助记符与机器指令一一对应,常用3或4个英文缩写字母表示</li>
</ul>
<h2 id="6-2-指令格式"><a href="#6-2-指令格式" class="headerlink" title="6.2 指令格式"></a>6.2 指令格式</h2><h3 id="指令的格式"><a href="#指令的格式" class="headerlink" title="指令的格式"></a>指令的格式</h3><p>指令包含的信息:</p>
<blockquote>
<ul>
<li>操作码: 一条操作码对应一个指令,计算机通过识别操作码来完成不同的操作</li>
<li>操作数(地址): 指出参与操作的数据的有关信息(内容或地址)</li>
<li>结果存放地址: 该地址存放操作完成后得到的结果</li>
<li>后继指令地址: 下一条指令的地址; 顺序执行的程序指令地址由程序计数器PC指出,仅当改变程序的运行顺序时下一条指令地址才由指令给出</li>
</ul>
</blockquote>
<p>可见,指令由一个操作码OP和若干个地址码A构成</p>
<p>指令可按照操作数或地址数来分类</p>
<blockquote>
<p>例: 常规双操作数指令(四地址格式)<br><code>OP-A1-A2-A3-A4</code></p>
<ul>
<li>执行操作: (A1)OP(A2)=&gt;A3,后继地址为A4</li>
<li>当然,现实情况中可能不需要显式地给出这么多地址<br>隐地址: 某地址在指令中以隐含的方式约定,指令中不给出该地址码; 这样可以减少存储空间与读取时间</li>
</ul>
</blockquote>
<p>寄存器传送语言</p>
<blockquote>
<ul>
<li>(A)表示地址码A中的内容,是数据</li>
<li>(B)=&gt;A表示将地址码B中的内容存入地址码A所指向的寄存器或主存储器</li>
</ul>
</blockquote>
<h4 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h4><p>格式:<code>OP</code></p>
<blockquote>
<p>执行操作: </p>
<ul>
<li>零操作数: OP,(PC)+1=&gt;PC</li>
<li>但操作数: OP(AC)=&gt;AC,(PC)+1=&gt;PC<br>注: 该指令为零操作数时,可以为空操作(延时)指令或停机指令; 该指令也可以是对累加器AC的操作指令或是对堆栈栈顶单元中的数据进行操作</li>
</ul>
</blockquote>
<h4 id="单地址指令"><a href="#单地址指令" class="headerlink" title="单地址指令"></a>单地址指令</h4><p>格式:<code>OP-A1</code></p>
<blockquote>
<p>执行操作: </p>
<ul>
<li>单操作数: OP(A1)=&gt;A1,(PC)+1=&gt;PC</li>
<li>双操作数: (AC)OP(A)=&gt;AC,(PC)+1=&gt;PC<br>注: AC为CPU中的累加器,一般为隐含规定,此时OP可以是加减乘除等</li>
</ul>
</blockquote>
<h4 id="二地址格式"><a href="#二地址格式" class="headerlink" title="二地址格式"></a>二地址格式</h4><p>格式:<code>OP-A1-A2</code></p>
<blockquote>
<p>执行操作(双操作数): (A1)OP(A2)=&gt;A1,(PC)+1=&gt;PC</p>
</blockquote>
<h4 id="三地址格式"><a href="#三地址格式" class="headerlink" title="三地址格式"></a>三地址格式</h4><p>格式:<code>OP-A1-A2-A3</code></p>
<blockquote>
<p>执行操作(双操作数): (A1)OP(A2)=&gt;A3,(PC)+1=&gt;PC<br>当然,某些性能较强的计算机中还有多地址指令</p>
</blockquote>
<h3 id="指令操作码的扩展技术"><a href="#指令操作码的扩展技术" class="headerlink" title="指令操作码的扩展技术"></a>指令操作码的扩展技术</h3><ul>
<li>定长操作码: 指令操作码的位置和长度固定,其余部分全部用于地址码; 此操作可以简化硬件操作,减少译码时间</li>
<li>扩展操作码: 指令操作码的位数和位置根据需要变化, 操作码的位数随地址数的减少而增加</li>
</ul>
<h4 id="15-15-15扩展法"><a href="#15-15-15扩展法" class="headerlink" title="15/15/15扩展法"></a>15/15/15扩展法</h4><p>机器字长16位,一条地址4位,可采用如下方法设计出15/15/15/16条三地址/双地址/单地址/零地址指令</p>
<ul>
<li>三地址指令: 0XXX-EXXX (X表示地址,变量)</li>
<li>双地址指令: F0XX-FEXX</li>
<li>单地址指令: FF0X-FFEX</li>
<li>零地址指令: FFF0-FFFF<blockquote>
<p>这里,前三位中的F为扩展标志,表示操作码已经被扩展到后面一个地址位中去</p>
</blockquote>
</li>
</ul>
<h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><p>霍夫曼编码: 根据程序中指令出现的频率高低赋予不同长度的操作码</p>
<h4 id="指令长度与数据字长"><a href="#指令长度与数据字长" class="headerlink" title="指令长度与数据字长"></a>指令长度与数据字长</h4><ul>
<li>字节: 由多个(一般8个)二进制位组成</li>
<li>字: 由多个字节组成</li>
<li>数据字: 计算机中的字表示一个数</li>
<li>指令字: 计算机中的字表示一条指令</li>
<li>机器字长: 计算机能直接处理的二进制数据位数</li>
<li>指令字长: 一个指令中的二进制位数<blockquote>
<p>指令字长有单字长,半字长,多字长,长度分别等于一个,半个,两个机器字长</p>
<ul>
<li>等字长指令: 指令字长不变,通常采用扩展操作码技术</li>
<li>变字长指令结构: 指令字长多为字节的整数倍,如单字节,双字节,三字节指令</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="6-3-寻址方式"><a href="#6-3-寻址方式" class="headerlink" title="6.3 寻址方式"></a>6.3 寻址方式</h2><p>寻址: 存取数据时,先给出地址码,再由硬件电路译码找到数据所在地址</p>
<p>寻址方式: 确定本条指令的数据地址以及下一条要执行指令的地址方式</p>
<h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><ul>
<li>顺序寻址: 由程序计数器PC对地址计数</li>
<li>跳跃寻址: 下一条指令地址由本条指令给出</li>
</ul>
<h3 id="操作数的寻址"><a href="#操作数的寻址" class="headerlink" title="操作数的寻址"></a>操作数的寻址</h3><p>操作数分类: 地址,数值,字符,逻辑数据</p>
<p>常见操作数寻址方式:</p>
<ul>
<li><p>隐含寻址: 不显式地给出操作数地址</p>
<blockquote>
<p>例: DAA – 将AL的内容调整为两位组合型的二进制数</p>
</blockquote>
</li>
<li><p>立即数寻址: 操作数直接包含在指令中,不需要访问存储器</p>
<blockquote>
<ul>
<li>一般用于提供一个常数或给寄存器初始化</li>
<li><code>MOV AL, 05H</code>: 05H为立即数</li>
</ul>
</blockquote>
</li>
<li><p>寄存器直接寻址: 提供的操作数存放在CPU内的寄存器中</p>
<blockquote>
<p><code>MOV AL, BL</code></p>
<ul>
<li>此时给出的地址是寄存器地址,不是主存储器地址</li>
</ul>
</blockquote>
</li>
<li><p>(寄存器)间接寻址: 操作数的地址存放在寄存器中</p>
<blockquote>
<p><code>MOV AL, [SI]</code>: SI中存放的是操作数在主存储器中的地址</p>
</blockquote>
</li>
<li><p>(存储器)直接寻址</p>
<blockquote>
<ul>
<li>直接给出操作数在主存储器中的地址</li>
<li><code>MOV AL, [2000H]</code></li>
</ul>
</blockquote>
</li>
<li><p>(存储器)间接寻址</p>
<blockquote>
<ul>
<li>主存储器中存放的是操作数的地址(指令中存的是地址的地址)</li>
<li><code>MOV AL, [[1000H]]</code></li>
</ul>
</blockquote>
</li>
<li><p>相对寻址</p>
<blockquote>
<ul>
<li>给出目标地址EA与当前执行指令地址(PC)的相对位移量Disp</li>
<li>这能够实现一个程序的内部跳转, Disp通常为补码,可正可负</li>
<li>EA = (PC) + Disp</li>
<li><code>MOV AL, DISP[PC]</code>: CPU需要将寄存器PC加上寄存器DISP得到目标地址</li>
</ul>
</blockquote>
</li>
<li><p>基址寻址</p>
<blockquote>
<ul>
<li>给出目标地址EA与基址BR的相对位移量A(Disp)</li>
<li>基址寻址可用于操作系统内部的程序定位</li>
<li>EA = (BR) + A</li>
<li><code>MOV AL, DISP[BR]</code></li>
</ul>
</blockquote>
</li>
<li><p>变址寻址</p>
<blockquote>
<ul>
<li>给出目标地址EA与变址DI的相对位移量A</li>
<li>变址寻址可以用于访问数组等结构,将A固定,改变DI内容即可</li>
<li>EA = (DI) + A</li>
<li><code>MOV AL, DISP[DI]</code></li>
</ul>
</blockquote>
</li>
<li><p>堆栈寻址</p>
<blockquote>
<ul>
<li>用于堆栈操作指令</li>
</ul>
</blockquote>
</li>
<li><p>复合寻址</p>
<blockquote>
<ul>
<li>基址,变址,程序当前地址可以重复相加来寻址</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="6-4-指令类型"><a href="#6-4-指令类型" class="headerlink" title="6.4 指令类型"></a>6.4 指令类型</h2><h3 id="算术逻辑运算指令"><a href="#算术逻辑运算指令" class="headerlink" title="算术逻辑运算指令"></a>算术逻辑运算指令</h3><p>对定点数进行运算</p>
<ul>
<li>常有与,或,非,异或及按位操作指令</li>
<li>运算结果有四个状态位: Z(零),N(结果为负),V(结果溢出),C(产生进位或借位)</li>
</ul>
<h3 id="移位操作指令"><a href="#移位操作指令" class="headerlink" title="移位操作指令"></a>移位操作指令</h3><p>类型:<br><img src="/2020/02/24/computer-composition0/move0.jpg" alt="move"></p>
<ul>
<li>移位指令可以实现较高速的乘除法运算</li>
</ul>
<h3 id="浮点数运算指令"><a href="#浮点数运算指令" class="headerlink" title="浮点数运算指令"></a>浮点数运算指令</h3><p>高级语言中的实数(real)运算通常是先转化为浮点数形式再进行处理</p>
<blockquote>
<ul>
<li>某些机器的浮点数运算是用子程序实现的,速度较慢</li>
<li>用于科学计算的计算机应设置浮点运算指令,能对32位单精度或64位双精度浮点数做处理</li>
</ul>
</blockquote>
<h3 id="十进制运算指令"><a href="#十进制运算指令" class="headerlink" title="十进制运算指令"></a>十进制运算指令</h3><p>设置指令直接对十进制数进行运算,不再需要用程序转换成二进制数</p>
<ul>
<li>在人机交互频繁的计算机系统中设置十进制运算指令可以提高数据处理的速度</li>
</ul>
<h3 id="字符串处理指令"><a href="#字符串处理指令" class="headerlink" title="字符串处理指令"></a>字符串处理指令</h3><p>字符串处理指令是一种非数值处理指令,一般包括:</p>
<blockquote>
<ul>
<li>字符串传送: 将数据块从主存储器的某区传送到另一区域</li>
<li>字符串比较: 按位确定两字符串是否相等</li>
<li>字符串查询: 查找字符串中是否含有某一字串或字符</li>
<li>字符串转换: 从一种数据表达形式转换成另一种表达形式(编码转换)</li>
</ul>
</blockquote>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>用于寄存器,存储单元,存储器之间的数据传送</p>
<ul>
<li>包括数据读写,数据复制,数据交换(双向数据传送)等,一次可以传送一个或一批数据</li>
</ul>
<h3 id="转移类指令"><a href="#转移类指令" class="headerlink" title="转移类指令"></a>转移类指令</h3><p>用以改变程序的顺序执行,控制程序流的转移,分类:</p>
<blockquote>
<ul>
<li>无条件转移: jump</li>
<li>条件转移: branch</li>
<li>过程的调用与返回: call, return</li>
<li>陷阱指令: 用于处理计算机的程序错误或意外情况</li>
</ul>
</blockquote>
<h3 id="堆栈及堆栈操作指令"><a href="#堆栈及堆栈操作指令" class="headerlink" title="堆栈及堆栈操作指令"></a>堆栈及堆栈操作指令</h3><p>堆栈是由若干个连续存储单元组成的FILO区域,栈底固定,存放最先送入栈中的数据(栈底地址大于栈顶地址)</p>
<blockquote>
<ul>
<li>SP: 堆栈指针,表示栈顶的位置</li>
<li>PUSH OPR: 压栈指令(压入单字节); (SP)-1=&gt;SP, OPR=&gt;SP</li>
<li>POP OPR: 弹出指令; (SP)=&gt;OPR, (SP)+1=&gt;SP</li>
</ul>
</blockquote>
<p>程序调用中的堆栈: A程序调用B程序</p>
<blockquote>
<p>(A中) call B</p>
<ol>
<li>将该指令的下一条指令(A1)及其他信息压入栈中</li>
<li>执行B</li>
<li>弹出A1作为返回地址,此时继续执行A程序</li>
</ol>
</blockquote>
<p>子程序调用中的参数传递: 利用堆栈</p>
<blockquote>
<p>先将参数压入栈中,然后调用子程序</p>
</blockquote>
<h3 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h3><p>格式:<code>OP-REG-A</code></p>
<ul>
<li>OP: 操作码,表示IO指令</li>
<li>REG: 寄存器名,用于和外部设备交换数据</li>
<li>A: 外部设备寄存器地址或设备码(输入/输出数据寄存器,控制寄存器)</li>
</ul>
<p>IO指令除了传输数据,还可以用来发送和接收控制命令和回答信号,用于控制外部设备的工作</p>
<p>在外部设备与存储器统一编址的计算机中,任何访问存储器的指令都可以访问外部设备,无需专设IO指令</p>
<h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>只能提供给操作系统或系统软件使用的指令</p>
<ul>
<li>这些指令使用不当会破坏系统或其他用户信息,不能提供给用户使用</li>
<li>主要为系统资源分配管理指令以及一些外部设备/输入输出管理指令</li>
</ul>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ul>
<li>向量指令: 用于对向量或矩阵进行运算</li>
<li>多处理机指令: 用于管理共享的公共资源和相互通信</li>
<li>控制指令: 包括等待,停机,空操,开关中断,设置条件码指令等</li>
</ul>
<h2 id="6-5-RISC计算机和CISC计算机"><a href="#6-5-RISC计算机和CISC计算机" class="headerlink" title="6.5 RISC计算机和CISC计算机"></a>6.5 RISC计算机和CISC计算机</h2><h3 id="CISC指令集"><a href="#CISC指令集" class="headerlink" title="CISC指令集"></a>CISC指令集</h3><p>代表: DEC的VAX11/780,303条指令,18种寻址方式; Intel的80x86</p>
<ul>
<li>庞大的指令系统使计算机研制周期变长, 增加了调试和维护的难度, 有可能导致系统性能的下降</li>
</ul>
<h3 id="RISC指令集"><a href="#RISC指令集" class="headerlink" title="RISC指令集"></a>RISC指令集</h3><h4 id="RISC的产生和发展"><a href="#RISC的产生和发展" class="headerlink" title="RISC的产生和发展"></a>RISC的产生和发展</h4><p>1975年IBM公司开始研究指令系统的合理性问题,发现CISC中20%的指令在程序种出现的频率为80%</p>
<p>复杂的指令系统</p>
<blockquote>
<ul>
<li>增加了硬件实现的复杂性</li>
<li>增加了研制时间和成本以及设计失误的可能性</li>
<li>很难实现流水线操作</li>
<li>降低了机器的速度</li>
</ul>
</blockquote>
<p>1987年,RISC产品被推出,RISC不包含复杂指令</p>
<h3 id="RISC特点"><a href="#RISC特点" class="headerlink" title="RISC特点"></a>RISC特点</h3><p>RISC希望通过简化指令使计算机结构更加简单合理,从而提高运算速度</p>
<p>计算机执行程序所需时间P的计算方法:</p>
<ul>
<li>P = I<em>CPI</em>T<blockquote>
<ul>
<li>I: 高级语言程序编译后在机器上运行的指令数</li>
<li>CPI: 指令执行的平均周期数</li>
<li>T: 每个机器周期时间</li>
</ul>
</blockquote>
</li>
</ul>
<p>RISC特点:</p>
<blockquote>
<ul>
<li>优先选择使用频率高的一些简单指令于有用的指令,避免复杂指令</li>
<li>指令长度固定,提供较少的指令格式和寻址方式; 在各指令间提供比较一致的字段划分和比较规整的字段功能</li>
<li>仅有存取指令访问存储器,其余指令的操作都在寄存器之间进行</li>
<li>CPU中寄存器数量相当多,算术逻辑运算的操作数都在通用寄存器中存取</li>
<li>大部分指令在一个或小于一个机器周期内完成</li>
<li>以硬布线控制逻辑为主,不用或少用微码控制</li>
<li>特别重视编译优化工作,减少程序执行时间</li>
</ul>
</blockquote>
<h2 id="6-6-指令系统举例"><a href="#6-6-指令系统举例" class="headerlink" title="6.6 指令系统举例"></a>6.6 指令系统举例</h2><h3 id="SPARC指令系统"><a href="#SPARC指令系统" class="headerlink" title="SPARC指令系统"></a>SPARC指令系统</h3><p>指令字长32位,3种指令格式,6种指令类型</p>
<p>指令类型:</p>
<blockquote>
<ul>
<li>31条算数/逻辑运算和移位指令</li>
<li>22条LOAD/STORE指令</li>
<li>5条控制转移指令</li>
<li>8条读写专用寄存器指令</li>
<li>浮点运算指令</li>
<li>协处理器指令: SPARC为整数运算部件, 需要用协处理器或子程序实现浮点数运算</li>
</ul>
</blockquote>
<p>指令格式:</p>
<blockquote>
<ul>
<li>CALL指令: <code>OP(2位)-Disp(30位)</code></li>
<li>SETHI指令和Branch指令: <code>OP(2)-rd(5)-OP2(2)-imm(22)</code>; <code>OP(2)-a(1)-Cond(4)-OP2(2)-disp(22)</code></li>
<li>其他指令</li>
</ul>
</blockquote>
<h3 id="Pentium微处理器指令系统"><a href="#Pentium微处理器指令系统" class="headerlink" title="Pentium微处理器指令系统"></a>Pentium微处理器指令系统</h3><p>程序员能见到的寄存器:</p>
<blockquote>
<ul>
<li>32位数据寄存器: E(xtended)AX,EBX,ECX,EDX; 低位可以分为AX等16位寄存器; 每个16位可以分为如AL和AH等两个8位高低寄存器</li>
<li>5个32位指针/变址寄存器: 堆栈指针ESP; 基址指针EBP; 源变址寄存器ESI; 目的变址寄存器EDI; 指令指针EIP(即PC)</li>
<li>6个段寄存器(访问主存和外设IO端口): 取指令CS(CS:IP); (默认)读写数据DS; 堆栈操作指针SS; ES,FS,GS可任意使用</li>
</ul>
</blockquote>
<p>指令系统:<code>OP-MOD/RM-SIB-Disp-Imm</code></p>
<blockquote>
<ul>
<li>OP: 操作码,1或2个字节,可扩展</li>
<li>MOD/RM: 指出操作数的位置,指出寻址方式,0或1个字节</li>
<li>SIB: 配合前面指出寻址方式,0或1个字节</li>
<li>Disp: 在特定寻址方式下指出地址偏移量,0、1、2或4个字节</li>
<li>Imm: 立即数寻址,0、1、2或4个字节</li>
</ul>
</blockquote>
<h2 id="6-7-机器语言-汇编语言和高级语言"><a href="#6-7-机器语言-汇编语言和高级语言" class="headerlink" title="6.7 机器语言,汇编语言和高级语言"></a>6.7 机器语言,汇编语言和高级语言</h2><ul>
<li>机器语言: 由二进制代码组成的指令和数据, 在计算机硬件设计时产生</li>
<li>汇编语言: 用助记符标注的机器语言, 易于阅读</li>
<li>高级语言: 扩展功能,简化编程复杂度</li>
</ul>
<h1 id="七、中央处理器"><a href="#七、中央处理器" class="headerlink" title="七、中央处理器"></a>七、中央处理器</h1><p>（原书第六章）<br>CPU是计算机中最重要的部分, 对指令流和数据流在时间和空间上实施正确的布控</p>
<blockquote>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>时序控制</li>
<li>数据加工处理</li>
</ul>
</blockquote>
<p>组成部件:</p>
<blockquote>
<ul>
<li>运算逻辑单元ALU</li>
<li>寄存器</li>
<li>中断系统</li>
<li>控制部件</li>
<li>(外部数据交换): 控制总线,数据总线,地址总线(单向,由CPU发出)</li>
</ul>
</blockquote>
<h2 id="7-1-控制器的组成"><a href="#7-1-控制器的组成" class="headerlink" title="7.1 控制器的组成"></a>7.1 控制器的组成</h2><h3 id="控制器组成"><a href="#控制器组成" class="headerlink" title="控制器组成"></a>控制器组成</h3><p><img src="/2020/02/24/computer-composition0/control0.jpg" alt="control">  </p>
<p>控制器组成:</p>
<blockquote>
<ul>
<li>程序计数器PC: 用于存放当前或即将执行的指令地址, 形成顺序执行指令地址(PC+1)或转移类指令地址</li>
<li>指令寄存器IR: 用于存放当前正在执行的指令</li>
<li>地址寄存器AR: 存储当前CPU访问的内存单元的地址</li>
<li>数据寄存器DR: 暂存由内存中读出或写入的指令/数据</li>
<li>指令译码器: 对IR中的操作码进行分析解释,产生相应的控制信号或有一定时序关系的控制信号序列</li>
<li>脉冲源CLK以及启停线路: CLK产生机器周期和工作脉冲的基准信号以及机器刚加点时的reset信号; 启停线路保证完整的时钟信号能够被可靠地送出或封锁,控制CLK的发生或停止,从而控制机器的启停</li>
<li>时序控制信号形成部件: 在CLK作用下根据指令需要产生时序控制信号并根据被控制部件的反馈信号进行时序信号的调整</li>
<li>程序状态寄存器PS(W)R: 保存程序状态字PSW</li>
</ul>
</blockquote>
<p>组成控制器的基本电路是具有记忆功能的触发器以及没有记忆功能的门电路</p>
<h3 id="控制器功能"><a href="#控制器功能" class="headerlink" title="控制器功能"></a>控制器功能</h3><p>控制器用于控制程序的执行,有如下功能:</p>
<blockquote>
<ul>
<li>取指令: 发出指令地址及控制信号,从程序入口取出第一条指令,然后不断地取出指令</li>
<li>分析指令: 对当前的指令进行分析, 根据指令要求产生相应的操作控制命令</li>
<li>执行指令: 对上述产生的操作控制命令进行执行,实现每条指令的功能</li>
<li>控制程序的数据输入与结果输出: 在适当的时候向输入输出设备发出一些命令来完成IO功能</li>
<li>处理异常情况和某些请求</li>
</ul>
</blockquote>
<p>指令执行过程</p>
<blockquote>
<ol>
<li>取指令: (PC)=&gt;AR, (AR)=&gt;DR, (DR)=&gt;IR, (PC)+1=&gt;PC</li>
<li>分析指令: 分析指令,计算操作数的有效地址</li>
<li>执行指令: 根据一系列操作控制信号执行指令</li>
</ol>
</blockquote>
<p>一些概念:</p>
<blockquote>
<ul>
<li>指令周期: 取出并执行一条指令的时间,由若干个机器周期组成</li>
<li>机器周期(CPU周期): 一般由从内存中读取一个指令字的最短时间规定CPU周期, 由若干个时钟周期组成</li>
<li>时钟周期: 处理操作的最基本单位, 又称为节拍脉冲或T周期</li>
</ul>
</blockquote>
<p>举例: ADD指令</p>
<blockquote>
<p>ADD指令的指令周期由3个CPU周期组成: </p>
<ol>
<li>取指与译码: 取指令,指令译码(得到操作性质和操作数)</li>
<li>执行指令: 送操作数地址,地址译码(计算地址)</li>
<li>执行指令: 取出操作数,执行操作</li>
<li>取下一条指令…</li>
</ol>
</blockquote>
<p>信息传输方向:</p>
<blockquote>
<ul>
<li>指令: M-DR-DBUS-IR</li>
<li>(指令)地址: PC-ABUS-AR-…</li>
<li>寄存器-寄存器数据: 直接通过总线</li>
<li>寄存器-存储器: R-DBUS-DR-M</li>
<li>存储器-寄存器: M-DR-DBUS-R</li>
</ul>
</blockquote>
<h3 id="时序产生和控制方式"><a href="#时序产生和控制方式" class="headerlink" title="时序产生和控制方式"></a>时序产生和控制方式</h3><p>操作控制器发出的各种控制信号都是时序信号和部件的函数</p>
<p>时序产生控制器:</p>
<blockquote>
<ul>
<li>硬布线控制器: 由组合逻辑实现,注状态周期-节拍电位-节拍脉冲</li>
<li>微程序控制器: 节拍电位-节拍脉冲</li>
</ul>
</blockquote>
<p>控制器控制方式:</p>
<blockquote>
<ul>
<li>同步控制: 一条已定的指令在执行时所需的机器周期数和节拍数固定不变</li>
<li>异步控制: 采用应答方式执行指令,每个微操作需要多少时间就占用多少时间</li>
<li>混合控制方式: 结合两种控制方式, 大部分操安排在固定的机器周期中同步控制, 对时间难以确定的操作以问答方式控制</li>
<li>人工控制: 用于调机和软件开放的需要,如reset键和单条指令执行切换开关</li>
</ul>
</blockquote>
<h2 id="7-2-微程序控制的计算机"><a href="#7-2-微程序控制的计算机" class="headerlink" title="7.2 微程序控制的计算机"></a>7.2 微程序控制的计算机</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>微程序控制器利用软件方法(微程序控制技术)来设计硬件,将存储逻辑和程序技术引入CPU</p>
<blockquote>
<ul>
<li>微命令: 控制部件向执行部件发出的控制命令</li>
<li>微操作: 执行一条指令所进行的一系列基本操作,如取指令,计算地址等; 是执行部件接受微命令后进行的操作</li>
<li>微指令: 实现一定操作功能的一组微命令</li>
<li>微程序: 实现一条机器指令功能的微指令序列</li>
</ul>
</blockquote>
<h3 id="微程序的实现原理"><a href="#微程序的实现原理" class="headerlink" title="微程序的实现原理"></a>微程序的实现原理</h3><p>控制存储器: 存放微程序的只读存储器,内部结构如下</p>
<blockquote>
<p>控制命令-下一条执行的微指令地址(下址)<br>控制命令-下一条执行的微指令地址<br>…</p>
</blockquote>
<p>微程序控制器执行流程:</p>
<blockquote>
<ul>
<li>OP-&gt;编码器-&gt;(取指微程序入口)</li>
<li>(取指微程序入口)=&gt;顺序控制逻辑=&gt;微地址寄存器=&gt;控制存储器=&gt;控制字段+下址</li>
<li>控制字段=&gt;产生控制信号</li>
<li>下址=&gt;顺序控制逻辑(转上面循环)</li>
</ul>
</blockquote>
<p>微程序控制器特点: 规整,灵活,可维护</p>
<p>确定微指令的结构</p>
<blockquote>
<ul>
<li>缩短微指令的长度</li>
<li>减少控制存储器的容量</li>
<li>提高微程序的执行速度</li>
<li>有利于对微指令的修改</li>
<li>有利于提高微程序设计的灵活性</li>
</ul>
</blockquote>
<p>微指令结构: 操作控制字段-顺序控制字段<br>微操作: 相容(能够在一个CPU周期内并行),相斥(不能并行)</p>
<p>微指令编码: 对微指令中的操作控制字段采用的表示方法</p>
<blockquote>
<ul>
<li>直接编码: 操作控制字段存储一组微命令,可以直接发出控制命令(一般每一位代表一个微命令); 这会导致微指令较长</li>
<li>译码控制法: 操作控制字段被分为若干个字段,每个字段通过译码器翻译成一个互斥的微命令执行; 这可以缩短微指令,但会增加微程序的执行时间</li>
<li>混合编码: 混合使用直接编码和译码编码, 综合两者特点</li>
</ul>
</blockquote>
<p>下址(微地址)生成方式:</p>
<blockquote>
<ul>
<li>计数器方式(增量方式): (uPC)+1=&gt;uPC</li>
<li>断定方式: 根据当前微指令的判定条件BCF断定下条指令的微地址BAF,BAF=&gt;uPC</li>
<li>增量和断定方式结合</li>
</ul>
</blockquote>
<p>微指令执行过程: 取微指令,执行微指令中的各个操作</p>
<blockquote>
<p>执行一条微指令所需时间为微周期</p>
<ul>
<li>串行执行: 取微指令和执行微指令串行执行, 此时微周期为控制存储器的工作周期</li>
<li>并行执行: 执行本条微指令和取下一条微指令操作同时进行; 取微指令执行时间和取指时间最长的作为微周期时间; 若遇到条件转移微指令,则延迟一个微周期再取指</li>
</ul>
</blockquote>
<p>多路转移: 有些微指令存在多个转移分支,根据不同操作码产生不同下址</p>
<blockquote>
<ul>
<li>实现电路: PROM/MAPROM, 输入指令操作码,输出下址; 该存储器容量略大于机器指令数,容量小速度快</li>
<li>一般只需要2路或4路转移,涉及的微地址变化仅有1或2位,多路转移可以减少微程序的长度</li>
</ul>
</blockquote>
<p>微中断: 终止当前执行的程序,转去执行微中断处理程序(已定义)</p>
<blockquote>
<ul>
<li>微中断请求信号是由程序中断请求信号引起的</li>
</ul>
</blockquote>
<p>毫微程序设计: 用于解释微程序的一种微程序; 毫微指令为解释微指令的微指令</p>
<blockquote>
<ul>
<li>目的: 采用两级微程序设计方法,减少控制存储器的容量</li>
<li>通常第一级采用垂直微程序,第二级采用水平微程序</li>
</ul>
</blockquote>
<h3 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h3><ul>
<li><p>水平型微指令: 一次能定义并执行多个并行微命令的微指令</p>
<blockquote>
<p>结构: <code>控制字段-判断测试字段-下址字段</code></p>
<ul>
<li>控制字段有全水平型译码,字段译码和混合译码法</li>
</ul>
</blockquote>
</li>
<li><p>垂直型微指令: 设有微操作码字段,不强调实现微指令的并行控制功能,一般能实现一到两个操作</p>
<blockquote>
<ul>
<li>相比于水平型微指令,垂直型微指令指令字较短,组成的微程序较长,效率较低但容易掌握</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="机器周期的确定"><a href="#机器周期的确定" class="headerlink" title="机器周期的确定"></a>机器周期的确定</h3><ul>
<li>所有的微操作都应当在一个机器周期内完成</li>
<li>当使用ready信号(低电平)时,若其出现时间较晚,则CPU会延长一个或以上的节拍信号</li>
</ul>
<h3 id="微程序控制计算机给简单工作流程"><a href="#微程序控制计算机给简单工作流程" class="headerlink" title="微程序控制计算机给简单工作流程"></a>微程序控制计算机给简单工作流程</h3><ul>
<li>机器加电,由reset信号在PC寄存器中置入第一条指令地址,在微指令寄存器中置入一条”取指”指令,同时初始化其他状态位和寄存器</li>
<li>电压稳定后,启动机器工作,产生节拍电位和CP信号,检查第一个机器周期信号的完整性</li>
<li>产生开机后第一个工作脉冲CP,开始工作</li>
<li>遇到停机指令或外来停机命令</li>
<li>待当前指令执行完或至少在这个机器周期结束时停机<blockquote>
<ul>
<li>停机: 停机时电压仍维持正常,寄存器和存储器的信息不变,重启后仍能从断点处继续执行下去</li>
<li>停电: 寄存器和存储器内容丢失,加点后重新从reset信号开始运行; 某些机器有停电后自动再启动功能,依靠后备电源将主存和程序断点及状态信息调入外存中,恢复电源后从断点处继续工作</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="7-4-硬布线控制的计算机"><a href="#7-4-硬布线控制的计算机" class="headerlink" title="7.4 硬布线控制的计算机"></a>7.4 硬布线控制的计算机</h2><p>硬布线控制器将控制部件看成专门固定时序控制信号的逻辑电路,由逻辑电路直接连线产生<br><img src="/2020/02/24/computer-composition0/hard0.jpg" alt="hard"></p>
<blockquote>
<p>cy1-cy4表示4个机器周期</p>
</blockquote>
<ul>
<li>设计目标: 使用最少的元件,取得最高的操作速度</li>
<li>设计原理: 以指令功能要实现的微操作序列为依据</li>
</ul>
<p>硬布线控制器修改指令很复杂,但性能高</p>
<h2 id="7-5-流水线工作原理"><a href="#7-5-流水线工作原理" class="headerlink" title="7.5 流水线工作原理"></a>7.5 流水线工作原理</h2><p>将两条或多条指令再时间上重叠起来运行,提高程序的执行速度</p>
<p>特点:</p>
<blockquote>
<ul>
<li>连续执行同类任务时效率最高</li>
<li>每个流水线都要设置一个流水寄存器</li>
<li>个流水段的时间应尽量相等</li>
<li>需要有装入时间和排空时间</li>
</ul>
</blockquote>
<p>执行N条K个机器周期的指令,流水线需要N+K-1个机器周期</p>
<p>流水线的问题:</p>
<ul>
<li>结构上,不同指令会争用同一部件</li>
<li>数据上,不同指令可能会因重叠操作改变读写访问顺序</li>
<li>控制上,转移指令可能会使流水线停顿</li>
</ul>
<h2 id="7-6-CPU举例"><a href="#7-6-CPU举例" class="headerlink" title="7.6 CPU举例"></a>7.6 CPU举例</h2><p>RISC: SPARC处理器<br>CISC: Pentium微处理器</p>
<h2 id="7-7-计算机的供电"><a href="#7-7-计算机的供电" class="headerlink" title="7.7 计算机的供电"></a>7.7 计算机的供电</h2><p>计算机的直流电源是由交流电源经过整流稳压而得到的</p>
<blockquote>
<ul>
<li>一般逻辑电路需要+5V直流电</li>
<li>为减少机器功耗,电源朝着降低电压值方向发展,出现3.5V和1.8V等</li>
<li>还有-5V,+-12V等直流电源供磁盘存储器等电路的使用</li>
</ul>
</blockquote>
<p>不间断电源UPS: 后备式,在线式</p>
<h1 id="八、辅助存储器"><a href="#八、辅助存储器" class="headerlink" title="八、辅助存储器"></a>八、辅助存储器</h1><p>辅助存储器容量大而成本低,是非易失性存储器</p>
<p>辅存主要由磁表面存储器和光存储器两大类</p>
<blockquote>
<ul>
<li>磁表面存储器将磁性材料沉积再盘片(或带)的基体上形成磁记录介质,并用饶有线圈的磁头与介质的相对运动来写入或读出信息</li>
<li>光存储器介质主要是光盘,它利用激光束在具有感光特性的表面上存储信息</li>
</ul>
</blockquote>
<h2 id="8-1-磁表面存储器的种类与技术指标"><a href="#8-1-磁表面存储器的种类与技术指标" class="headerlink" title="8.1 磁表面存储器的种类与技术指标"></a>8.1 磁表面存储器的种类与技术指标</h2><h3 id="存储密度"><a href="#存储密度" class="headerlink" title="存储密度"></a>存储密度</h3><p>单位长度或面积磁层表面所存储的二进制信息量</p>
<blockquote>
<ul>
<li>磁盘: 道密度和位密度或面密度</li>
<li>磁带: 位密度</li>
</ul>
<p>磁道: 存储在介质表面上信息的磁化轨迹</p>
</blockquote>
<p>磁盘存储器中:</p>
<blockquote>
<ul>
<li>磁道: 磁盘表面上的同心圆</li>
<li>扇区: 磁道组成的扇形表面</li>
<li>柱面: 多个盘片在同一半径的磁道形成的整体</li>
<li>道宽: 磁道宽度</li>
<li>道距: 两磁道中心线距离,一般比道宽大</li>
<li>道密度: 沿磁盘半径方向单位长度的磁道数(道/英寸 tpi)</li>
<li>位密度(线密度): 单位长度磁道所能记录的二进制信息(位/英寸 bpi)；内圈位密度大于外圈位密度</li>
<li>面密度: 道密度*位密度</li>
</ul>
</blockquote>
<p>磁带中,存储密度用位密度衡量</p>
<h3 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h3><p>存储容量: 存储器能存的二进制信息总量,一般以字节位单位</p>
<ul>
<li>格式化容量: 按照某种记录格式所能存储的信息的总量,为用户可由使用的容量</li>
<li>非格式化容量: 磁记录表面可以利用的磁化单元总量<blockquote>
<ul>
<li>低级格式化: 在盘片上建立扇区和磁道,并将每个扇区的开始和结束部分写入到盘片上</li>
<li>高级格式化: 写入文件储存的结构,如将文件分配表写入扇区</li>
</ul>
</blockquote>
</li>
</ul>
<p>格式化容量一般为非格式化容量的60%-70%</p>
<h3 id="寻址时间"><a href="#寻址时间" class="headerlink" title="寻址时间"></a>寻址时间</h3><p>磁盘存储器采用直接存取方式:</p>
<blockquote>
<ul>
<li>寻道时间$t_s$: 磁头寻找目标磁道所需的时间</li>
<li>等待时间$t_w$: 磁头等待目标区域旋转到其下方所需的时间</li>
</ul>
</blockquote>
<p>平均寻址时间$T_a = T_s+T_w = \overline t_s + \overline t_w$</p>
<p>一般硬盘平均寻址时间在10ms左右,磁带平均寻址时间更长</p>
<h3 id="数据传输速率"><a href="#数据传输速率" class="headerlink" title="数据传输速率"></a>数据传输速率</h3><ul>
<li>数据传输速率$D_r$: 单位时间内存储器与主机之间传送数据的位数或字节数</li>
<li>传输率与存储设备和主机接口逻辑有关</li>
<li>从设备方面考虑，传输率等于记录密度D和记录介质的运动速度V的乘积。</li>
<li>从主机接口逻辑考虑，应有足够快的传送速度接收／发送信息，以便主机与辅存之间的传输正确无误</li>
</ul>
<h3 id="误码率和价格"><a href="#误码率和价格" class="headerlink" title="误码率和价格"></a>误码率和价格</h3><p>误码率: 衡量磁表面存储器出错概率的参数; 它等于从辅存读出时，出错信息位数和读出的总信息位数之比。</p>
<p>价格: 通常用位价格来比较各种存储器。位价格是设备价格除以容量，在所有存储设备中，磁表面存储器和光盘存储器的位价格是很低的。</p>
<h2 id="8-2-磁记录原理与记录方式"><a href="#8-2-磁记录原理与记录方式" class="headerlink" title="8.2 磁记录原理与记录方式"></a>8.2 磁记录原理与记录方式</h2><ul>
<li>磁记录原理: 磁表面存储器通过磁头和记录介质的相对运动完成写入和读出, 本质是电和磁之间的转换</li>
<li>磁记录介质: 涂有薄层磁性材料的信息载体,又称为磁记录媒体; 可分为软性介质和硬性介质</li>
<li>磁头: 一个电磁转换装置,可以将电脉冲表示的二进制代码和磁化信息相互转化</li>
<li>磁记录方式: 按照某种规律将二进制数字信息变换成存储介质的磁化翻转方式<br><img src="/2020/02/24/computer-composition0/disc0.jpg" alt="disc"></li>
</ul>
<h2 id="8-3-磁盘存储器"><a href="#8-3-磁盘存储器" class="headerlink" title="8.3 磁盘存储器"></a>8.3 磁盘存储器</h2><p>种类:</p>
<blockquote>
<ul>
<li>硬磁盘存储器：硬盘存储器和软盘存储器。</li>
<li>根据磁头的工作方式分类：移动头磁盘存储器和固定头磁盘存储器</li>
<li>根据磁盘可换与否分类：可换盘存储器和固定盘存储器两</li>
</ul>
</blockquote>
<p>结构:</p>
<blockquote>
<ul>
<li>驱动器HDD: 独立于主机之外的一个完整的磁盘驱动器装置</li>
<li>控制器HDC: 在主机总线上的一个控制电路板</li>
</ul>
</blockquote>
<p>磁盘阵列存储器: 廉价冗余磁盘阵列(Redundent Array Of Inexpensive Disk，简称RAID)是用多台磁盘存储器组成的大容量外存储子系统</p>
<blockquote>
<ul>
<li>数据分块技术: 在多个磁盘上交错存放数据,使之可以并行存取</li>
<li>数据冗余技术: 阵列中的一部分磁盘存有冗余信息</li>
</ul>
</blockquote>
<p>RAID分类:</p>
<blockquote>
<ul>
<li>RAID0: 无冗余无校验的数据分块; 磁盘利用率和IO性能最高,但可靠性最低</li>
<li>RAID1: 镜像磁盘阵列; 安全性高,IO性能不变,利用率为50%</li>
<li>RAID2: 纠错海明码和位交叉存取; 对数据的访问涉及磁盘阵列中的每一个盘,很少使用</li>
<li>RAID3: 奇偶校验码和位交叉存取; 计算较为费时</li>
<li>RAID4: 奇偶校验码和块交叉存取; 有专用校验盘,对少量数据(块)读写只涉及数据盘和校验盘两个盘</li>
<li>RAID5: 奇偶校验码和块交叉存取; 无专用校验盘,校验信息分布到组内所有盘上,性能较号,普遍采用</li>
<li>RAID6: 两种奇偶校验码和块交叉; 需要多两个盘的容量来存储校验信息,可靠性高</li>
<li>RAID7: 独立接口的磁盘阵列; 主机可以独立地对每个磁盘驱动器进行访问</li>
<li>RAID10: RAID0和RAID1的组合,性能好安全性高,但利用率低</li>
</ul>
</blockquote>
<h2 id="8-4-磁带存储器"><a href="#8-4-磁带存储器" class="headerlink" title="8.4 磁带存储器"></a>8.4 磁带存储器</h2><p>读写工作原理基本上与磁盘存储器相同,区别如下</p>
<blockquote>
<ul>
<li>磁带是顺序存取设备</li>
<li>介质时涂上磁粉的薄塑料带</li>
<li>读写某点信息需要进行快进或者倒转</li>
<li>读写时磁头会直接接触磁带</li>
<li>磁带移动速度较慢</li>
</ul>
</blockquote>
<h2 id="8-5-光盘存储器"><a href="#8-5-光盘存储器" class="headerlink" title="8.5 光盘存储器"></a>8.5 光盘存储器</h2><p>光盘是使用光学方式进行读写信息的圆盘</p>
<blockquote>
<ul>
<li>只读型光盘CD-ROM: 由厂商预先写入信息,只读不可写</li>
<li>一次性写入型WORM: 用户只能一次写入,可以多次读出</li>
<li>可擦写型: 可以重复读写; 其采用磁光可重写技术,即利用激光在磁记录介质上存储信息</li>
</ul>
</blockquote>
<h2 id="8-6-固态盘"><a href="#8-6-固态盘" class="headerlink" title="8.6 固态盘"></a>8.6 固态盘</h2><ul>
<li>固态盘是用半导体存储介质和传统磁盘接口构成的存储器</li>
<li>存储器介质可以是DRAM或NVRAM,也有用NAND闪存为核心的SSD</li>
<li>U盘,闪盘,存储卡等都是SSD</li>
</ul>
<h1 id="九、输入输出IO设备"><a href="#九、输入输出IO设备" class="headerlink" title="九、输入输出IO设备"></a>九、输入输出IO设备</h1><h2 id="9-1-外部设备概述"><a href="#9-1-外部设备概述" class="headerlink" title="9.1 外部设备概述"></a>9.1 外部设备概述</h2><p>中处理器和主存储器构成计算机主体，输入输出设备、外存储器、脱机输入输出设备构成外部设备</p>
<ul>
<li>IO设备由信息载体、设备及设备控制器组成<blockquote>
<ul>
<li>IO设备的工作速度比主机慢</li>
<li>各IO设备的信息类型和结构均不同</li>
<li>各IO设备的电气特性不同</li>
</ul>
</blockquote>
</li>
</ul>
<p>结构：</p>
<blockquote>
<ul>
<li>CPU和主存构成主机</li>
<li>主机由总线与外部设备控制器相连</li>
<li>外部设备控制器包括外存设备控制器、输入设备控制器、输出设备控制器、通信控制器和过程控制器等</li>
<li>不同控制器和不同外设相连 </li>
</ul>
</blockquote>
<p>信息交换代码格式：ASCII码 </p>
<p>传送格式：串行传送、并行传送</p>
<h2 id="9-2-输入设备"><a href="#9-2-输入设备" class="headerlink" title="9.2 输入设备"></a>9.2 输入设备</h2><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>键盘是由一组排列成阵列形式的按键开关组成的</p>
<p>ASCII码：</p>
<blockquote>
<ul>
<li>ASCII码每一个字符都由7位二进制表示，正常情况下最高一位为0；奇偶校验时它也可以存放校验位</li>
<li>ASCII是由128个字符组成的字符集<br>字符集中，0－31为控制字符，其余94个字符为可印刷字符</li>
</ul>
</blockquote>
<h3 id="光笔、图形板和画笔（游动标）输入"><a href="#光笔、图形板和画笔（游动标）输入" class="headerlink" title="光笔、图形板和画笔（游动标）输入"></a>光笔、图形板和画笔（游动标）输入</h3><p>这些设备输入的是绝对坐标</p>
<p>光笔：</p>
<blockquote>
<ul>
<li>外形似钢笔，头部有一个透镜系统</li>
<li>它可以拾取显示器屏幕上的坐标，和屏幕上的光标配合可以修改或画出图形</li>
</ul>
</blockquote>
<p>图形板和画笔：</p>
<blockquote>
<ul>
<li>图形板是一个二维的数字化板</li>
<li>图形板 和画笔结合构成二维坐标输入系统，主要用于输入工程图等</li>
</ul>
</blockquote>
<p>游动标：一种高精度的读图设备</p>
<h3 id="鼠标器、跟踪球和操纵杆"><a href="#鼠标器、跟踪球和操纵杆" class="headerlink" title="鼠标器、跟踪球和操纵杆"></a>鼠标器、跟踪球和操纵杆</h3><p>鼠标器，跟踪球操纵杆输入的是相对坐标</p>
<h3 id="触摸屏"><a href="#触摸屏" class="headerlink" title="触摸屏"></a>触摸屏</h3><p>触摸屏是一种透明的，安装在显示器屏幕的外表面的一种设备</p>
<p>分类：电阻式、电容式、红外线式、表面声波技术和底坐式矢量压力测力技术</p>
<h3 id="图像输入设备"><a href="#图像输入设备" class="headerlink" title="图像输入设备"></a>图像输入设备</h3><p>摄像机和摄像头，数字照相机</p>
<h3 id="条形码"><a href="#条形码" class="headerlink" title="条形码"></a>条形码</h3><p>条码：由一组宽度和反射率不同的平行相邻的“条”和“空”，按照预先规定的编码规则组合起来，用以表示一组数据的符号。这组数据可以是数字、字母或某些符号。</p>
<h3 id="光学字符识别（OCR）技术和语音文字输入系统"><a href="#光学字符识别（OCR）技术和语音文字输入系统" class="headerlink" title="光学字符识别（OCR）技术和语音文字输入系统"></a>光学字符识别（OCR）技术和语音文字输入系统</h3><p>NaN</p>
<h2 id="9-3-显示器"><a href="#9-3-显示器" class="headerlink" title="9.3 显示器"></a>9.3 显示器</h2><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul>
<li>图形：最初指没有亮暗层次变化的线条图，早期的图形显示局限在二值化的范围</li>
<li>图像最初指具有亮暗层次的图，经计算机处理后显示的图像称作数字图像</li>
<li>分辨率：显示屏光点的多少</li>
<li>灰度级：所显示像素点的亮暗差别</li>
<li>亮度：单位为坎德拉每平方米</li>
<li>对比度：显示器画面上最大亮度和最小亮度的比值</li>
<li>刷新屏率（扫描频率）：显示器每秒刷新的次数 </li>
<li>刷新存储器：用来存放一帧图像信息的存储器，其容量为分辨率*灰度</li>
<li>帧存储器：为连续提供刷新图像的信号而用于存储图像的存储器（VRAM）；一般在适配器或显卡内，性能比一般DRAM好</li>
<li>光栅扫描：一种电视中采用的扫描方法，一般为从上到下的逐行扫描或隔行扫描</li>
</ul>
<h3 id="显示器种类"><a href="#显示器种类" class="headerlink" title="显示器种类"></a>显示器种类</h3><ul>
<li>阴极射线管：一个电真空器件，由电子枪、偏转装置和荧光屏构成</li>
<li>液晶显示器</li>
<li>彩色等离子体显示器</li>
</ul>
<h2 id="9-4-打印机"><a href="#9-4-打印机" class="headerlink" title="9.4 打印机"></a>9.4 打印机</h2><p>打印机是计算机系统最基本的输出形式</p>
<p>分类：击打式、非击打式；串行打印机、行式打印机等</p>
<h3 id="点阵式打印机"><a href="#点阵式打印机" class="headerlink" title="点阵式打印机"></a>点阵式打印机</h3><p>特点：结构简单，体积小，重量轻，价格低</p>
<h3 id="激光打印机"><a href="#激光打印机" class="headerlink" title="激光打印机"></a>激光打印机</h3><p>速度快，打印质量高</p>
<h3 id="喷墨打印机"><a href="#喷墨打印机" class="headerlink" title="喷墨打印机"></a>喷墨打印机</h3><p>有压电式喷墨技术和热电式喷墨技术</p>
<h3 id="热转打印机"><a href="#热转打印机" class="headerlink" title="热转打印机"></a>热转打印机</h3><p>分为串式印字和行式印字</p>
<h2 id="9-5-汉子处理技术"><a href="#9-5-汉子处理技术" class="headerlink" title="9.5 汉子处理技术"></a>9.5 汉子处理技术</h2><h3 id="汉子交换编码"><a href="#汉子交换编码" class="headerlink" title="汉子交换编码"></a>汉子交换编码</h3><p>国标码：GB2312－80，共计收录一级汉字3755个，二级汉子3008个，各种符号682个</p>
<h3 id="汉字处理技术"><a href="#汉字处理技术" class="headerlink" title="汉字处理技术"></a>汉字处理技术</h3><p>汉字内码：用于汉字信息的存储、检索等操作的机内代码，一般由两个字节组成</p>
<p>一般以国标码为基础进行编码，如将国标码最高位置1</p>
<p>汉字点阵编码：用于汉字的输出显示</p>
<p>汉字表示方法：字符代码化，输入码向机内码转换，处理机内码，机内码向字形码转换，显示/打印输出</p>
<h1 id="十、输入输出IO系统"><a href="#十、输入输出IO系统" class="headerlink" title="十、输入输出IO系统"></a>十、输入输出IO系统</h1><h2 id="10-1-输入输出系统概述"><a href="#10-1-输入输出系统概述" class="headerlink" title="10.1 输入输出系统概述"></a>10.1 输入输出系统概述</h2><p>输入输出系统包括外部设备（辅存和输入输出设备）及其与主机之间的控制设备</p>
<blockquote>
<p>控制部件又称为设备控制器（设备适配器或接口）</p>
<ul>
<li>如磁盘控制器、打印机控制器等</li>
<li>作用：控制并实现主机与外部设备之间的数据传送</li>
<li>设备控制器与主机之间传送数据的协议：系统总线</li>
</ul>
</blockquote>
<p>输入输出设备的编址</p>
<blockquote>
<ul>
<li>设备号或设备代码：每台设备的一个地址码，为了CPU对IO设备进行寻址和选择</li>
</ul>
<p>两种寻址方式：</p>
<ul>
<li>专设IO指令：指令的地址码字段直接指出输入输出设备的设备代码</li>
<li>利用访存指令完成IO功能：此时需要从主存地址空间中分出一部分地址码作为IO的设备代码，当IO指令访问到这些地址时表示对IO设备寄存器的访问</li>
</ul>
<p>IBM PC中有专门IO指令，设备编址可达512个；每台设备占用若干个地址码，分别表示相应的设备控制器中的寄存器地址</p>
</blockquote>
<p>设备控制器的基本功能：</p>
<blockquote>
<ul>
<li>实现主机和外部设备之间的数据传送</li>
<li>实现数据缓冲，使得主机和外部设备之间的速度相匹配</li>
<li>接受主机的命令，提供设备接口的状态，并按照主机的命令控制设备</li>
</ul>
</blockquote>
<p>输入输出接口类型：</p>
<blockquote>
<ul>
<li>并行接口（按数据传送宽度分类）：设备和接口将一个字（节）的所有位同时传送</li>
<li>串行接口：设备和接口之间数据是一位一位串行传送，然后接口完成数据格式的串并转换；接口和主机之间按字节或并行传送</li>
<li>程序控制输入输出接口（按数据传送控制方式分类）</li>
<li>程序中断输入输出接口</li>
<li>直接存储器存取（DMA）接口</li>
</ul>
</blockquote>
<p>IO设备数据传送控制方式：</p>
<blockquote>
<p>程序直接控制方式：</p>
<ul>
<li>完全通过程序控制主机和外设之间的信息传送；CPU和外设串行工作，效率较低</li>
<li>策略：在用户程序中安排一段由IO指令和其他指令组成的程序段直接控制外围设备的工作</li>
<li>工作流程：发出启动命令启动设备，重复用一条测试指令检测IO设备的工作状态，待检测到“完成“状态时，进行数据传送</li>
</ul>
<p>程序中断传送方式</p>
<ul>
<li>一定程度上实现了CPU和外设的并行工作；但对于一些工作频率较高的外设这么传送数据有可能造成信息丢失</li>
<li>在程序中安排一条启动外围设备的指令，发出指令后原程序继续执行直到IO设备完成准备，此时IO设备向CPU发送中断请求INT信号</li>
<li>接收到信号后CPU停止正在运行的程序，转去执行中断服务程序，完成数据传送工作后，返回继续执行原来的程序</li>
</ul>
<p>直接存储器存取（DMA）</p>
<ul>
<li>策略：在外围设备和主存之间开辟直接的数据传送通路；无需CPU频繁干预，但多个DMA的同时使用会引起访问主存的冲突增加</li>
<li>正常工作时，所有工作周期用于执行CPU程序；当外围设备完成输入输出数据准备后，占用一个总线周期来和主存直接交换数据；然后CPU继续控制主线；如此重复直到所有数据传送完成</li>
<li>数据交换这个工作由DMA控制器完成，它给出每次传送数据的主存地址，并统计确定传送是否结束</li>
</ul>
<p>IO通道控制方式：</p>
<ul>
<li>IO通道是一个专用的设备；通道能独立执行用通道命令编写的IO控制程序，产生相应的控制信号，完成复杂的输入输出过程</li>
</ul>
<p>外围处理机方式</p>
<ul>
<li>外围处理机结构更接近于计算机；它除了能完成IO通道所要完成的控制功能，还能完成码制变换、格式处理、纠错等功能</li>
<li>它可以简化设备控制器，基本上能够独立于主机工作</li>
</ul>
</blockquote>
<h2 id="10-2-程序中断输入输出方式"><a href="#10-2-程序中断输入输出方式" class="headerlink" title="10.2 程序中断输入输出方式"></a>10.2 程序中断输入输出方式</h2><h3 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h3><p>中断是由IO设备或其他非预期的急需处理的事件引起的，它需要CPU中断现在正在执行的程序，转而去处理中断程序；处理完之后再返回执行原程序</p>
<p>作用：</p>
<blockquote>
<ul>
<li>宏观上使得CPU和IO设备并行工作：处理中断的时间是很短的</li>
<li>处理硬件故障</li>
<li>实现人机联系：利用中断系统实现用户干预机器</li>
<li>实现实时处理：通过要求计算机执行中断服务程序来实现实时处理</li>
<li>多处理机系统之间的联系</li>
</ul>
</blockquote>
<p>一些概念：</p>
<blockquote>
<ul>
<li>中断源：引起中断的事件，即发出中断请求的来源<ul>
<li>外中断：IO设备、定时钟等来自处理机外部设备的中断</li>
<li>内中断：处理器硬件故障或程序引起的中断；外中断和内中断是随机发生的</li>
<li>软中断：由“Trap”指令产生的中断，它在程序中是预先安排好的</li>
<li>中断触发器：在设备控制器中断用于保存中断事件的触发器，当其为1时向CPU发出中断请求信号；多个中断触发器构成中断寄存器，用于存储中断码；CPU处理中断时，根据中断码确定中断源，转入执行相应的服务程序</li>
</ul>
</li>
<li>中断的分级与优先权：按中断级确定中断的优先次序，然后同一级内再确定各个中断源的优先权</li>
<li>禁止中断：请求中断后，CPU由于某种原因不能中止执行现在的程序；当禁止中断触发器为1时，不响应所有中断申请</li>
<li>中断屏蔽：用程序方式封锁部分中断请求，其余部分中断仍会得到相应；有些中断是不可屏蔽的（如掉电中断），非屏蔽中断具有最高优先权</li>
</ul>
</blockquote>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><h4 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h4><blockquote>
<ul>
<li>关中断：进入不可再次响应中断的状态，由硬件自动实现</li>
<li>保存断点和现场：用于恢复现场继续执行程序</li>
<li>判别中断源，转入中断服务程序：判别中断源，相应优先级最高的中断</li>
<li>开中断：此时允许更高级别的中断请求得到相应，实现中断嵌套</li>
<li>执行中断服务程序，实现有效的中断处理</li>
<li>退出中断：顺序执行关中断、恢复断点和现场、开中断、返回断点的操作，继续执行原程序</li>
</ul>
<p>关中断、保存断点等操作一般由硬件实现，这种指令不会出现在程序中，称为“中断隐指令”</p>
</blockquote>
<h4 id="判断中断源"><a href="#判断中断源" class="headerlink" title="判断中断源"></a>判断中断源</h4><p>有软件和硬件两种方式来确定中断源</p>
<blockquote>
<ul>
<li>查询法：测试程序按一定优先级排队检查各个设备的中断触发器，当遇到第一个1时取出其对应设备码，进入进入中断服务程序</li>
<li>串行排队链法：由硬件确定中断源</li>
</ul>
</blockquote>
<p>转向中断程序入口方法</p>
<blockquote>
<ul>
<li>在中断程序中设置一条专门接收终端设备码的指令，取到设备号后，通过主存的跳转表产生程序入口地址</li>
<li>向量中断：为每个中断源设置一个中断向量，该向量包括程序入口地址，该向量可由被选中的设备直接产生或由主存中的中断跳转表产生</li>
</ul>
</blockquote>
<p>多中断处理：</p>
<blockquote>
<ul>
<li>多中断：在处理某中断的过程中又发生了新的中断请求，又称中断嵌套</li>
<li>CPU能够相应更高级别的中断</li>
</ul>
</blockquote>
<h2 id="10-3-DMA输入输出方式"><a href="#10-3-DMA输入输出方式" class="headerlink" title="10.3 DMA输入输出方式"></a>10.3 DMA输入输出方式</h2><blockquote>
<ul>
<li>DMA是I/O设备与主存储器之间由硬件组成的直接数据通路，用于高速I/O设备与主存之间的成组数据传送。</li>
<li>数据传送是在DMA控制器控制下进行的，由DMA控制器给出当前正在传送的数据字的主存地址，并统计传送数据的个数以确定一组数据的传送是否已结束。</li>
<li>需要在主存中要开辟连续地址的专用缓冲器，用来提供或接收传送的数据。</li>
<li>在数据传送前和结束后要通过程序或中断方式对缓冲器和DMA控制器进行预处理和后处理。</li>
</ul>
</blockquote>
<h3 id="DMA工作方式"><a href="#DMA工作方式" class="headerlink" title="DMA工作方式"></a>DMA工作方式</h3><ul>
<li>CPU暂停方式：主机相应DMA请求后，让出存储总线，使DMA控制并使用内存，待一组数据传输完成后，DMA交还总线控制权</li>
<li>CPU周期窃取方式：DMA控制器与主存储器之间一次传送一个数据，窃取一个CPU周期，然后CPU继续执行程序</li>
<li>直接访问存储器：这是标准的DMA工作方式；如果传送数据时CPU不占用存储总线，则DMA对CPU不产生任何影响，若DMA和CPU需要同时访问存储总线，则DMA优先级高于CPU；在DMA传输数据时，不能占用或破坏CPU硬件资源或工作状态</li>
</ul>
<h3 id="DMA控制器组成"><a href="#DMA控制器组成" class="headerlink" title="DMA控制器组成"></a>DMA控制器组成</h3><p><img src="/2020/02/24/computer-composition0/DMA0.jpg" alt="DMA"></p>
<ul>
<li>设备寄存器：<blockquote>
<ul>
<li>主存地址寄存器MAR：主存缓冲区首地址，传送数据前由程序送入</li>
<li>外围设备地址寄存器ADR：存放IO设备的设备码，或表示该设备存储器的寻址信息</li>
<li>字数计数器WC：统计传送数据的总字数</li>
<li>控制与状态寄存器CSR：存放控制字和状态字</li>
<li>数据缓冲寄存器DBR：暂存IO设备与主存之间传送的数据</li>
</ul>
</blockquote>
</li>
<li>中断控制逻辑：负责申请CPU对DMA进行预处理和后处理</li>
<li>DMA控制逻辑：负责在DMA取得总线控制权之后控制主存和设备之间的数据传输<blockquote>
<ul>
<li>设备码选择电路</li>
<li>DMA优先排队电路</li>
<li>DMA请求线路</li>
</ul>
</blockquote>
</li>
<li>DMA接口连接线：包括DMA接口与主机和IO设备两个方向的数据线、地址线和控制信号线以及有关的收发和驱动线路</li>
</ul>
<h3 id="DMA数据传送过程"><a href="#DMA数据传送过程" class="headerlink" title="DMA数据传送过程"></a>DMA数据传送过程</h3><p><img src="/2020/02/24/computer-composition0/DMA1.jpg" alt="DMA"></p>
<blockquote>
<ul>
<li>DMA传送前预处理</li>
<li>数据传送</li>
<li>传送后处理<br>其中，预处理和后处理由CPU执行程序完成</li>
</ul>
</blockquote>
<h2 id="10-4-IO通道控制方式"><a href="#10-4-IO通道控制方式" class="headerlink" title="10.4 IO通道控制方式"></a>10.4 IO通道控制方式</h2><p>IO通道是计算机系统中代替CPU管理控制外部设备的独立部件，是一种能执行有限条IO指令集合的IO处理机</p>
<p>在通道控制方式下，一个主机可以连接多个通道，每个通道下面又可以连接多个不同的IO设备；这增强了主机与通道操作的并行能力以及增减外围设备的灵活性</p>
<p>IO通道控制方式:</p>
<blockquote>
<ul>
<li>四级连接方式: 主机-通道-设备控制器-IO设备</li>
</ul>
<ol>
<li>CPU启动通道,通道自动地去内存中取出通道指令并执行,实施对IO系统的统一管理和控制</li>
<li>数据交换过程结束,通道像CPU发出中断请求,进行通道结束处理工作<br>通道除了承担DMA的全部功能外,还承担了设备控制器的初始化工作,分担了计算机系统中全部或大部分IO功能,提高了计算机系统功能的分散化程度</li>
</ol>
</blockquote>
<p>分类:<br><img src="/2020/02/24/computer-composition0/IO0.jpg" alt="io">  </p>
<blockquote>
<ul>
<li>字节多路通道</li>
<li>选择通道</li>
<li>数组多路通道</li>
</ul>
</blockquote>
<p>字节多路通道:</p>
<blockquote>
<ul>
<li>以字节为单位轮流为多个中低速设备进行数据传输</li>
<li>多个设备可以同时处于工作状态,能交叉进行数据传输</li>
<li>数据传输率是各个外设传输率之和</li>
</ul>
</blockquote>
<p>数组多路通道:</p>
<blockquote>
<ul>
<li>将数据分成多个固定大小的数据块,以块为单位选择传输的外设</li>
<li>多个设备可以同时处于工作状态,当一个设备传输一个数据块之后就换一台外部设备</li>
<li>最大传输率为外设中传输率最大的一个</li>
</ul>
</blockquote>
<p>选择通道:</p>
<blockquote>
<ul>
<li>适合对高速设备进行数据传输,对多个不同外设进行控制,但一次只能有一台外设处于工作状态</li>
<li>在连接多个块设备时，采用轮流选择设备的方法，一次选择一个外部设备，在完成所要求的数据传输之后，再选择另一个外部设备进行数据传输</li>
<li>最大传输率应为所接外部设备传输率中最大的一个</li>
</ul>
</blockquote>
<h2 id="10-5-总线结构"><a href="#10-5-总线结构" class="headerlink" title="10.5 总线结构"></a>10.5 总线结构</h2><p>计算机系统多采用模块结构,一个模块就是一个部件,如主机板等</p>
<p>各模块之间传送信息的通路称为总线</p>
<p>为便于不同厂家生产的模块能灵活构成系统，形成了总线标准</p>
<h3 id="总线类型"><a href="#总线类型" class="headerlink" title="总线类型"></a>总线类型</h3><ul>
<li>内总线: 连接计算机内部各模块的总线; 如连接CPU,存储器,IO接口的总线</li>
<li>外总线: 系统之间或系统与外部设备之间的总线</li>
<li>单总线: 所有模块都连接到单一总线上; 如地址线,数据线,控制线和电源(地)线</li>
<li>多总线: 将速度较低的IO设备从总线上分出去,形成系统总线与IO总线的双总线结构,还有三总线结构等</li>
</ul>
<h3 id="总线组成"><a href="#总线组成" class="headerlink" title="总线组成"></a>总线组成</h3><p>总线是从两个或以上的源部件传送信息到一个或过高部件的一组数据传输线; 是一个源部件到多个目标部件的数据传输线不称为总线</p>
<h4 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h4><p>多个模块连接到一条共用总线上,需经过选择判优来避免多个部件同时发送信息的矛盾</p>
<blockquote>
<ul>
<li>同一个时间只能有一个申请者使用总线,总线判优机构按照申请者的优先权选择可以控制总线的设备或部件</li>
<li>主控器或主设备: 可以控制总线并启动数据传送的设备,如CPU和IO设备等</li>
<li>受控器或从设备: 能够响应总线主控器发出的总线命令的设备,如存储器和IO设备等</li>
</ul>
</blockquote>
<p>分类:</p>
<blockquote>
<ul>
<li>集中式控制: 总线控制逻辑基本上集中于一个设备(如CPU)</li>
<li>分布式总线控制: 总线控制逻辑分散在连接总线的各个部件或设备中</li>
</ul>
</blockquote>
<p>优先仲裁方式: 串行链接方式; 其优先次序是由“总线可用”线所接部件的位置决定的，离总线控制器越近的部件其优先权越高<br><img src="/2020/02/24/computer-composition0/BUS1.jpg" alt="bus"></p>
<h4 id="总线通信"><a href="#总线通信" class="headerlink" title="总线通信"></a>总线通信</h4><ul>
<li><p>同步通信</p>
<blockquote>
<ul>
<li>通信双方由统一的时钟 控制数据的传送</li>
<li>时钟通常由CPU发出,送到总线上的所有部件</li>
<li>经过一段固定时间，本次总线传送周期结束，开始下一个新的总线传送周期</li>
</ul>
</blockquote>
</li>
<li><p>异步通信</p>
<blockquote>
<ul>
<li>利用数据发送部件和接收部件之间的相互“握手”信号来实现总线数据传送</li>
</ul>
</blockquote>
</li>
<li><p>并行通信</p>
<blockquote>
<ul>
<li>数据的多个位同时进行传送,相同频率下位数多则传输率高</li>
<li>距离较短,限制在一个机柜内使用</li>
</ul>
</blockquote>
</li>
<li><p>串行通信</p>
<blockquote>
<ul>
<li>数据一位一位地顺序传送</li>
<li>通信线路简单,只需一对传输线即可双向通信,适合远距离通信</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h4><p>数据传送过程可能产生错误，有些接收部件有自动纠错能力，可以自动纠正错误；而有些部件无自动纠错能力但能发现错误，可发出“数据出错”信号，通常向 CPU 发出中断请求信号，CPU 响应中断后，转入出错处理程序。</p>
<h4 id="总线驱动"><a href="#总线驱动" class="headerlink" title="总线驱动"></a>总线驱动</h4><p>总线上可连接多个部件，具有扩充灵活的优点，但总线的驱动能力总是有限制的，因此在扩充时要加以注意。通常一个模块或一个部件限制在1～2个负载以内。</p>
<h3 id="微机总线"><a href="#微机总线" class="headerlink" title="微机总线"></a>微机总线</h3><h4 id="ISA总线和EISA总线"><a href="#ISA总线和EISA总线" class="headerlink" title="ISA总线和EISA总线"></a>ISA总线和EISA总线</h4><p>ISA总线:</p>
<blockquote>
<ul>
<li>最初8根,80年代中期扩展成16根,时钟为8MHz</li>
<li>CPU速度提高后,CPU与存储器之间交换数据不再通过ISA总线</li>
<li>ISA总线用于连接外设,最大传输速率16.6MB/s</li>
</ul>
</blockquote>
<p>EISA总线:</p>
<blockquote>
<ul>
<li>32位,时钟为8MHz</li>
<li>传输速率可达33MB/s</li>
</ul>
</blockquote>
<h4 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h4><blockquote>
<ul>
<li>PC: 32位,时钟频率33MHz,传输率132MB/s</li>
<li>服务器和中高端工作站：64位、33MHz(266MB/s)、66MHz(533MB/s)</li>
<li>有即插即用功能</li>
</ul>
</blockquote>
<p><img src="/2020/02/24/computer-composition0/PCI0.jpg" alt="pci"></p>
<blockquote>
<ul>
<li>系统总线：连接一个或多个微处理器、cache和主存储器</li>
<li>PCI设备：PCI总线连接的高速I/O设备</li>
<li>主机桥：PCI总线控制器，含有集中式总线仲裁器</li>
<li>PCI-PCI桥：PCI总线扩展，形成多层次PCI结构，减轻单个PCI总线的负载</li>
<li>PCI-ISA桥：连接PCI总线和ISA总线，接入ISA设备</li>
</ul>
</blockquote>
<h4 id="PCI-X"><a href="#PCI-X" class="headerlink" title="PCI-X"></a>PCI-X</h4><blockquote>
<ul>
<li>处理器和外部设备之间数据的传输速度与千兆以太网和光纤通道的要求相比差距很大</li>
<li>PCI-X 2.0：频率提升到266MHz(传输率2.1GB/s)和533MHz(传输率4.3GB/s)</li>
<li>PCI-X DDR（双倍数据速率）可在一个时钟周期中传输两次数据</li>
</ul>
</blockquote>
<h4 id="PCI-Express"><a href="#PCI-Express" class="headerlink" title="PCI Express"></a>PCI Express</h4><blockquote>
<ul>
<li>采用点到点的串行连接技术: 每个设备有自己专用的连接，独享带宽，不必向共享总线请求带宽</li>
<li>一个PCI Express连接可以包含多个信道(lane)</li>
<li>采用串行传输技术，传输率比PCI高</li>
<li>单个信道的PCI Express X1提供单向250MB/s带宽; 16个信道的PCI Express X16带宽4GB/s</li>
</ul>
</blockquote>
<p><img src="/2020/02/24/computer-composition0/pcie0.jpg" alt="pcie"></p>
<h2 id="10-6-外设接口"><a href="#10-6-外设接口" class="headerlink" title="10.6 外设接口"></a>10.6 外设接口</h2><p>ATA(IDE):</p>
<blockquote>
<ul>
<li>并行ATA</li>
<li>串行ATA(SATA)</li>
</ul>
</blockquote>
<p>还有SCSI,SAS,光纤,USB串口等</p>
<h2 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h2><ul>
<li>DAS: 直接连接存储器</li>
<li>SAN: 存储区域网络,建立在光纤通道技术上</li>
<li>NAS: 网络附加存储,以文件为传输单位的存储网络,按照TCP/IP协议进行数据传输</li>
</ul>
<hr>
<p>博文创建时间: 2020-02-24 10:32:00</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/02/24/computer-composition0/" data-id="ckh1rlcb00055kovnd14ncg9n"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="tag">计算机组成</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/02/24/Lucence0/" class="article-nav-link">
        <strong class="article-nav-caption">Prev Post</strong>
        <div class="article-nav-title">
          
            Lucence相关
          
        </div>
      </a>
    
    
      <a href="/2020/02/24/java0/" class="article-nav-link">
        <strong class="article-nav-caption">Next Post</strong>
        <div class="article-nav-title">Java学习笔记</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: 'ze0YzGUMUrLXgdRQpKyDCEEm-gzGzoHsz',
        app_key: 'NnhAiNVNGXwbCD1sMGNRjA8B',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: 'Leave your comments here ~',
        recordIP: true,
        lang: 'en'
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        George Chen
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="George"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HOME</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives/">ARCHIVE</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">CATE.</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">TAGS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://github.com/georgechen1827/" target="_blank" rel="noopener">about me</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/coming_soon.html" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>







<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>