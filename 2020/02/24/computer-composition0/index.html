<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="this is George Chen&#39;s blog!" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    计算机组成相关知识 |  George
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-computer-composition0" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  计算机组成相关知识
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/02/24/computer-composition0/" class="article-date">
  <time datetime="2020-02-24T02:32:00.000Z" itemprop="datePublished">2020-02-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> about </span>
            <span class="post-count">13.4k words</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> costs </span>
            <span class="post-count">47 minutes</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>未完结,持续更新</p>
<hr>
<p>网课资源: (智慧树)长春师范大学计算机组成</p>
<p>参考教材: 清华大学出版社《计算机组成与结构(第5版)》</p>
<p>课程内容:</p>
<ul>
<li>讨论单机系统范围内计算机各部件和系统的组成原理以及内部工作机制</li>
</ul>
<p>课程目标:</p>
<ul>
<li>计算机个大部件的组成原理</li>
<li>计算机各大部件的逻辑实现</li>
<li>计算机各大部件的设计方法</li>
<li>计算机各大部件互联构成整体系统的技术</li>
<li>(为后继课程的学习打好基础)</li>
</ul>
<p>课程地位: 承上启下</p>
<ul>
<li>先导课程: 计算机导论,数字逻辑</li>
<li>后继课程: 微机原理,接口技术,计算机系统结构</li>
</ul>
<p>重点难点:</p>
<ul>
<li>掌握五大基本部件的原理及实现</li>
<li>掌握各部件互联构成整机系统的知识(整机概念的建立)</li>
</ul>
<p>课程要求:</p>
<ul>
<li>重点掌握: 多层次的存储器,中央处理器</li>
<li>掌握: 运算方法和运算器,指令系统,总线系统</li>
<li>理解: 外存与io设备</li>
<li>了解: 计算机系统概论,输入输出系统</li>
</ul>
<a id="more"></a>

<h1 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h1><p>计算机的定义,分类.发展史</p>
<h2 id="1-1-计算机发展简史"><a href="#1-1-计算机发展简史" class="headerlink" title="1.1 计算机发展简史"></a>1.1 计算机发展简史</h2><p>计算机: 能够连续自动进行数值和逻辑运算的机器</p>
<p>分类:</p>
<ul>
<li>原理角度: 数字计算机,模拟计算机</li>
<li>性能指标: 巨型机,大型机,小型机,微型机</li>
<li>用途角度: 专用机,通用机</li>
</ul>
<p>计算机发展阶段:</p>
<ul>
<li>1946-1957: 电子管时代,ENIAC(1946)</li>
<li>1958-1964: 晶体管时代,整体性能大幅度提高,TRADIC(增加浮点运算)</li>
<li>1965-1971: 中小规模集成电路,进入文字处理和图形图像处理</li>
<li>1972-: 大和超大规模集成电路,出现微处理器</li>
</ul>
<h2 id="1-2-计算机硬件"><a href="#1-2-计算机硬件" class="headerlink" title="1.2 计算机硬件"></a>1.2 计算机硬件</h2><p>硬件系统的组成: 冯诺依曼结构,以存储器为中心</p>
<p>特点:</p>
<ul>
<li>计算机(硬件)应由运算器,存储器,控制器,输入设备,输出设备组成</li>
<li>计算机内部采用二进制来表示指令和数据</li>
<li>将编好的程序和原始数据实现存入存储器中然后再启动计算机工作</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/compo0.jpg" alt="composition">  </p>
<ul>
<li>运算器: 数据的加工处理  </li>
<li>控制器: 指令控制,操作控制,时序控制  </li>
<li>存储器: 存放数据和程序  </li>
<li>输入设备: 将外部数据送给计算机并转换成计算机能够识别的形式  </li>
<li>输出设备: 将计算机处理结果送出给外界并转换成外界能够识别的形式<blockquote>
<ul>
<li>运算器,控制器一般为cpu  </li>
<li>存储器一般由主存(内存)和辅存组成  </li>
<li>cpu和主存一般构成主机</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>以运算器为核心构造时,输入设备的数据得通过运算器才能进入存储器中;因此以存储器为核心的构造可以提高计算机系统运行的效率</p>
</blockquote>
<p>个计算结构时以总线连接起来的: 总线上有地址,数据,控制三种信号线,结构如下:<br><img src="/2020/02/24/computer-composition0/bus0.jpg" alt="bus"></p>
<h2 id="1-3-计算机软件"><a href="#1-3-计算机软件" class="headerlink" title="1.3 计算机软件"></a>1.3 计算机软件</h2><p>软件和硬件之间存在着逻辑等价关系</p>
<p>语言: 计算机语言经历了由机器语言-&gt;汇编语言-&gt;高级语言的发展过程</p>
<p>计算机系统的多级层次结构(由低到高):</p>
<ul>
<li>硬件(机器语言级)-&gt;操作系统级-&gt;中间件/平台级-&gt;应用程序级(高级语言)</li>
</ul>
<h1 id="二、计算机中常用的组合逻辑电路"><a href="#二、计算机中常用的组合逻辑电路" class="headerlink" title="二、计算机中常用的组合逻辑电路"></a>二、计算机中常用的组合逻辑电路</h1><h2 id="2-1-计算机种常用的组合逻辑电路"><a href="#2-1-计算机种常用的组合逻辑电路" class="headerlink" title="2.1 计算机种常用的组合逻辑电路"></a>2.1 计算机种常用的组合逻辑电路</h2><h3 id="三态门"><a href="#三态门" class="headerlink" title="三态门"></a>三态门</h3><p>三态: 0,1,高阻态Z<br><img src="/2020/02/24/computer-composition0/compo1.jpg" alt="composition"></p>
<p>三态门通常用于驱动总线,当控制端G=1时,数据线A和总线接通,G=0时,该数据线和总线断开</p>
<blockquote>
<p>当总线传输数据时,应当只有一个三态门是正常工作的</p>
</blockquote>
<h3 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h3><p>异或门是计算单元中常用的逻辑电路<br><img src="/2020/02/24/computer-composition0/compo2.jpg" alt="composition"></p>
<p>常见异或门应用:</p>
<ul>
<li>数码比较器 </li>
<li>原码/反码输出电路  </li>
<li>奇偶检测电路</li>
</ul>
<h3 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h3><p>加法器是计算机的基本运算部件之一</p>
<p>半加器不考虑前一位的进位输入:<br><img src="/2020/02/24/computer-composition0/compo3.jpg" alt="composition"></p>
<p>全加器考虑前一位的进位输入:<br><img src="/2020/02/24/computer-composition0/compo4.jpg" alt="composition"></p>
<h4 id="串行进位加法器"><a href="#串行进位加法器" class="headerlink" title="串行进位加法器"></a>串行进位加法器</h4><p>将多个全加器串联,可以得到多位的加法器,但后一位的计算需要等前一位计算完成后才能开始,导致加法效率较低  </p>
<h4 id="超前进位加法器"><a href="#超前进位加法器" class="headerlink" title="超前进位加法器"></a>超前进位加法器</h4><p>超前进位产生电路通过迭代各位进位的产生式,得到直接产生各位进位的表达式来实现的;后一位的进位无需等待前一位的进位就可以产生,高效但需要使用更多的组合逻辑单元</p>
<p>原理如下:</p>
<ol>
<li>考虑第每一位进位ci的产生条件:<br>$X_i,Y_i$均为1,或$X_i,Y_i$有一个为1且$C_{i-1}$为1,即<br>$C_i=X_iY_i+(X_i+Y_i)C_{i-1}$</li>
<li>由$C_1=X_1Y_1+(X_1+Y_1)C_0$不停对$C_i$进行迭代化简,得到:<br>$$C_i=X_iY_i+\sum_{n=i-1}^1(X_nY_n\prod_{k=i}^{n}(X_k+Y_k))+C_0\prod_{k=i}^{1}(X_k+Y_k)$$<br>如:$C_4=X_4Y_4+(X_4+Y_4)X_3Y_3+(X_4+Y_4)(X_3+Y_3)X_2Y_2+…+..C_0$</li>
<li>定义进位传递函数$P_i=X_i+Y_i$,表明$X_i,Y_i$有一个为1时,将前一位进位传给下一位,达到一种进位传递的效果<br>定义进位产生函数$G_i=X_iY_i$,表明$X_i,Y_i$都为1时,无论$P_i$如何必定向高位产生进位<br>如,此时$C_3=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0$</li>
<li>将各进位改成与非式,画出电路图,如下<br><img src="/2020/02/24/computer-composition0/compo5.jpg" alt="composition"></li>
</ol>
<h4 id="ALU算数逻辑单元"><a href="#ALU算数逻辑单元" class="headerlink" title="ALU算数逻辑单元"></a>ALU算数逻辑单元</h4><p>考虑到超前进位电路的复杂程度是随着位数呈指数增加,一般可以将4位超前进位电路封装成算数逻辑单元,然后再通过组间的串行或超前进位组成16位的ALU</p>
<p>16位快速ALU:组间快速进位<br><img src="/2020/02/24/computer-composition0/compo6.jpg" alt="composition"></p>
<ul>
<li>$G_n=(片内)G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0$</li>
<li>$P_n=(片内)P_3P_2P_1P_0$</li>
<li>$C_11=G_{N_2}+P_{N_2}G_{N_1}+P_{N_2}P_{N_1}G_{N_0}+P_{N_2}P_{N_1}P_{N_0}C_n$,依次类推</li>
</ul>
<p>相比于组间串行进位,最高位进位需要等待前三次进位;16位快速ALU只需要等待一次片内的进位即可;ALU在保证一定运行速度间的同时使得电路规模没有过大</p>
<h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>由n个输入,最多$2^n$个输出组合而成的逻辑电路,包含:</p>
<ul>
<li>$\overline E$:使能端,一般低有效</li>
<li>$A,B,C(A_1,A_2,A_3)…$:输入端,高有效</li>
<li>$Y_1,Y_2,…,Y_8,…$:输出端,一般低有效</li>
</ul>
<p>通常将使能端连接另一个译码器的输出(CS:芯片选择功能),可以将译码器的译码范围进行扩展</p>
<h3 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h3><p>由$2^n$个输入,n个输出组合而成的逻辑电路,包含:</p>
<ul>
<li>$\overline G_1,\overline G_2$(双数据选择器):使能信号,由一个三态门控制,一般低有效</li>
<li>$S_0,S_1$:通道选择端,高有效</li>
<li>$D_0,D_1,D_2,D_3,…,D_7$(双4选1):通道输入端</li>
<li>$Y_1,Y_2$:输出端,输出所选择通道的电位</li>
</ul>
<p>在保证$\overline G_1,\overline G_2$反相的情况下,可以连接$Y_1,Y_2$来扩展选择通道数</p>
<h2 id="2-2-时序逻辑电路"><a href="#2-2-时序逻辑电路" class="headerlink" title="2.2 时序逻辑电路"></a>2.2 时序逻辑电路</h2><p>如果逻辑电路的输出状态不但和当时的输入状态有关，而且还与电路在此以前的输入状态有关，称这种电路为时序逻辑电路。</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="电位触发器"><a href="#电位触发器" class="headerlink" title="电位触发器"></a>电位触发器</h4><p><img src="/2020/02/24/computer-composition0/compo7.jpg" alt="composition"></p>
<p>普通触发器存在触发不能被同步的问题</p>
<h4 id="边沿D触发器"><a href="#边沿D触发器" class="headerlink" title="边沿D触发器"></a>边沿D触发器</h4><p>每当经过一个时钟周期时(CP上升沿或下降沿):<br>$Q^n=D$</p>
<p>边沿触发器存在空翻问题</p>
<h4 id="主从JK触发器"><a href="#主从JK触发器" class="headerlink" title="主从JK触发器"></a>主从JK触发器</h4><p>$Q^n=J \overline Q + \overline K Q$</p>
<h3 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h3><p><img src="/2020/02/24/computer-composition0/compo8.jpg" alt="composition"></p>
<p>每当经过一个时钟周期时,移位寄存器向最低位读取数据,将最高位数据输出,并进行移位</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>每当经过一个时钟周期,将计数加1,计数满则清零并输出进位信息</p>
<ul>
<li>$\overline R_D$:异步清零信号,一般低有效</li>
<li>$L$:同步置数信号,高有效</li>
<li>$Q_1,Q_2,…$:同步置数端</li>
<li>$P,T$:计数使能信号,均高有效,否则为保持状态</li>
<li>$CK$:时钟信号</li>
<li>$RC$:进位信号</li>
</ul>
<h2 id="2-3-阵列逻辑电路"><a href="#2-3-阵列逻辑电路" class="headerlink" title="2.3 阵列逻辑电路"></a>2.3 阵列逻辑电路</h2><p>阵列逻辑电路表明逻辑元件以阵列的形式在硅芯片上排列</p>
<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p>存储器:</p>
<ul>
<li>字:放置信息的单元,由多个位组成</li>
<li>位:一个二进制信息</li>
<li>地址(码):存储器中每个字的编号,用于寻找存入存储器的字</li>
</ul>
<p>ROM主要由地址译码器和存储单元体构成,通过在每个位置设置或不设置三极管、二极管、熔丝等元件来表示存入的二进制信息<br><img src="/2020/02/24/computer-composition0/rom0.jpg" alt="rom"><br><img src="/2020/02/24/computer-composition0/rom1.jpg" alt="rom"><br>由上图可以看出,ROM存储的是一种主析取范式的表达式</p>
<p>ROM主要有如下两个缺陷:</p>
<ul>
<li>ROM实际存储的字数常少于它所能提供的字数,造成存储单元的闲置和芯片面积的浪费</li>
<li>ROM中的地址和字之间有一一对应的关系,在存储大量重复内容时不能灵活节省空间</li>
</ul>
<h3 id="可编程序逻辑阵列PLA"><a href="#可编程序逻辑阵列PLA" class="headerlink" title="可编程序逻辑阵列PLA"></a>可编程序逻辑阵列PLA</h3><ul>
<li>相比于ROM,PLA能用较少的存储单元存储大量的信息</li>
<li>ROM存储的是一种主析取范式的表达式,而PLA可以存储最简的与或式,因此可以节省一些存储资源的消耗<br><img src="/2020/02/24/computer-composition0/rom2.jpg" alt="rom"> </li>
</ul>
<h3 id="可编程序阵列逻辑PAL"><a href="#可编程序阵列逻辑PAL" class="headerlink" title="可编程序阵列逻辑PAL"></a>可编程序阵列逻辑PAL</h3><ul>
<li>PAL中的与阵列是可编程的,但或阵列不可编程;而在PAL中,两者都可以编程,还有一些PAL中带有记忆元件或反馈电路</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/pal0.jpg" alt="pal"></p>
<h3 id="通用阵列逻辑GAL"><a href="#通用阵列逻辑GAL" class="headerlink" title="通用阵列逻辑GAL"></a>通用阵列逻辑GAL</h3><ul>
<li>ROM,PLA,PAL是一次性编程的,编程后不能修改</li>
<li>GAL是一种可用电擦除的,可重复编程的高速PLD(可编程逻辑电路)</li>
<li>可重复擦写100次以上,数据可保存20年以上,数秒内即可完成擦除和编程的过程</li>
</ul>
<h3 id="门阵列GA-宏单元阵列MCA，标准单元阵列SCA"><a href="#门阵列GA-宏单元阵列MCA，标准单元阵列SCA" class="headerlink" title="门阵列GA,宏单元阵列MCA，标准单元阵列SCA"></a>门阵列GA,宏单元阵列MCA，标准单元阵列SCA</h3><ul>
<li>这些芯片是用来实现批量较大的专用集成电路的</li>
<li>这三种芯片内部的单元都是以阵列形式排列的</li>
</ul>
<h4 id="门阵列"><a href="#门阵列" class="headerlink" title="门阵列"></a>门阵列</h4><p>门阵列设计利用预先制造好的“母片”来进行布图设计;母片上通常以一定的间距成行成列的排列着基本单元电路。</p>
<ul>
<li>这样可以降低设计成本,缩短设计周期:因为母片已完成了整个集成电路制造工艺的大部分流程,剩下只要进行布线连接,就可以实现各种逻辑需求</li>
<li>门阵列器件是一种半用户器件或半定制器件</li>
</ul>
<h4 id="宏单元阵列"><a href="#宏单元阵列" class="headerlink" title="宏单元阵列"></a>宏单元阵列</h4><p>宏单元阵列是一种对门阵列的改进,逻辑功能更强,布图密度更高,制造周期更短</p>
<h4 id="标准单元阵列"><a href="#标准单元阵列" class="headerlink" title="标准单元阵列"></a>标准单元阵列</h4><p>标准单元以预先设计好的功能单元(如门,触发器,加法器等)为基础进行设计生产</p>
<ul>
<li>不同于门阵列那样事先生产半成品芯片;在标准单元阵列中,所有单元都是根据用户逻辑图的需要安排在芯片上。</li>
<li>标准单元阵列是定制器件而非半定制器件,但布局布线更易于实现</li>
</ul>
<h3 id="现场可编程序门阵列FPGA"><a href="#现场可编程序门阵列FPGA" class="headerlink" title="现场可编程序门阵列FPGA"></a>现场可编程序门阵列FPGA</h3><ul>
<li>FPGA由大规模集成电路构成，门电路数达到几万个到几百万个</li>
<li>它主要由四个部分组成：<blockquote>
<ul>
<li>可编程序逻辑宏单元(CLB)</li>
<li>可编程序输入输出宏单元(IOB)</li>
<li>互连资源</li>
<li>重构逻辑的程序存储器: 可以允许多次逻辑的修改,适合在在产品试验或生产批蜇不大时使用</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="三、运算方法和运算部件"><a href="#三、运算方法和运算部件" class="headerlink" title="三、运算方法和运算部件"></a>三、运算方法和运算部件</h1><h2 id="3-1-数值型数据的表示方法和转换"><a href="#3-1-数值型数据的表示方法和转换" class="headerlink" title="3.1 数值型数据的表示方法和转换"></a>3.1 数值型数据的表示方法和转换</h2><ul>
<li>数制: $ (D_m…D_0.D_{-1} .. D_{-k})i $ 是一个i进制数,可以表示成 $ \sum_{n=-k}^mD_n*i^n $,其中i称为基数或底</li>
</ul>
<h3 id="不同数制之间的数据转换"><a href="#不同数制之间的数据转换" class="headerlink" title="不同数制之间的数据转换"></a>不同数制之间的数据转换</h3><h4 id="二进制-八进制-和十六进制转换"><a href="#二进制-八进制-和十六进制转换" class="headerlink" title="二进制,八进制,和十六进制转换"></a>二进制,八进制,和十六进制转换</h4><ul>
<li>二进制转八进制: 从小数点向两边三位成一组转换</li>
<li>二进制转十六进制: 从小数点向两边四位成一组转换</li>
</ul>
<h4 id="二进制-十进制的转换"><a href="#二进制-十进制的转换" class="headerlink" title="二进制,十进制的转换"></a>二进制,十进制的转换</h4><ul>
<li>二进制转十进制用公式$ \sum_{n=-k}^mD_n*2^n $</li>
<li>十进制转二进制用除2取余法(整数部分)和乘2取整法(小数部分)</li>
</ul>
<h3 id="十进制数的编码与运算"><a href="#十进制数的编码与运算" class="headerlink" title="十进制数的编码与运算"></a>十进制数的编码与运算</h3><h4 id="有权码"><a href="#有权码" class="headerlink" title="有权码"></a>有权码</h4><p>如8421,5421,2421BCD编码</p>
<ul>
<li>注意,这种编码是对十进制的每一位进行编码运算,而不是对整个十进制数的运算</li>
</ul>
<h4 id="无权码"><a href="#无权码" class="headerlink" title="无权码"></a>无权码</h4><p>如余3码,格雷码(循环码)</p>
<h2 id="3-2-带符号的二进制数在计算机中的表示方法及加减运算"><a href="#3-2-带符号的二进制数在计算机中的表示方法及加减运算" class="headerlink" title="3.2 带符号的二进制数在计算机中的表示方法及加减运算"></a>3.2 带符号的二进制数在计算机中的表示方法及加减运算</h2><ul>
<li>计算机中表示的带符号的二进制数称为机器数</li>
<li>机器数有原码,补码,反码三种表示方式</li>
<li>这里,假设机器数的真值为[-1,1]的小数,小数部分为数值,整数部分为符号<blockquote>
<p>如:1.0100=10100</p>
</blockquote>
</li>
</ul>
<h3 id="原码-反码-补码及其加减运算"><a href="#原码-反码-补码及其加减运算" class="headerlink" title="原码,反码,补码及其加减运算"></a>原码,反码,补码及其加减运算</h3><h4 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h4><ul>
<li>原码最高位是符号位,0表示正数,1表示负数</li>
<li>其他位是数值位,以绝对值的方式给出</li>
<li>数值0有+0和-0两种原码表示,即0.0000和1.0000</li>
</ul>
<p>原码的加减法需要判断正负号,比较麻烦</p>
<h4 id="反码表示"><a href="#反码表示" class="headerlink" title="反码表示"></a>反码表示</h4><p>正数不变;负数反码在原码的基础上,符号位不变,其他位取反</p>
<ul>
<li>反码的反码是原码</li>
<li>运算时，当最高位有进位而丢掉进位时,要在最低位加1(循环进位)。</li>
</ul>
<h4 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h4><p>正数不变;负数补码在反码的基础上,数值加1</p>
<ul>
<li>数值0的补码形式是唯一的,为0.0000</li>
<li>补码的补码是原码</li>
</ul>
<p>补码在运算中有如下性质:</p>
<ul>
<li>符号位与数值位一样参与运算</li>
<li>补码运算的结果仍为补码</li>
<li>[X]补+[Y]补=[X+Y]补</li>
<li>[X]补-[Y]补=[X]补+[-Y]补</li>
<li>注意,Y与-Y正负号不同,求补码的策略也不同</li>
<li>补码运算时最高位产生的进位直接舍去即可</li>
</ul>
<h3 id="加减运算的溢出处理"><a href="#加减运算的溢出处理" class="headerlink" title="加减运算的溢出处理"></a>加减运算的溢出处理</h3><p>溢出:运算结果超出机器数所能表示的范围</p>
<ul>
<li>异号相加或同号相减结果是不会溢出的,只考虑同号相加或异号相减的情况</li>
<li>注意,最高位是否产生进位和运算结果是否溢出没有关系</li>
</ul>
<p>溢出判断有如下几种方法:</p>
<ul>
<li>同号两数相加,结果符号与两加数不相同,则溢出<blockquote>
<p>$\overline f_A \overline f_B f_S + f_A f_B \overline f_S = 1,其中,f_A f_B f_S$分别为两运算数的符号和结果的符号</p>
</blockquote>
</li>
<li>最高位进位和符号位进位不相同,则溢出<ul>
<li>即,运算正确的情况下,最高位(符号位的前一位)的进位一定要导致符号位进<blockquote>
<p>$C \overline C_f +\overline  C C_f = 1; 其中C,C_f$分别是最高位的进位和符号位的进位</p>
</blockquote>
</li>
</ul>
</li>
<li>采用双符号位运算,正数符号为00,负数为11,此时当结果的两个符号位不同时,溢出<blockquote>
<p>$\overline f_{S2} f_{S1} + f_{S2} \overline f_{S1} = 1,其中f_{S2},f_{S1}$分别是两位符号位</p>
</blockquote>
</li>
</ul>
<h3 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h3><p>在计算机中的数据有定点数和浮点数两种表示方式</p>
<h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>定点数指小数点固定在某个位置上的数据,前面加减法中讨论的为定点数</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数指小数点位置可以浮动的数据,可以用$N = M*R^E$表示</p>
<ul>
<li>N为浮点数,M为尾数,E为阶码,R为阶的基数;一般情况下一个计算机中的R都是相同的,无需存储</li>
</ul>
<p>浮点数在计算机中一般以这样的形式显示:$M_S$–$E$–$M$</p>
<ul>
<li>$M_S$: 尾数的符号位(一般为一位),设置在最高位</li>
<li>$E$: 阶码,有n+1位,一般为整数,第一位为符号位</li>
<li>$M$: 尾数,有m位,和前面的$M_S$一同组成一个定点小数<blockquote>
<ul>
<li>规格化尾数:当R=2(二进制数)且尾数不为0时,其绝对值应大于或等于十进制的0.5(即最高位应当为1);对非规格化浮点数,需要将尾数左移或右移,并改变阶码使其满足规格化要求  <blockquote>
<p>如:0.0011 —&gt; (0.11)*2^(0010)</p>
</blockquote>
</li>
<li>机器零值:表示比机器数能表示的最小数还要小的值</li>
</ul>
</blockquote>
</li>
</ul>
<p>浮点数国际标准: IEEE 754</p>
<ul>
<li>单精度浮点数(32位):阶码8位,尾数24位(含一位符号位)</li>
<li>双精度浮点数(64位):阶码11位,尾数53位(含一位符号位)</li>
<li>浮点数基数为2,阶码采用增码(移码),尾数采用原码</li>
<li>而在多数通用机中，浮点数的尾数用原码或补码表示，阶码用补码或移码表示。</li>
<li>注意,由于规格化后的原码最高位恒为1,存储时自动省略,需要在计算时自己加上去<blockquote>
<ul>
<li>移码:在补码基础上,将符号位取反;在阶码上的移码只执行加减运算,且需要对结果进行修正</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="数值范围和精度"><a href="#数值范围和精度" class="headerlink" title="数值范围和精度"></a>数值范围和精度</h3><p>数值范围指机器所能表示的一个数的最大值和最小值;精度是指一个数的有效位数</p>
<ul>
<li>32位定点小数(补码):$-1$(1000…)~$1-2^{-31}$(0111…)</li>
<li>32位定点整数(补码):$-2^{31}$(1000…)~$2^{31}-1$(0111…)</li>
<li>32位单精度浮点数:$-2^{127}$~$(1-2^{-23})*2^{127}$,精度为24位</li>
</ul>
<h2 id="3-3-二进制乘法运算"><a href="#3-3-二进制乘法运算" class="headerlink" title="3.3 二进制乘法运算"></a>3.3 二进制乘法运算</h2><h3 id="定点数一位乘法"><a href="#定点数一位乘法" class="headerlink" title="定点数一位乘法"></a>定点数一位乘法</h3><h4 id="定点原码一位乘"><a href="#定点原码一位乘" class="headerlink" title="定点原码一位乘"></a>定点原码一位乘</h4><p>人工算法:<br><img src="/2020/02/24/computer-composition0/multi0.jpg" alt="multipy"></p>
<p>机器算法:<br><img src="/2020/02/24/computer-composition0/multi1.jpg" alt="multipy"></p>
<ul>
<li>在机器中,有3个寄存器ABC,分别存放部分积,被乘数和乘数的绝对值,其中部分积和被乘数都以双符号位表示;具体过程如下:</li>
</ul>
<ol>
<li>初始化:A寄存器清零,被乘数X放在B中,n位乘数Y放在C中,Cd初始值设为n(用于判断C是否被乘完)</li>
<li>判断C的最低为是否为1,是则将A+B赋给A</li>
<li>将{A,C}向右移一位(A高位补符号位),此时A的最低位进入C的最高位,C的最低位丢失</li>
<li>Cd减1,若减1后Cd仍不为0,转2.继续进行循环</li>
<li>计算A的最高符号位,其为被乘数和乘数符号位的异或</li>
<li>得出结果,此时结果的高位在A中,低位在C中</li>
</ol>
<p>示意图如下,其中被乘数X=0.1101,乘数Y=0.1011<br><img src="/2020/02/24/computer-composition0/multi2.jpg" alt="multipy"><br>得到X*Y=0.10001111</p>
<h4 id="定点补码一位乘"><a href="#定点补码一位乘" class="headerlink" title="定点补码一位乘"></a>定点补码一位乘</h4><p>由于计算机中机器数常以补码形式存在,可以直接使用补码相乘</p>
<p>补码相乘规则如下:</p>
<blockquote>
<p>设被乘数$[X]_补=X_0.X_1X_2…X_n$,乘数$[Y]_补=Y_0.Y_1Y_2…Y_n$,则有:<br>$$ [X*Y]_补=[X]_补*(0.Y_1Y_2…Y_n)-[X]_补*Y_0 $$<br>可见,如果$Y$为负数,需要补充进行$-[X]_补$操作</p>
</blockquote>
<p>布斯补码乘法规则如下:</p>
<blockquote>
<p>考虑相邻的两位$Y_{i+1}$和$Y_i$(乘数的最后一位和倒数第二位),将定点原码一位乘中的2.3.策略改成如下</p>
<ul>
<li>最后两位为00或11,{A,C}右移一位</li>
<li>最后两位为01,将部分积A增加$[X]_补$,{A,C}右移一位</li>
<li>最后两位为10,将部分积A增加$[-X]_补$,{A,C}右移一位</li>
<li>最后一步运算结束后不需要移位<br>计算时,乘数末位需要添加附加位$Y_{n+1}=0$</li>
</ul>
</blockquote>
<p>示意图如下,其中被乘数X=-0.1101,乘数Y=0.1011,即[X]补=11.0011,[Y]补=0.1011,[-X]补=00.1101:<br><img src="/2020/02/24/computer-composition0/multi3.jpg" alt="multipy"> </p>
<h3 id="定点数二位乘"><a href="#定点数二位乘" class="headerlink" title="定点数二位乘"></a>定点数二位乘</h3><p>相比于定点一位乘法,定点数二位乘按乘数每两位的取值情况，一次求出对应于该两位的部分积。此时，只要增加少拭逻辑电路，就可使乘法速度提高一倍。 </p>
<h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><p>为了进一步提高乘法运算速度，可采用类似于人了计算的方法，用一个阵列乘法器完成乘法运算</p>
<h2 id="3-4-二进制除法运算"><a href="#3-4-二进制除法运算" class="headerlink" title="3.4 二进制除法运算"></a>3.4 二进制除法运算</h2><h3 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><p>人工算法:<br><img src="/2020/02/24/computer-composition0/div0.jpg" alt="div"> </p>
<p>机器算法:(要求被除数小于除数,即除法结果应小于1)</p>
<ul>
<li>使用3个寄存器ABC,存放余数(被除数),除数和商的绝对值,商的符号独立计算</li>
</ul>
<ol>
<li>初始化:被除数X放在A中,n位除数Y放在B中,C寄存器清零,计数器i=n+1,若X&gt;Y,则溢出</li>
<li>将A减去B;若余数大于等于0,则商C中的最低位上1,否则上0并恢复余数</li>
<li>i减1,若减1后i仍不为0,将A,C左移一位,重复2.过程</li>
<li>计算C的最高符号位,其为被除数和除数符号位的异或</li>
<li>得出结果,此时商在C中,余数在A中</li>
</ol>
<p>示意图如下,其中被除数X=0.1011,Y=0.1101,即[Y]补=00.1101, [-Y]补=11.0011:<br><img src="/2020/02/24/computer-composition0/div1.jpg" alt="div"><br>得到结果X/Y=0.1101,余数位0.0111</p>
<h4 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h4><p>加减交替法省略了恢复余数的操作,将恢复余数法中的2.策略改成如下</p>
<blockquote>
<ul>
<li>若A&gt;0,则将A减去B;结果余数A&gt;0,则商C中的最低位上1,否则上0(此时下一步就会执行减法操作)</li>
<li>若A&lt;0,则将A加上B;若余数A&gt;0,则商C中的最低位上1,否则上0<br>此时若最后一次上商为0,在计算余数时,依然需要为最后一步恢复余数</li>
</ul>
</blockquote>
<p>示意图如下,其中被除数X=0.1011,Y=0.1101,即[-Y]补=11.0011:<br><img src="/2020/02/24/computer-composition0/div2.jpg" alt="div">  </p>
<ul>
<li>实际上在上述除法运算策略中,被除数的位数可以是除数的两倍,初始化时其高位放在A中,低位在C中,在左移操作时将C中的高位移入A中的低位</li>
</ul>
<h3 id="提高除法运算速度的方法"><a href="#提高除法运算速度的方法" class="headerlink" title="提高除法运算速度的方法"></a>提高除法运算速度的方法</h3><ul>
<li>跳0跳1除法</li>
<li>除法运算通过乘法操作来实现</li>
</ul>
<h2 id="3-5-浮点数的运算方法"><a href="#3-5-浮点数的运算方法" class="headerlink" title="3.5 浮点数的运算方法"></a>3.5 浮点数的运算方法</h2><h3 id="浮点数的加减法运算"><a href="#浮点数的加减法运算" class="headerlink" title="浮点数的加减法运算"></a>浮点数的加减法运算</h3><p>考虑两个浮点数$X = M_X*2^E_X, Y = X = M_Y*2^E_Y$的运算</p>
<p>浮点数加减法运算需要如下五个过程:</p>
<ol>
<li>对阶操作,使得两个浮点数阶码相等(注意阶码是移码)<blockquote>
<ul>
<li>小阶向大阶对齐,将阶码小的数位数右移$\Delta$E位,使其阶码变成E(一般对于补码尾数,符号位参加移位,高位补符号位;但对于原码尾数对阶,符号位不参加移位,高位补0),右移所丢失的位可以保留下来以供舍入操作</li>
</ul>
</blockquote>
</li>
<li>尾数加减,即通常的尾数加减(两个符号位)</li>
<li>(补码)结果规格化操作<blockquote>
<ul>
<li>右规: 运算结果两个符号位的值不同,即运算尾数向上溢出,需要将尾数结果右移一位(高位补符号位),阶码E+1</li>
<li>左规: 运算结果最高数值位与符号位相同(补码),应将尾数连续左移直到最高位数值与符号位不同,并减去相应阶码</li>
</ul>
</blockquote>
</li>
<li>舍入操作: 用于右规和对阶操作时低位舍去的处理<blockquote>
<ul>
<li>截断法: 直接丢掉低位</li>
<li>置1法: 舍去后最低位直接置1</li>
<li>0舍1入法: 若舍去的最高位为1,则它前面的最低为加1,这是常用方法</li>
</ul>
</blockquote>
</li>
<li>检查阶码是否溢出: 在规格化和舍入时阶码可能发生溢出情况<blockquote>
<ul>
<li>阶码向下溢出: 运算结果为机器零</li>
<li>阶码向上溢出: 置溢出标记</li>
</ul>
</blockquote>
</li>
</ol>
<p>具体流程图如下:<br><img src="/2020/02/24/computer-composition0/float0.jpg" alt="float"></p>
<h3 id="浮点数的乘除法运算"><a href="#浮点数的乘除法运算" class="headerlink" title="浮点数的乘除法运算"></a>浮点数的乘除法运算</h3><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><ol>
<li>检测操作数是否为0，若其中有一个操作数为0，则置结果为0；</li>
<li>阶码相加，阶符相同的加可能会溢出，若溢出，则作溢出处理；(阶码一般是移码)</li>
<li>尾数相乘；</li>
<li>尾数乘积规格化,只有左规.</li>
<li>舍入</li>
<li>截断处理:无条件地丢掉正常尾数最低位之后的全部数值</li>
<li>舍入处理:运算过程中保留右移中移出的若干高位的值,然而再按某种规则用这些位上的值修正尾数</li>
<li>判溢出</li>
</ol>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>浮点数除法运算与乘法运算类似,也分求商的阶码、尾数相除、规格化、舍入和判溢这几个步骤</p>
<h2 id="3-6-运算部件"><a href="#3-6-运算部件" class="headerlink" title="3.6 运算部件"></a>3.6 运算部件</h2><h3 id="定点运算部件"><a href="#定点运算部件" class="headerlink" title="定点运算部件"></a>定点运算部件</h3><p>定点运算部件由算术逻辑运算部件ALU、多个寄存器、移位电路、计数器、门电路组成</p>
<ul>
<li>一般定点运算部件中有3个寄存器A、B、C,在不同运算中作用如下:<blockquote>
<ul>
<li>加法:A为被加数-&gt;运算结果,B为加数</li>
<li>减法:A为被减数-&gt;运算结果,B为减数</li>
<li>乘法:A为部分积-&gt;乘积高位,B为被乘数,C为乘数-&gt;乘积低位</li>
<li>除法:A为被除数-&gt;余数,B为除数,C为商</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="浮点运算部件"><a href="#浮点运算部件" class="headerlink" title="浮点运算部件"></a>浮点运算部件</h3><p>浮点运算部件通常由阶码运算部件和尾数运算部件组成</p>
<ul>
<li>阶码部分仅执行加减运算</li>
<li>尾数部分执行加减乘除运算</li>
</ul>
<h2 id="3-7-数据校验码"><a href="#3-7-数据校验码" class="headerlink" title="3.7 数据校验码"></a>3.7 数据校验码</h2><p>通过在数据为中加入一些冗余位,从而达到在数据传输过程中能自动发现错误和校正错误</p>
<ul>
<li>码距: 任意两个合法码之间至少由几个二进制位不同; 较大的码距能使得一个合法码变成另一个合法码的概率较小, 但会增加存储的代价</li>
</ul>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>方法: 在数据(开头)补充一个校验位,使得补充校验位后的数据编码中1值的个数为奇数(奇校验)或偶数(偶校验)</p>
<p><img src="/2020/02/24/computer-composition0/check0.jpg" alt="check"></p>
<ul>
<li>奇偶校验码只能发现一位或奇数个位的出错</li>
<li>奇偶校验码只能发现错误,不能校正错误</li>
<li>就校验码常用于存储器读写检查，或ASCII字符传送过程中的检查。</li>
</ul>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>方法: 在数据中加入多个校验位,将数据中的每一个二进制位分配在几个校验组中;当某一位出错时,就会导致多个校验组的数值发生变化,通过综合分析这些变化来发现出错的位置,为纠错提供依据</p>
<p>一位纠错海明码:</p>
<ul>
<li>设有r位校验位，则共有0到2^r-1个共2^r个组合。若用0表示无差错，则剩余2^r-1个值表示有差错，并指出错在第几位。由于差错可能发生在k个数据位中或r个校验位中，因此有: 2^r–1 &gt;= r+k<blockquote>
<ul>
<li>例如,5-11位数据可用4位校验位来校验</li>
</ul>
</blockquote>
</li>
<li>校验位的分布(下标从1开始):<blockquote>
<ul>
<li>将原数据按位从前向后标号,遇到第$2^{i-1}$个位时,插入第i个校验位$P_i$,得到海明码的数据排列</li>
</ul>
</blockquote>
</li>
<li>校验位的计算<blockquote>
<ul>
<li>按照上述的数据排列给每一位一个二进制编号(从1开始),则对于第i个校验位,它需要校验的是所有二进制编号中第i位为1的数<br>如,第二位校验码$P_2$就需要校验第2(010),3(011),6(110),7(111)位;注意,此时校验码本身也在这些校验位中</li>
<li>用上述方法按校验位进行分组,校验位计算是进行偶校验计算,它等于同组的其他数据的异或</li>
</ul>
</blockquote>
</li>
<li>还可以加入一个总校验位$P_{i+1}$,它等于前面所有位的异或,这时的校验码不仅能纠正一位错,还能发现两位错</li>
</ul>
<p>此时,原数据中每一位都至少由两位校验码校验,码距为4<br>检验方法: 对上述分组中的每一组进行异或检验(包括总校验位),所有检验结果都为0则无措,若有些组为1则可根据检验结果推理出哪一位出错(或者是两位错)</p>
<h3 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h3><p>CRC编码以模2运算为基础,可以发现并纠正多位错误</p>
<h1 id="四、主存储器"><a href="#四、主存储器" class="headerlink" title="四、主存储器"></a>四、主存储器</h1><p>主存储器(主存或内存)在现代计算机中处于中心地位</p>
<ul>
<li>计算机执行的程序和数据均放在存储器中</li>
<li>计算机系 统中输入输出设备数量增多,数据传送速度加快</li>
<li>共享存储器的多处理机的出现 </li>
</ul>
<h2 id="4-1-主存储器分类-技术指标和基本操作"><a href="#4-1-主存储器分类-技术指标和基本操作" class="headerlink" title="4.1 主存储器分类,技术指标和基本操作"></a>4.1 主存储器分类,技术指标和基本操作</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>随机存储器RAM<blockquote>
<ul>
<li>又称读写存储器,通过指令可以随机对各个存储单元进行访问的存储器;一般访问所需时间与存储单元的地址无关,但停电会造成信息丢失</li>
</ul>
</blockquote>
</li>
<li>非易失性存储器<blockquote>
<ul>
<li>停电仍能保持其内容</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h3><ul>
<li>容量<blockquote>
<ul>
<li>计算机可寻址的最小单位是一个存储字;一个存储字所包括的二进制位数称为字长</li>
<li>由于现代计算机中一个字节为8位,因此一个字的字长通常为8的倍数</li>
<li>以字节为单位来表示主存储器存储单元的总数就是主存储器的容量</li>
<li>指令中地址码的位数决定了主存储器可以直接寻址的最大空间,如32位微型机提供32位物理地址,支持对4G物理存储空间的访问</li>
</ul>
</blockquote>
</li>
<li>存取时间<blockquote>
<ul>
<li>存储器的存取时间又称存储器访问时间,是指启动一次存储器操作(读/写)到完成该操作所经历的时间<br>存储周期</li>
<li>存储周期指连续启动两次独立的存储器操作(例如连续两次读操作)所需间隔的最小时间</li>
<li>通常,存储周期略长于存取时间</li>
</ul>
</blockquote>
</li>
</ul>
<p>主存储器的速度和容址两项指标随着存储器件的发展得到了极大的提高。但是，具有 合适价格的主存储器能提供信息的速度总是跟不上CPU的处理指令和数据的速度。</p>
<h3 id="主存储器的基本操作"><a href="#主存储器的基本操作" class="headerlink" title="主存储器的基本操作"></a>主存储器的基本操作</h3><p>主存储器和CPU的连接是由总线支持的:<br><img src="/2020/02/24/computer-composition0/rw0.jpg" alt="rw"></p>
<ul>
<li>AR位地址寄存器</li>
<li>DR为数码寄存器</li>
</ul>
<h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p>读操作是将存储器的数据读取到CPU中:</p>
<ol>
<li>CPU把信息字的地址送到AR,经地址总线送往主存储器</li>
<li>CPU发读(Read)命令</li>
<li>CPU等待主存储器的Ready回答信号，Ready为 1，表示信息已读出经数据总线,送入DR</li>
</ol>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>写操作是将CPU中的数据写入存储器中</p>
<ol>
<li>CPU把信息字的地址送到AR，经地址总线送往主存储器,并将信息字送往DR</li>
<li>CPU发写(Write)命令</li>
<li>CPU等待主存储器的Ready回答信号，Ready为 1，表示信息已从DR经数据总线写入主存储器</li>
</ol>
<h2 id="4-2-读-写存储器-的发展"><a href="#4-2-读-写存储器-的发展" class="headerlink" title="4.2 读/写存储器(的发展)"></a>4.2 读/写存储器(的发展)</h2><h3 id="静态存储器SRAM"><a href="#静态存储器SRAM" class="headerlink" title="静态存储器SRAM"></a>静态存储器SRAM</h3><p>静态存储器利用触发器保存信息,只要不断电,信息就不会丢失</p>
<ul>
<li>集成度低,功耗较大</li>
</ul>
<h3 id="动态存储器DRAM"><a href="#动态存储器DRAM" class="headerlink" title="动态存储器DRAM"></a>动态存储器DRAM</h3><p>动态存储器利用MOS管存储电荷来保存信息,需要不断给电容充电使信息保存</p>
<ul>
<li>使用单管存储单元,通过电容充电来保存信息</li>
<li>再生: DRAM需要在电容的电荷漏掉之间进行充电,又称刷新,一般周期小于2ms</li>
<li>集成度高,功耗小,速度快;但读出是破坏性的,读出后需要立即对单元进行重写</li>
<li>单元读出信号很小,要求有高灵敏度的读出放大器</li>
<li>主要用于大容量存储器<blockquote>
<ul>
<li>相比SRAM,DRAM每片存储容量约是前者4倍,造价约为前者1/4,功率约为前者1/6</li>
</ul>
</blockquote>
</li>
</ul>
<p>DRAM发展:</p>
<ul>
<li>FPM快页式内存</li>
<li>EDO DRAM</li>
<li>同步DRAM(SDRAM):将RAM与CPU以相同的时钟频率进行控制,使RAM和CPU外频同步,取消等待时间</li>
<li>DDR SDRAM:双数据传送速率的SDRAM,在时钟的上升沿和下降沿都能读出数据(预取2位)</li>
<li>DDR 2:预读取能力为4位,降低电压和功耗,等效传输频率翻倍</li>
<li>DDR 3:预读取能力为8位</li>
</ul>
<h2 id="4-3-非易失性半导体存储器"><a href="#4-3-非易失性半导体存储器" class="headerlink" title="4.3 非易失性半导体存储器"></a>4.3 非易失性半导体存储器</h2><p>非易失性半导体存储器在停电时所存储的内容也不会丢失</p>
<ul>
<li><p>只读存储器ROM: 掩模式ROM由芯片制造商在制造时写入内容,以后只能读而不能再写入,前面叙述过它的存储原理</p>
</li>
<li><p>可编程序的只读存储器PROM: 一次性写入的存储器;如熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元的熔丝(写入)。</p>
</li>
<li><p>可擦除可编程序的只读存储器EPROM: 能多次修改数据的ROM;产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线照射后,浮置栅上的电子将逸散,即整体擦除</p>
</li>
<li><p>可电擦可编程序只读存储器E2PROM: 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写入周期要几毫秒,寿命为10万次。</p>
</li>
<li><p>快擦读写存储器Flash Memory: 用电擦除,但只能整体擦除或分区擦除; 可做成内存卡应用于各种电子产品</p>
</li>
</ul>
<h2 id="4-4-存储器的组成与控制"><a href="#4-4-存储器的组成与控制" class="headerlink" title="4.4 存储器的组成与控制"></a>4.4 存储器的组成与控制</h2><h3 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h3><p>一个存储器的芯片容量是有限的,要达到所需要的存储字数和存储字长,需要在字向和位向进行扩充; 这里展示静态存储器的位扩展和字扩展</p>
<p>静态存储芯片表示:</p>
<ul>
<li>芯片容量: 由字数*字长表示</li>
<li>地址线: 用于寻址,地址线的位数可由字数表示;如16K表示地址线有14条($16K=2^{14}$,其中1K的地址线是10条</li>
<li>数据线: 用于向芯片写入/读出数据,数据线的位数可由字长表示;如字长为4的芯片数据线有4条</li>
<li>使能(片选)端: 用于控制芯片是否能进行读写操作,一般低有效</li>
<li>读写控制端: 用于切换芯片的读/写操作,一般高位读取低位写入</li>
</ul>
<h4 id="位扩展-扩充数据线字长"><a href="#位扩展-扩充数据线字长" class="headerlink" title="位扩展(扩充数据线字长)"></a>位扩展(扩充数据线字长)</h4><ul>
<li>地址线,使能线(片选$\overline {CS}$),读写控制端$R/ \overline W$并联</li>
<li>数据线串联,分高低位分别引出<br>两片16K*4扩展成一片16K*8<br><img src="/2020/02/24/computer-composition0/sram0.jpg" alt="sram"></li>
</ul>
<h4 id="字扩展-扩充地址线字数"><a href="#字扩展-扩充地址线字数" class="headerlink" title="字扩展(扩充地址线字数)"></a>字扩展(扩充地址线字数)</h4><ul>
<li>地址线,读写控制线,使能线并联</li>
<li>片选连接译码器,用于区分各芯片的地址范围,地址高位通过译码器控制使能端来访问不同的芯片<br>四片16K*8扩展成一片64K*8<br><img src="/2020/02/24/computer-composition0/sram1.jpg" alt="sram"></li>
</ul>
<h4 id="字位扩展"><a href="#字位扩展" class="headerlink" title="字位扩展"></a>字位扩展</h4><p>同时对字向和位向进行扩展</p>
<ul>
<li>片内成组进行位扩展,然后组间进行字扩展</li>
<li>需要用MN/LK个芯片将L*K的存储器扩展成M*N的存储器<br><img src="/2020/02/24/computer-composition0/sram2.jpg" alt="sram"></li>
</ul>
<h3 id="存储控制"><a href="#存储控制" class="headerlink" title="存储控制"></a>存储控制</h3><p>在存储器中，往往需要增设附加电路。这些附加电路包括地址多路转换线路、地址选 通、刷新逻辑，以及读／写控制逻辑等。</p>
<ul>
<li>在大容量存储芯片中,为了减少芯片的地址线引出端的数目,将地址码分两次送到存储器芯片中,使得芯片地址线引出端减少一半</li>
<li>刷新逻辑: 通过定时刷新(读出)保证DRAM中的信息不丢失<blockquote>
<ul>
<li>刷新周期: 从上一次对整个存储器刷新结束到下一次刷新结束为止需要的时间,一般为2ms</li>
<li>分布式刷新:  在2ms内分散地将存储器的每一行刷新</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="存储校验线路"><a href="#存储校验线路" class="headerlink" title="存储校验线路"></a>存储校验线路</h3><ul>
<li>早期计算机多采用奇偶校验电路,只能发现一位错且不能纠正</li>
<li>由于大规模集成电路的发展，主存储器的位数可以做得更多，使多数计算机的存储器有纠正错误代码的功能(ECC)</li>
<li>一般采用的海明码校验线路可以纠正一位错</li>
</ul>
<h2 id="4-5-多体交叉存储器"><a href="#4-5-多体交叉存储器" class="headerlink" title="4.5 多体交叉存储器"></a>4.5 多体交叉存储器</h2><p>计算机中的大容量主存可由多个存储体构成,每个存储体都有自己的读写线路、地址寄存器和数据寄存器,称这种存储体为存储模块</p>
<ul>
<li>为了提高每个模块的使用率和总体的读取效率,对每个模块进行低位交叉编址,连续的地址分布在相邻的模块中<blockquote>
<p>M个交叉模块的使用率在$\sqrt M$和$M$之间</p>
</blockquote>
</li>
</ul>
<h1 id="五、存储系统"><a href="#五、存储系统" class="headerlink" title="五、存储系统"></a>五、存储系统</h1><p>(本章为原书第七章)</p>
<h2 id="5-1-存储系统的层次结构"><a href="#5-1-存储系统的层次结构" class="headerlink" title="5.1 存储系统的层次结构"></a>5.1 存储系统的层次结构</h2><h3 id="存储器类型"><a href="#存储器类型" class="headerlink" title="存储器类型"></a>存储器类型</h3><ul>
<li>主存储器:<blockquote>
<ul>
<li>一般为半导体存储器</li>
<li>存放当前正在执行的程序和数据</li>
<li>主存储器可以随机访问任一单元</li>
</ul>
</blockquote>
</li>
<li>辅助存储器(外存储器)<blockquote>
<ul>
<li>一般为磁盘,磁带,光盘等</li>
<li>存放当前不在运行的大量程序和数据</li>
<li>辅助存储器一般为串行访问存储器,需要顺序地按位进行访问,访问指定信息所需时间与信息所在位置有关   </li>
</ul>
<p>串行存储器:</p>
<ul>
<li>顺序存取存储器(磁带等): 磁带上的信息以顺序的方式存储在带上，读／写时要待磁带移动到合适位置后才能顺序读／写，需要耗费较多时间</li>
<li>直接存取存储器(磁盘等): 它对信息的存取包括移动磁头到信息所在区域(磁道)和从磁道的合适位置进行顺序读写;它比磁带快得多</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h3><p>操作系统和硬件结合,把主存和辅存统一在一起,形成了一个存储层次</p>
<ul>
<li>整体上看,其速度接近于主存</li>
<li>整体上看,其容量接近于辅存  </li>
<li>主存-辅存层次满足了存储器的大容量和低成本的需求<br>这种系统的发展和完善形成了现在广泛使用的虚拟存储系统</li>
</ul>
<p>cache-主存层次</p>
<ul>
<li>在速度方面,计算机的主存和CPU存在一个数量级的差距</li>
<li>高速缓冲存储器cache在速度上能满足CPU的要求</li>
<li>从CPU的角度看,cache-主存层次的速度接近于cache,容量与每位价格接近于主存</li>
<li>这个层次完全由硬件实现</li>
</ul>
<p>计算机的存储层次解决了速度与成本之间的矛盾</p>
<p>现代计算机同时采用上述两种存储层次,构成cache-主存-辅存三级存储层次</p>
<h2 id="5-2-高速缓冲存储器"><a href="#5-2-高速缓冲存储器" class="headerlink" title="5.2 高速缓冲存储器"></a>5.2 高速缓冲存储器</h2><h3 id="cache存在的合理性"><a href="#cache存在的合理性" class="headerlink" title="cache存在的合理性"></a>cache存在的合理性</h3><ul>
<li>程序访问的局部性原理: 在一个较短的时间间隔内,程序访问的地址往往集中在一个很小的范围内<blockquote>
<ul>
<li>程序指令地址本身就是连续分布的,且循环程序段和子程序段经常被反复执行</li>
<li>程序数据分布虽然不一定是集中的,但短时间内对数组的存储和访问以及对工作单元的选择也需要使用到局部范围的存储器地址</li>
</ul>
</blockquote>
</li>
</ul>
<p>根据局部性原理,在主存和CPU之间设置一个高速而容量相对较小的存储器,将当前执行的程序和数据存放在这个存储器中;当程序运行时,不需要再从主存储器中取指令和数据,访问cache即可</p>
<h3 id="cache的结构"><a href="#cache的结构" class="headerlink" title="cache的结构"></a>cache的结构</h3><p>cache一般由SRAM组成,它的工作速度数倍于主存,全部功能由硬件实现,并且对程序员是透明的</p>
<p>其基本结构如下:<br><img src="/2020/02/24/computer-composition0/cache0.jpg" alt="cache">  </p>
<ul>
<li>将n位的主存地址分块,前m位为主存块号,后b位为块内地址;将cache也分成同样大小的多个块,前c位为cache块号,后b位为块内地址(块内字节数与主存相同)</li>
<li>cache内每一个块外加一个标记地址,指明它是主存哪一块的副本,这个标记地址应该为m-c位</li>
<li>注意,cache的块号和它的标记地址不同</li>
</ul>
<p>当CPU发出读请求时,将主存地址m位(或m中的一部分)与cache某块的标记相比较,当结果相等时,说明需要的数据已经在cache中,直接访问cache即可,在CPU与cache之间,通常一次传送一个字块;当比较结果不相等时,说明需要的数据尚未调入cache,那么就要把该数据所在的整个字块从主存中调进来</p>
<ul>
<li>命中: CPU所要访问的信息在cache中,否则为不命中</li>
<li>命中率: CPU所要访问的信息在cache中的比率</li>
<li>失效率: 所要访问的信息不在cache中的比率</li>
</ul>
<p>具有cache的存储器的平均存取时间的计算:</p>
<ul>
<li>设cache本身的存取时间(周期)为tc,命中率为h,主存的存取时间为tm,则:<blockquote>
<p>平均存取时间t = h*tc+(1-h)(tc+tm) 或者估算为 h*tc+(1-h)tm</p>
</blockquote>
</li>
</ul>
<p>cache写策略:如何保证cache中的副本在更改后与主存一致</p>
<ul>
<li>标志交换或写回法: 暂时只修改cache中数据,待该字块被替换出去时写入主存</li>
<li>通过式写法或写通法: 每次修改cache的同时也修改主存</li>
<li>若被修改的单元根本不在cache中,也可以直接对主存进行写操作</li>
</ul>
<h3 id="cache映像"><a href="#cache映像" class="headerlink" title="cache映像"></a>cache映像</h3><h4 id="地址映射-映像-的概念"><a href="#地址映射-映像-的概念" class="headerlink" title="地址映射(映像)的概念"></a>地址映射(映像)的概念</h4><p>为了将信息存放到cache中,需要某种函数将主存的地址映射到cache中;执行程序时,需要通过地址变换将主存地址变换成cache地址,这种变换基于地址映像来实现</p>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><ul>
<li>特点: 主存中第$2^i+k$块只能映射到cache中第k块,其中,i&gt;c(c为cache字块地址位数)<blockquote>
<p>即: $cache字块号 = 主存字块号 mod 2^c$</p>
</blockquote>
</li>
</ul>
<p>从实现上,只需要将m位的主存分成t位主存字块标记和c位cache字块标记;cache中只需要t位进行标记,将其与t位主存字块标记对比即可判断是否命中</p>
<p><img src="/2020/02/24/computer-composition0/cache1.jpg" alt="cache"></p>
<p>由于cache块号与主存块号的部分相关连,因此标记只需要t位;实现简单,cache块的定位迅速(主存的块只能映射到一个cache块中),但不够灵活</p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><ul>
<li>特点: 主存中的每一块可以映射到cache中的任意一块<blockquote>
<p>cache中的标记需要m位,在定位cache块时需要将m位主存块号和所有的cache标记比对一次,才能判断是否”命中”</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/cache2.jpg" alt="cache"></p>
<p>这种方式最灵活,cache命中率最高,但成本也最高,开销大速度慢</p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><ul>
<li>特点: 是直接映射和全相联映射的一个折衷,主存中的每一块可以映射到cache中的$2^{c-r}$块<blockquote>
<ul>
<li>主存和cache分成r组,取主存块地址和cache块地址的后r位</li>
<li>组间为直接映射,组内为全相联映射</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/cache3.jpg" alt="cache"></p>
<p>上图中cache每一组(行)内都有多个全相联的块</p>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><p>新的主存字块需要调入cache而原可用位置已被占满时,就需要用替换算法来更新cache内容</p>
<h4 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h4><ul>
<li>按调入cache的先后顺序来决定需要被替换出去的cache块;最先被调入cache的块最先被替换成新的块<blockquote>
<ul>
<li>这种算法考虑了局部访问性原理</li>
<li>这种算法实现容易,开销小</li>
<li>但有些时候会使得命中率下降</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h4><ul>
<li>将近期长久未被访问过的块替换出去<blockquote>
<ul>
<li>这种算法按调用频繁程度来决定淘汰顺序,并没有考虑局部访问性原理,比较合理</li>
<li>这种算法的cache命中率较高</li>
<li>这种算法实现开销比FIFO稍大</li>
</ul>
</blockquote>
</li>
</ul>
<p>LRU+FIFO实现: 每次命中新块,都将它移动到队头;若未命中,则将队尾元素替换成新块,然后将它移动到队头</p>
<h4 id="cache地址的监听"><a href="#cache地址的监听" class="headerlink" title="cache地址的监听"></a>cache地址的监听</h4><p>在外部设备对存储器进行修改时,需要保证cache与主存对应快的内容一致,需要对地址进行监听</p>
<p>做法: 若某一IO设备直接对存储器而非cache写入数据时,将对应地址的cache(若有的话)标记有效的位清0,当CPU再次访问该cache时将产生不命中信号;保证CPU所取数据的正确性</p>
<h3 id="多层次cache"><a href="#多层次cache" class="headerlink" title="多层次cache"></a>多层次cache</h3><h4 id="指令cache和数据cache"><a href="#指令cache和数据cache" class="headerlink" title="指令cache和数据cache"></a>指令cache和数据cache</h4><p>将指令和数据放在同一cache中通常会使得存取数据操作和取指令操作发生冲突,延迟了指令的读取</p>
<p>哈佛结构: 将指令cache和数据cache独立分开来</p>
<h4 id="多层次cache-1"><a href="#多层次cache-1" class="headerlink" title="多层次cache"></a>多层次cache</h4><p>集成度高的芯片可用设计出高速的片内cache,与大容量的片外cache配合使用</p>
<p>一般一级cache和二级cache设计在片内,高性能处理器均已采用三级cache方案</p>
<h2 id="5-3-虚拟存储器"><a href="#5-3-虚拟存储器" class="headerlink" title="5.3 虚拟存储器"></a>5.3 虚拟存储器</h2><p>虚拟存储器指的是主存-辅存层次,程序员可以按虚存空间编址</p>
<p>几个单位: 段,页,段页</p>
<h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><p>段: 利用程序模块化性质,按照程序逻辑结构划分出的多个相对的独立部分</p>
<ul>
<li>如: 过程,子过程,数据表,阵列等</li>
<li>这些逻辑部分可以互相调用或者被外部程序调用,形成段间连接,产生规模较大的程序</li>
<li>一般用段表指明段在主存中的位置: 段号,段起点,装入位(表示段是否已经装入主存),段长等(段表本身也是由一个段存储)</li>
</ul>
<p>段式管理: 主存按段进行分配</p>
<ul>
<li>优点: 逻辑独立性好,与程序的自然分界相对应,易于编译、管理、修改和保护,也易于多道程序共享</li>
<li>缺点: 会在段间留下许多空余的零碎存储空间,造成存储资源的浪费</li>
</ul>
<h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>页面: 主存的物理空间被划分位等长的固定区域,称为页面</p>
<p>页式管理: 主存按页进行管理,信息传送单位是定长的页</p>
<ul>
<li>优点: 新页调入主存十分容易,,只要有空白页即可; 可能造成浪费的地方是程序最后一页的零头,它比段式管理系统的空间浪费要小得很多</li>
<li>缺点: 由于页不是逻辑上独立的实体,在处理、保护和共享都不及段式来得方便</li>
</ul>
<p>段页式管理: 将程序按模块分段,段内再分页; 出入主存仍以页为信息传送单位, 用段表和页表(每段一个页表)进行两级管理</p>
<p>####页式虚拟存储器</p>
<ul>
<li>逻辑页: 在页式虚拟存储器中,把虚拟空间分成页,称为虚页或逻辑页</li>
<li>物理页: 主存空间分成和虚存同样大小的页,称为实页或物理页</li>
<li>虚存地址: 虚拟地址由高低两个字段组成,高字段为逻辑页号,低字段为页内地址</li>
<li>实存地址: 主存实地址由高低两个字段组成, 高字段为物理页号,低字段为页内地址</li>
</ul>
<p>虚存地址到主存实地址的变换是由页表来实现的<br><img src="/2020/02/24/computer-composition0/page0.jpg" alt="page"></p>
<ul>
<li>对应每个虚页号有一个页表条目,该条目要包含虚页对应主存的物理页号</li>
<li>其他属性包含装入(有效)位,修改位(表示页面内容是否被修改),替换控制位(指出需要替换的页)和其他保护位等<blockquote>
<p>页表本身也在主存中,如果一次访问不命中,那么进行替换、修改再访问,需要和主存进行多次通讯,效率较低</p>
</blockquote>
</li>
</ul>
<p>快表TLB: 将频繁访问的页表信息存放在一个快速存储器中<br><img src="/2020/02/24/computer-composition0/TLB0.jpg" alt="tlb"></p>
<ul>
<li>首先按虚页号同时查询快表慢表</li>
<li>快表查到即访问,查不到即花费一个周期去主存中的慢表找</li>
<li>找到后用替换算法将该页号调入快表</li>
</ul>
<p>页式虚拟存储器优点:</p>
<ul>
<li>主存储器利用率较高</li>
<li>页表相对简单</li>
<li>地址变换速度较快</li>
<li>对磁盘管理比较容易</li>
</ul>
<p>缺点:</p>
<ul>
<li>程序模块化性能不好</li>
<li>页表很长,需要占用大量的存储空间</li>
</ul>
<p>内页表: 虚地址到主存物理地址的变换表<br>外页表: 虚地址和具体辅存地址之间的变换表</p>
<h3 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h3><p>在段页式管理的基础上,产生段页式虚拟存储器</p>
<ul>
<li>多道程序: 如果有多个用户在机器上运行,称为多道程序<blockquote>
<ul>
<li>每一道(每个用户)需要一个基号(用户标志号)</li>
<li>这个地址需要指明该道程序的段表起点(存放在基址寄存器中)</li>
</ul>
</blockquote>
</li>
<li>虚拟地址: 包括基号D,段号S,页号P,页内地址D</li>
</ul>
<p>段页式虚拟存储器地址变换过程见课本第174 175页<br><img src="/2020/02/24/computer-composition0/para0.jpg" alt="para"><br>查询过程:</p>
<ul>
<li>程序段起点+段号-&gt;页表起点</li>
<li>页表起点+页号+页内偏移量-&gt;实存地址</li>
</ul>
<h3 id="虚拟存储器工作过程"><a href="#虚拟存储器工作过程" class="headerlink" title="虚拟存储器工作过程"></a>虚拟存储器工作过程</h3><p><img src="/2020/02/24/computer-composition0/storage0.jpg" alt="storage"></p>
<h3 id="存储管理部件MMU"><a href="#存储管理部件MMU" class="headerlink" title="存储管理部件MMU"></a>存储管理部件MMU</h3><p>虚拟存储系统的特点:</p>
<ul>
<li>允许用户程序用比主存空间大得多的空间来访问主存</li>
<li>每次访存都要进行虚实地址的变换<br>整个虚拟存储器的管理是由存储管理部件MMU和操作系统共同完成的</li>
</ul>
<h2 id="5-4-相连存储器"><a href="#5-4-相连存储器" class="headerlink" title="5.4 相连存储器"></a>5.4 相连存储器</h2><p>在cache和虚拟存储器中,需要用到按内容寻址的相连存储器(页表查询等)</p>
<ul>
<li>相连存储器按照所存数据字的全部内容或部分内容进行查找(检索)访问<br><img src="/2020/02/24/computer-composition0/CR0.jpg" alt></li>
<li>CR是比较数寄存器</li>
<li>MR是屏蔽数寄存器,无需进行匹配的位置为0,置1的位为关键字段</li>
<li>WSR为字选择寄存器,对应位为0的字不参与查找(可以用这个进行二次或多次查找;将上一次的SRR放入WSR即可)</li>
<li>SRR为查找结果寄存器,满足要求的相应位为1</li>
<li>相联存储器能够进行比较操作(相等比较,大小比较,求最值)看,比较操作是并行的,时间复杂度为常数</li>
</ul>
<h2 id="5-5-存储保护"><a href="#5-5-存储保护" class="headerlink" title="5.5 存储保护"></a>5.5 存储保护</h2><p>多个用户对主存进行共享,需要防止由于一个用户程序出错导致其他用户程序和系统软件被破坏,也要防止一个用户程序不合法地访问其他的主存区域</p>
<h3 id="存储区域保护"><a href="#存储区域保护" class="headerlink" title="存储区域保护"></a>存储区域保护</h3><ul>
<li>在主存系统中由系统软件经特权指令设置上下界寄存器为每个程序划定存储区域,禁止越界访问</li>
</ul>
<p>虚拟存储系统中:</p>
<ul>
<li>页表保护: 每个程序都有自己的页表和段表,对它们进行保护; 除非地址变换出错,否则程序只能影响分配给它的几个主存页面</li>
<li>键保护: 为主存的每一页配一个由操作系统赋予的存储键,给相应的每个用户分配一个访问键,这个访问键赋予每道程序; 当访问键与存储键相符合时,这一页的数据才能被允许操作</li>
<li>环保护: 按系统程序和用户程序的重要性对整个系统正常运行的影响程度进行分层(环); 环号大小表示保护级别,环号越大等级越低; 某环内的程序只能转到环号大于等于它本身的页中去</li>
</ul>
<h3 id="访问方式保护"><a href="#访问方式保护" class="headerlink" title="访问方式保护"></a>访问方式保护</h3><p>对主存信息进行读R,写W和执行E(指将数据作为指令使用)保护</p>
<h3 id="管理状态和用户状态"><a href="#管理状态和用户状态" class="headerlink" title="管理状态和用户状态"></a>管理状态和用户状态</h3><p>大多数计算机在执行程序时把工作状态分成两种</p>
<ul>
<li>管理状态：执行操作系统或管理程序时所处的状态</li>
<li>用户状态：执行用户程序时所处的状态<br>为了防止因程序员编程出错而影响整个系统的工作，在机器中设置了一些特权指令(规定特权指令只有操作系统等系统程序才能使用，如在用户程序中出现特权指令)，则在执行到该指令时立即中止程序的执行并发出中断。</li>
</ul>
<h1 id="六、指令系统"><a href="#六、指令系统" class="headerlink" title="六、指令系统"></a>六、指令系统</h1><p>(原书第五章)</p>
<h2 id="指令系统的发展"><a href="#指令系统的发展" class="headerlink" title="指令系统的发展"></a>指令系统的发展</h2><ul>
<li>指令: 计算机执行某种操作的命令 </li>
</ul>
<hr>
<p><em>待更新…</em></p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/02/24/computer-composition0/" data-id="ck90lisuw0006wcvn1x46cu4q"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" rel="tag">计算机组成</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/02/24/compilers0/" class="article-nav-link">
        <strong class="article-nav-caption">Prev Post</strong>
        <div class="article-nav-title">
          
            编译原理相关知识
          
        </div>
      </a>
    
    
      <a href="/2020/02/24/java0/" class="article-nav-link">
        <strong class="article-nav-caption">Next Post</strong>
        <div class="article-nav-title">Java学习笔记</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: 'ze0YzGUMUrLXgdRQpKyDCEEm-gzGzoHsz',
        app_key: 'NnhAiNVNGXwbCD1sMGNRjA8B',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: 'Leave your comments here ~',
        recordIP: true,
        lang: 'en'
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        George Chen
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="George"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HOME</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives/">ARCHIVE</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">CATE.</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">TAGS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://github.com/georgechen1827/" target="_blank" rel="noopener">about me</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/coming_soon.html" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>







<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>