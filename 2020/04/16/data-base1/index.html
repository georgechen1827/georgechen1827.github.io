<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="this is George Chen&#39;s blog!" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    数据库原理与设计(高级篇) |  George
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-data-base1" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数据库原理与设计(高级篇)
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/16/data-base1/" class="article-date">
  <time datetime="2020-04-16T06:06:44.000Z" itemprop="datePublished">2020-04-16</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> about </span>
            <span class="post-count">11.2k words</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> costs </span>
            <span class="post-count">40 minutes</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>未完结,持续更新</p>
<hr>
<p>任课教师: 赵朋朋<a href="http://web.suda.edu.cn/ppzhao/" target="_blank" rel="noopener">http://web.suda.edu.cn/ppzhao/</a></p>
<p>网课资源: 慕课中国人民大学数据库系统概论<a href="https://www.icourse163.org/course/RUC-488001" target="_blank" rel="noopener">https://www.icourse163.org/course/RUC-488001</a></p>
<p>参考教材: 高等教育出版社《数据库系统概论(第5版)》</p>
<p>课程主要讲述关系型数据库的原理, 不着重于具体数据库的使用</p>
<p>在高级篇中,从管理系统的角度来介绍DBMS系统,用使用和应用的角度来讲解数据库设计的方法</p>
<p>数据库原理与设计(基础篇)见<a href="http://georgechen.top/2020/02/27/data-base0/" target="_blank" rel="noopener">http://georgechen.top/2020/02/27/data-base0/</a></p>
<a id="more"></a>

<h1 id="六、关系数据理论"><a href="#六、关系数据理论" class="headerlink" title="六、关系数据理论"></a>六、关系数据理论</h1><h2 id="6-1-关系数据理论的提出"><a href="#6-1-关系数据理论的提出" class="headerlink" title="6.1 关系数据理论的提出"></a>6.1 关系数据理论的提出</h2><p>需要解决的问题:怎么根据具体问题构造出一个合适的数据模式;即,什么是一个好的数据库逻辑设计</p>
<p>好的关系模式不会因为数据冗余而发生:</p>
<ul>
<li>存储空间浪费</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常<blockquote>
<p>因此,好的关系模式数据冗余应尽可能少(但较少的冗余度可能会降低增删改查时的效率)</p>
</blockquote>
</li>
</ul>
<p>问题的根源:数据依赖</p>
<h3 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h3><p>数据库中,数据依赖是完整性约束的一种表现形式,是数据库模式设计的关键</p>
<ul>
<li>限定属性的取值范围</li>
<li>定义属性间的相互关联(一般以相等关系体现)</li>
</ul>
<p>现实生活中,数据依赖是</p>
<ul>
<li>现实世界属性间相互联系的抽象</li>
<li>数据内在的性质</li>
<li>语义的体现</li>
</ul>
<p>数据依赖的类型</p>
<ul>
<li>函数依赖FD</li>
<li>多值依赖MVD</li>
<li>连接依赖</li>
<li>…</li>
</ul>
<p>不适合的数据依赖会造成插入、删除、更新异常和数据冗余问题</p>
<h3 id="关系模式的简化表示"><a href="#关系模式的简化表示" class="headerlink" title="关系模式的简化表示"></a>关系模式的简化表示</h3><p>$R&lt;U,F&gt;$是一个简化表示的关系模式</p>
<ul>
<li>$U$:关系的属性集合</li>
<li>$F$: 属性间数据依赖的关系集合<blockquote>
<p>当且仅当$U$上的一个关系r满足$F$时,r为关系模式$R$的一个关系</p>
</blockquote>
</li>
</ul>
<h2 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集.若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等;则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。X称为这个函数依赖的决定属性组，也称为决定因素(Determinant)。</p>
<ul>
<li>Y依赖于X:X相等则Y相等</li>
<li>X确定了那么Y也确定了</li>
</ul>
<p>注意: </p>
<ul>
<li>函数依赖是语义范畴的概念,只能根据数据的语义来确定函数依赖,而不能根据数据的具体形式来反推可能的函数依赖</li>
<li>函数依赖确定后,所有的关系实例都要满足该约束条件<blockquote>
<p>当然,数据库设计者可以对现实世界做强制的规定来使得某两个属性产生函数依赖;如:不允许有学生重名,则学生的其他信息可以依赖于学生姓名</p>
</blockquote>
</li>
</ul>
<h4 id="平凡函数依赖和非平凡函数依赖"><a href="#平凡函数依赖和非平凡函数依赖" class="headerlink" title="平凡函数依赖和非平凡函数依赖"></a>平凡函数依赖和非平凡函数依赖</h4><ul>
<li>$X\to Y,Y\subseteq X,X\to Y$为非平凡函数依赖</li>
<li>$X\to Y,Y\not \subseteq X,X\to Y$为平凡函数依赖</li>
</ul>
<p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明， 我们总是讨论非平凡 函数依赖。</p>
<h4 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h4><ul>
<li>$X\to Y$,且对于任意的$X’ \subsetneq X,X \not \to Y$,则$X\to Y$为完全函数依赖,记作$X$-F-&gt;$Y$(Full)</li>
<li>非完全函数依赖记作$X$-P-&gt;$Y$(Part)<blockquote>
<p>注意,X是一个属性的集合</p>
</blockquote>
</li>
</ul>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><ul>
<li>$X\to Y,Y \to Z 且 Y \not \subseteq X,Y \not \to X$时,称Z传递函数依赖于X,X传递(函数)确定Z,记作$X$-传递-&gt;$Z$<blockquote>
<p>注意,若$Y\to X$,则$Z$直接依赖于$X$</p>
</blockquote>
</li>
</ul>
<h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="*多值依赖"></a>*多值依赖</h3><p>函数依赖中X确定一个单值Y,但有时给定X的值x,它能确定多个Y的值;在插入x时,需要插入多条(x,y)元组才能符合这种依赖关系,而且这种依赖关系是隐式的,十分不方便.</p>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>候选码: $R&lt;U,F&gt;$中,$K \subset U,K$-F-&gt;$U$,则K为R的一个(候选)码</li>
<li>超码: 上述情况下$K$-P-&gt;$U$</li>
<li>主码: 若R有多个候选码,则选定其中一个作为主码</li>
<li>全码: 整个属性组都是码,称为全码(候选码为整个属性组)<blockquote>
<ul>
<li>候选码长度是超码长度的一个极小值,即候选码的任意一个真子集都不是候选码</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h4><ul>
<li>任意一个候选码中的任意一个属性都为主属性</li>
<li>不包含在任何码中的属性为非主属性(非码属性)</li>
</ul>
<h4 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h4><ul>
<li>$R&lt;U,F&gt;$中属性(组)$X$不是$R$的(候选)码,但$X$是另外一个关系模式的码,则称$X$是$R$的外部码</li>
</ul>
<p>主码与外码一起提供了表示关系间联系的手段</p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式是符合某一种级别的关系模式的集合</p>
<p>关系数据库中的关系必须满足一定的要求,满足不同程度要求的为不同范式</p>
<p>范式种类(级别由低到高):</p>
<ul>
<li>第一范式1NF: 关系模式的最低要求</li>
<li>第二范式2NF: 消除非主属性对码的部分函数依赖</li>
<li>第三范式3NF: 消除非主属性对码的传递函数依赖</li>
<li>修正的第三范式BCNF: 消除主属性对码的部分和传递函数依赖</li>
<li>第四范式4NF: 消除非平凡且非函数依赖的多值依赖</li>
<li>第五范式5NF: 消除非候选码所蕴含的连接依赖<blockquote>
<ul>
<li>低级别的范式一定包含高级别的范式</li>
<li>某一关系模式R为第n范式,记为$R \in nNF$</li>
</ul>
</blockquote>
</li>
</ul>
<p>一个低一级范式的关系模式,通过模式分解可以转化成若干个高一级范式的关系模式的集合,这种过程叫做规范化</p>
<p>关系数据库的规范化理论是数据库逻辑设计的工具</p>
<h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>如果一个关系模式$R$的所有属性都是不可分的基本数据项,则$R\in 1NF$</p>
<ul>
<li>即,不能表中嵌表</li>
<li>所有的关系数据库模式都满足第一范式,第一范式是对关系模式的最起码的要求;不满足第一范式的数据库模式不能称为关系数据模式</li>
</ul>
<p>然而,满足第一范式的关系模式不一定是一个好的关系模式</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>若关系模式$R \in 1NF$,且每一个非主属性都完全依赖于$R$的码,则$R \in 2NF$</p>
<ul>
<li>即,$R$中码的任何一部分都不能单独决定一些属性,这些属性必须由整个码来确定<blockquote>
<p>能够单独决定一些属性的码需要被独立成另外的关系</p>
</blockquote>
</li>
<li>不符合第二范式的关系模式会产生问题<blockquote>
<ul>
<li>插入异常: 数据库不能插入一些只包含部分合理信息的元组(码的其他部分也得被确定下来)</li>
<li>删除异常: 数据库有时不能将元组的部分信息合理删除(这些信息可能包含码的部分)</li>
<li>数据冗余</li>
<li>修改复杂: 修改元组部分信息时,表中其他元组的部分信息也得被修改(数据冗余造成的)<br>根本原因: 一些属性部分依赖于码</li>
</ul>
</blockquote>
</li>
<li>解决上述问题的方法: 投影分解法,消除部分依赖,使得关系符合第二范式</li>
</ul>
<p>但是,第二范式并不能完全消除关系模式中异常情况和修改复杂、数据冗余情况,因为有传递函数依赖的存在</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>若关系模式$R \in 1NF$,且不存在这样的码$X$、属性<strong>组</strong>$Y$以及非主属性$Z(Z\not \subset Y)$,使得$X\to Y,Y \to Z,Y \not \to X$成立($Z$不传递依赖于X),则$R \in 2NF$</p>
<ul>
<li>传递函数依赖的存在使得一些信息被”隐式”地存储在表中,需要将它们独立成另外的关系</li>
</ul>
<p>性质:</p>
<ul>
<li>第三范式关系中的每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码</li>
<li>若R属于第三范式,那么R必定属于第二范式</li>
<li>采用投影分解法能将一个第二范式关系分解成多个第三范式关系</li>
</ul>
<p>然而,第三范式还是不能完全消除关系模式中的各种异常情况和数据冗余,因为主属性之间也会存在依赖</p>
<h4 id="修正的第三范式-BCNF"><a href="#修正的第三范式-BCNF" class="headerlink" title="修正的第三范式(BCNF)"></a>修正的第三范式(BCNF)</h4><p>若关系模式$R \in 1NF$,且对$R$中每个函数依赖$X\to Y 且 Y\not \in X时$,X必含有码,则$R \in 2NF$</p>
<p>性质:</p>
<ul>
<li>所有非主属性对每一个码都是完全函数依赖</li>
<li>所有主属性对每一个不包含它的码都是完全函数依赖</li>
<li>没有任何属性完全函数依赖于一些非码属性(不存在传递函数依赖)</li>
<li>符合BCNF的范式一定符合3NF,反之不然<blockquote>
<p>BCNF在函数依赖范畴内已经实现了模式的彻底分解,达到了最高的规范化程度,消除了操作异常的诸多问题</p>
</blockquote>
</li>
</ul>
<h2 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a>6.3 数据依赖的公理系统</h2><p>数据依赖的公理系统式模式分解算法的理论基础</p>
<p>Armstrong公理系统式函数依赖的一个有效而完备的公理系统</p>
<h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><p>Armstrong公理系统是一套推理规则,用于回答某个函数依赖是否被某组函数依赖F蕴含</p>
<ul>
<li>有效性: 由F出发根据Armstrong公理推导出的每一个函数依赖一定在$F^+$中</li>
<li>完备性: $F^+$中的每一个函数依赖必定可以由Armstrong公理推导出来</li>
</ul>
<h3 id="逻辑蕴涵的定义"><a href="#逻辑蕴涵的定义" class="headerlink" title="逻辑蕴涵的定义"></a>逻辑蕴涵的定义</h3><p>对于满足一组函数依赖F的关系模式$R(U,F)$,对符合它的任意关系r,若都有函数依赖$X\to Y$成立,则称F(逻辑)蕴涵$X\to Y$</p>
<h3 id="几个导出的推理规则"><a href="#几个导出的推理规则" class="headerlink" title="几个导出的推理规则"></a>几个导出的推理规则</h3><p>设U为属性集总体, F是U上的一组函数依赖, 对关系$R&lt;U,F&gt;$ 来说, 有以下的推理规则: </p>
<ul>
<li>自反律: 若$Y \subseteq X \subseteq U$,则F蕴含$X\to Y$</li>
<li>增广律: 若F蕴含$X\to Y$且$Z\subseteq U$,则F蕴含$XZ\to YZ$</li>
<li>传递律: 若F蕴含$X\to Y和Y\to Z$,则F蕴含$X\to Z$</li>
</ul>
<p>上述三个推理规则可以进一步得到以下几个推理规则:</p>
<ul>
<li>合并规则: 由$X\to Y,X\to Z$,可以得到$X\to YZ$</li>
<li>伪传递规则: 由$X\to Y,YW\to Z$,可以得到$XW\to Z$</li>
<li>分解规则: 由$X\to Y,Z \subseteq Y$,可以得到$X\to Z$</li>
</ul>
<p>根据合并规则和分解规则可以得到下述重要引理:</p>
<ul>
<li>$X\to A_1A_2…A_n$成立的充要条件是$X\to A_i(i=1,2,…n)$</li>
</ul>
<h3 id="函数依赖闭包"><a href="#函数依赖闭包" class="headerlink" title="函数依赖闭包"></a>函数依赖闭包</h3><h4 id="定义和一些引理"><a href="#定义和一些引理" class="headerlink" title="定义和一些引理"></a>定义和一些引理</h4><ul>
<li>在关系模式$R&lt;U,F&gt;$中被F所蕴含的函数依赖的全体称为F的闭包,记作$F^+$</li>
<li>设F为属性集U上的一组函数依赖,$X\subseteq U$,$X_{F^+} = \lbrace A | X\to A能由F根据Armstrong公理导出 \rbrace$,称为属性集X关于函数依赖集F的闭包<blockquote>
<ul>
<li>$X_{F^+}$表示属性组X能根据F推导出的所有属性</li>
<li>$F^+$不容易直接求出,在考虑某函数依赖是否在$F^+$中时,需要转化成对$X_{F^+}$的判定</li>
</ul>
</blockquote>
</li>
</ul>
<p>关于闭包的引理</p>
<ul>
<li>F为属性集U上的一组函数依赖,X Y为U上的两个属性组;$X\to Y$能由F根据Armstrong公理导出的充要条件是$Y\subseteq X_{F^+}$<blockquote>
<ul>
<li>判断$X\to Y$是否在$F^+$中,只需判断Y是否是$X_{F^+}$的子集</li>
<li>若$X_{F^+}=U$,则X为R的候选码</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="求-X-F-的算法"><a href="#求-X-F-的算法" class="headerlink" title="求$X_{F^+}$的算法"></a>求$X_{F^+}$的算法</h4><p>遵循如下迭代算法求取$X_{F^+}$:</p>
<ol>
<li>令$X_{add} = \emptyset$</li>
<li>扫描F,将能根据X或部分X推导出的元素加入$X_{add}$</li>
<li>$X = X \cup X_{add}$</li>
<li>若X并没有改变,则得到结果$X_{F^+}$,否则转1.</li>
</ol>
<h3 id="函数依赖集的一些性质"><a href="#函数依赖集的一些性质" class="headerlink" title="函数依赖集的一些性质"></a>函数依赖集的一些性质</h3><h4 id="函数依赖集的等价"><a href="#函数依赖集的等价" class="headerlink" title="函数依赖集的等价"></a>函数依赖集的等价</h4><p>两个函数依赖集$F$和$G$,若$F^+=G^+$,则$F$与$G$等价(F覆盖G,F是G的覆盖或反之)</p>
<ul>
<li>函数依赖集的等价是指它们的闭包等价</li>
</ul>
<h4 id="最小-极小-依赖集"><a href="#最小-极小-依赖集" class="headerlink" title="最小(极小)依赖集"></a>最小(极小)依赖集</h4><p>满足下列条件的依赖集F称为一个最小依赖集</p>
<ul>
<li>F中任意一个函数依赖的右边只含有一个属性</li>
<li>F中的每个函数依赖的左边均为最小属性集<blockquote>
<p>若存在一个函数依赖$X\to A$,使得去掉这条依赖中X的部分属性,得到的函数依赖集F’与F等价,则原F不是最小依赖集</p>
</blockquote>
</li>
<li>F中的每个函数依赖均不能由F中其他的函数依赖导出</li>
</ul>
<h4 id="求最小依赖集的算法"><a href="#求最小依赖集的算法" class="headerlink" title="求最小依赖集的算法"></a>求最小依赖集的算法</h4><ol>
<li>扫描F中的函数依赖,将所有依赖项的右边拆分成单属性</li>
<li>扫描每个函数依赖的左边,去除左边冗余的属性</li>
<li>去掉F中冗余的函数依赖关系</li>
</ol>
<ul>
<li>F的最小依赖集不是唯一的</li>
</ul>
<h2 id="6-4-模式的分解"><a href="#6-4-模式的分解" class="headerlink" title="6.4 模式的分解"></a>6.4 模式的分解</h2><p>关系模式的规范化是通过模式分解来实现的</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>投影:</p>
<ul>
<li>$F_i = \lbrace X\to Y | X\to Y \in F^+ , XY \subseteq U_i \rbrace$ 称为$F$在$U_i$上的投影</li>
</ul>
<p>关系模式的分解:</p>
<ul>
<li>$R&lt;U,F&gt;$的一个分解为$\rho = \lbrace R_1&lt;U_1,F_1&gt;,…,R_n&lt;U_n,F_n&gt;\rbrace$,其中$U = U_1\cup … U_n$, 且不存在$U_i\subseteq U_j$</li>
</ul>
<p>模式分解主要涉及到投影和自然连接两个运算</p>
<h3 id="模式分解的三个目标"><a href="#模式分解的三个目标" class="headerlink" title="模式分解的三个目标"></a>模式分解的三个目标</h3><p>一个模式有多种分解方法,符合一些要求的分解方法才有意义</p>
<ul>
<li><p>无损连接分解: 将分解后的多个模式进行自然连接,结果应和原模式一样</p>
</li>
<li><p>保持函数依赖: 分解前F的最小依赖集中的每个函数依赖都应该被投影到分解后的某个关系模式中去</p>
<blockquote>
<p>即:$F^+ = (F_1\cup … \cup F_n)^+$</p>
</blockquote>
</li>
<li><p>达到更高级范式: 分解得到的每个关系模式应该相比于分解前的关系模式达到更高级别的范式</p>
</li>
</ul>
<h3 id="模式分解算法"><a href="#模式分解算法" class="headerlink" title="模式分解算法"></a>模式分解算法</h3><h4 id="达到BCNF并保持无损连接的算法"><a href="#达到BCNF并保持无损连接的算法" class="headerlink" title="达到BCNF并保持无损连接的算法"></a>达到BCNF并保持无损连接的算法</h4><ol>
<li>令$\rho = \lbrace R&lt;U,F&gt; \rbrace$</li>
<li>检查$\rho$中各关系模式是否属于BCNF,若是则返回结果</li>
<li>发现有$R_i&lt;U_i,F_i&gt;$不是BCNF,即有$X\to A$在$F_i^+$中且X不包含$R_i$的码,则将$X\to A$单独从$R_i$中分出来,指定X为新模式的码,将新模式加入$\rho$中(原$R_i$中不再有$X\to A$),转2.</li>
</ol>
<blockquote>
<p>这种分解方法能达到BCNF,但不一定保持原有的函数依赖</p>
</blockquote>
<h4 id="达到3NF并保持函数依赖的算法"><a href="#达到3NF并保持函数依赖的算法" class="headerlink" title="达到3NF并保持函数依赖的算法"></a>达到3NF并保持函数依赖的算法</h4><ol>
<li>求出$F$的最小覆盖$F_m$</li>
<li>找出不在$F_m$中出现的属性,将它们从U中分离出来构成一个新的关系模式(这个关系模式的码是全码)</li>
<li>若有$X\to A \in F_m$ ，且XA=U，则$\rho$={R}，算法终止</li>
<li>对FC按具有相同左部的原则进行分组（设为k组），每一组函数依赖所涉及的属性全体为Ui，令$F_i$为$F_m$在$U_i$上的投影，则$\rho$ = {R1&lt;U1 ,F1&gt; ,… , Rk&lt;Uk , Fk&gt;}是R&lt;U , F&gt;的一个保持函数依赖的分解，并且每个Ri&lt;Ui , Fi&gt; $\in$ 3NF</li>
</ol>
<blockquote>
<p>这种分解算法可能有损</p>
</blockquote>
<h4 id="达到3NF并保持无损分解和函数依赖的算法"><a href="#达到3NF并保持无损分解和函数依赖的算法" class="headerlink" title="达到3NF并保持无损分解和函数依赖的算法"></a>达到3NF并保持无损分解和函数依赖的算法</h4><p>在上一个算法后继续进行操作</p>
<ol start="5">
<li>考虑R的码X,若X在某个$U_i$中,则无需进行操作,否则需要将{&lt;X,$F_X$&gt;}加入到$\rho$中</li>
</ol>
<blockquote>
<p>这种分解算法不一定能达到BCNF</p>
</blockquote>
<h1 id="七、数据库设计"><a href="#七、数据库设计" class="headerlink" title="七、数据库设计"></a>七、数据库设计</h1><h2 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h2><ul>
<li>广义上,数据库设计是设计整个数据库应用系统</li>
<li>狭义上,数据库设计就是设计数据库本身</li>
</ul>
<p>特点:</p>
<ul>
<li>数据库设计是三分技术,七分管理,十二分基础数据</li>
<li>数据库设计是结构(数据)设计和行为(处理)设计的结合</li>
</ul>
<p>数据库设计方法:</p>
<ul>
<li>手工设计法</li>
<li>规范设计法:如新奥尔良法</li>
<li>基于ER模型的设计方法</li>
<li>3NF设计方法</li>
<li>ODL方法</li>
<li>UML方法</li>
</ul>
<p>数据库设计工具: SYSBASE等</p>
<p>数据库设计基本步骤:</p>
<ol>
<li>需求分析: 了解和分析用户需求</li>
<li>概念结构设计: 综合,归纳,抽象用户需求,形成概念模型(ER图 )<blockquote>
<p>需求分析和概念结构设计独立于任何DBMS系统</p>
</blockquote>
</li>
<li>逻辑结构设计: 将概念模型转化成数据模型,并进行数据模型优化</li>
<li>物理结构设计: 为数据模型选取一个物理结构(存储结构和存取方法设计),并评价设计,预测性能;不满意需要重新进行逻辑设计<blockquote>
<p>逻辑结构设计和物理结构设计与选用数据库系统相关</p>
</blockquote>
</li>
<li>数据库实施: 进行物理实现和实验性运行;不满意需要返回物理结构或逻辑结构设计</li>
<li>数据库运行和维护</li>
</ol>
<p>设计一个完善的数据库应用系统是上述6个阶段的不断反复</p>
<h2 id="7-2-需求分析"><a href="#7-2-需求分析" class="headerlink" title="7.2 需求分析"></a>7.2 需求分析</h2><p>需求分析是分析用户的需求,是设计数据库的起点</p>
<p>任务: 通过了解原系统的工作情况,调查应用的环境,明确用户的需求,从而确定新系统的功能</p>
<ul>
<li>调查重点是数据和处理两方面</li>
</ul>
<p>方法:</p>
<ol>
<li>调查组织机构总体情况</li>
<li>熟悉业务活动<blockquote>
<p>上述两点需要数据库设计人员和用户进行对接</p>
</blockquote>
</li>
<li>明确用户的需求</li>
<li>确定系统的边界: 设计数据字典,设计用户需求规格说明书</li>
<li>概念设计等…</li>
</ol>
<p>数据字典:</p>
<ul>
<li>数据字典是对数据库中数据的描述,为元数据;它是一种数据的数据</li>
<li>数据字典在需求分析阶段建立,在数据库设计过程总不断修改充实完善; 是详细数据收集和分析获得的主要结果<blockquote>
<p>数据字典内容</p>
<ul>
<li>数据项: 数据最小组成单位; 有含义说明,取值范围和函数依赖等描述</li>
<li>数据结构: 由若干个数据项或数据结构组成</li>
<li>数据流: 由数据结构,数据流来源,数据流去向等组成; 描述数据结构在系统内部传输的路径</li>
<li>数据存储: 是数据结构停留或保存的地方,也是数据流的来源和去向之一</li>
<li>处理过程: 是从输入数据流到输出数据流的转换; 具体逻辑一般用判定表或判定树表示</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h2><p>概念结构设计: 将需求分析得到的用户需求抽象为信息结构(概念模型)的过程</p>
<p>概念模型是现实世界的一种抽象</p>
<h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p>实体-联系模型称为E-R模型,它用E-R图来描述现实世界的概念模型</p>
<p>实体之间的联系:</p>
<ul>
<li><p>一对一联系: 对于两个实体集中的每一个实体,它至多只与对方实体集中的一个实体有联系,则称两个实体集具有一对一联系,记为1:1</p>
<blockquote>
<p>当然,这并不要求每一个实体都得和另一个实体有联系</p>
</blockquote>
</li>
<li><p>一对多联系: 对于实体集A中的每一个实体,实体集B中有多个实体与之联系,反之实体集B中的实体最多只能和A中的一个实体有联系,则称实体集A与实体集B有一对多联系,记为1:n</p>
</li>
<li><p>多对多联系: 于实体集A中的每一个实体,实体集B中有多个实体与之联系,反之亦然, 则称实体集A与实体集B有多对多联系,记为m:n</p>
<blockquote>
<p>多个实体围绕一个动作也可以形成一对一等联系,单个实体内部也可以形成联系</p>
</blockquote>
</li>
<li><p>联系的度: 把参与联系的实体的数据称为联系的度,N个实体之间的联系的度为N,称为N元联系</p>
</li>
</ul>
<p>E-R模型表示:</p>
<ul>
<li>实体型: 用矩形表示,矩形内写明实体名; 如学生</li>
<li>属性: 用椭圆形表示,由无向边和实体型连接</li>
<li>联系: 用菱形表示,框内标注联系名,用无向边与有关实体联系起来,同时在边上标明联系的类型(n:m); 联系也可以有自己的属性,由无向边连接</li>
</ul>
<h3 id="扩展的E-R模型"><a href="#扩展的E-R模型" class="headerlink" title="扩展的E-R模型"></a>扩展的E-R模型</h3><p>扩展的E-R模型用于丰富基本E-R模型的表达能力</p>
<h4 id="ISA联系"><a href="#ISA联系" class="headerlink" title="ISA联系"></a>ISA联系</h4><ul>
<li>ISA联系用三角形表示,表明某些实体是某个实体的子类型</li>
<li>子类继承了父类的所有属性,同时也可以有自己的属性</li>
</ul>
<p>分类属性:</p>
<ul>
<li>分类属性是父实体型的一个属性</li>
<li>分类属性的值把夫实体型中的实体分派到子实体型中</li>
</ul>
<p><img src="/2020/04/16/data-base1/ISA.jpg" alt="isa"></p>
<p>约束:</p>
<ul>
<li>不相交约束: 表明父类某个实体最多只能属于一个子类实体集; 此时三角形中需要有一个叉号</li>
<li>完备性约束: 表明父类中的某个实体必须是某一个子类中的实体,又称完全特化; 此时父类到子类之间的线用双线表示</li>
</ul>
<p><img src="/2020/04/16/data-base1/ISA1.jpg" alt="isa"></p>
<h4 id="基数约束"><a href="#基数约束" class="headerlink" title="基数约束"></a>基数约束</h4><ul>
<li>技术约束用于表明一个实体可以在联系中出现的次数上下限</li>
<li>这是一个一对一,一对多,多对多联系的细化</li>
<li>约束用一个数对min..max表示,标注在联系和实体之间,max为’*‘时表示无穷大</li>
</ul>
<p><img src="/2020/04/16/data-base1/restrain0.jpg" alt="res"></p>
<p>约束类型:</p>
<ul>
<li>强制参与约束: min=1,表明被施加约束的实体型中的每个实体都要参与联系</li>
<li>非强制参与约束: min=0,表明被施加约束的实体型中的实体可以出现在联系中,也可以不出现在联系中</li>
</ul>
<h4 id="PART-OF联系"><a href="#PART-OF联系" class="headerlink" title="PART-OF联系"></a>PART-OF联系</h4><ul>
<li>PART-OF联系用于描述某个实体型是另外一个实体型的一部分</li>
</ul>
<p>PART-OF联系的分类:</p>
<ul>
<li>非独占联系: 整体实体如果被破坏,部分实体仍可以独立存在</li>
<li>独占联系: 整体实体如果被破坏,则部分实体不能存在<blockquote>
<ul>
<li>非独占联系可以用用非强制参与的一对多联系表示(0..1)</li>
<li>独占联系需要用弱实体类型和识别联系表示</li>
</ul>
</blockquote>
</li>
</ul>
<p>弱实体类型和识别联系:</p>
<ul>
<li>弱实体类型表明该实体型的存在依赖于其他实体型的存在(否则为强实体型); 弱实体型用双矩形表示</li>
<li>独占联系用双菱形表示</li>
</ul>
<p><img src="/2020/04/16/data-base1/PO0.jpg" alt="partof"></p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><ul>
<li>UML为统一建模语言,是对象管理组织的一个标准</li>
<li>UML中的类大致对应E-R图中的实体</li>
</ul>
<p>用UML的类图表示E-R图:</p>
<ul>
<li>实体型: 用类表示; 矩形框上部记录实体名,下部列出属性名</li>
<li>实体的码: 在类图中的属性后面加上’PK’表示码</li>
<li>联系: 用类图之间的关联来表示</li>
<li>基数约束: 和E-R图中的基数约束表示类似</li>
<li>UML中的子类和E-R图中的ISA联系一致</li>
</ul>
<p><img src="/2020/04/16/data-base1/UML0.jpg" alt="UML"></p>
<h3 id="概念结构设计方法"><a href="#概念结构设计方法" class="headerlink" title="概念结构设计方法"></a>概念结构设计方法</h3><h4 id="实体与属性的划分原则"><a href="#实体与属性的划分原则" class="headerlink" title="实体与属性的划分原则"></a>实体与属性的划分原则</h4><p>实体和属性的划分方法:</p>
<ul>
<li>对需求分析阶段收集到的数据进行分类,组织</li>
<li>确定实体,实体的属性,实体之间的联系类型</li>
</ul>
<p>原则:</p>
<ul>
<li>现实世界的事物能以属性对待的,尽量以属性对待,这可以简化E-R图的处理</li>
<li>作为属性,不能再具有需要描述的性质; 即它必须是不可分的数据项,不能包含其他属性</li>
<li>属性不能与其他实体具有联系; 联系应当是实体之间的联系</li>
</ul>
<h4 id="分E-R图的设计"><a href="#分E-R图的设计" class="headerlink" title="分E-R图的设计"></a>分E-R图的设计</h4><ul>
<li>先设计分E-R图的草图: 先写出框架</li>
<li>对E-R图进行详细的设计和调整: 填入一些细节,加入一些具体的联系,填入如联系名等</li>
</ul>
<h4 id="E-R图的集成"><a href="#E-R图的集成" class="headerlink" title="E-R图的集成"></a>E-R图的集成</h4><p>合并: 解决各E-R图之间的冲突,将分E-R图合并,生成初步的E-R图</p>
<ul>
<li>属性冲突: 属性值的类型,取值范围,取值单位冲突</li>
<li>命名冲突: 同名异义,异名同义<blockquote>
<ul>
<li>命名冲突在在实体,联系,属性中都可能发生</li>
<li>命名冲突需要根据具体情况解决</li>
</ul>
</blockquote>
</li>
<li>结构冲突：<blockquote>
<ul>
<li>同一对象在不同应用中有不同的抽象,需要统一(全是实体或全是属性)</li>
<li>同一实体在不同子系统的E-R图中的属性个数和次序不同; 需要取各系统属性的并集,再适当调整次序</li>
<li>实体间的联系再不同E-R图中有不同的类型; 需要根据语义进行调整</li>
</ul>
</blockquote>
</li>
</ul>
<p>消除不必要的冗余,设计基本E-R图:</p>
<ul>
<li>冗余的数据: 可由基本数据导出的数据</li>
<li>冗余的联系: 可由其他联系导出的联系</li>
<li>消除冗余的方法: 分析法,规范化理论法<blockquote>
<p>规范化理论: </p>
<ol>
<li>确定分E-R图之间的数据依赖,可以通过联系的类型来确定函数依赖集F</li>
<li>求F的最小覆盖G,求差集D=F-G</li>
<li>注意考察D中的函数依赖,确定是否为冗余依赖,若是则将其去除<br>注意: 冗余的联系一定在D中,反之不然;当实体之间存在多种联系时,需要将其在形式上加以区分</li>
</ol>
</blockquote>
</li>
</ul>
<p>一个例子:<br><img src="/2020/04/16/data-base1/example0.jpg" alt="example"></p>
<h2 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h2><p>任务: 将概念结构的E-R图转换为DBMS产品支持的逻辑结构</p>
<ul>
<li>就目前关系数据库而言,其逻辑结构为一组关系模式的集合<br><img src="/2020/04/16/data-base1/logic.jpg" alt="logic"><h3 id="E-R图向关系模型的转换"><a href="#E-R图向关系模型的转换" class="headerlink" title="E-R图向关系模型的转换"></a>E-R图向关系模型的转换</h3></li>
<li>实体型的转换: 一个实体型转换为一个关系模式<blockquote>
<ul>
<li>属性: 实体的各属性</li>
<li>码: 实体的码</li>
</ul>
</blockquote>
</li>
<li>实体型间的一对一联系:<blockquote>
<p>转换为独立的关系模式</p>
<ul>
<li>属性: 与该联系相连的各实体的码以及联系本身的属性</li>
<li>码: 每个实体的码都是该关系模式的候选码<br>将上述关系模式合并到相连的任意一个关系模式中(更倾向)</li>
<li>属性: 原关系模式属性加上上述属性</li>
<li>码: 上述的码</li>
</ul>
</blockquote>
</li>
<li>实体间的一对多联系:<blockquote>
<p>转换为一个独立的关系模式</p>
<ul>
<li>属性: 与该联系相连的各实体的码以及联系本身的属性</li>
<li>码: n端的实体的码(即多端的实体的码)<br>与n端的关系模式合并(更倾向)</li>
<li>属性: n端关系模式属性加上上述属性</li>
<li>码: n端实体的码</li>
</ul>
</blockquote>
</li>
<li>实体间的多对多联系:转换成一个独立的关系模式<blockquote>
<ul>
<li>属性: 各实体的码以及联系本身的属性</li>
<li>码: 各实体的码的组合</li>
</ul>
</blockquote>
</li>
<li>三个或以上实体间的一个多元联系: 转换成一个独立的关系模式</li>
<li>可以合并具有相同码的关系模式(减少关系个数)<blockquote>
<ul>
<li>将其中一个关系模式的全部属性加入另一个关系模式中</li>
<li>去掉同义的属性,并适当调整属性的次序</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="数据模型的优化"><a href="#数据模型的优化" class="headerlink" title="数据模型的优化"></a>数据模型的优化</h3><p>数据库逻辑设计结果不是唯一的,需要运用规范化理论进行修改和调整</p>
<blockquote>
<ul>
<li>确定数据依赖</li>
<li>对各个关系模式之间的数据依赖进行极小化处理,消除冗余</li>
<li>确定各关系模式属于的范式</li>
<li>按要求对各关系模式进行合并或分解<br>注意:</li>
<li>规范化通常的代价是更多的连接运算</li>
<li>非BCNF的关系模式只会存在更新异常,不会存在查询异常,若实际应用中只是查询为主,则高范式对关系模式没有实际影响</li>
</ul>
</blockquote>
<h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><p>考虑局部应用的特殊需求和用户体验,可由视图机制来定义用户子模式</p>
<ul>
<li>使用更符合用户习惯的别名</li>
<li>针对不同级别的用户定义不同的视图,提高系统的安全性</li>
<li>简化用户对系统的使用</li>
</ul>
<h2 id="7-5-物理结构设计"><a href="#7-5-物理结构设计" class="headerlink" title="7.5 物理结构设计"></a>7.5 物理结构设计</h2><p>物理设计: 为逻辑数据模型选取一个最适合应用要求的物理结构,包括物理设备上的存储结构和存取方法</p>
<p><img src="/2020/04/16/data-base1/phys0.jpg" alt="phys"></p>
<h3 id="物理设计的内容和方法"><a href="#物理设计的内容和方法" class="headerlink" title="物理设计的内容和方法"></a>物理设计的内容和方法</h3><p>内容:</p>
<ul>
<li>为关系模式选择存取方法(建立存取路径)</li>
<li>为关系,索引,日志,备份等数据库文件选择物理存储结构</li>
</ul>
<p>设计原则:</p>
<ul>
<li>充分了解应用环境: 分析运行的事物,选择设计所需参数</li>
<li>充分了解RDBMS内部特征: 了解系统提供的存取方法和存储结构,如索引等<blockquote>
<p>物理数据库设计参数</p>
<ul>
<li>数据库查询事务: 查询所涉及的关系,属性等</li>
<li>数据更新事务: 被更新的关系,所设计的属性等</li>
<li>每个事务在各关系上运行的频率和性能要求</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="关系模式存取方法选择"><a href="#关系模式存取方法选择" class="headerlink" title="关系模式存取方法选择"></a>关系模式存取方法选择</h3><h4 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h4><p>建立索引可以提高存取效率,索引存取方法的选择需要根据应用要求确定</p>
<blockquote>
<ul>
<li>对哪些属性列建立索引</li>
<li>对哪些索引要设计唯一索引,组合索引</li>
<li>选择合适的索引方法</li>
</ul>
</blockquote>
<p>创建索引:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">USING</span> &lt;索引方法&gt;] (列<span class="number">1</span> [,列<span class="number">2</span>,...]);</span><br></pre></td></tr></table></figure>
<ul>
<li>RDBMS提供的索引方法: B-tree(缺省),hash,R-tree,Bitmap等</li>
</ul>
<p>在某属性(组)上选择索引存取方法的一般规则:</p>
<ul>
<li>某属性(组)经常在查询条件中</li>
<li>一个属性(组)常作为聚集函数(最值)的参数</li>
<li>一个属性(组)常在连接操作的条件中出现</li>
</ul>
<p>索引建立会带来维护,查找,存储索引的开销</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树特点:</p>
<ul>
<li>多分平衡树,存取效率高</li>
<li>能随机查找也能顺序查找</li>
<li>增删改操作中能通过算法保持树平衡  </li>
</ul>
<p>B+树结构如下:<br><img src="/2020/04/16/data-base1/B0.jpg" alt="B"></p>
<ul>
<li>随机查找: 与每一层进行一次比较,若在叶节点中找到码值相等的记录,则根据指针取出相应记录<blockquote>
<p>若B+树完全存储在文件中,则进行一次比较消耗一次IO操作;若找到相等的节点,最后取记录也消耗一次IO操作</p>
</blockquote>
</li>
<li>范围查找: 先找到起始记录(码值最小的记录),然后沿着叶节点链向后查找,直到码值超出范围</li>
</ul>
<h4 id="hash存取方法"><a href="#hash存取方法" class="headerlink" title="hash存取方法"></a>hash存取方法</h4><p>hash通过散列函数将key与record一一对应起来</p>
<p>hash存取方法适用下列情况:</p>
<ul>
<li>一个关系属性主要出现在等值连接条件或等值比较选择条件中</li>
<li>该关系大小可预知,且不变</li>
<li>该关系大小动态改变,但所选用DBMS提供了动态hash存取方法</li>
</ul>
<h4 id="聚簇方法"><a href="#聚簇方法" class="headerlink" title="聚簇方法"></a>聚簇方法</h4><p>聚簇: 通过将属性(组)上具有相同值的元组集中存放在连续的物理块上,提高某个属性(组)的查询速度(减少IO操作)</p>
<blockquote>
<p>上述属性(组)称为聚簇码</p>
</blockquote>
<p>聚簇建立:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CLUSTER &lt;聚簇名&gt; (&lt;聚簇码&gt;) <span class="keyword">SIZE</span> (&lt;大小&gt;);</span><br></pre></td></tr></table></figure>

<p>适用范围:</p>
<ul>
<li>对单个关系进行独立聚簇,也适用多个关系组合聚簇</li>
<li>SQL语句中包含有与聚簇码有关的排序,聚集,集合交并操作时,使用聚簇可以省去或减少对结果集的排序操作</li>
<li>很少对基表进行增删操作</li>
<li>很少对其中的变长列进行修改操作</li>
</ul>
<p>局限性:</p>
<ul>
<li>一个基本表上最多只能建立一个聚簇索引</li>
<li>聚簇只能提高某些特定应用的性能</li>
<li>建立与维护聚簇开销相当大<blockquote>
<ul>
<li>聚簇建立会导致关系中元组的物理存储位置移动,使关系上原有的索引失效,需要重建索引</li>
<li>当一个元组聚簇码改变时,它的存储位置也要相应改变</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="确定数据的存储结构"><a href="#确定数据的存储结构" class="headerlink" title="确定数据的存储结构"></a>确定数据的存储结构</h4><p>基本原则:</p>
<ul>
<li>易变部分和稳定部分分开存放</li>
<li>经常存取的部分和存取频率较低的部分分开存放</li>
<li>将日志和数据库对象分开存放</li>
</ul>
<h4 id="评价物理结构"><a href="#评价物理结构" class="headerlink" title="评价物理结构"></a>评价物理结构</h4><p>物理设计可以有多种方案,需要从中选择一个较优的方案进行实现</p>
<p>方法:</p>
<ul>
<li>定量估算各种方案<blockquote>
<p>存储空间,存取时间,维护代价等</p>
</blockquote>
</li>
<li>对估算结构进行权衡比较,选择出一个较优的合理的物理结构</li>
<li>返回用户,征求意见,修改设计</li>
</ul>
<h2 id="7-6-数据库的实施和维护"><a href="#7-6-数据库的实施和维护" class="headerlink" title="7.6 数据库的实施和维护"></a>7.6 数据库的实施和维护</h2><p>示意图:<br><img src="/2020/04/16/data-base1/act0.jpg" alt></p>
<h3 id="数据的载入和应用程序的调试"><a href="#数据的载入和应用程序的调试" class="headerlink" title="数据的载入和应用程序的调试"></a>数据的载入和应用程序的调试</h3><ul>
<li>定义数据库结构: 用DDL语言创建基本表,视图,索引等(产生目标模式,生成数据字典)</li>
<li>数据装载: 数据抽取,数据转换,数据载入(ETL)<blockquote>
<p>数据装载相当费时费力,可以使用DBMS提供的ETL工具辅助完成</p>
</blockquote>
</li>
<li>编制调试应用程序: 数据库设计和数据库应用程序设计是并行的,在数据库实施阶段应当进行编制与调试数据库的应用程序<blockquote>
<p>此时可以使用一些模拟数据</p>
</blockquote>
<h3 id="数据库试运行"><a href="#数据库试运行" class="headerlink" title="数据库试运行"></a>数据库试运行</h3></li>
</ul>
<p>在调试完成后,让一小部分数据入库,对数据库系统进行综合的调试; 这里可以包括功能测试和性能测试</p>
<ul>
<li>数据库性能指标的测量: 需要测量实际运行的性能指标,若不符合设计目标,需要返回物理设计阶段调整物理结构,甚至返回逻辑设计阶段调整逻辑结构</li>
<li>数据的分期入库: 先输入小批量数据供先期联合调试; 待试运行基本合格后再输入大批量数据; 逐步增加数据量来逐步完成运行评价</li>
<li>数据库的转储和恢复: 做好数据库的转储和恢复工作,尽量减少对数据库的破坏</li>
</ul>
<h3 id="数据库的运行和维护"><a href="#数据库的运行和维护" class="headerlink" title="数据库的运行和维护"></a>数据库的运行和维护</h3><p>数据库的运行和维护主要由数据库管理员完成</p>
<ul>
<li>数据库的转储和恢复<blockquote>
<ul>
<li>针对不同的应用要求制定不同的转储计划,定期对数据库和日志文件进行备份</li>
<li>一旦发生介质故障,需要利用数据库备份及日志文件备份尽快将数据库恢复到某种一致性的状态</li>
</ul>
</blockquote>
</li>
<li>数据库安全性,完整性控制<blockquote>
<ul>
<li>初始定义: 数据库管理员根据用户实际需求授予不同的操作权限</li>
<li>修改定义: 应用环境发生变化时,数据库管理员需要根据实际情况修改原有的安全控制和完整性约束条件</li>
</ul>
</blockquote>
</li>
<li>数据库性能的监督,分析和改进<blockquote>
<ul>
<li>利用监测工具获取系统运行过程中的性能参数值</li>
<li>分析数据判断系统的运行状态是否最佳</li>
<li>适时通过调整某些参数来改进数据库的性能</li>
</ul>
</blockquote>
</li>
<li>数据库的重组织与重构造: 记录的增删改查会影响数据库的物理存储,降低数据库存储空间利用率,使得数据库性能下降<blockquote>
<ul>
<li>重组织: 按原设计要求重新安排存储位置,回收垃圾,减少指针链(这不会破坏数据库的逻辑结构和物理结构)</li>
<li>重构造: 增加新的应用或实体,修改某些已有应用; 根据新环境调整数据库的模式和内模式<br>注意,重构造数据库的程度是有限的, 当应用需求变化太大或者软硬件发展太快导致重构数据库代价太大时,需要重新设计数据库应用系统了,原有数据库应用系统的生命周期已经结束</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="八、数据库编程"><a href="#八、数据库编程" class="headerlink" title="八、数据库编程"></a>八、数据库编程</h1><p>问题: 一些要求无法使用SQL语言表达</p>
<p>突破SQL语言局限性的解决方案:</p>
<ul>
<li>利用高级语言的表达能力: 嵌入式SQL</li>
<li>扩展SQL语言: 过程化SQL</li>
<li>在一个更大的视野上将数据库看成是一类数据源: ODBC编程</li>
</ul>
<h2 id="8-1-嵌入式SQL"><a href="#8-1-嵌入式SQL" class="headerlink" title="8.1 嵌入式SQL"></a>8.1 嵌入式SQL</h2><h3 id="C语言中的SQL基本语法"><a href="#C语言中的SQL基本语法" class="headerlink" title="C语言中的SQL基本语法"></a>C语言中的SQL基本语法</h3><p>基本格式: <code>EXEC SQL &lt;语句块;&gt;</code></p>
<p>主语言程序编译过程:</p>
<blockquote>
<ol>
<li>编写含嵌入式SQL语句的主语言程序</li>
<li>预编译程序,将嵌入式SQL变为函数调用(形式上消除SQL)</li>
<li>正常编译主语言程序</li>
</ol>
</blockquote>
<p>主语言访问数据库的基本步骤</p>
<blockquote>
<ol>
<li>打开数据库</li>
<li>定义必要的主变量和数据通信区</li>
<li>用SQL访问数据库,并对返回结果进行处理</li>
<li>关闭数据库</li>
</ol>
</blockquote>
<h4 id="建立数据库连接"><a href="#建立数据库连接" class="headerlink" title="建立数据库连接"></a>建立数据库连接</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CONNECT TO &lt;服务器名&gt; [AS &lt;连接名&gt;] [USER &lt;用户名&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器名是要连接的数据库服务器的名字,可以是<blockquote>
<ul>
<li>服务器标识串,如<dbname>@<hostname>:<port></port></hostname></dbname></li>
<li>包含服务器标识的SQL串常量</li>
<li>DEFAULT</li>
</ul>
</blockquote>
</li>
<li>整个程序内只有一个连接时可以不指定连接名</li>
<li>可以通过<code>EXEC SQL CONNECTION &lt;连接名&gt;|DEFAULT</code>来修改当前的连接</li>
</ul>
<h4 id="定义主变量与数据通讯区"><a href="#定义主变量与数据通讯区" class="headerlink" title="定义主变量与数据通讯区"></a>定义主变量与数据通讯区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>; <span class="comment">/*主变量说明开始*/</span> </span><br><span class="line">    &lt;变量类型&gt; &lt;变量名&gt;;</span><br><span class="line">    &lt;类型&gt; &lt;名&gt;;...</span><br><span class="line">EXEC SQL <span class="keyword">END</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>; <span class="comment">/*主变量说明结束*/</span></span><br><span class="line">long SQLCODE;</span><br><span class="line">EXEC SQL INCLUDE SQLCA; <span class="comment">/*定义SQL通信区*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这些数据的定义一般在函数外定义</li>
<li>后面SQL查询所INTO的变量需要在主变量说明中定义</li>
</ul>
<h4 id="执行相关SQL语句"><a href="#执行相关SQL语句" class="headerlink" title="执行相关SQL语句"></a>执行相关SQL语句</h4><p>所有SQL语句都可以通过执行,包括数据的定义控制更新查询</p>
<p>查询:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">SELECT</span> &lt;属性<span class="number">1</span>&gt; [,&lt;属性<span class="number">2</span>&gt;,...]</span><br><span class="line">    <span class="keyword">INTO</span>:&lt;主变量<span class="number">1</span>&gt; [,:&lt;主变量<span class="number">2</span>&gt;,...]</span><br><span class="line">    <span class="keyword">FROM</span> ...</span><br><span class="line">    <span class="keyword">WHERE</span> ...</span><br><span class="line">    ...;</span><br></pre></td></tr></table></figure>
<ul>
<li>INTO子句用于保存查询结果</li>
<li>前面带”:”标识的变量为主变量,即主语言的变量<blockquote>
<ul>
<li>INTO,WHERE,HAVING中都可以使用主变量</li>
<li>返回的记录中某些列的值可能为NULL</li>
<li>主变量只能存储一条记录,若返回多条记录则程序出错</li>
</ul>
</blockquote>
</li>
</ul>
<p>增删改:</p>
<ul>
<li>增删改中的SET和WHERE子句中可以使用主变量</li>
<li>使用SET时,需要在主程序中将相应的值赋给主变量</li>
</ul>
<h4 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DISCONNECT &lt;连接名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>高级语言是一种过程性语言(执行命令),而SQL语言是描述性语言(描述集合)</p>
<p>通信机制:</p>
<ul>
<li>状态信息传递: 利用SQL通信区,向主语言传递SQL语句的执行状态信息,使主语言能够控制程序流程</li>
<li>参数传递: 利用主变量,让主语言向SQL语句提供参数</li>
<li>结果传递: 使用主变量和游标,将SQL语句查询结果返回给主语言</li>
</ul>
<h4 id="SQL通信区SQLCA"><a href="#SQL通信区SQLCA" class="headerlink" title="SQL通信区SQLCA"></a>SQL通信区SQLCA</h4><p>用途:</p>
<ul>
<li>在执行完SQL语句后,DBMS将系统的当前工作状态和运行环境送到通信区返回给应用程序,应用程序根据这些信息决定接下来的动作</li>
</ul>
<p>SQLCA是一个数据结构(SQL Communication Area)</p>
<p>使用方法:</p>
<ul>
<li>定义: <code>EXEC SQL INCLUDE SQLCA</code></li>
<li>使用: SQL的返回代码会存储在SQLCODE中,SQLCODE为SUCCESS则表示语句成功,否则出错</li>
</ul>
<h4 id="主变量"><a href="#主变量" class="headerlink" title="主变量"></a>主变量</h4><p>主变量是在SQL语句中使用的主语言程序变量</p>
<ul>
<li>输入主变量: 由应用程序赋值,SQL语句引用</li>
<li>输出主变量: 由SQL语句对其赋值或设置状态信息, 返回给应用程序</li>
<li>指示变量: 整型变量,可以带在主变量后面; 用于指示输入或输出主变量的值是否为空值<blockquote>
<p>例1: </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">SELECT</span> Sno,Cno,Grade</span><br><span class="line">   <span class="keyword">INTO</span> :Hsno,:Hcno,:Hgrade:Gradeid  <span class="comment">/*指示变量Gradeid*/</span></span><br><span class="line">   <span class="keyword">FROM</span>  SC</span><br><span class="line">   <span class="keyword">WHERE</span> Sno=:givensno <span class="keyword">AND</span> Cno=:givencno </span><br></pre></td></tr></table></figure>
<p>若Gradeid&lt;0,不论Hgrade为何值,Hgrade都为空  </p>
<p>例2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradeid=-1</span><br><span class="line"> EXEC SQL <span class="keyword">INSERT</span> </span><br><span class="line"> <span class="keyword">INTO</span> SC(Sno,Cno,Grade)                 <span class="keyword">VALUES</span>(:stdno,:couno,:gr:gradeid); </span><br></pre></td></tr></table></figure>
<p>此时Grade插入的是空值</p>
</blockquote>
</li>
</ul>
<p>使用主变量和指示变量需要事先声明</p>
<ul>
<li>声明之后的主变量可以在主程序中或SQL中任何一个可以使用表达式的地方使用</li>
<li>SQL中的主变量之前要加上’:’以示区别</li>
<li>指示变量必须紧跟主变量之后使用,也需要加上’:’区别</li>
<li>SQL之外的主变量正常使用即可</li>
</ul>
<h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><ul>
<li>INTO主变量的方式只能得到一条查询结果</li>
<li>游标是数据库系统为用户开设的数据缓冲区,用于存放SQL语句的执行结果,可以是多条查询结果(集合)</li>
<li>每个游标区有一个名字,可以看成该缓冲区的指针</li>
<li>可以用SQL语句逐一从游标中获取记录赋给主变量</li>
</ul>
<p>何时使用游标:</p>
<ul>
<li>查询结果为多条SELECT语句</li>
<li>CURRENT形式的UPDATE和DELETE语句</li>
</ul>
<p>游标声明:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> &lt;游标名&gt; <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span> &lt;<span class="keyword">SELECT</span>语句&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>该语句是一条说明性语句并不执行SELECT语句,只是申请一个数据空间来存放未来的执行结果</li>
</ul>
<p>打开游标:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时游标中定义的SELECT语句被执行,查询结果被放到缓冲区中</li>
<li>此时游标处于活动状态,指针指向查询结果的第一条记录</li>
</ul>
<p>推进游标:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH &lt;游标名&gt;</span><br><span class="line">    INTO &lt;主变量1&gt;[, &lt;主变量2&gt;, ...];</span><br></pre></td></tr></table></figure>
<ul>
<li>每执行一次该语句,指针将指向的记录赋给主变量,并将指针后移一位</li>
</ul>
<p>关闭游标:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CLOSE &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭游标,释放缓冲区以及占用的其他资源</li>
<li>游标被关闭后,就不再和原来的结果集相联系; 但可以再次打开游标,重新生成并连接结果集</li>
</ul>
<p>CURRENT形式的UPDATE和DELETE语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span></span><br><span class="line">    &lt;删改语句&gt;</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时游标应事先打开</li>
<li>删除或修改的是游标指针目前指向的记录</li>
<li>一般使用方法: 先用游标SELECT出所有满足条件的记录; 再推进游标,找到想要修改或删除的记录; 最后使用CURRENT语句删改该记录<blockquote>
<p>注意: 当游标SELECT语句中带有UNION或ORDER BY等子句,删改操作无法转换成对基本表的删改,此时无法使用CURRENT形式的删改语句</p>
</blockquote>
</li>
</ul>
<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>有些SQL语句无法在编译阶段就确定下来,需要在程序执行时才能确定,称为动态嵌入式SQL</p>
<ul>
<li>它允许程序在运行过程中临时”组装”出SQL语句</li>
<li>支持动态组装SQL语句和动态参数两种形式</li>
</ul>
<h4 id="SQL语句主变量"><a href="#SQL语句主变量" class="headerlink" title="SQL语句主变量"></a>SQL语句主变量</h4><p>语句主变量定义:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>;</span><br><span class="line">    const char *stmt="&lt;SQL语句字符串&gt;";</span><br><span class="line">EXEC SQL <span class="keyword">END</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>;</span><br></pre></td></tr></table></figure>

<p>执行动态SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">EXECUTE</span> <span class="keyword">IMMEDIATE</span> :stmt; <span class="comment">/*stmt为字符串常量指针名*/</span></span><br></pre></td></tr></table></figure>

<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><p>动态参数是上面SQL语句主变量中的可变元素,使用参数符号’?’标识; 其输入是在程序执行过程中完成绑定</p>
<p>声明SQL语句主变量例:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *stmt = "INSERT INTO table VALUES(?);";</span><br></pre></td></tr></table></figure>

<p>准备SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">PREPARE</span> &lt;语句名&gt; <span class="keyword">FROM</span> &lt;<span class="keyword">SQL</span>语句主变量(:stmt)&gt;;</span><br></pre></td></tr></table></figure>

<p>执行SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">EXECUTE</span> &lt;语句名&gt;</span><br><span class="line">    [<span class="keyword">INTO</span> &lt;主变量表&gt;]</span><br><span class="line">    [<span class="keyword">USING</span> &lt;主变量或常量&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>此时用INTO和USING后面的内容来与前面的(?)相绑定</li>
</ul>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/04/16/data-base1/" data-id="cka3crhph000ovcvn4k0o4m0z"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
    
      <a href="/2020/04/12/Unithon%20%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92%E4%B9%A6%E6%A8%A1%E6%9D%BF/" class="article-nav-link">
        <strong class="article-nav-caption">Next Post</strong>
        <div class="article-nav-title">Unithon 项目计划书模板</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: 'ze0YzGUMUrLXgdRQpKyDCEEm-gzGzoHsz',
        app_key: 'NnhAiNVNGXwbCD1sMGNRjA8B',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: 'Leave your comments here ~',
        recordIP: true,
        lang: 'en'
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2020
        George Chen
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="George"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HOME</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives/">ARCHIVE</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">CATE.</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">TAGS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://github.com/georgechen1827/" target="_blank" rel="noopener">about me</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/coming_soon.html" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>







<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>