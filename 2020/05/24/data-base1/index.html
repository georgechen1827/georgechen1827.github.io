<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="this is George Chen&#39;s blog!" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    数据库原理与设计(高级篇) |  George
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>


  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      <section class="outer">
  <article id="post-data-base1" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数据库原理与设计(高级篇)
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/24/data-base1/" class="article-date">
  <time datetime="2020-05-24T12:45:00.000Z" itemprop="datePublished">2020-05-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/notes/">notes</a> / <a class="article-category-link" href="/categories/notes/%E5%AD%A6%E4%BD%8D%E8%AF%BE%E7%A8%8B/">学位课程</a>
  </div>

      
      
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> about </span>
            <span class="post-count">20.1k words</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> costs </span>
            <span class="post-count">71 minutes</span>
        </span>
    </span>
</div>

      
    </div>
    

    
    
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>未完结,持续更新</p>
<hr>
<p>任课教师: 赵朋朋<a href="http://web.suda.edu.cn/ppzhao/" target="_blank" rel="noopener">http://web.suda.edu.cn/ppzhao/</a></p>
<p>网课资源: 慕课中国人民大学数据库系统概论<a href="https://www.icourse163.org/learn/RUC-1001655006" target="_blank" rel="noopener">https://www.icourse163.org/learn/RUC-1001655006</a></p>
<p>参考教材: 高等教育出版社《数据库系统概论(第5版)》</p>
<p>课程主要讲述关系型数据库的原理, 不着重于具体数据库的使用</p>
<p>在高级篇中,从管理系统的角度来介绍DBMS系统,用使用和应用的角度来讲解数据库设计的方法</p>
<p>数据库原理与设计(基础篇)见<a href="http://georgechen.top/2020/02/27/data-base0/" target="_blank" rel="noopener">http://georgechen.top/2020/02/27/data-base0/</a></p>
<a id="more"></a>

<h1 id="六、关系数据理论"><a href="#六、关系数据理论" class="headerlink" title="六、关系数据理论"></a>六、关系数据理论</h1><h2 id="6-1-关系数据理论的提出"><a href="#6-1-关系数据理论的提出" class="headerlink" title="6.1 关系数据理论的提出"></a>6.1 关系数据理论的提出</h2><p>需要解决的问题:怎么根据具体问题构造出一个合适的数据模式;即,什么是一个好的数据库逻辑设计</p>
<p>好的关系模式不会因为数据冗余而发生:</p>
<blockquote>
<ul>
<li>存储空间浪费</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常<br>因此,好的关系模式数据冗余应尽可能少(但较少的冗余度可能会降低增删改查时的效率)</li>
</ul>
</blockquote>
<p>问题的根源:数据依赖</p>
<h3 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h3><p>数据库中,数据依赖是完整性约束的一种表现形式,是数据库模式设计的关键</p>
<ul>
<li>限定属性的取值范围</li>
<li>定义属性间的相互关联(一般以相等关系体现)</li>
</ul>
<p>现实生活中,数据依赖是</p>
<blockquote>
<ul>
<li>现实世界属性间相互联系的抽象</li>
<li>数据内在的性质</li>
<li>语义的体现</li>
</ul>
</blockquote>
<p>数据依赖的类型</p>
<blockquote>
<ul>
<li>函数依赖FD</li>
<li>多值依赖MVD</li>
<li>连接依赖</li>
<li>…</li>
</ul>
</blockquote>
<p>不适合的数据依赖会造成插入、删除、更新异常和数据冗余问题</p>
<h3 id="关系模式的简化表示"><a href="#关系模式的简化表示" class="headerlink" title="关系模式的简化表示"></a>关系模式的简化表示</h3><p>$R&lt;U,F&gt;$是一个简化表示的关系模式</p>
<blockquote>
<ul>
<li>$U$:关系的属性集合</li>
<li>$F$: 属性间数据依赖的关系集合<br>当且仅当$U$上的一个关系r满足$F$时,r为关系模式$R$的一个关系</li>
</ul>
</blockquote>
<h2 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集.若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等;则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。X称为这个函数依赖的决定属性组，也称为决定因素(Determinant)。</p>
<blockquote>
<ul>
<li>Y依赖于X:X相等则Y相等</li>
<li>X确定了那么Y也确定了</li>
</ul>
</blockquote>
<p>注意: </p>
<blockquote>
<ul>
<li>函数依赖是语义范畴的概念,只能根据数据的语义来确定函数依赖,而不能根据数据的具体形式来反推可能的函数依赖</li>
<li>函数依赖确定后,所有的关系实例都要满足该约束条件<br>当然,数据库设计者可以对现实世界做强制的规定来使得某两个属性产生函数依赖;如:不允许有学生重名,则学生的其他信息可以依赖于学生姓名</li>
</ul>
</blockquote>
<h4 id="平凡函数依赖和非平凡函数依赖"><a href="#平凡函数依赖和非平凡函数依赖" class="headerlink" title="平凡函数依赖和非平凡函数依赖"></a>平凡函数依赖和非平凡函数依赖</h4><ul>
<li>$X\to Y,Y\subseteq X,X\to Y$为非平凡函数依赖</li>
<li>$X\to Y,Y\not \subseteq X,X\to Y$为平凡函数依赖</li>
</ul>
<p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明， 我们总是讨论非平凡 函数依赖。</p>
<h4 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h4><ul>
<li>$X\to Y$,且对于任意的$X’ \subsetneq X,X \not \to Y$,则$X\to Y$为完全函数依赖,记作$X$-F-&gt;$Y$(Full)</li>
<li>非完全函数依赖记作$X$-P-&gt;$Y$(Part)<blockquote>
<p>注意,X是一个属性的集合</p>
</blockquote>
</li>
</ul>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><ul>
<li>$X\to Y,Y \to Z 且 Y \not \subseteq X,Y \not \to X$时,称Z传递函数依赖于X,X传递(函数)确定Z,记作$X$-传递-&gt;$Z$<blockquote>
<p>注意,若$Y\to X$,则$Z$直接依赖于$X$</p>
</blockquote>
</li>
</ul>
<h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖*"></a>多值依赖*</h3><p>函数依赖中X确定一个单值Y,但有时给定X的值x,它能确定多个Y的值;在插入x时,需要插入多条(x,y)元组才能符合这种依赖关系,而且这种依赖关系是隐式的,十分不方便.</p>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote>
<ul>
<li>候选码: $R&lt;U,F&gt;$中,$K \subset U,K$-F-&gt;$U$,则K为R的一个(候选)码</li>
<li>超码: 上述情况下$K$-P-&gt;$U$</li>
<li>主码: 若R有多个候选码,则选定其中一个作为主码</li>
<li>全码: 整个属性组都是码,称为全码(候选码为整个属性组)<br>候选码长度是超码长度的一个极小值,即候选码的任意一个真子集都不是候选码</li>
</ul>
</blockquote>
<h4 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h4><ul>
<li>任意一个候选码中的任意一个属性都为主属性</li>
<li>不包含在任何码中的属性为非主属性(非码属性)</li>
</ul>
<h4 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h4><ul>
<li>$R&lt;U,F&gt;$中属性(组)$X$不是$R$的(候选)码,但$X$是另外一个关系模式的码,则称$X$是$R$的外部码</li>
</ul>
<p>主码与外码一起提供了表示关系间联系的手段</p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式是符合某一种级别的关系模式的集合</p>
<p>关系数据库中的关系必须满足一定的要求,满足不同程度要求的为不同范式</p>
<p>范式种类(级别由低到高):</p>
<ul>
<li>第一范式1NF: 关系模式的最低要求</li>
<li>第二范式2NF: 消除非主属性对码的部分函数依赖</li>
<li>第三范式3NF: 消除非主属性对码的传递函数依赖</li>
<li>修正的第三范式BCNF: 消除主属性对码的部分和传递函数依赖</li>
<li>第四范式4NF: 消除非平凡且非函数依赖的多值依赖</li>
<li>第五范式5NF: 消除非候选码所蕴含的连接依赖<blockquote>
<ul>
<li>低级别的范式一定包含高级别的范式</li>
<li>某一关系模式R为第n范式,记为$R \in nNF$</li>
</ul>
</blockquote>
</li>
</ul>
<p>一个低一级范式的关系模式,通过模式分解可以转化成若干个高一级范式的关系模式的集合,这种过程叫做规范化</p>
<p>关系数据库的规范化理论是数据库逻辑设计的工具</p>
<h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>如果一个关系模式$R$的所有属性都是不可分的基本数据项,则$R\in 1NF$</p>
<blockquote>
<ul>
<li>即,不能表中嵌表</li>
<li>所有的关系数据库模式都满足第一范式,第一范式是对关系模式的最起码的要求;不满足第一范式的数据库模式不能称为关系数据模式</li>
</ul>
</blockquote>
<p>然而,满足第一范式的关系模式不一定是一个好的关系模式</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>若关系模式$R \in 1NF$,且每一个非主属性都完全依赖于$R$的码,则$R \in 2NF$</p>
<ul>
<li>即,$R$中码的任何一部分都不能单独决定一些属性,这些属性必须由整个码来确定<blockquote>
<p>能够单独决定一些属性的码需要被独立成另外的关系</p>
</blockquote>
</li>
<li>不符合第二范式的关系模式会产生问题<blockquote>
<ul>
<li>插入异常: 数据库不能插入一些只包含部分合理信息的元组(码的其他部分也得被确定下来)</li>
<li>删除异常: 数据库有时不能将元组的部分信息合理删除(这些信息可能包含码的部分)</li>
<li>数据冗余</li>
<li>修改复杂: 修改元组部分信息时,表中其他元组的部分信息也得被修改(数据冗余造成的)<br>根本原因: 一些属性部分依赖于码</li>
</ul>
</blockquote>
</li>
<li>解决上述问题的方法: 投影分解法,消除部分依赖,使得关系符合第二范式</li>
</ul>
<p>但是,第二范式并不能完全消除关系模式中异常情况和修改复杂、数据冗余情况,因为有传递函数依赖的存在</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>若关系模式$R \in 1NF$,且不存在这样的码$X$、属性<strong>组</strong>$Y$以及非主属性$Z(Z\not \subset Y)$,使得$X\to Y,Y \to Z,Y \not \to X$成立($Z$不传递依赖于X),则$R \in 3NF$</p>
<ul>
<li>传递函数依赖的存在使得一些信息被”隐式”地存储在表中,需要将它们独立成另外的关系</li>
</ul>
<p>性质:</p>
<blockquote>
<ul>
<li>第三范式关系中的每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码</li>
<li>若R属于第三范式,那么R必定属于第二范式</li>
<li>采用投影分解法能将一个第二范式关系分解成多个第三范式关系</li>
</ul>
</blockquote>
<p>然而,第三范式还是不能完全消除关系模式中的各种异常情况和数据冗余,因为主属性之间也会存在依赖</p>
<h4 id="修正的第三范式-BCNF"><a href="#修正的第三范式-BCNF" class="headerlink" title="修正的第三范式(BCNF)"></a>修正的第三范式(BCNF)</h4><p>若关系模式$R \in 1NF$,且对$R$中每个函数依赖$X\to Y 且 Y\not \in X时$,X必含有码,则$R \in BCNF$</p>
<p>性质:</p>
<blockquote>
<ul>
<li>所有非主属性对每一个码都是完全函数依赖</li>
<li>所有主属性对每一个不包含它的码都是完全函数依赖</li>
<li>没有任何属性完全函数依赖于一些非码属性(不存在传递函数依赖)</li>
<li>符合BCNF的范式一定符合3NF,反之不然<br>BCNF在函数依赖范畴内已经实现了模式的彻底分解,达到了最高的规范化程度,消除了操作异常的诸多问题</li>
</ul>
</blockquote>
<h2 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a>6.3 数据依赖的公理系统</h2><p>数据依赖的公理系统式模式分解算法的理论基础</p>
<p>Armstrong公理系统式函数依赖的一个有效而完备的公理系统</p>
<h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><p>Armstrong公理系统是一套推理规则,用于回答某个函数依赖是否被某组函数依赖F蕴含</p>
<blockquote>
<ul>
<li>有效性: 由F出发根据Armstrong公理推导出的每一个函数依赖一定在$F^+$中</li>
<li>完备性: $F^+$中的每一个函数依赖必定可以由Armstrong公理推导出来</li>
</ul>
</blockquote>
<h3 id="逻辑蕴涵的定义"><a href="#逻辑蕴涵的定义" class="headerlink" title="逻辑蕴涵的定义"></a>逻辑蕴涵的定义</h3><p>对于满足一组函数依赖F的关系模式$R(U,F)$,对符合它的任意关系r,若都有函数依赖$X\to Y$成立,则称F(逻辑)蕴涵$X\to Y$</p>
<h3 id="几个导出的推理规则"><a href="#几个导出的推理规则" class="headerlink" title="几个导出的推理规则"></a>几个导出的推理规则</h3><p>设U为属性集总体, F是U上的一组函数依赖, 对关系$R&lt;U,F&gt;$ 来说, 有以下的推理规则: </p>
<blockquote>
<ul>
<li>自反律: 若$Y \subseteq X \subseteq U$,则F蕴含$X\to Y$</li>
<li>增广律: 若F蕴含$X\to Y$且$Z\subseteq U$,则F蕴含$XZ\to YZ$</li>
<li>传递律: 若F蕴含$X\to Y和Y\to Z$,则F蕴含$X\to Z$</li>
</ul>
</blockquote>
<p>上述三个推理规则可以进一步得到以下几个推理规则:</p>
<blockquote>
<ul>
<li>合并规则: 由$X\to Y,X\to Z$,可以得到$X\to YZ$</li>
<li>伪传递规则: 由$X\to Y,YW\to Z$,可以得到$XW\to Z$</li>
<li>分解规则: 由$X\to Y,Z \subseteq Y$,可以得到$X\to Z$</li>
</ul>
</blockquote>
<p>根据合并规则和分解规则可以得到下述重要引理:</p>
<blockquote>
<ul>
<li>$X\to A_1A_2…A_n$成立的充要条件是$X\to A_i(i=1,2,…n)$</li>
</ul>
</blockquote>
<h3 id="函数依赖闭包"><a href="#函数依赖闭包" class="headerlink" title="函数依赖闭包"></a>函数依赖闭包</h3><h4 id="定义和一些引理"><a href="#定义和一些引理" class="headerlink" title="定义和一些引理"></a>定义和一些引理</h4><ul>
<li>在关系模式$R&lt;U,F&gt;$中被F所蕴含的函数依赖的全体称为F的闭包,记作$F^+$</li>
<li>设F为属性集U上的一组函数依赖,$X\subseteq U$,$X_{F^+} = \lbrace A | X\to A能由F根据Armstrong公理导出 \rbrace$,称为属性集X关于函数依赖集F的闭包<blockquote>
<ul>
<li>$X_{F^+}$表示属性组X能根据F推导出的所有属性</li>
<li>$F^+$不容易直接求出,在考虑某函数依赖是否在$F^+$中时,需要转化成对$X_{F^+}$的判定</li>
</ul>
</blockquote>
</li>
</ul>
<p>关于闭包的引理</p>
<ul>
<li>F为属性集U上的一组函数依赖,X Y为U上的两个属性组;$X\to Y$能由F根据Armstrong公理导出的充要条件是$Y\subseteq X_{F^+}$<blockquote>
<ul>
<li>判断$X\to Y$是否在$F^+$中,只需判断Y是否是$X_{F^+}$的子集</li>
<li>若$X_{F^+}=U$,则X为R的候选码</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="求-X-F-的算法"><a href="#求-X-F-的算法" class="headerlink" title="求$X_{F^+}$的算法"></a>求$X_{F^+}$的算法</h4><p>遵循如下迭代算法求取$X_{F^+}$:</p>
<ol>
<li>令$X_{add} = \emptyset$</li>
<li>扫描F,将能根据X或部分X推导出的元素加入$X_{add}$</li>
<li>$X = X \cup X_{add}$</li>
<li>若X并没有改变,则得到结果$X_{F^+}$,否则转1.</li>
</ol>
<h3 id="函数依赖集的一些性质"><a href="#函数依赖集的一些性质" class="headerlink" title="函数依赖集的一些性质"></a>函数依赖集的一些性质</h3><h4 id="函数依赖集的等价"><a href="#函数依赖集的等价" class="headerlink" title="函数依赖集的等价"></a>函数依赖集的等价</h4><p>两个函数依赖集$F$和$G$,若$F^+=G^+$,则$F$与$G$等价(F覆盖G,F是G的覆盖或反之)</p>
<ul>
<li>函数依赖集的等价是指它们的闭包等价</li>
</ul>
<h4 id="最小-极小-依赖集"><a href="#最小-极小-依赖集" class="headerlink" title="最小(极小)依赖集"></a>最小(极小)依赖集</h4><p>满足下列条件的依赖集F称为一个最小依赖集</p>
<blockquote>
<ul>
<li>F中任意一个函数依赖的右边只含有一个属性</li>
<li>F中的每个函数依赖的左边均为最小属性集<ul>
<li>若存在一个函数依赖$X\to A$,使得去掉这条依赖中X的部分属性,得到的函数依赖集F’与F等价,则原F不是最小依赖集</li>
</ul>
</li>
<li>F中的每个函数依赖均不能由F中其他的函数依赖导出</li>
</ul>
</blockquote>
<h4 id="求最小依赖集的算法"><a href="#求最小依赖集的算法" class="headerlink" title="求最小依赖集的算法"></a>求最小依赖集的算法</h4><ol>
<li>扫描F中的函数依赖,将所有依赖项的右边拆分成单属性</li>
<li>扫描每个函数依赖的左边,去除左边冗余的属性</li>
<li>去掉F中冗余的函数依赖关系</li>
</ol>
<ul>
<li>F的最小依赖集不是唯一的</li>
</ul>
<h2 id="6-4-模式的分解"><a href="#6-4-模式的分解" class="headerlink" title="6.4 模式的分解"></a>6.4 模式的分解</h2><p>关系模式的规范化是通过模式分解来实现的</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>投影:</p>
<ul>
<li>$F_i = \lbrace X\to Y | X\to Y \in F^+ , XY \subseteq U_i \rbrace$ 称为$F$在$U_i$上的投影</li>
</ul>
<p>关系模式的分解:</p>
<ul>
<li>$R&lt;U,F&gt;$的一个分解为$\rho = \lbrace R_1&lt;U_1,F_1&gt;,…,R_n&lt;U_n,F_n&gt;\rbrace$,其中$U = U_1\cup … U_n$, 且不存在$U_i\subseteq U_j$</li>
</ul>
<p>模式分解主要涉及到投影和自然连接两个运算</p>
<h3 id="模式分解的三个目标"><a href="#模式分解的三个目标" class="headerlink" title="模式分解的三个目标"></a>模式分解的三个目标</h3><p>一个模式有多种分解方法,符合一些要求的分解方法才有意义</p>
<blockquote>
<ul>
<li>无损连接分解: 将分解后的多个模式进行自然连接,结果应和原模式一样</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>保持函数依赖: 分解前F的最小依赖集中的每个函数依赖都应该被投影到分解后的某个关系模式中去<ul>
<li>即:$F^+ = (F_1\cup … \cup F_n)^+$</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>达到更高级范式: 分解得到的每个关系模式应该相比于分解前的关系模式达到更高级别的范式</li>
</ul>
</blockquote>
<h3 id="模式分解算法"><a href="#模式分解算法" class="headerlink" title="模式分解算法"></a>模式分解算法</h3><h4 id="达到BCNF并保持无损连接的算法"><a href="#达到BCNF并保持无损连接的算法" class="headerlink" title="达到BCNF并保持无损连接的算法"></a>达到BCNF并保持无损连接的算法</h4><ol>
<li>令$\rho = \lbrace R&lt;U,F&gt; \rbrace$</li>
<li>检查$\rho$中各关系模式是否属于BCNF,若是则返回结果</li>
<li>发现有$R_i&lt;U_i,F_i&gt;$不是BCNF,即有$X\to A$在$F_i^+$中且X不包含$R_i$的码,则将$X\to A$单独从$R_i$中分出来,指定X为新模式的码,将新模式加入$\rho$中(原$R_i$中不再有$X\to A$),转2.</li>
</ol>
<blockquote>
<p>这种分解方法能达到BCNF,但不一定保持原有的函数依赖</p>
</blockquote>
<h4 id="达到3NF并保持函数依赖的算法"><a href="#达到3NF并保持函数依赖的算法" class="headerlink" title="达到3NF并保持函数依赖的算法"></a>达到3NF并保持函数依赖的算法</h4><ol>
<li>求出$F$的最小覆盖$F_m$</li>
<li>找出不在$F_m$中出现的属性,将它们从U中分离出来构成一个新的关系模式(这个关系模式的码是全码)</li>
<li>若有$X\to A \in F_m$ ，且XA=U，则$\rho$={R}，算法终止</li>
<li>对FC按具有相同左部的原则进行分组（设为k组），每一组函数依赖所涉及的属性全体为Ui，令$F_i$为$F_m$在$U_i$上的投影，则$\rho$ = {R1&lt;U1 ,F1&gt; ,… , Rk&lt;Uk , Fk&gt;}是R&lt;U , F&gt;的一个保持函数依赖的分解，并且每个Ri&lt;Ui , Fi&gt; $\in$ 3NF</li>
</ol>
<blockquote>
<p>这种分解算法可能有损</p>
</blockquote>
<h4 id="达到3NF并保持无损分解和函数依赖的算法"><a href="#达到3NF并保持无损分解和函数依赖的算法" class="headerlink" title="达到3NF并保持无损分解和函数依赖的算法"></a>达到3NF并保持无损分解和函数依赖的算法</h4><p>在上一个算法后继续进行操作</p>
<ol start="5">
<li>考虑R的码X,若X在某个$U_i$中,则无需进行操作,否则需要将{&lt;X,$F_X$&gt;}加入到$\rho$中</li>
</ol>
<blockquote>
<p>这种分解算法不一定能达到BCNF</p>
</blockquote>
<h1 id="七、数据库设计"><a href="#七、数据库设计" class="headerlink" title="七、数据库设计"></a>七、数据库设计</h1><h2 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h2><ul>
<li>广义上,数据库设计是设计整个数据库应用系统</li>
<li>狭义上,数据库设计就是设计数据库本身</li>
</ul>
<p>特点:</p>
<blockquote>
<ul>
<li>数据库设计是三分技术,七分管理,十二分基础数据</li>
<li>数据库设计是结构(数据)设计和行为(处理)设计的结合</li>
</ul>
</blockquote>
<p>数据库设计方法:</p>
<blockquote>
<ul>
<li>手工设计法</li>
<li>规范设计法:如新奥尔良法</li>
<li>基于ER模型的设计方法</li>
<li>3NF设计方法</li>
<li>ODL方法</li>
<li>UML方法</li>
</ul>
</blockquote>
<p>数据库设计工具: SYSBASE等</p>
<p>数据库设计基本步骤:</p>
<ol>
<li>需求分析: 了解和分析用户需求</li>
<li>概念结构设计: 综合,归纳,抽象用户需求,形成概念模型(ER图 )<blockquote>
<p>需求分析和概念结构设计独立于任何DBMS系统</p>
</blockquote>
</li>
<li>逻辑结构设计: 将概念模型转化成数据模型,并进行数据模型优化</li>
<li>物理结构设计: 为数据模型选取一个物理结构(存储结构和存取方法设计),并评价设计,预测性能;不满意需要重新进行逻辑设计<blockquote>
<p>逻辑结构设计和物理结构设计与选用数据库系统相关</p>
</blockquote>
</li>
<li>数据库实施: 进行物理实现和实验性运行;不满意需要返回物理结构或逻辑结构设计</li>
<li>数据库运行和维护</li>
</ol>
<p>设计一个完善的数据库应用系统是上述6个阶段的不断反复</p>
<h2 id="7-2-需求分析"><a href="#7-2-需求分析" class="headerlink" title="7.2 需求分析"></a>7.2 需求分析</h2><p>需求分析是分析用户的需求,是设计数据库的起点</p>
<p>任务: 通过了解原系统的工作情况,调查应用的环境,明确用户的需求,从而确定新系统的功能</p>
<ul>
<li>调查重点是数据和处理两方面</li>
</ul>
<p>方法:</p>
<ol>
<li>调查组织机构总体情况</li>
<li>熟悉业务活动<blockquote>
<p>上述两点需要数据库设计人员和用户进行对接</p>
</blockquote>
</li>
<li>明确用户的需求</li>
<li>确定系统的边界: 设计数据字典,设计用户需求规格说明书</li>
<li>概念设计等…</li>
</ol>
<p>数据字典:</p>
<ul>
<li>数据字典是对数据库中数据的描述,为元数据;它是一种数据的数据</li>
<li>数据字典在需求分析阶段建立,在数据库设计过程总不断修改充实完善; 是详细数据收集和分析获得的主要结果<blockquote>
<p>数据字典内容</p>
<ul>
<li>数据项: 数据最小组成单位; 有含义说明,取值范围和函数依赖等描述</li>
<li>数据结构: 由若干个数据项或数据结构组成</li>
<li>数据流: 由数据结构,数据流来源,数据流去向等组成; 描述数据结构在系统内部传输的路径</li>
<li>数据存储: 是数据结构停留或保存的地方,也是数据流的来源和去向之一</li>
<li>处理过程: 是从输入数据流到输出数据流的转换; 具体逻辑一般用判定表或判定树表示</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h2><p>概念结构设计: 将需求分析得到的用户需求抽象为信息结构(概念模型)的过程</p>
<p>概念模型是现实世界的一种抽象</p>
<h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p>实体-联系模型称为E-R模型,它用E-R图来描述现实世界的概念模型</p>
<p>实体之间的联系:</p>
<ul>
<li><p>一对一联系: 对于两个实体集中的每一个实体,它至多只与对方实体集中的一个实体有联系,则称两个实体集具有一对一联系,记为1:1</p>
<blockquote>
<p>当然,这并不要求每一个实体都得和另一个实体有联系</p>
</blockquote>
</li>
<li><p>一对多联系: 对于实体集A中的每一个实体,实体集B中有多个实体与之联系,反之实体集B中的实体最多只能和A中的一个实体有联系,则称实体集A与实体集B有一对多联系,记为1:n</p>
</li>
<li><p>多对多联系: 于实体集A中的每一个实体,实体集B中有多个实体与之联系,反之亦然, 则称实体集A与实体集B有多对多联系,记为m:n</p>
<blockquote>
<p>多个实体围绕一个动作也可以形成一对一等联系,单个实体内部也可以形成联系</p>
</blockquote>
</li>
<li><p>联系的度: 把参与联系的实体的数据称为联系的度,N个实体之间的联系的度为N,称为N元联系</p>
</li>
</ul>
<p>E-R模型表示:</p>
<blockquote>
<ul>
<li>实体型: 用矩形表示,矩形内写明实体名; 如学生</li>
<li>属性: 用椭圆形表示,由无向边和实体型连接</li>
<li>联系: 用菱形表示,框内标注联系名,用无向边与有关实体联系起来,同时在边上标明联系的类型(n:m); 联系也可以有自己的属性,由无向边连接</li>
</ul>
</blockquote>
<h3 id="扩展的E-R模型"><a href="#扩展的E-R模型" class="headerlink" title="扩展的E-R模型"></a>扩展的E-R模型</h3><p>扩展的E-R模型用于丰富基本E-R模型的表达能力</p>
<h4 id="ISA联系"><a href="#ISA联系" class="headerlink" title="ISA联系"></a>ISA联系</h4><ul>
<li>ISA联系用三角形表示,表明某些实体是某个实体的子类型</li>
<li>子类继承了父类的所有属性,同时也可以有自己的属性</li>
</ul>
<p>分类属性:</p>
<blockquote>
<ul>
<li>分类属性是父实体型的一个属性</li>
<li>分类属性的值把夫实体型中的实体分派到子实体型中</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/ISA.jpg" alt="isa"></p>
<p>约束:</p>
<blockquote>
<ul>
<li>不相交约束: 表明父类某个实体最多只能属于一个子类实体集; 此时三角形中需要有一个叉号</li>
<li>完备性约束: 表明父类中的某个实体必须是某一个子类中的实体,又称完全特化; 此时父类到子类之间的线用双线表示</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/ISA1.jpg" alt="isa"></p>
<h4 id="基数约束"><a href="#基数约束" class="headerlink" title="基数约束"></a>基数约束</h4><ul>
<li>技术约束用于表明一个实体可以在联系中出现的次数上下限</li>
<li>这是一个一对一,一对多,多对多联系的细化</li>
<li>约束用一个数对min..max表示,标注在联系和实体之间,max为’*‘时表示无穷大</li>
</ul>
<p><img src="/2020/05/24/data-base1/restrain0.jpg" alt="res"></p>
<p>约束类型:</p>
<blockquote>
<ul>
<li>强制参与约束: min=1,表明被施加约束的实体型中的每个实体都要参与联系</li>
<li>非强制参与约束: min=0,表明被施加约束的实体型中的实体可以出现在联系中,也可以不出现在联系中</li>
</ul>
</blockquote>
<h4 id="PART-OF联系"><a href="#PART-OF联系" class="headerlink" title="PART-OF联系"></a>PART-OF联系</h4><ul>
<li>PART-OF联系用于描述某个实体型是另外一个实体型的一部分</li>
</ul>
<p>PART-OF联系的分类:</p>
<blockquote>
<ul>
<li>非独占联系: 整体实体如果被破坏,部分实体仍可以独立存在</li>
<li>独占联系: 整体实体如果被破坏,则部分实体不能存在</li>
<li>非独占联系可以用用非强制参与的一对多联系表示(0..1)</li>
<li>独占联系需要用弱实体类型和识别联系表示</li>
</ul>
</blockquote>
<p>弱实体类型和识别联系:</p>
<blockquote>
<ul>
<li>弱实体类型表明该实体型的存在依赖于其他实体型的存在(否则为强实体型); 弱实体型用双矩形表示</li>
<li>独占联系用双菱形表示</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/PO0.jpg" alt="partof"></p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><ul>
<li>UML为统一建模语言,是对象管理组织的一个标准</li>
<li>UML中的类大致对应E-R图中的实体</li>
</ul>
<p>用UML的类图表示E-R图:</p>
<blockquote>
<ul>
<li>实体型: 用类表示; 矩形框上部记录实体名,下部列出属性名</li>
<li>实体的码: 在类图中的属性后面加上’PK’表示码</li>
<li>联系: 用类图之间的关联来表示</li>
<li>基数约束: 和E-R图中的基数约束表示类似</li>
<li>UML中的子类和E-R图中的ISA联系一致</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/UML0.jpg" alt="UML"></p>
<h3 id="概念结构设计方法"><a href="#概念结构设计方法" class="headerlink" title="概念结构设计方法"></a>概念结构设计方法</h3><h4 id="实体与属性的划分原则"><a href="#实体与属性的划分原则" class="headerlink" title="实体与属性的划分原则"></a>实体与属性的划分原则</h4><p>实体和属性的划分方法:</p>
<blockquote>
<ul>
<li>对需求分析阶段收集到的数据进行分类,组织</li>
<li>确定实体,实体的属性,实体之间的联系类型</li>
</ul>
</blockquote>
<p>原则:</p>
<blockquote>
<ul>
<li>现实世界的事物能以属性对待的,尽量以属性对待,这可以简化E-R图的处理</li>
<li>作为属性,不能再具有需要描述的性质; 即它必须是不可分的数据项,不能包含其他属性</li>
<li>属性不能与其他实体具有联系; 联系应当是实体之间的联系</li>
</ul>
</blockquote>
<h4 id="分E-R图的设计"><a href="#分E-R图的设计" class="headerlink" title="分E-R图的设计"></a>分E-R图的设计</h4><ul>
<li>先设计分E-R图的草图: 先写出框架</li>
<li>对E-R图进行详细的设计和调整: 填入一些细节,加入一些具体的联系,填入如联系名等</li>
</ul>
<h4 id="E-R图的集成"><a href="#E-R图的集成" class="headerlink" title="E-R图的集成"></a>E-R图的集成</h4><p>合并: 解决各E-R图之间的冲突,将分E-R图合并,生成初步的E-R图</p>
<ul>
<li>属性冲突: 属性值的类型,取值范围,取值单位冲突</li>
<li>命名冲突: 同名异义,异名同义<blockquote>
<ul>
<li>命名冲突在在实体,联系,属性中都可能发生</li>
<li>命名冲突需要根据具体情况解决</li>
</ul>
</blockquote>
</li>
<li>结构冲突：<blockquote>
<ul>
<li>同一对象在不同应用中有不同的抽象,需要统一(全是实体或全是属性)</li>
<li>同一实体在不同子系统的E-R图中的属性个数和次序不同; 需要取各系统属性的并集,再适当调整次序</li>
<li>实体间的联系在不同E-R图中有不同的类型; 需要根据语义进行调整</li>
</ul>
</blockquote>
</li>
</ul>
<p>消除不必要的冗余,设计基本E-R图:</p>
<ul>
<li>冗余的数据: 可由基本数据导出的数据</li>
<li>冗余的联系: 可由其他联系导出的联系</li>
<li>消除冗余的方法: 分析法,规范化理论法<blockquote>
<p>规范化理论: </p>
<ol>
<li>确定分E-R图之间的数据依赖,可以通过联系的类型来确定函数依赖集F</li>
<li>求F的最小覆盖G,求差集D=F-G</li>
<li>注意考察D中的函数依赖,确定是否为冗余依赖,若是则将其去除<br>注意: 冗余的联系一定在D中,反之不然;当实体之间存在多种联系时,需要将其在形式上加以区分</li>
</ol>
</blockquote>
</li>
</ul>
<p>一个例子:<br><img src="/2020/05/24/data-base1/example0.jpg" alt="example"></p>
<h2 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h2><p>任务: 将概念结构的E-R图转换为DBMS产品支持的逻辑结构</p>
<ul>
<li>就目前关系数据库而言,其逻辑结构为一组关系模式的集合<br><img src="/2020/05/24/data-base1/logic.jpg" alt="logic"><h3 id="E-R图向关系模型的转换"><a href="#E-R图向关系模型的转换" class="headerlink" title="E-R图向关系模型的转换"></a>E-R图向关系模型的转换</h3></li>
<li>实体型的转换: 一个实体型转换为一个关系模式<blockquote>
<ul>
<li>属性: 实体的各属性</li>
<li>码: 实体的码</li>
</ul>
</blockquote>
</li>
<li>实体型间的一对一联系:<blockquote>
<p>转换为独立的关系模式</p>
<ul>
<li>属性: 与该联系相连的各实体的码以及联系本身的属性</li>
<li>码: 每个实体的码都是该关系模式的候选码<br>将上述关系模式合并到相连的任意一个关系模式中(更倾向)</li>
<li>属性: 原关系模式属性加上上述属性</li>
<li>码: 上述的码</li>
</ul>
</blockquote>
</li>
<li>实体间的一对多联系:<blockquote>
<p>转换为一个独立的关系模式</p>
<ul>
<li>属性: 与该联系相连的各实体的码以及联系本身的属性</li>
<li>码: n端的实体的码(即多端的实体的码)<br>与n端的关系模式合并(更倾向)</li>
<li>属性: n端关系模式属性加上上述属性</li>
<li>码: n端实体的码</li>
</ul>
</blockquote>
</li>
<li>实体间的多对多联系:转换成一个独立的关系模式<blockquote>
<ul>
<li>属性: 各实体的码以及联系本身的属性</li>
<li>码: 各实体的码的组合</li>
</ul>
</blockquote>
</li>
<li>三个或以上实体间的一个多元联系: 转换成一个独立的关系模式</li>
<li>可以合并具有相同码的关系模式(减少关系个数)<blockquote>
<ul>
<li>将其中一个关系模式的全部属性加入另一个关系模式中</li>
<li>去掉同义的属性,并适当调整属性的次序</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="数据模型的优化"><a href="#数据模型的优化" class="headerlink" title="数据模型的优化"></a>数据模型的优化</h3><p>数据库逻辑设计结果不是唯一的,需要运用规范化理论进行修改和调整</p>
<blockquote>
<ul>
<li>确定数据依赖</li>
<li>对各个关系模式之间的数据依赖进行极小化处理,消除冗余</li>
<li>确定各关系模式属于的范式</li>
<li>按要求对各关系模式进行合并或分解<br>注意:</li>
<li>规范化通常的代价是更多的连接运算</li>
<li>非BCNF的关系模式只会存在更新异常,不会存在查询异常,若实际应用中只是查询为主,则高范式对关系模式没有实际影响</li>
</ul>
</blockquote>
<h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><p>考虑局部应用的特殊需求和用户体验,可由视图机制来定义用户子模式</p>
<ul>
<li>使用更符合用户习惯的别名</li>
<li>针对不同级别的用户定义不同的视图,提高系统的安全性</li>
<li>简化用户对系统的使用</li>
</ul>
<h2 id="7-5-物理结构设计"><a href="#7-5-物理结构设计" class="headerlink" title="7.5 物理结构设计"></a>7.5 物理结构设计</h2><p>物理设计: 为逻辑数据模型选取一个最适合应用要求的物理结构,包括物理设备上的存储结构和存取方法</p>
<p><img src="/2020/05/24/data-base1/phys0.jpg" alt="phys"></p>
<h3 id="物理设计的内容和方法"><a href="#物理设计的内容和方法" class="headerlink" title="物理设计的内容和方法"></a>物理设计的内容和方法</h3><p>内容:</p>
<blockquote>
<ul>
<li>为关系模式选择存取方法(建立存取路径)</li>
<li>为关系,索引,日志,备份等数据库文件选择物理存储结构</li>
</ul>
</blockquote>
<p>设计原则:</p>
<blockquote>
<ul>
<li>充分了解应用环境: 分析运行的事物,选择设计所需参数</li>
<li>充分了解RDBMS内部特征: 了解系统提供的存取方法和存储结构,如索引等<br>物理数据库设计参数<ul>
<li>数据库查询事务: 查询所涉及的关系,属性等</li>
<li>数据更新事务: 被更新的关系,所设计的属性等</li>
<li>每个事务在各关系上运行的频率和性能要求</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="关系模式存取方法选择"><a href="#关系模式存取方法选择" class="headerlink" title="关系模式存取方法选择"></a>关系模式存取方法选择</h3><h4 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h4><p>建立索引可以提高存取效率,索引存取方法的选择需要根据应用要求确定</p>
<blockquote>
<ul>
<li>对哪些属性列建立索引</li>
<li>对哪些索引要设计唯一索引,组合索引</li>
<li>选择合适的索引方法</li>
</ul>
</blockquote>
<p>创建索引:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">USING</span> &lt;索引方法&gt;] (列<span class="number">1</span> [,列<span class="number">2</span>,...]);</span><br></pre></td></tr></table></figure>
<ul>
<li>RDBMS提供的索引方法: B-tree(缺省),hash,R-tree,Bitmap等</li>
</ul>
<p>在某属性(组)上选择索引存取方法的一般规则:</p>
<blockquote>
<ul>
<li>某属性(组)经常在查询条件中</li>
<li>一个属性(组)常作为聚集函数(最值)的参数</li>
<li>一个属性(组)常在连接操作的条件中出现</li>
</ul>
</blockquote>
<p>索引建立会带来维护,查找,存储索引的开销</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树特点:</p>
<blockquote>
<ul>
<li>多分平衡树,存取效率高</li>
<li>能随机查找也能顺序查找</li>
<li>增删改操作中能通过算法保持树平衡  </li>
</ul>
</blockquote>
<p>B+树结构如下:<br><img src="/2020/05/24/data-base1/B0.jpg" alt="B"></p>
<blockquote>
<ul>
<li>随机查找: 与每一层进行一次比较,若在叶节点中找到码值相等的记录,则根据指针取出相应记录<ul>
<li>若B+树完全存储在文件中,则进行一次比较消耗一次IO操作;若找到相等的节点,最后取记录也消耗一次IO操作</li>
</ul>
</li>
<li>范围查找: 先找到起始记录(码值最小的记录),然后沿着叶节点链向后查找,直到码值超出范围</li>
</ul>
</blockquote>
<h4 id="hash存取方法"><a href="#hash存取方法" class="headerlink" title="hash存取方法"></a>hash存取方法</h4><p>hash通过散列函数将key与record一一对应起来</p>
<p>hash存取方法适用下列情况:</p>
<blockquote>
<ul>
<li>一个关系属性主要出现在等值连接条件或等值比较选择条件中</li>
<li>该关系大小可预知,且不变</li>
<li>该关系大小动态改变,但所选用DBMS提供了动态hash存取方法</li>
</ul>
</blockquote>
<h4 id="聚簇方法"><a href="#聚簇方法" class="headerlink" title="聚簇方法"></a>聚簇方法</h4><p>聚簇: 通过将属性(组)上具有相同值的元组集中存放在连续的物理块上,提高某个属性(组)的查询速度(减少IO操作)</p>
<blockquote>
<p>上述属性(组)称为聚簇码</p>
</blockquote>
<p>聚簇建立:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CLUSTER &lt;聚簇名&gt; (&lt;聚簇码&gt;) <span class="keyword">SIZE</span> (&lt;大小&gt;);</span><br></pre></td></tr></table></figure>

<p>适用范围:</p>
<blockquote>
<ul>
<li>对单个关系进行独立聚簇,也适用多个关系组合聚簇</li>
<li>SQL语句中包含有与聚簇码有关的排序,聚集,集合交并操作时,使用聚簇可以省去或减少对结果集的排序操作</li>
<li>很少对基表进行增删操作</li>
<li>很少对其中的变长列进行修改操作</li>
</ul>
</blockquote>
<p>局限性:</p>
<blockquote>
<ul>
<li>一个基本表上最多只能建立一个聚簇索引</li>
<li>聚簇只能提高某些特定应用的性能</li>
<li>建立与维护聚簇开销相当大<ul>
<li>聚簇建立会导致关系中元组的物理存储位置移动,使关系上原有的索引失效,需要重建索引</li>
<li>当一个元组聚簇码改变时,它的存储位置也要相应改变</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="确定数据的存储结构"><a href="#确定数据的存储结构" class="headerlink" title="确定数据的存储结构"></a>确定数据的存储结构</h4><p>基本原则:</p>
<blockquote>
<ul>
<li>易变部分和稳定部分分开存放</li>
<li>经常存取的部分和存取频率较低的部分分开存放</li>
<li>将日志和数据库对象分开存放</li>
</ul>
</blockquote>
<h4 id="评价物理结构"><a href="#评价物理结构" class="headerlink" title="评价物理结构"></a>评价物理结构</h4><p>物理设计可以有多种方案,需要从中选择一个较优的方案进行实现</p>
<p>方法:</p>
<blockquote>
<ul>
<li>定量估算各种方案<ul>
<li>存储空间,存取时间,维护代价等</li>
</ul>
</li>
<li>对估算结构进行权衡比较,选择出一个较优的合理的物理结构</li>
<li>返回用户,征求意见,修改设计</li>
</ul>
</blockquote>
<h2 id="7-6-数据库的实施和维护"><a href="#7-6-数据库的实施和维护" class="headerlink" title="7.6 数据库的实施和维护"></a>7.6 数据库的实施和维护</h2><p>示意图:<br><img src="/2020/05/24/data-base1/act0.jpg" alt></p>
<h3 id="数据的载入和应用程序的调试"><a href="#数据的载入和应用程序的调试" class="headerlink" title="数据的载入和应用程序的调试"></a>数据的载入和应用程序的调试</h3><ul>
<li>定义数据库结构: 用DDL语言创建基本表,视图,索引等(产生目标模式,生成数据字典)</li>
<li>数据装载: 数据抽取,数据转换,数据载入(ETL)<blockquote>
<p>数据装载相当费时费力,可以使用DBMS提供的ETL工具辅助完成</p>
</blockquote>
</li>
<li>编制调试应用程序: 数据库设计和数据库应用程序设计是并行的,在数据库实施阶段应当进行编制与调试数据库的应用程序<blockquote>
<p>此时可以使用一些模拟数据</p>
</blockquote>
<h3 id="数据库试运行"><a href="#数据库试运行" class="headerlink" title="数据库试运行"></a>数据库试运行</h3></li>
</ul>
<p>在调试完成后,让一小部分数据入库,对数据库系统进行综合的调试; 这里可以包括功能测试和性能测试</p>
<ul>
<li>数据库性能指标的测量: 需要测量实际运行的性能指标,若不符合设计目标,需要返回物理设计阶段调整物理结构,甚至返回逻辑设计阶段调整逻辑结构</li>
<li>数据的分期入库: 先输入小批量数据供先期联合调试; 待试运行基本合格后再输入大批量数据; 逐步增加数据量来逐步完成运行评价</li>
<li>数据库的转储和恢复: 做好数据库的转储和恢复工作,尽量减少对数据库的破坏</li>
</ul>
<h3 id="数据库的运行和维护"><a href="#数据库的运行和维护" class="headerlink" title="数据库的运行和维护"></a>数据库的运行和维护</h3><p>数据库的运行和维护主要由数据库管理员完成</p>
<ul>
<li>数据库的转储和恢复<blockquote>
<ul>
<li>针对不同的应用要求制定不同的转储计划,定期对数据库和日志文件进行备份</li>
<li>一旦发生介质故障,需要利用数据库备份及日志文件备份尽快将数据库恢复到某种一致性的状态</li>
</ul>
</blockquote>
</li>
<li>数据库安全性,完整性控制<blockquote>
<ul>
<li>初始定义: 数据库管理员根据用户实际需求授予不同的操作权限</li>
<li>修改定义: 应用环境发生变化时,数据库管理员需要根据实际情况修改原有的安全控制和完整性约束条件</li>
</ul>
</blockquote>
</li>
<li>数据库性能的监督,分析和改进<blockquote>
<ul>
<li>利用监测工具获取系统运行过程中的性能参数值</li>
<li>分析数据判断系统的运行状态是否最佳</li>
<li>适时通过调整某些参数来改进数据库的性能</li>
</ul>
</blockquote>
</li>
<li>数据库的重组织与重构造: 记录的增删改查会影响数据库的物理存储,降低数据库存储空间利用率,使得数据库性能下降<blockquote>
<ul>
<li>重组织: 按原设计要求重新安排存储位置,回收垃圾,减少指针链(这不会破坏数据库的逻辑结构和物理结构)</li>
<li>重构造: 增加新的应用或实体,修改某些已有应用; 根据新环境调整数据库的模式和内模式<br>注意,重构造数据库的程度是有限的, 当应用需求变化太大或者软硬件发展太快导致重构数据库代价太大时,需要重新设计数据库应用系统了,原有数据库应用系统的生命周期已经结束</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="八、数据库编程"><a href="#八、数据库编程" class="headerlink" title="八、数据库编程"></a>八、数据库编程</h1><p>问题: 一些要求无法使用SQL语言表达</p>
<p>突破SQL语言局限性的解决方案:</p>
<blockquote>
<ul>
<li>利用高级语言的表达能力: 嵌入式SQL</li>
<li>扩展SQL语言: 过程化SQL</li>
<li>在一个更大的视野上将数据库看成是一类数据源: ODBC编程接口</li>
</ul>
</blockquote>
<h2 id="8-1-嵌入式SQL"><a href="#8-1-嵌入式SQL" class="headerlink" title="8.1 嵌入式SQL"></a>8.1 嵌入式SQL</h2><h3 id="C语言中的SQL基本语法"><a href="#C语言中的SQL基本语法" class="headerlink" title="C语言中的SQL基本语法"></a>C语言中的SQL基本语法</h3><p>基本格式: <code>EXEC SQL &lt;语句块;&gt;</code></p>
<p>主语言程序编译过程:</p>
<blockquote>
<ol>
<li>编写含嵌入式SQL语句的主语言程序</li>
<li>预编译程序(预编译器由SQL厂商提供),将嵌入式SQL变为函数调用(形式上消除SQL)</li>
<li>正常编译主语言程序</li>
</ol>
</blockquote>
<p>主语言访问数据库的基本步骤</p>
<blockquote>
<ol>
<li>打开数据库</li>
<li>定义必要的主变量和数据通信区</li>
<li>用SQL访问数据库,并对返回结果进行处理</li>
<li>关闭数据库</li>
</ol>
</blockquote>
<h4 id="建立数据库连接"><a href="#建立数据库连接" class="headerlink" title="建立数据库连接"></a>建立数据库连接</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CONNECT TO &lt;服务器名&gt; [AS &lt;连接名&gt;] [USER &lt;用户名&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器名是要连接的数据库服务器的名字,可以是<blockquote>
<ul>
<li>服务器标识串,如<code>&lt;dbname&gt;@&lt;hostname&gt;:&lt;port&gt;</code></li>
<li>包含服务器标识的SQL串常量</li>
<li>DEFAULT</li>
</ul>
</blockquote>
</li>
<li>整个程序内只有一个连接时可以不指定连接名</li>
<li>可以通过<code>EXEC SQL CONNECTION &lt;连接名&gt;|DEFAULT</code>来修改当前的连接</li>
</ul>
<h4 id="定义主变量与数据通讯区"><a href="#定义主变量与数据通讯区" class="headerlink" title="定义主变量与数据通讯区"></a>定义主变量与数据通讯区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>; <span class="comment">/*主变量说明开始*/</span> </span><br><span class="line">    &lt;变量类型&gt; &lt;变量名&gt;;</span><br><span class="line">    &lt;类型&gt; &lt;名&gt;;...</span><br><span class="line">EXEC SQL <span class="keyword">END</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>; <span class="comment">/*主变量说明结束*/</span></span><br><span class="line">long SQLCODE;</span><br><span class="line">EXEC SQL INCLUDE SQLCA; <span class="comment">/*定义SQL通信区*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这些数据的定义一般在函数外定义<ul>
<li>后面SQL查询所INTO的变量需要在主变量说明中定义</li>
</ul>
</li>
</ul>
<h4 id="执行相关SQL语句"><a href="#执行相关SQL语句" class="headerlink" title="执行相关SQL语句"></a>执行相关SQL语句</h4><p>所有SQL语句都可以通过执行,包括数据的定义控制更新查询</p>
<p>查询:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">SELECT</span> &lt;属性<span class="number">1</span>&gt; [,&lt;属性<span class="number">2</span>&gt;,...]</span><br><span class="line">    <span class="keyword">INTO</span>:&lt;主变量<span class="number">1</span>&gt; [,:&lt;主变量<span class="number">2</span>&gt;,...]</span><br><span class="line">    <span class="keyword">FROM</span> ...</span><br><span class="line">    <span class="keyword">WHERE</span> ...</span><br><span class="line">    ...;</span><br></pre></td></tr></table></figure>
<ul>
<li>INTO子句用于保存查询结果</li>
<li>前面带”:”标识的变量为主变量,即主语言的变量<blockquote>
<ul>
<li>INTO,WHERE,HAVING中都可以使用主变量</li>
<li>返回的记录中某些列的值可能为NULL</li>
<li>主变量只能存储一条记录,若返回多条记录则程序出错</li>
</ul>
</blockquote>
</li>
</ul>
<p>增删改:</p>
<blockquote>
<ul>
<li>增删改中的SET和WHERE子句中可以使用主变量</li>
<li>使用SET时,需要在主程序中将相应的值赋给主变量</li>
</ul>
</blockquote>
<h4 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DISCONNECT &lt;连接名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>高级语言是一种过程性语言(执行命令),而SQL语言是描述性语言(描述集合)</p>
<p>通信机制:</p>
<blockquote>
<ul>
<li>状态信息传递: 利用SQL通信区,向主语言传递SQL语句的执行状态信息,使主语言能够控制程序流程</li>
<li>参数传递: 利用主变量,让主语言向SQL语句提供参数</li>
<li>结果传递: 使用主变量和游标,将SQL语句查询结果返回给主语言</li>
</ul>
</blockquote>
<h4 id="SQL通信区SQLCA"><a href="#SQL通信区SQLCA" class="headerlink" title="SQL通信区SQLCA"></a>SQL通信区SQLCA</h4><p>用途:</p>
<ul>
<li>在执行完SQL语句后,DBMS将系统的当前工作状态和运行环境送到通信区返回给应用程序,应用程序根据这些信息决定接下来的动作</li>
</ul>
<p>SQLCA是一个数据结构(SQL Communication Area)</p>
<p>使用方法:</p>
<blockquote>
<ul>
<li>定义: <code>EXEC SQL INCLUDE SQLCA</code></li>
<li>使用: SQL的返回代码会存储在SQLCODE中,SQLCODE为SUCCESS则表示语句成功,否则出错</li>
</ul>
</blockquote>
<h4 id="主变量"><a href="#主变量" class="headerlink" title="主变量"></a>主变量</h4><p>主变量是在SQL语句中使用的主语言程序变量</p>
<blockquote>
<ul>
<li>输入主变量: 由应用程序赋值,SQL语句引用</li>
<li>输出主变量: 由SQL语句对其赋值或设置状态信息, 返回给应用程序</li>
<li>指示变量: 整型变量,可以带在主变量后面; 用于指示输入或输出主变量的值是否为空值<br>例1: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">SELECT</span> Sno,Cno,Grade</span><br><span class="line">   <span class="keyword">INTO</span> :Hsno,:Hcno,:Hgrade:Gradeid  <span class="comment">/*指示变量Gradeid*/</span></span><br><span class="line">   <span class="keyword">FROM</span>  SC</span><br><span class="line">   <span class="keyword">WHERE</span> Sno=:givensno <span class="keyword">AND</span> Cno=:givencno </span><br></pre></td></tr></table></figure>
若Gradeid&lt;0,不论Hgrade为何值,Hgrade都为空  </li>
</ul>
<p>例2:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradeid=-1</span><br><span class="line"> EXEC SQL <span class="keyword">INSERT</span> </span><br><span class="line"> <span class="keyword">INTO</span> SC(Sno,Cno,Grade)                 <span class="keyword">VALUES</span>(:stdno,:couno,:gr:gradeid); </span><br></pre></td></tr></table></figure>
<p>此时Grade插入的是空值</p>
</blockquote>
<p>使用主变量和指示变量需要事先声明</p>
<blockquote>
<ul>
<li>声明之后的主变量可以在主程序中或SQL中任何一个可以使用表达式的地方使用</li>
<li>SQL中的主变量之前要加上’:’以示区别</li>
<li>指示变量必须紧跟主变量之后使用,也需要加上’:’区别</li>
<li>SQL之外的主变量正常使用即可</li>
</ul>
</blockquote>
<h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><ul>
<li>INTO主变量的方式只能得到一条查询结果</li>
<li>游标是数据库系统为用户开设的数据缓冲区,用于存放SQL语句的执行结果,可以是多条查询结果(集合)</li>
<li>每个游标区有一个名字,可以看成该缓冲区的指针</li>
<li>可以用SQL语句逐一从游标中获取记录赋给主变量</li>
</ul>
<p>何时使用游标:</p>
<blockquote>
<ul>
<li>查询结果为多条SELECT语句</li>
<li>CURRENT形式的UPDATE和DELETE语句</li>
</ul>
</blockquote>
<p>游标声明:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> &lt;游标名&gt; <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span> &lt;<span class="keyword">SELECT</span>语句&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>该语句是一条说明性语句并不执行SELECT语句,只是申请一个数据空间来存放未来的执行结果</li>
</ul>
<p>打开游标:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时游标中定义的SELECT语句被执行,查询结果被放到缓冲区中</li>
<li>此时游标处于活动状态,指针指向查询结果的第一条记录</li>
</ul>
<p>推进游标:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH &lt;游标名&gt;</span><br><span class="line">    INTO &lt;主变量1&gt;[, &lt;主变量2&gt;, ...];</span><br></pre></td></tr></table></figure>
<ul>
<li>每执行一次该语句,指针将指向的记录赋给主变量,并将指针后移一位</li>
</ul>
<p>关闭游标:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CLOSE &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭游标,释放缓冲区以及占用的其他资源</li>
<li>游标被关闭后,就不再和原来的结果集相联系; 但可以再次打开游标,重新生成并连接结果集</li>
</ul>
<p>CURRENT形式的UPDATE和DELETE语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span></span><br><span class="line">    &lt;删改语句&gt;</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时游标应事先打开</li>
<li>删除或修改的是游标指针目前指向的记录</li>
<li>一般使用方法: 先用游标SELECT出所有满足条件的记录; 再推进游标,找到想要修改或删除的记录; 最后使用CURRENT语句删改该记录<blockquote>
<p>注意: 当游标SELECT语句中带有UNION或ORDER BY等子句,删改操作无法转换成对基本表的删改,此时无法使用CURRENT形式的删改语句</p>
</blockquote>
</li>
</ul>
<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>有些SQL语句无法在编译阶段就确定下来,需要在程序执行时才能确定,称为动态嵌入式SQL</p>
<blockquote>
<ul>
<li>它允许程序在运行过程中临时”组装”出SQL语句</li>
<li>支持动态组装SQL语句和动态参数两种形式</li>
</ul>
</blockquote>
<h4 id="SQL语句主变量"><a href="#SQL语句主变量" class="headerlink" title="SQL语句主变量"></a>SQL语句主变量</h4><p>语句主变量定义:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>;</span><br><span class="line">    const char *stmt="&lt;SQL语句字符串&gt;";</span><br><span class="line">EXEC SQL <span class="keyword">END</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>;</span><br></pre></td></tr></table></figure>

<p>执行动态SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">EXECUTE</span> <span class="keyword">IMMEDIATE</span> :stmt; <span class="comment">/*stmt为字符串常量指针名*/</span></span><br></pre></td></tr></table></figure>

<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><p>动态参数是上面SQL语句主变量中的可变元素,使用参数符号’?’标识; 其输入是在程序执行过程中完成绑定</p>
<p>声明SQL语句主变量例:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *stmt = "INSERT INTO table VALUES(?);";</span><br></pre></td></tr></table></figure>

<p>准备SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">PREPARE</span> &lt;语句名&gt; <span class="keyword">FROM</span> &lt;<span class="keyword">SQL</span>语句主变量(:stmt)&gt;;</span><br></pre></td></tr></table></figure>

<p>执行SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">EXECUTE</span> &lt;语句名&gt;</span><br><span class="line">    [<span class="keyword">INTO</span> &lt;主变量表&gt;]</span><br><span class="line">    [<span class="keyword">USING</span> &lt;主变量或常量&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>此时用INTO和USING后面的内容来与前面的(?)相绑定</li>
</ul>
<h2 id="8-2-过程化SQL"><a href="#8-2-过程化SQL" class="headerlink" title="8.2 过程化SQL"></a>8.2 过程化SQL</h2><p>目标: 扩展SQL语言本身的能力,加入过程控制的功能</p>
<ul>
<li>过程化SQL尽量减少系统之间的通讯和协同,使得这些功能能被数据库本身完成</li>
</ul>
<p>过程化SQL又称PL/SQL,是对SQL的扩展</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>PL/SQL中</p>
<blockquote>
<ul>
<li>基本结构是块</li>
<li>增加了变量常量的定义,变量的赋值和流程控制语句</li>
</ul>
</blockquote>
<p>定义语句:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">    &lt;变量名&gt; &lt;数据类型&gt; [[<span class="keyword">NOT</span> <span class="literal">NULL</span>] [:=] &lt;初值表达式&gt;];</span><br><span class="line">    &lt;常量名&gt; &lt;数据类型&gt; CONSTANT := &lt;常量表达式&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义的变量,常量生命周期为整个块</li>
<li>常量定义后在作用域中不能再赋值</li>
</ul>
<p>执行语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">    [<span class="keyword">SET</span>] &lt;变量名&gt; := &lt;表达式&gt;;</span><br><span class="line">    </span><br><span class="line">    IF &lt;条件&gt; THEN</span><br><span class="line">        &lt;语句&gt;;</span><br><span class="line">    [ELSE &lt;语句&gt;;]</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    [WHILE &lt;条件&gt;]|    </span><br><span class="line">    [FOR &lt;count&gt; IN [REVERSE] &lt;值1&gt;...&lt;值n&gt;]</span><br><span class="line">    LOOP</span><br><span class="line">        &lt;语句&gt; [EXIT|BREAK|LEAVE];</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    </span><br><span class="line">EXCEPTION</span><br></pre></td></tr></table></figure>

<h3 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h3><p>存储过程: 由过程化SQL书写的一段语句经编译和优化后命名并存储在数据库服务器中待使用时调用的过程</p>
<blockquote>
<p>优点</p>
<ul>
<li>运行效率高</li>
<li>降低客户机和服务器之间的通讯量</li>
<li>方便实施企业规划</li>
</ul>
</blockquote>
<p>过程化SQL块类型:</p>
<blockquote>
<ul>
<li>命名块: 编译后保存在数据库中供反复高效调用,过程和函数是命名块</li>
<li>匿名块: 每次执行都要编译的块,不能被存储和调用</li>
</ul>
</blockquote>
<h4 id="存储过程的用户接口"><a href="#存储过程的用户接口" class="headerlink" title="存储过程的用户接口"></a>存储过程的用户接口</h4><p>创建存储:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt; ([&lt;参数<span class="number">1</span>&gt;,&lt;参数<span class="number">2</span>&gt;,...]) <span class="keyword">AS</span> &lt;过程化<span class="keyword">SQL</span>块&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表: 调用时给出的参数值,需要指定值的数据类型; 参数可定义为输入参数(默认),输出参数和输入/输出参数</li>
<li>过程块: 一个包括声明部分和可执行语句部分的块,过程块中可以调用其他存储过程</li>
</ul>
<p>执行存储过程:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span>|PREFORM <span class="keyword">PROCEDURE</span> &lt;过程名&gt; (&lt;参数列表&gt;);</span><br></pre></td></tr></table></figure>

<p>修改存储过程:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新过程名&gt;;</span><br></pre></td></tr></table></figure>

<p>删除存储过程:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数和存储过程都是持久性的存储过程,但函数必须执行返回值的类型</p>
<p>函数定义:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> &lt;函数名&gt; ([&lt;参数列表&gt;])</span><br><span class="line"><span class="keyword">RETURNS</span> &lt;返回值类型&gt; <span class="keyword">AS</span> &lt;过程化<span class="keyword">SQL</span>块&gt;;</span><br></pre></td></tr></table></figure>

<p>函数执行:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CALL</span>|<span class="keyword">SELECT</span> &lt;函数名&gt; ([&lt;参数列表&gt;]);</span><br></pre></td></tr></table></figure>

<p>修改函数:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> &lt;过程名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新过程名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> &lt;过程名&gt; COMPILE; //重新编译</span><br></pre></td></tr></table></figure>

<h2 id="8-3-ODBC编程"><a href="#8-3-ODBC编程" class="headerlink" title="8.3 ODBC编程"></a>8.3 ODBC编程</h2><p>DOBC提供了一组访问数据库的应用程序编程接口,为不同应用程序对不同数据库的访问提供了同一的接口</p>
<p>ODBC约束力:</p>
<blockquote>
<ul>
<li>规范应用开发</li>
<li>规范关系数据库管理系统应用接口</li>
</ul>
</blockquote>
<h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p>ODBC体系接口:</p>
<blockquote>
<ul>
<li>用户应用程序</li>
<li>ODBC驱动程序管理器</li>
<li>数据库驱动程序</li>
<li>数据源</li>
</ul>
</blockquote>
<ul>
<li>ODBC应用程序:<blockquote>
<ul>
<li>请求连接数据库</li>
<li>断开与数据源的连接</li>
<li>操作数据库以及获取数据库的执行状态</li>
</ul>
</blockquote>
</li>
<li>驱动程序管理器: 用于管理各种驱动程序</li>
<li>数据库驱动程序: 由厂商提供<blockquote>
<p>类型:</p>
<ul>
<li>单束驱动程序: 数据源和应用程序在同一台</li>
<li>多束驱动程序: 支持网络环境下的数据访问</li>
</ul>
</blockquote>
</li>
<li>　数据源: 最终用户需要访问的数据,包含了数据库位置和数据库类型等信息,是一种数据连接的抽象<blockquote>
<p>数据源对最终用户是透明的</p>
</blockquote>
</li>
</ul>
<p>ODBC优点:</p>
<blockquote>
<ul>
<li>应用程序移植性好</li>
<li>能在同一个应用中同时访问不同的数据库</li>
</ul>
</blockquote>
<h3 id="ODBC-API基础"><a href="#ODBC-API基础" class="headerlink" title="ODBC API基础"></a>ODBC API基础</h3><h4 id="函数概述"><a href="#函数概述" class="headerlink" title="函数概述"></a>函数概述</h4><ul>
<li>环境句柄: 管理多个连接句柄,访问不同数据源</li>
<li>连接句柄: 连接某一个数据源(同一个RDBMS下每个数据库可以创建一个数据源)</li>
<li>语句句柄: 执行SQL语句</li>
</ul>
<p>函数接口(ODBC3.0):</p>
<blockquote>
<ul>
<li>分配和释放环境,连接,语句句柄</li>
<li>连接函数: SQLDriverconnect等</li>
<li>与信息相关的函数: SQLGetinfo,SQLGetFunction等</li>
<li>事务处理函数: SQLEndTran</li>
<li>执行相关函数:SQLExecdirect,SQLExecute等</li>
<li>编目函数(数据字典相关)</li>
</ul>
</blockquote>
<h4 id="句柄及其属性"><a href="#句柄及其属性" class="headerlink" title="句柄及其属性"></a>句柄及其属性</h4><ul>
<li>句柄是一个32位整数值,是一个指向程序的指针</li>
<li>每一个ODBC应用程序需要建立一个ODBC环境,分配一个环境句柄,存储数据的全局性背景</li>
<li>一个环境句柄可以建立多个连接句柄,每个连接句柄实现与一个数据源之间的连接</li>
</ul>
<blockquote>
<p>ODBC应用程序-1:1-环境句柄-1:n-连接句柄</p>
<p>连接句柄下可接一个数据源句柄和多个语句或描述符句柄</p>
</blockquote>
<h4 id="ODBC标准数据类型"><a href="#ODBC标准数据类型" class="headerlink" title="ODBC标准数据类型"></a>ODBC标准数据类型</h4><ul>
<li>SQL数据类型: 用于数据源</li>
<li>C数据类型: 用于应用程序的C代码</li>
</ul>
<p>相应数据映射关系参照<a href="https://msdn.microsoft.com/en-us/library/ms714556(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/ms714556(v=vs.85).aspx</a></p>
<p>SQLBindcol用于从SQL结果集列中返回结果到应用程序变量; SQLBindparameter用于从应用程序中传变量到语句参数</p>
<h4 id="ODBC工作流程"><a href="#ODBC工作流程" class="headerlink" title="ODBC工作流程"></a>ODBC工作流程</h4><ol>
<li>配置数据源</li>
<li>初始化环境</li>
<li>连接数据源</li>
<li>分配语句句柄</li>
<li>执行SQL语句</li>
<li>(产生结果集)处理结果集</li>
<li>结束</li>
</ol>
<p>配置数据源:</p>
<blockquote>
<p>在ODBC数据源管理器中添加数据源</p>
</blockquote>
<p>初始化环境:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLHENV henv; &#x2F;&#x2F;声明环境句柄变量</span><br><span class="line">SQLAllocHandle(SQL_HANDLE_ENV,SQL_NULL_HANDLE,&amp;henv); &#x2F;&#x2F;创建环境句柄变量</span><br><span class="line">SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0); &#x2F;&#x2F;初始化环境句柄变量</span><br></pre></td></tr></table></figure>

<p>建立连接:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLHDBC hdbc; &#x2F;&#x2F;声明连接句柄变量</span><br><span class="line">SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc); &#x2F;&#x2F;创建连接句柄变量</span><br><span class="line">SQLConnect(hdbc, &lt;数据源名称&gt;,SQL_NTS, &lt;用户名字符串&gt;,SQL_NTS,&lt;密码字符串&gt;,SQL_NTS); &#x2F;&#x2F;初始化连接句柄变量,连接创建的数据源</span><br></pre></td></tr></table></figure>

<p>分配语句句柄:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQLHSTMT hstmt; &#x2F;&#x2F;声明语句句柄变量</span><br><span class="line">SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp; hstmt); &#x2F;&#x2F;创建语句句柄变量</span><br><span class="line">SQLSetStmtAttr(hstmt,SQL_ATTR_ROW_BIND_TYPE,(S QLPOINTER)SQL_BIND_BY_COLUMN,SQL_IS_INTEGER ); &#x2F;&#x2F;初始化,设置语句句柄属性</span><br></pre></td></tr></table></figure>

<p>执行SQL语句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQLExecDirect(hstmt,&lt;SQL语句字符串&gt;,SQL_NTS); &#x2F;&#x2F;直接执行</span><br><span class="line"></span><br><span class="line">SQLPrepare(hstmt,&lt;SQL语句字符串&gt;, SQL_NTS);</span><br><span class="line">SQLPrepare(hstmt,&lt;SQL语句字符串2&gt;, SQL_NTS);</span><br><span class="line">SQLExecute(hstmt); &#x2F;&#x2F;批量执行</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SQLPrepar中的语句字符串可以带”?”参数,需要通过SQLBindParameter动态绑定</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def SQLRETURN SQLBindparameter(</span><br><span class="line">    &lt;SQL语句句柄&gt;,</span><br><span class="line">    &lt;变量参数位置(从1开始计数)&gt;,</span><br><span class="line">    &lt;指明输入&#x2F;输出标志&gt;, &#x2F;&#x2F;SQL_PARAM_INPUT|SQL_PARAM_OUTPUT|SQL_PARAM_INPUT_OUTPUT</span><br><span class="line">    &lt;用于和参数绑定的C语言的数据类型&gt;,</span><br><span class="line">    &lt;SQL数据类型&gt;,</span><br><span class="line">    &lt;接受数据的宽度(普通变量为0即可)&gt;,</span><br><span class="line">    &lt;SQL类型为NUMERIC或DECIMAL时指明小数点进度(否则为0)&gt;,</span><br><span class="line">    &lt;参数指针指向缓冲区的字节数大小(普通变量为0)&gt;,</span><br><span class="line">    &lt;输入数据字节数大小(普通变量为0)&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例如:</span><br><span class="line"></span><br><span class="line">SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR,SQL_CHAR, SNO_LEN, 0, sSno, 0, &amp;SQL_NTS);</span><br></pre></td></tr></table></figure>

<p>结果集处理(如果产生结果集):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;例: </span><br><span class="line">&#x2F;&#x2F;将查询结果绑定到应用程序缓冲区</span><br><span class="line">SQLBindCol(hstmt, 1, SQL_C_CHAR,sSno,SNO_LEN, &amp;SQLINTEGER); </span><br><span class="line">SQLBindCol(hstmt, 2, SQL_C_CHAR, sName, NAME_LEN, &amp;SQLINTEGER); </span><br><span class="line">SQLBindCol(hstmt, 3, SQL_C_CHAR, sSex, SSEX_LEN, &amp;SQLINTEGER); </span><br><span class="line">SQLBindCol(hstmt, 4, SQL_C_LONG, &amp;sAge, 0, &amp;SQLINTEGER); </span><br><span class="line">SQLBindCol(hstmt, 5, SQL_C_CHAR, sDepart, DEPART_LEN, &amp;SQLINTEGER);</span><br><span class="line">&#x2F;&#x2F;移动游标获取结果集中的每一行数据</span><br><span class="line">while ((ret&#x3D;SQLFetch(hstmt)) !&#x3D;SQL_NO_DATA_FOUND)   </span><br><span class="line">    process(sSno, sName, sSex, sAge, sDepart);</span><br></pre></td></tr></table></figure>

<p>终止处理: 释放语句句柄,释放数据库连接,断开数据库服务器,释放ODBC环境</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQLFreeHandle(SQL_HANDLE_STMT, hstmt); </span><br><span class="line">SQLDisconnect(hdbc); </span><br><span class="line">SQLFreeHandle(SQL_HANDLE_DBC, hdbc); </span><br><span class="line">SQLFreeHandle(SQL_HANDLE_ENV, henv); </span><br><span class="line">SQLFreeHandle(SQL_HANDLE_ENV,serverhenv);</span><br></pre></td></tr></table></figure>

<h1 id="九、关系查询处理"><a href="#九、关系查询处理" class="headerlink" title="九、关系查询处理"></a>九、关系查询处理</h1><h2 id="9-1-SQL语句的处理过程"><a href="#9-1-SQL语句的处理过程" class="headerlink" title="9.1 SQL语句的处理过程"></a>9.1 SQL语句的处理过程</h2><p>处理步骤:<br><img src="/2020/05/24/data-base1/query0.jpg" alt="query"></p>
<h3 id="查询分析"><a href="#查询分析" class="headerlink" title="查询分析"></a>查询分析</h3><p>任务: 对查询语句进行扫描,词法分析和语法分析</p>
<ul>
<li>词法分析: 从查询语句中识别出正确的语言符号</li>
<li>语法分析: 进行语法检查</li>
</ul>
<h3 id="查询检查"><a href="#查询检查" class="headerlink" title="查询检查"></a>查询检查</h3><ul>
<li>有效性检查: 根据数据字典检查语句中的数据库对象是否存在和有效</li>
<li>视图转换: 用视图消解法将对视图的操作转换成对基本表的操作</li>
<li>安全性检查: 根据数据字典对用户权限进行检查</li>
<li>完整性初步检查: 根据数据字典对完整性约束进行检查  </li>
</ul>
<p>检查通过后,SQL语句会被转换成内部表示,一般为语法分析树</p>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>任务: 选择一个高效执行的查询处理策略</p>
<p>分类:</p>
<blockquote>
<ul>
<li>代数/逻辑优化: 针对关系代数表达式进行优化</li>
<li>物理优化: 对存取路径和底层操作算法进行选择优化</li>
</ul>
</blockquote>
<p>查询优化的依据:</p>
<blockquote>
<ul>
<li>基于规则</li>
<li>基于代价</li>
<li>基于语义</li>
</ul>
</blockquote>
<h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><p>任务: 根据优化器得到的执行策略生成查询指向计划</p>
<p>两种执行方法: 自顶向下; 自底向上</p>
<h2 id="9-2-关系算子的实现"><a href="#9-2-关系算子的实现" class="headerlink" title="9.2 关系算子的实现"></a>9.2 关系算子的实现</h2><h3 id="选择操作的实现"><a href="#选择操作的实现" class="headerlink" title="选择操作的实现"></a>选择操作的实现</h3><h4 id="全表扫描法"><a href="#全表扫描法" class="headerlink" title="全表扫描法"></a>全表扫描法</h4><p>对查询的基本表顺序扫描,逐一检查每个元组是否满足选择条件,将符合条件的元组输出</p>
<ul>
<li>适合小表,不适合大表</li>
</ul>
<h4 id="索引扫描法"><a href="#索引扫描法" class="headerlink" title="索引扫描法"></a>索引扫描法</h4><p>通过索引先找出满足条件的元组主码或指针,通过指针直接在查询的基本表中找到元组</p>
<ul>
<li>适合选择条件中的属性上有索引(B+树索引或Hash索引)</li>
</ul>
<h3 id="连接操作的实现"><a href="#连接操作的实现" class="headerlink" title="连接操作的实现"></a>连接操作的实现</h3><h4 id="嵌套循环法"><a href="#嵌套循环法" class="headerlink" title="嵌套循环法"></a>嵌套循环法</h4><p>对外层循环的每一个元组,检查内层循环中的每一个元组是否和前面的元组满足连接条件,满足则输出</p>
<h4 id="排序-合并算法"><a href="#排序-合并算法" class="headerlink" title="排序-合并算法"></a>排序-合并算法</h4><p>先对两表中的连接属性进行排序,取外层循环中的一个元组,将内层循环中第一个和它连接属性相同的元组a进行连接,当遇到一个不能连接的元组时就放弃,取下一个元组,从刚才的a继续往下连接</p>
<ul>
<li>此时连接应为等值连接</li>
</ul>
<h4 id="索引连接算法"><a href="#索引连接算法" class="headerlink" title="索引连接算法"></a>索引连接算法</h4><p>在内层表中对连接属性建立索引,在外层表中,通过索引找到对应的内层表元组进行连接</p>
<ul>
<li>此时连接应为等值连接</li>
</ul>
<h4 id="Hash-Join算法"><a href="#Hash-Join算法" class="headerlink" title="Hash Join算法"></a>Hash Join算法</h4><p>将连接属性作为hash码,将两表中的元组散列到hash表中;(划分阶段)对包含较少元组的表进行一遍处理,将它的元组散列到哈士表的桶中;(试探阶段)对另一个表也按同一个hash函数进行散列,将结果与桶中匹配的元组连接起来</p>
<ul>
<li>前提: 两个表中较小的表在划分阶段时可以完全放入内存的hash桶中</li>
</ul>
<h1 id="十、数据库恢复技术"><a href="#十、数据库恢复技术" class="headerlink" title="十、数据库恢复技术"></a>十、数据库恢复技术</h1><h2 id="10-1-事务"><a href="#10-1-事务" class="headerlink" title="10.1 事务"></a>10.1 事务</h2><p>事务时用户定义的一个数据库操作序列,这组操作是一个不可分割的操作单位; 这些操作要么全做,要么全不做</p>
<blockquote>
<ul>
<li>一个程序中可以包含多个事务</li>
<li>一个事务可以是一条或者多条SQL语句</li>
</ul>
</blockquote>
<p>事务时恢复和并发控制的基本单位</p>
<h3 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h3><p>显式定义:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACRION</span><br><span class="line">    <span class="keyword">SQL</span> &lt;语句<span class="number">1</span>&gt;</span><br><span class="line">    <span class="keyword">SQL</span> &lt;语句<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">COMMIT</span>|<span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure>
<ul>
<li>COMMIT: 提交, 事务正常结束,提交事务的所有操作</li>
<li>ROLLBACK: 主动回滚, 事务异常终止,撤销所有操作,数据库回滚到事务开始的状态</li>
</ul>
<p>隐式定义: 当用户没有显式定义事务时,DBMS按缺省规定自动划分事务</p>
<h3 id="事务的性质"><a href="#事务的性质" class="headerlink" title="事务的性质"></a>事务的性质</h3><p>ACID性质:</p>
<ul>
<li>原子性: 事务是数据库的逻辑工作单位</li>
<li>一致性: 事务执行的结构必须使数据库从一个一致性状态变为另一个一致性状态 (银行转账)<blockquote>
<ul>
<li>一致性状态: 数据库中只包含成功事务的提交结果</li>
<li>不一致状态: 一些未完成事务对数据库所做的修改有一部分被写入物理数据库, 此时数据库处于一种不正确的状态  </li>
</ul>
</blockquote>
</li>
<li>隔离性: 一个事务的执行不能被其他事务干扰 (两个人抢同一张票)<blockquote>
<ul>
<li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li>
<li>并发执行的各个事务之间不能相互干扰</li>
</ul>
</blockquote>
</li>
<li>持续性: 提交的事务对数据库的修改应该是永久性的<blockquote>
<ul>
<li>接下来的其他操作或故障不应该对该事务的执行结果有任何影响</li>
</ul>
</blockquote>
</li>
</ul>
<p>保证事务ACID特性是事务处理的任务</p>
<p>破坏事务ACID特性的因素:</p>
<blockquote>
<ul>
<li>多个事务并行运行,不同事物的操作交叉执行</li>
<li>事务在运行过程中被强行终止<br>数据库管理系统必须保证多个事务交叉运行不影响事务的隔离性; 必须保证被强行终止的事务对数据库和其他事务没有任何影响</li>
</ul>
</blockquote>
<h2 id="10-2-数据库恢复技术"><a href="#10-2-数据库恢复技术" class="headerlink" title="10.2 数据库恢复技术"></a>10.2 数据库恢复技术</h2><p>故障是不可避免的,会影响数据库中数据的正确性,破坏数据库</p>
<p>对策: DBMS必须具有把数据库从错误状态恢复到某一已知的正确状态的功能</p>
<p>恢复子系统是DBMS的一个重要组成部分,恢复技术是衡量系统优劣性的重要指标</p>
<h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a>10.3 故障的种类</h2><h3 id="事务内部的故障"><a href="#事务内部的故障" class="headerlink" title="事务内部的故障"></a>事务内部的故障</h3><ul>
<li>可预期的: 该故障可以通过事务程序本身发现<blockquote>
<p>可预期的故障一般可以通过添加ROLLBACK处理</p>
</blockquote>
</li>
<li>非预期的: 不能由事务程序处理,一般事务故障指的是非预期故障<blockquote>
<ul>
<li>运算溢出</li>
<li>并发事务发生死锁而被选中撤销该事务</li>
<li>违反某些完整性限制而被终止</li>
</ul>
</blockquote>
</li>
</ul>
<p>事务故障意味着事务没有被commit或者被显式的rollback,数据库可能处于不正常的状态</p>
<p>事务故障的恢复: 事务撤销(UNDO)</p>
<blockquote>
<ul>
<li>UNDO表示强行回滚该事务</li>
<li>撤销事务已经做出的任何对数据库的修改,使得该事务像根本没有启动一样</li>
</ul>
</blockquote>
<h3 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h3><p>系统故障指造成系统停止运转的任何事件(需要重启系统)</p>
<blockquote>
<ul>
<li>特定类型的硬件错误</li>
<li>操作系统故障</li>
<li>DBMS代码错误</li>
<li>系统断电</li>
</ul>
</blockquote>
<p>系统故障的影响:</p>
<blockquote>
<ul>
<li>系统的正常运行被突然破坏</li>
<li>所有正在运行的事务被异常终止</li>
<li>内存中数据库缓冲区的信息全部丢失</li>
<li>不破坏数据库</li>
</ul>
</blockquote>
<p>然而此时一些尚未完成的结果可能已经送入物理数据库,使得数据库可能处于不正常的状态</p>
<blockquote>
<p>恢复策略: 系统重启后,恢复程序让所有非正常终止的事务回滚,强行撤销所有未完成的事务</p>
</blockquote>
<p>此时有些已完成的事务可能还留在缓冲区没被写回物理磁盘上</p>
<blockquote>
<p>恢复策略: 撤销所有未完成的事务后,重做所有已提交的事务</p>
</blockquote>
<h3 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h3><p>介质故障又称硬故障,指外存故障</p>
<ul>
<li>介质故障破坏部分或整个数据库,并影响正在存取这部分数据 的所有事务</li>
<li>介质故障发生的可能性较低,但破坏性很大</li>
</ul>
<p>恢复策略: 重装数据库备份文件</p>
<h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><p>计算机病毒是一种人为的破坏,可以繁殖和传播,造成对计算机系统的危害</p>
<p>数据库一旦被破坏仍要用恢复技术把数据库加以恢复 </p>
<h3 id="恢复的要点"><a href="#恢复的要点" class="headerlink" title="恢复的要点"></a>恢复的要点</h3><p>恢复操作的基本原理: 冗余</p>
<p>恢复的实现技术是复杂的,代码占数据库全部代码的10%以上</p>
<h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a>10.4 恢复的实现技术</h2><h3 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h3><p>转储: 数据库管理员定期地将整个数据库复制到磁带,磁盘或其他存储介质上保存起来的过程</p>
<p>备用的数据文本称为后备副本backup或后援副本</p>
<blockquote>
<ul>
<li>被破坏后,数据库可以将后备副本重新装入</li>
<li>后备副本只能将数据库恢复到转储时的状态,后续还需要运行自转储后的所有更新事务</li>
</ul>
</blockquote>
<h4 id="静态转储"><a href="#静态转储" class="headerlink" title="静态转储"></a>静态转储</h4><blockquote>
<ul>
<li>在系统中无运行事务时进行转储操作</li>
<li>转储开始时数据库处于一致性状态</li>
<li>转储期间不允许对数据库进行任何存取,修改活动</li>
</ul>
</blockquote>
<p>优点: 简单,恢复速度较快</p>
<p>缺点: 降低了数据库的可用性</p>
<h4 id="动态转储"><a href="#动态转储" class="headerlink" title="动态转储"></a>动态转储</h4><blockquote>
<ul>
<li>转储操作与用户事务并发进行</li>
<li>转储期间允许对数据库进行存取或修改</li>
<li>动态转储得到的是数据库的一个中间状态,非一致性状态</li>
</ul>
</blockquote>
<p>优点: 不用等待正在允许的用户事务结束; 不会影响新事务的运行</p>
<p>缺点: 不能保证副本中的数据有效</p>
<p>动态转储的故障恢复:</p>
<blockquote>
<ul>
<li>动态转储时: 建立日志文件,对动态转储期间各事务对数据库的修改活动登记</li>
<li>后备副本加上日志文件可以把数据库恢复到某一时刻的正确状态</li>
</ul>
</blockquote>
<h4 id="海量转储"><a href="#海量转储" class="headerlink" title="海量转储"></a>海量转储</h4><p>每次转储全部数据库</p>
<p>特点: 恢复更方便</p>
<h4 id="增量转储"><a href="#增量转储" class="headerlink" title="增量转储"></a>增量转储</h4><p>只转储上次转储后更新过的数据</p>
<p>特点: 适合庞大而且事务处理十分繁杂的数据库</p>
<h3 id="登记日志文件"><a href="#登记日志文件" class="headerlink" title="登记日志文件"></a>登记日志文件</h3><p>日志文件是用来记录事务对数据库的更新操作的文件</p>
<p>两种格式: 以记录为单位的日志和以数据块为单位的日志文件</p>
<h4 id="以记录为单位的日志文件"><a href="#以记录为单位的日志文件" class="headerlink" title="以记录为单位的日志文件"></a>以记录为单位的日志文件</h4><p>一个日志记录应包含(T表示事务标志):</p>
<blockquote>
<ul>
<li>各个事务的开始标记(T1 BEGIN TRANSACTION)</li>
<li>各事务的结束标记(T1 COMMIT/T2 ROLLBACK)</li>
<li>各事务的所有更新操作(包含事务标志,操作类型,操作对象,旧值和新值)</li>
</ul>
</blockquote>
<h4 id="以数据块为单位的日志文件"><a href="#以数据块为单位的日志文件" class="headerlink" title="以数据块为单位的日志文件"></a>以数据块为单位的日志文件</h4><p>包含内容:</p>
<blockquote>
<ul>
<li>事务标志</li>
<li>被更新的数据块</li>
</ul>
</blockquote>
<h4 id="日志文件作用"><a href="#日志文件作用" class="headerlink" title="日志文件作用"></a>日志文件作用</h4><p>用途:</p>
<blockquote>
<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
</blockquote>
<p>静态转储中也可以建立日志文件,利用日志文件重做已完成的事务并撤销未完成的事务; 而不用重新运行事务程序</p>
<p>日志文件登记原则:</p>
<blockquote>
<ul>
<li>等级的次序严格按照并发事务执行的时间次序</li>
<li>必须先写日志文件后写数据库(先记录修改操作后执行i修改)</li>
</ul>
</blockquote>
<h2 id="10-5-恢复策略"><a href="#10-5-恢复策略" class="headerlink" title="10.5 恢复策略"></a>10.5 恢复策略</h2><p>以记录为单位的日志文件格式为例</p>
<h3 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h3><p>事务故障: 事务在运行至正常终止点前被终止</p>
<p>策略: 由恢复子系统利用日志文件撤销该事务对数据库进行的修改</p>
<blockquote>
<p>此恢复过程不需要用户干预</p>
</blockquote>
<p>步骤:</p>
<blockquote>
<ol>
<li>反向扫描日志文件,查找该事务的更新操作</li>
<li>对该事务的更新操作执行逆操作,将更新前的值写入数据库</li>
<li>重复2.直到扫描到该事务的开始标记,事务故障恢复完成</li>
</ol>
</blockquote>
<h3 id="系统故障的恢复"><a href="#系统故障的恢复" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h3><p>系统故障对数据库的影响:</p>
<blockquote>
<ul>
<li>未完成事务的更新操作已经写入数据库</li>
<li>已完成事务的更新操作还留在缓冲区中未写入数据库</li>
</ul>
</blockquote>
<p>策略: 撤销故障发生时未完成的事务,重做已完成的事务</p>
<blockquote>
<p>此恢复过程不需要用户干预</p>
</blockquote>
<p>步骤:</p>
<blockquote>
<ol>
<li>正向扫描日志文件,生成已提交事务(有COMMIT记录)的重做队列和未完成事务(无COMMIT和ROLLBACK记录)的撤销队列</li>
<li>对撤销队列中的事务进行撤销操作,即反向扫描队列对更新操作执行逆操作</li>
<li>对重做队列中的事务进行重做操作,即正向扫描队列,将记录中更新后的值重新写入数据库</li>
</ol>
</blockquote>
<h3 id="介质故障的恢复"><a href="#介质故障的恢复" class="headerlink" title="介质故障的恢复"></a>介质故障的恢复</h3><p>策略: 重新装载数据库,重做已完成的数据库</p>
<p>步骤:</p>
<blockquote>
<ol>
<li>装入最新的后备副本(装入转储时刻的日志文件副本),使得数据库恢复到最近一次转储时的一致性状态</li>
<li>装入转储结束时刻的日志文件副本,重做到故障发生之前所有已完成的事务</li>
</ol>
</blockquote>
<p>这需要数据库管理员介入,装载数据库副本和各日志文件副本,执行系统提供的恢复命令; 但具体的恢复操作仍由DBMS完成</p>
<h2 id="10-6-具有检查点的恢复技术"><a href="#10-6-具有检查点的恢复技术" class="headerlink" title="10.6 具有检查点的恢复技术"></a>10.6 具有检查点的恢复技术</h2><p>用于更好地解决系统故障</p>
<h3 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h3><ul>
<li>系统故障恢复时,扫描整个日志文件将耗费大量时间</li>
<li>重做事务时,会浪费大量时间</li>
</ul>
<p>具有检查点的恢复技术:</p>
<blockquote>
<ul>
<li>在日志文件中增加检查点记录(checkpoint)</li>
<li>增加重新开始文件</li>
<li>恢复子系统在登录日志文件期间动态地维护日志</li>
</ul>
</blockquote>
<p>使用检查点技术之后,恢复数据库时只需要从最近的检查点开始扫描日志并重做事务即可</p>
<h3 id="检查点技术"><a href="#检查点技术" class="headerlink" title="检查点技术"></a>检查点技术</h3><ul>
<li>检查点记录的内容<blockquote>
<ul>
<li>建立检查点时刻所有正在执行的事务清单</li>
<li>这些事务最近一个日志记录的地址<br>这样,可以保证检查点之前的所有事务已经被提交并写入数据库,恢复时不需重做这些事务</li>
</ul>
</blockquote>
</li>
<li>重新开始文件的内容<blockquote>
<p>记录各个检查点记录在日志文件中的地址</p>
</blockquote>
</li>
<li>动态维护日志文件的方法: 周期性建立检查点,保存数据库的状态<blockquote>
<ol>
<li>将当前缓冲区内的日志记录写入到磁盘的日志文件上</li>
<li>在日志文件中写入一个检查点记录</li>
<li>将当前缓冲区内的所有数据记录写入四篇的数据库中</li>
<li>把检查点记录在日志文件中的地址写入一个重新开始文件</li>
</ol>
</blockquote>
</li>
</ul>
<p>检查点的建立可以是定期或不定期的</p>
<h3 id="检查点的恢复策略"><a href="#检查点的恢复策略" class="headerlink" title="检查点的恢复策略"></a>检查点的恢复策略</h3><p>事务的T执行策略:</p>
<blockquote>
<ul>
<li>无需操作: T在检查点之前完成</li>
<li>重做: T在系统故障前完成,但在检查点建立时并未完成</li>
<li>撤销: T在系统故障时未完成</li>
</ul>
</blockquote>
<p>恢复步骤:</p>
<blockquote>
<ol>
<li>通过重新开始文件找到最后一个检查点记录</li>
<li>通过该检查点记录得到当前执行的事务清单ACTIVATE-LIST,并将它们全部放入撤销队列</li>
<li>从检查点开始正向扫描日志文件,遇到事务开始则先将其放入撤销队列,遇到事务结束则将其从撤销队列移入重做队列,直到日志结束</li>
<li>对重做队列中的每个事务执行重做操作,对撤销队列中的每个事务执行撤销操作</li>
</ol>
</blockquote>
<h2 id="10-7-数据库镜像"><a href="#10-7-数据库镜像" class="headerlink" title="10.7 数据库镜像"></a>10.7 数据库镜像</h2><p>用于更好地解决介质故障</p>
<p>问题: 介质故障恢复比较费时,DBA需要周期性地转储数据库</p>
<p>解决策略: 数据库镜像(Mirror)</p>
<p>数据库镜像:</p>
<blockquote>
<ul>
<li>DBMS自动把整个数据库或其中的关键数据复制到另一个磁盘上</li>
<li>DBMS自动保证镜像数据与主数据的一致性; DBMS自动将更新后的数据复制到镜像上</li>
</ul>
</blockquote>
<p>用途:</p>
<blockquote>
<ul>
<li>出现介质故障时可由镜像磁盘继续提供数据库服务,并对故障磁盘进行数据恢复,不需要关闭系统或重装数据库副本</li>
<li>未出现故障时可由用于提高并发操作的效率</li>
</ul>
</blockquote>
<p>问题: 频繁地复制数据会降低DBMS的运行效率,实际使用中往往只会对关键数据和日志文件进行镜像</p>
<h1 id="十一、并发控制"><a href="#十一、并发控制" class="headerlink" title="十一、并发控制"></a>十一、并发控制</h1><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><p>数据库是多用户数据库系统,在同一时刻并发运行的事务数可达数百上千个</p>
<ul>
<li><p>多事务串行执行不能充分利用系统资源，发挥数据库共 享资源的特点</p>
</li>
<li><p>交叉并发:  事务的并行执行是这些并行事务的并行操作轮流交叉运行,这可以提高系统效率,但并不是真正的并行运行</p>
</li>
<li><p>同时并发: 多处理机系统中每个处理机可以运行一个事务,实现多个事务真正并行运行; 这是效率最高的并发方式,但复杂并受制于硬件环境</p>
</li>
</ul>
<p>本章讨论的数据库系统并发控制技术是以单处理机系统为基础的 </p>
<h3 id="并发带来的问题"><a href="#并发带来的问题" class="headerlink" title="并发带来的问题"></a>并发带来的问题</h3><blockquote>
<ul>
<li>多个事务同时存取同一时间</li>
<li>这会导致存取和存储不正确的数据,破坏事务隔离性和数据库一致性</li>
</ul>
</blockquote>
<p>数据库管理系统必须提供并发控制机制<br>并发控制机制是衡量一个数据库管理系统性能的重要标志之一 </p>
<p>并发操作带来的数据不一致性:</p>
<blockquote>
<ul>
<li>丢失修改: 当前修改被其他事务覆盖</li>
<li>不可重复读: 读取数据后该数据被其他事务修改(删除,插入:幻影现象)</li>
<li>读”脏”数据: 之前读取的(错误)数据被撤销</li>
</ul>
</blockquote>
<p>对数据库的应用有时允许某些不一致性，可以降低对一致 性的要求以减少系统开销 </p>
<h3 id="并发控制主要技术"><a href="#并发控制主要技术" class="headerlink" title="并发控制主要技术"></a>并发控制主要技术</h3><blockquote>
<ul>
<li>封锁</li>
<li>时间戳</li>
<li>乐观控制法</li>
<li>多版本并发控制</li>
</ul>
</blockquote>
<h2 id="11-2-封锁"><a href="#11-2-封锁" class="headerlink" title="11.2 封锁"></a>11.2 封锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>封锁: 事务T对某个数据对象操作之前,先向系统发出请求对其加锁,使该事务对此数据对象有了一定的控制; 在该锁被释放之前,其他事务不能更新此数据对象</p>
<blockquote>
<p>封锁是实现并发控制的一个重要的技术</p>
</blockquote>
<p>类型:</p>
<blockquote>
<ul>
<li>排他锁(X锁)</li>
<li>共享锁(S锁)</li>
</ul>
</blockquote>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><ul>
<li><p>该事务可以读取和修改被加锁对象</p>
</li>
<li><p>直到该事务释放锁之前,其他任何事物都不能再对该对象加任何类型的锁</p>
</li>
</ul>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><ul>
<li><p>该事务只能读取被加锁对象</p>
</li>
<li><p>其他事务只能再对该对象加共享锁而不能加排他锁,保证其他事务也能读取该对象</p>
</li>
</ul>
<h3 id="锁的相容矩阵"><a href="#锁的相容矩阵" class="headerlink" title="锁的相容矩阵"></a>锁的相容矩阵</h3><table>
<thead>
<tr>
<th align="center">T1\T2</th>
<th align="center">X</th>
<th align="center">S</th>
<th align="center">-</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
</tbody></table>
<h2 id="11-3-封锁协议"><a href="#11-3-封锁协议" class="headerlink" title="11.3 封锁协议"></a>11.3 封锁协议</h2><p>封锁协议: 运用锁对数据对象加锁时的一些规则</p>
<blockquote>
<ul>
<li>何时申请X锁或S锁</li>
<li>持锁时间</li>
<li>何时释放</li>
</ul>
</blockquote>
<p>不同封锁协议可以在不同程度上保证并发操作的正确调度</p>
<h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><blockquote>
<ul>
<li>事务T在修改R数据前必须先对其加X锁,直到事务结束(提交或回滚)才释放</li>
</ul>
</blockquote>
<blockquote>
<p>该协议可以防止修改丢失,保证T是可恢复的</p>
</blockquote>
<p>一级封锁协议无法保证读脏数据</p>
<h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><blockquote>
<ul>
<li>事务T在修改R数据前必须先对其加X锁,直到事务结束(提交或回滚)才释放</li>
<li>事务T在读取R数据之前必须先对其加S锁,读完之后即可释放S锁<br>该协议可以防止丢失修改和读脏数据</li>
</ul>
</blockquote>
<p>二级封锁协议不能保证可重复读</p>
<h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><blockquote>
<ul>
<li>事务T在修改R数据前必须先对其加X锁,直到事务结束(提交或回滚)才释放</li>
<li>事务T在读取R数据之前必须先对其加S锁,直到事务结束才释放<br>三级封锁协议可防止丢失修改、读脏数据和不可重复读</li>
</ul>
</blockquote>
<h2 id="11-4-活锁和死锁"><a href="#11-4-活锁和死锁" class="headerlink" title="11.4 活锁和死锁"></a>11.4 活锁和死锁</h2><p>封锁技术带来的问题: 活锁和死锁</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>系统先行批准后请求的(一批)事务对数据加锁,导致前面的事务无法获得封锁而一直处于等待状态</p>
<p>解决策略: 采用先来先服务策略</p>
<blockquote>
<ul>
<li>当多个事务请求封锁同一数据对象时</li>
<li>按请求封锁的先后次序对这些事务进行排队</li>
<li>该数据对象上的锁一旦被释放,首先批准队列中第一个事务获得该锁</li>
</ul>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个或多个事务都已封锁一些数据对象未释放时,又请求访问被对方锁住的数据对象,导致这些事务同时进入无限等待的状态</p>
<p>解决策略:</p>
<ol>
<li>预防死锁: 代价较高<blockquote>
<p>一次封锁法: </p>
<ul>
<li>每个事务必须一次将所有要使用的数据全部加锁,否则不能执行</li>
<li>这样过早加锁,降低系统并发度; 且实际情况下难以精确缺点封锁对象</li>
</ul>
<p>顺序封锁法:</p>
<ul>
<li>预先对数据对象规定一个封锁顺序,所有事物都按这个顺序实行封锁</li>
<li>数据库中的对象多且动态变化,维护这样一个顺序成本很高; 实际情况下封锁请求可以随着事物的执行动态缺点,实现难度大</li>
</ul>
</blockquote>
</li>
<li>诊断和解除死锁:<blockquote>
<p>超时法:</p>
<ul>
<li>如果一个事物等待时间超过了规定的时限,就认为发生了死锁</li>
<li>实现简单,但有可能误判死锁,且需要等待长时间才能发现死锁<br>等待图法:</li>
<li>若T2请求数据时发现它被T1锁住,则称T2等待T1,由节点T2画一条有向边指向T1</li>
<li>并发控制子系统周期性地生成事务等待图,若发现整个有向图中出现了回路,则表示系统中出现了死锁</li>
<li>解除死锁: 选择一个处理死锁代价最小的事务,将其撤销,释放其持有的锁</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="11-5-并发调度的可串行性"><a href="#11-5-并发调度的可串行性" class="headerlink" title="11.5 并发调度的可串行性"></a>11.5 并发调度的可串行性</h2><p>DBMS对并发事务的不同的调度可能会产生不同的结果</p>
<blockquote>
<ul>
<li>串行调度是正确的</li>
<li>执行结果等价于串行调度也的调度是正确的,称为可串行化调度</li>
</ul>
</blockquote>
<h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><p>多个事务并发执行是正确的,当且仅当其执行结果与按某一次序串行执行这些植物时的结果相同</p>
<blockquote>
<ul>
<li>可串行性时并发事务正确调度的准则</li>
<li>一个给定的并发调度,当且仅当它是可串行化的,才认为是正确的调度</li>
</ul>
</blockquote>
<p>如何判断一个调度是可串行化调度是个问题</p>
<h3 id="冲突可串行化的调度"><a href="#冲突可串行化的调度" class="headerlink" title="冲突可串行化的调度"></a>冲突可串行化的调度</h3><p>冲突可串行化比可串行化更严格,它是可串行化的充分条件</p>
<p>冲突操作: 不同事务对同一数据的读写操作和写写操作; 即两个操作涉及同一个数据库元素,且至少有一个为写操作</p>
<p>定义: 不能交换的动作</p>
<blockquote>
<ul>
<li>同一事务的两个操作</li>
<li>不同事务的冲突操作</li>
</ul>
</blockquote>
<p>冲突可串行化的调度: 一个调度S在保证冲突操作次序不变的情况下,通过交换<strong>两个</strong>事务的不冲突操作的次序得到了一个串行调度S’,则S为冲突可串行化的调度</p>
<h2 id="11-6-两段锁协议"><a href="#11-6-两段锁协议" class="headerlink" title="11.6 两段锁协议"></a>11.6 两段锁协议</h2><p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性,从而保证调度的正确性</p>
<p>两段锁协议: 所有事物必须分两个阶段对数据项加锁和解锁</p>
<blockquote>
<ul>
<li>扩展阶段: 在对任何数据进行读写操作之前,事务首先要获得对该数据的封锁; 此时事务不能释放任何锁</li>
<li>收缩阶段: 在释放一个封锁之后,事务不在申请和获得任何其他的封锁; 此时事务可以释放锁,但不能再获得任何锁</li>
</ul>
</blockquote>
<p>若一组并发事务都遵守两段锁协议,则这些事务的任何并发调度策略都是可串行化的; 事务遵守两段锁协议是可串行化的充分条件</p>
<p>注意: </p>
<blockquote>
<ul>
<li>两段锁协议遵守三级封锁协议,反之不然</li>
<li>一次封锁法遵守两段锁协议,但两者不同,两段锁协议不能防止事务死锁</li>
</ul>
</blockquote>
<h2 id="11-7-封锁的粒度"><a href="#11-7-封锁的粒度" class="headerlink" title="11.7 封锁的粒度"></a>11.7 封锁的粒度</h2><p>封锁的对象可以是逻辑单元(属性组等)也可以是物理单元(数据页等),封锁对象的大小称为封锁粒度</p>
<p>封锁粒度越大,系统开销越小,但并发度也越小; 反之亦然</p>
<p>多粒度封锁: 在一个系统中同时支持多种封锁粒度供不同的事务选择 </p>
<h3 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h3><p>多粒度树:</p>
<blockquote>
<ul>
<li>以树形结构来表示多级封锁粒度</li>
<li>根结点是整个数据库,表示最大的数据粒度</li>
<li>叶节点表示最小的数据粒度<br><img src="/2020/05/24/data-base1/tree0.jpg" alt="tree"></li>
</ul>
</blockquote>
<p>多粒度封锁协议允许多粒度树种每个节点被独立加锁</p>
<blockquote>
<ul>
<li>对一个节点加锁意味着这个节点下的所有子节点也被加以同样的锁</li>
<li>显式封锁: 直接加到数据对象上的锁</li>
<li>隐式封锁: 该数据对象由于其上级节点被加锁而使得它本身也被加锁</li>
<li>从效果上看,显式封锁和隐式封锁是一样的</li>
</ul>
</blockquote>
<p>锁的冲突检查: 对某个数据对象加锁时,系统要检查</p>
<blockquote>
<ul>
<li>该数据对象上有无显式封锁与之冲突</li>
<li>该对象所有上级节点,有无上级节点的显式封锁造成的该对象的隐式封锁与之冲突</li>
<li>该对象所有下级节点,有无下级节点的显示封锁与该对象封锁对其造成的隐式封锁冲突</li>
</ul>
</blockquote>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁的引入能提高对某个数据对象加锁时系统的检查效率</p>
<blockquote>
<ul>
<li>如果一个节点被加意向锁,说明该节点的某个下层节点正在被加锁</li>
<li>对任一节点加基本锁,必须先对它的上层节点加意向锁</li>
</ul>
</blockquote>
<p>类型:</p>
<blockquote>
<ul>
<li>意向共享(IS)锁</li>
<li>意向排他(IX)锁</li>
<li>共享意向排他锁(SIX)锁</li>
</ul>
<p>其中,SIX锁表示某一个事务要访问某一数据节点,并且更新它的后代节点; 该节点的上层节点被加IS和IX锁; 该节点被先加S锁后加IX锁(合在一起就是SIX锁); 该节点的某个后代节点被加X锁</p>
</blockquote>
<p>数据锁的相容矩阵:<br><img src="/2020/05/24/data-base1/matrix0.jpg" alt="matrix"></p>
<p>锁的强度:  </p>
<blockquote>
<ul>
<li>锁的强度是指它对其他锁的排斥程度</li>
<li>一个事务再申请封锁时,以强锁代替弱锁是安全的,反之不然</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/lock0.jpg" alt="lock"></p>
<p>具有意向锁的多粒度封锁方法:</p>
<blockquote>
<ul>
<li>申请封锁时应按照自上而下的次序进行</li>
<li>释放封锁时应按照自下而上的次序进行</li>
</ul>
</blockquote>
<p>优点:</p>
<blockquote>
<ul>
<li>提高了系统的并发度</li>
<li>减少了加锁和解锁的开销</li>
<li>实际应用广泛</li>
</ul>
</blockquote>
<hr>
<p>简明的数据库使用笔记可参考<a href="http://georgechen.top/2020/04/11/mysql0/" target="_blank" rel="noopener">http://georgechen.top/2020/04/11/mysql0/</a></p>
<p>博文创建时间: 2020-04-16 14:06:44</p>

      
      <!-- 打赏 -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://georgechen1827.github.io/2020/05/24/data-base1/" data-id="ckmcrlz5r0047h8vn8io2frr1"
        class="article-share-link">share</a>
        
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learning/" rel="tag">learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/05/24/mysql0/" class="article-nav-link">
        <strong class="article-nav-caption">Prev Post</strong>
        <div class="article-nav-title">
          
            sql使用
          
        </div>
      </a>
    
    
      <a href="/2020/05/24/data-base0/" class="article-nav-link">
        <strong class="article-nav-caption">Next Post</strong>
        <div class="article-nav-title">数据库原理与设计(基础篇)</div>
      </a>
    
  </nav>


  

  
  
<!-- valine评论 -->
<div id="vcomments-box">
    <div id="vcomments">
    </div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#vcomments',
        notify: false,
        verify: '',
        app_id: 'ze0YzGUMUrLXgdRQpKyDCEEm-gzGzoHsz',
        app_key: 'NnhAiNVNGXwbCD1sMGNRjA8B',
        path: window.location.pathname,
        avatar: 'mp',
        placeholder: 'Leave your comments here ~',
        recordIP: true,
        lang: 'en'
    });
    const infoEle = document.querySelector('#vcomments .info');
    if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
        infoEle.childNodes.forEach(function (item) {
            item.parentNode.removeChild(item);
        });
    }
</script>
<style>
    #vcomments-box {
        padding: 5px 30px;
    }

    @media screen and (max-width: 800px) {
        #vcomments-box {
            padding: 5px 0px;
        }
    }

    #vcomments-box #vcomments {
        background-color: #fff;
    }

    .v .vlist .vcard .vh {
        padding-right: 20px;
    }

    .v .vlist .vcard {
        padding-left: 10px;
    }
</style>

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2019-2021
        George Chen
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="George"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HOME</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives/">ARCHIVE</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories/">CATE.</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">TAGS</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="https://github.com/georgechen1827/" target="_blank" rel="noopener">about me</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/coming_soon.html" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>







<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer:'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
    onClick: (e) => {
      $('.toc-link').removeClass('is-active-link');
      $(`a[href=${e.target.hash}]`).addClass('is-active-link');
      $(e.target.hash).scrollIntoView();
      return false;
    }
  });
</script>


<script>
  var ayerConfig = {
    mathjax: true
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>



<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>