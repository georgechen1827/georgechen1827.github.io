<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>软件工程实践</title>
    <url>/2021/03/09/software-engineering0/</url>
    <content><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>开发软件的过程：</p>
<ol>
<li>可行性分析<ul>
<li>是否符合相关规定</li>
<li>技术上的可行性</li>
<li>经济上的可行性</li>
</ul>
</li>
<li>软件需求分析<ul>
<li>把握到用户在业务上的需求</li>
<li>通过对用户的访谈得到用户真正想要的东西</li>
<li>引导用户的需求</li>
<li>需求报告: 便于共享, 作为验收标准</li>
</ul>
</li>
<li>…</li>
</ol>
<p>软件危机典型表现：</p>
<ol>
<li>对软件开发成本和进度的估计常常不准确</li>
<li>用户对已完成的软件系统不满意</li>
<li>软件产品质量往往靠不住</li>
<li>软件常常是不可维护的</li>
</ol>
<p>软件工程的方法、工具、过程</p>
<p>传统瀑布模型</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统</title>
    <url>/2021/03/08/linux/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Linux发行商：</p>
<ul>
<li>Ubuntu</li>
<li>RedHat</li>
<li>Centos</li>
</ul>
<p>命令样式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uname -a <span class="comment">## (-all)</span></span><br><span class="line">Linux KVD-Standard-PC 4.15.0-33-generic <span class="comment">#36-Ubuntu SMP Wed Aug 15</span></span><br><span class="line">16:00:05 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>Ubuntu资源管理器：</p>
<ul>
<li>家目录Home Folder</li>
<li>（家目录下）桌面Desktop</li>
<li>文档Documents</li>
<li>音乐、图片、视频、公共….</li>
</ul>
<p>Ubuntu工作区Workplace（桌面）：默认有4个工作区</p>
<p>终端Terminal： Terminal是用于连接内核的一个shell</p>
<p>Linux的文件:</p>
<ul>
<li>大小写区分</li>
<li>文件名最长256字节, 不推荐用中文</li>
<li>除了<code>/</code>外所有字符都可以作为文件名</li>
<li>文件隐藏用<code>.name</code>表示, 可以用<code>ls -a</code>查看</li>
</ul>
<p>多用户支持:</p>
<ul>
<li>同时支持多个用户登录</li>
<li>区分存储读写和隐私保护</li>
</ul>
<p>一些Linux的命令举例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ uname -a :命令是uname;-a是选项(显示全部的信息)。可以查看内核（kernel）版本号等。</span><br><span class="line">$ uname:查看名字</span><br><span class="line">$ PS1=<span class="string">'hi'</span>:设置提示符</span><br><span class="line">$ <span class="built_in">pwd</span>:显示当前工作目录（<span class="built_in">print</span> working directory）</span><br><span class="line">$ ls :显示目标列表（list）</span><br><span class="line">$ <span class="built_in">cd</span> :切换目录（change directory）。</span><br><span class="line">$ cat: 显示文件内容</span><br><span class="line">$ sudo adduser ll12:创建一个新用户命令。sudo--以root的身份执行后面的命令; useradd命令比较低级，使用起来比较麻烦</span><br><span class="line">$ sudo su:可以进入root账户</span><br><span class="line"><span class="comment"># cd :切换到root的家目录下（/root）</span></span><br><span class="line"><span class="comment"># exit :回到普通用户下</span></span><br><span class="line">$ <span class="built_in">cd</span> ~ :回到当前用户的根目录下</span><br><span class="line">$/bin$ <span class="built_in">cd</span> /home/zhanghua/Download：用绝对路径进行切换</span><br></pre></td></tr></table></figure>

<h2 id="Linux目录树结构"><a href="#Linux目录树结构" class="headerlink" title="Linux目录树结构"></a>Linux目录树结构</h2><p>root目录结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;</span><br><span class="line">	bin 可执行文件</span><br><span class="line">	etc （and so on）系统配置文件（windows使用注册表进行系统配置）</span><br><span class="line">	boot 启动</span><br><span class="line">	root 超级管理员文件夹 </span><br><span class="line">	home 家目录，里面是每个用户的家目录</span><br></pre></td></tr></table></figure>

<h2 id="Linux用户身份"><a href="#Linux用户身份" class="headerlink" title="Linux用户身份"></a>Linux用户身份</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd （低级）添加用户</span><br><span class="line">adduser  添加用户，同时可以自动添加用户组等</span><br><span class="line">deluser</span><br></pre></td></tr></table></figure>
<p>每个用户属于一个工作组</p>
<p><code>sudo</code>可以让用户以root的身份执行指令</p>
<blockquote>
<ul>
<li>能够进行sudo的用户为sudoer</li>
<li>sudoer进行sudo时，需要输入当前用户的密码</li>
<li>root用户需要谨慎分配sudo权限</li>
<li>root和sudoer的需要保证自己账号的安全</li>
<li>不推荐直接在root用户下做大量操作，使用<code>sudo</code>会更谨慎</li>
</ul>
</blockquote>
<p><code>su</code>用于切换用户(<code>switch user</code>)</p>
<blockquote>
<ul>
<li><code>su user</code>并输入相应用户密码就可以切换到对应用户</li>
<li>不输入用户名，默认切换到root用户</li>
</ul>
</blockquote>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>举例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -a</span><br><span class="line">pwd</span><br><span class="line">cd</span><br></pre></td></tr></table></figure>

<p>shell和命令：<code># cmd option argument</code></p>
<ul>
<li><code>#</code>：提示符</li>
<li>cmd：操作对象</li>
<li>option：操作方式</li>
<li>命令<code>cmd</code>和参数<code>argument</code>选项<code>option</code>之间需要有一个空格</li>
</ul>
<p>默认参数举例：</p>
<ul>
<li><code>cd</code>默认切换到当前用户家目录</li>
<li><code>su</code>默认切换到root用户</li>
<li><code>ls</code>默认看当前目录下的文件</li>
</ul>
<p><code>ls</code>(<code>list contents</code>)查看目录下的所有文件</p>
<blockquote>
<ul>
<li><code>-a</code>查看隐藏文件</li>
<li><code>-c</code>排序，和<code>-lt</code>一起使用</li>
<li><code>-l</code>显示长信息，total为目录下文件和目录文件总占用字节数</li>
<li><code>-d</code>,<code>--color</code>…</li>
<li>…</li>
</ul>
</blockquote>
<p><code>touch</code>创建一个文件</p>
<blockquote>
<ul>
<li><code>touch name</code>创建一个名为name的文件</li>
<li>若文件存在，则将其时间信息更新</li>
</ul>
</blockquote>
<p><code>man</code>查看命令文档</p>
<blockquote>
<ul>
<li><code>Name</code>名称</li>
<li><code>Synopsis</code>用法</li>
<li><code>Description</code>描述</li>
</ul>
</blockquote>
<p><code>passwd</code>修改用户密码</p>
<blockquote>
<ul>
<li>sudo passwd (root) 修改的是root密码</li>
</ul>
</blockquote>
<p><code>date</code>用于看时间</p>
<p><code>cal calendar</code>用于看日历</p>
<p><code>echo</code>用于向命令行打印信息</p>
<p><code>uname</code>用于询问Linux的名字</p>
<p><code>uptime</code>用于查看系统启动时间、登录用户数</p>
<p><code>hostname</code>用于查看机器名</p>
<p><code>users</code>用于查看登录系统的用户（一个终端登录一个用户，图形界面占用一个用户）</p>
<p><code>who</code> <code>w</code>用于查看登录用户的详细信息，<code>w</code>还可以查看用户当前执行的任务</p>
<p><code>whoami</code>查看当前用户名</p>
<p><code>du</code>查看目录及子文件总大小</p>
<h2 id="第三次课"><a href="#第三次课" class="headerlink" title="第三次课"></a>第三次课</h2><p><code>adduser</code>添加用户</p>
<blockquote>
<ul>
<li>默认添加用户、家目录、同名用户组</li>
</ul>
</blockquote>
<p><code>visudo</code>修改sudoer配置</p>
<blockquote>
<ul>
<li>^O表示control+O</li>
<li>M-D表示alt/option+D</li>
</ul>
</blockquote>
<p><code>usermod</code>修改用户账号</p>
<blockquote>
<ul>
<li><code>-G</code>添加用户组，<code>-g</code>覆盖用户组，重新登录即可生效</li>
</ul>
</blockquote>
<p><code>sudo</code>的好处</p>
<blockquote>
<ul>
<li>安全，相当于增加对命令的一次确认，让用户明白自己正在使用root权限</li>
<li>使得可以有多个管理员账号同时管理系统</li>
<li>当然，root账户还是需要的，比如可以在sudoer文件被破坏时进行恢复</li>
</ul>
</blockquote>
<p><code>chmod</code></p>
<h2 id="常见命令选项"><a href="#常见命令选项" class="headerlink" title="常见命令选项"></a>常见命令选项</h2><ul>
<li><code>-a</code>: -all</li>
<li><code>-r -R</code>: –reverse, –recursive</li>
<li><code>-t</code>: –target</li>
</ul>
<p><code>cp target(s) dest</code>：拷贝</p>
<p><code>mv target dest</code>：剪切，移动</p>
<p><code>whereis target</code>: 寻找二进制文件、源文件、文档文件或命令的地址  </p>
<p><code>hexdump</code>：查看二进制文件</p>
<p><code>mkdir dir(s)</code>：创建文件夹</p>
<p><code>rmdir dir(s)</code>：移除空文件夹</p>
<p><code>rm file(s)</code>：</p>
<p>命令行参数：argc argv</p>
<p>文本文件、二进制文件</p>
<p><code>cat</code>：concatenate拼接</p>
<p><code>tail -n linenum target</code>：查看文件尾部；<code>-f</code>持续监测</p>
<p><code>head</code>：查看文件头部，选项同<code>tail</code></p>
<p><code>wc</code>：wordcount</p>
<p><code>more(less)</code>：查看文件<code>less</code>适合大文件</p>
<ul>
<li>上下箭头 按行移动；</li>
<li>空格 forward翻屏</li>
<li>ctrl + f/b forward/backward翻屏</li>
<li>/regex 字符串或者正则表达式 进行搜索</li>
</ul>
<p><code>man</code>在线文档：</p>
<ul>
<li>1 用户命令</li>
<li>2 系统调用（内核函数）</li>
<li>3 库函数</li>
<li>7 杂项 miscellaneous（macro宏；micro微）</li>
<li>8 系统管理员命令，root可以调用</li>
<li>man -f printf 非常简洁的说明</li>
<li>man -k search 查找名字或说明中包含search的文件、命令等</li>
</ul>
<p><code>printf</code>：格式化打印</p>
<p><code>vim</code>：vi iMproved；</p>
<h2 id="第四节课"><a href="#第四节课" class="headerlink" title="第四节课"></a>第四节课</h2><p>命令行<code>path/cmd [option]... [arg]...</code>：</p>
<ul>
<li>选项<code>option config choice selection alternative</code>：确定功能（方式）</li>
<li>参数<code>arg parameter</code>：确定对象</li>
</ul>
<p><code>ls -aldrRs</code></p>
<p><code>stat fname</code>：文件信息</p>
<h4 id="文件三时间"><a href="#文件三时间" class="headerlink" title="文件三时间"></a>文件三时间</h4><p><code>stat fname</code>文件信息</p>
<ul>
<li><code>Access</code>访问时间<code>atime</code></li>
<li><code>Modify</code>文件属性或内容改变时间<code>ctime</code></li>
<li><code>Change</code>文件属性(inode)改变时间</li>
</ul>
<p><code>ls -l</code>输出文件内容修改时间；<code>-ltc</code></p>
<p><code>ls -ld &lt;dirname&gt;</code>查看文件夹本身的信息</p>
<p><code>cp</code>文件拷贝</p>
<ul>
<li><code>cp a.txt ~/b.txt</code> <code>cp -r dir1 ~/dir2</code></li>
<li><code>cp a.txt b.txt ~[/]</code></li>
<li><code>cp -t ~/ a.txt b.txt</code></li>
</ul>
<h2 id="Vim相关"><a href="#Vim相关" class="headerlink" title="Vim相关"></a>Vim相关</h2><p>查看文本文件的相关命令：</p>
<ul>
<li>less, more, cat, head, tail</li>
</ul>
<p>文件操作命令：</p>
<ul>
<li>cp, mv, mkdir, rm</li>
</ul>
<p>查看帮助命令：</p>
<ul>
<li>man, info, help</li>
</ul>
<p>文本编辑器：</p>
<ul>
<li>vim, emacs</li>
</ul>
<p><code>type</code>类型：查看命令名字如何被执行</p>
<ul>
<li>外部命令hash：寻找可执行文件、创建子进程、执行、返回shell</li>
<li>别名alias</li>
<li>内部命令builtin，由shell实现</li>
</ul>
<p><code>alias</code>给命令取别名</p>
<blockquote>
<p><code>alias &lt;aliasName&gt;=&#39;&lt;command&gt;&#39;</code></p>
</blockquote>
<p>PATH环境变量：</p>
<ul>
<li>shell会在PAHT所指定的文件夹中寻找命令（不递归）</li>
<li>由于当前文件夹<code>.</code>默认不在PATH中，因此在运行可执行文件时需要<code>./XX.out</code></li>
</ul>
<p><code>vim</code>：Vi IMproved</p>
<p>vim几种模式：</p>
<ul>
<li>命令模式</li>
<li>插入模式</li>
<li>末行模式<code>:/?</code></li>
<li>视图模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令---&gt;插入模式（i&#x2F;I光标在行首&#x2F;a&#x2F;A光标在行尾&#x2F;o光标在下一行&#x2F;O上面再插入一行，光标在下一行）</span><br><span class="line">插入模式---&gt;命令模式下（ESC键，u撤销，x删除一个字符，r替换，yy复制一行，p粘贴，dd删除一行，3dd删除三行：set nu 显示行号；^光标到行首，$光标到行尾，G光标到最后一行，：5直接跑到第五行，3G跑到第三行）</span><br><span class="line">命令---&gt;视图模式（v）  按字符选择</span><br><span class="line">命令---&gt;视图行模式（V） 按行选择 </span><br><span class="line">命令---&gt;按列选择（ctrl+v）</span><br><span class="line">命令---&gt;底行模式（&#x2F;搜索 n正向找，N反着找； ？反向搜索；正则表达式查找&#x2F;o[uv]---找到所有含有ou或者ov的字符；“:!date”可查看时间;“:r!date”将命令执行的结果保存在当前文本中；“:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g   n1和n2为数字，在第n1行和n2行之间寻找word字符串，并将该字符串替换为word2  :1,$s&#x2F;word1&#x2F;word2&#x2F;g    从第一行到最后一行查找字符串word1字符串，并将字符串word1替换为word2 :1,$s&#x2F;word1&#x2F;word2&#x2F;gc   从第一行到最后一行查找字符串word1，并将字符串word1替换为word2,在替换之前提示用户确认是否替换(confirm)”替换）</span><br><span class="line">vi wenjianming---进入命令模式---输入“i&#x2F;insert”---进入插入模式----按“ESC”---进入命令模式---“：wq”---保存退出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令模式“:sp”利用“ctrl +w+w”进行切换</span><br></pre></td></tr></table></figure>



<h2 id="第五节课"><a href="#第五节课" class="headerlink" title="第五节课"></a>第五节课</h2><p><code>mv</code>移动文件或文件夹<code>mv dir1 path/dir2</code>：</p>
<ul>
<li><code>dir2</code>存在则移动到此文件夹下，不存在则将<code>dir1</code>改为<code>dir2</code></li>
<li>若<code>path</code>不存在则报错</li>
</ul>
<p><code>mkdir</code>创建文件夹：</p>
<ul>
<li><code>-p</code>递归创建多级目录</li>
</ul>
<p><code>rm</code>删除只读文件时不加<code>-f</code>会进行提示</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>专业选修</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文献阅读与写作</title>
    <url>/2021/03/08/english-papers0/</url>
    <content><![CDATA[<p>张莉</p>
<hr>
<p>期中20分；期末40分；平时20+20</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>管理学基本原理</title>
    <url>/2020/11/08/management/</url>
    <content><![CDATA[<p>东吴商学院：陈东健</p>
<p>13063885748</p>
<p><a href="mailto:&#99;&#100;&#x6a;&#52;&#48;&#x35;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;">&#99;&#100;&#x6a;&#52;&#48;&#x35;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;</a></p>
<h1 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h1><p>管理学是研究人类管理活动一般规律的科学，研究对象：</p>
<blockquote>
<ul>
<li>个体活动与群体活动</li>
<li>一般组织与企业组织</li>
<li>管理学的研究体系</li>
</ul>
</blockquote>
<h2 id="管理的内涵与本质"><a href="#管理的内涵与本质" class="headerlink" title="管理的内涵与本质"></a>管理的内涵与本质</h2><p>管理：在<strong>特定的环境</strong>中由管理者对组织的活动进行决策、计划、组织、领导和控制并不断创新，以有效达到组织目标的过程。</p>
<p>管理的基本特征：</p>
<blockquote>
<ul>
<li>载体：组织</li>
<li>目的：有效实现组织预定的目标</li>
<li>主体：具有专门知识、利用专门技术和方法来进行专门活动的管理者</li>
<li>客体：组织活动及其参与要素</li>
<li>内容：管理是一个包括多阶段、多项工作的综合过程</li>
<li>职能：决策、计划、组织、领导、控制、创新</li>
<li>本质：资源的配置和行为的协调</li>
</ul>
</blockquote>
<p>管理对组织的作用：</p>
<blockquote>
<ul>
<li>组织要素的粘合剂</li>
<li>组织关系的润滑剂</li>
<li>组织效率的推进器</li>
</ul>
</blockquote>
<p>管理者的主要工作：（卢森斯）</p>
<blockquote>
<ul>
<li>传统管理：决策、计划、控制活动</li>
<li>沟通：交流信息和处理文件等工作（有效的管理者）</li>
<li>人员管理：人员配备和培训、激励、奖惩、调解冲突等</li>
<li>网络关系：社交活动、政治活动和对外交流等（成功的管理者）</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="管理者的角色理论"><a href="#管理者的角色理论" class="headerlink" title="管理者的角色理论"></a>管理者的角色理论</h2><p>管理者的角色：</p>
<blockquote>
<ul>
<li>人际关系角色（基层管理者）：代表人、领导者、联络者</li>
<li>信息转换角色：信息收集者、信息传播者、发言人</li>
<li>决策角色（高层管理者）：企业家、危机处理者、资源分配者、谈判者</li>
</ul>
</blockquote>
<h2 id="管理者需要具备的技能"><a href="#管理者需要具备的技能" class="headerlink" title="管理者需要具备的技能"></a>管理者需要具备的技能</h2><p>技能：</p>
<blockquote>
<ul>
<li>概念技能：（高层管理者）行业发展趋势与战略等</li>
<li>人际关系技能</li>
<li>技术技能：（低层管理者）行业专业知识</li>
<li>时间管理技能</li>
</ul>
</blockquote>
<h1 id="二、管理理论的形成和发展"><a href="#二、管理理论的形成和发展" class="headerlink" title="二、管理理论的形成和发展"></a>二、管理理论的形成和发展</h1><p>科学管理的基本原理：</p>
<blockquote>
<ul>
<li>工作定额原理</li>
<li>作业标准化原理</li>
<li>差别计件工资制</li>
<li>健全的认识制度</li>
<li>管理专业化</li>
<li>例外管理原则</li>
</ul>
</blockquote>
<h2 id="古典管理理论"><a href="#古典管理理论" class="headerlink" title="古典管理理论"></a>古典管理理论</h2><h3 id="人际关系学说"><a href="#人际关系学说" class="headerlink" title="人际关系学说"></a>人际关系学说</h3><p>人际关系学说主要观点</p>
<blockquote>
<ul>
<li>员工是“社会人”而非“经济人”</li>
<li>企业中存在“非正式组织”</li>
<li>劳动生产率升降主要取决于员工士气以及其人际关系；</li>
<li>新型的领导能力在于通过提升满意度来提高员工的士气</li>
</ul>
</blockquote>
<h3 id="行为科学理论"><a href="#行为科学理论" class="headerlink" title="行为科学理论"></a>行为科学理论</h3><p>行为科学的发展集中于以下方面：</p>
<blockquote>
<ul>
<li>关于人的需要和动机的理论</li>
<li>关于”人性假设”的理论</li>
<li>关于领导方式的理论</li>
<li>关于组织中人与人关系的理论</li>
</ul>
</blockquote>
<h2 id="现代管理学派"><a href="#现代管理学派" class="headerlink" title="现代管理学派"></a>现代管理学派</h2><h3 id="…"><a href="#…" class="headerlink" title="…"></a>…</h3><h3 id="权变管理理论"><a href="#权变管理理论" class="headerlink" title="权变管理理论"></a>权变管理理论</h3><h3 id="经验（案例）学派"><a href="#经验（案例）学派" class="headerlink" title="经验（案例）学派"></a>经验（案例）学派</h3><h2 id="当代管理理论"><a href="#当代管理理论" class="headerlink" title="当代管理理论"></a>当代管理理论</h2><h3 id="竞争战略理论"><a href="#竞争战略理论" class="headerlink" title="竞争战略理论"></a>竞争战略理论</h3><p>P91</p>
<h1 id="三、决策"><a href="#三、决策" class="headerlink" title="三、决策"></a>三、决策</h1><p>决策树、决策准则</p>
<p>重要性：决策是管理的中心</p>
<blockquote>
<ul>
<li>决策贯穿于管理的过程始终</li>
</ul>
</blockquote>
<p>影响决策的主要因素：</p>
<blockquote>
<ul>
<li>价值观</li>
<li>环境</li>
<li>资源</li>
<li>风险态度</li>
</ul>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>决策是组织或个人为实现特定目标，根据对客观环境和自身状况的认识，在两个以上解决问题的备选方案中，选择一个满意方案的<strong>分析判断与实施过程</strong></p>
<p>成功决策的特点P76：</p>
<blockquote>
<ul>
<li>目标性</li>
<li>可行性</li>
<li>创造性</li>
<li>动态性</li>
</ul>
</blockquote>
<p>决策的分类：</p>
<blockquote>
<ul>
<li>根据决策主体的分类：个体决策、群体决策</li>
<li>感觉决策影响范围分类：战略决策、战术决策、业务决策</li>
</ul>
</blockquote>
<h1 id="九、领导"><a href="#九、领导" class="headerlink" title="九、领导"></a>九、领导</h1><h2 id="领导理论"><a href="#领导理论" class="headerlink" title="领导理论"></a>领导理论</h2>]]></content>
      <categories>
        <category>notes</category>
        <category>辅修</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>管理学</tag>
      </tags>
  </entry>
  <entry>
    <title>会计学</title>
    <url>/2020/11/07/accountancy/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>财务会计：基础（初级）、中级、高级会计</li>
<li>管理会计</li>
<li>成本会计</li>
</ul>
</blockquote>
<h1 id="二、会计要素和会计等式"><a href="#二、会计要素和会计等式" class="headerlink" title="二、会计要素和会计等式"></a>二、会计要素和会计等式</h1><h2 id="会计对象"><a href="#会计对象" class="headerlink" title="会计对象"></a>会计对象</h2><p>会计对象：</p>
<blockquote>
<ul>
<li>是会计所反映和监督的内容</li>
<li>是社会再生产过程中（企业）的资金运动</li>
</ul>
</blockquote>
<p>资金运动过程：资金投入、资金使用、资金退出</p>
<h2 id="会计要素"><a href="#会计要素" class="headerlink" title="会计要素"></a>会计要素</h2><p>会计要素定义：</p>
<blockquote>
<ul>
<li>对会计对象内容（资金运动）的基本分类，是会计对象的实例化</li>
<li>是反映会计主体财务状况和经营成果的基本单位</li>
<li>分类：静态会计要素和动态会计要素</li>
</ul>
</blockquote>
<p>会计要素</p>
<blockquote>
<ul>
<li>资产</li>
<li>负债</li>
<li>所有者权益（资产负债表）</li>
<li>收入</li>
<li>费用</li>
<li>利润</li>
</ul>
</blockquote>
<p>划分会计要素的意义：</p>
<blockquote>
<ul>
<li>是实现会计反映职能，分类、系统反映会计对象的需要</li>
<li>是设置会计科目和会计账户的基本依据</li>
<li>会计要素是构成会计报表的基本框架</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="资产"><a href="#资产" class="headerlink" title="资产"></a>资产</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>定义：资产是一种满足如下三个条件的资源</p>
<blockquote>
<ul>
<li>由过去的交易或者事项形成的资源</li>
<li>由企业拥有或控制的资源</li>
<li>预期会给企业带来经济利益的资源</li>
</ul>
</blockquote>
<p>由过去交易或事项形成的资源：</p>
<blockquote>
<ul>
<li>交易：企业主体和另外一个主体发生的价值交换，如购买</li>
<li>事项：企业内部的价值转移形成的资源，如生产</li>
<li>资产是过去事实形成的现实权利，注意，预期在未来产生的结果不属于现在的资产</li>
</ul>
</blockquote>
<p>由企业拥有或控制的资源：</p>
<blockquote>
<ul>
<li>拥有：企业享有某项资源的所有权</li>
<li>控制：企业享有某项资源的（排他性）使用权，如借入款项、融资租入（经营租赁现在也算）设备等</li>
</ul>
</blockquote>
<p>预期会给企业带来经济利益：资产要素最本质的特征</p>
<blockquote>
<ul>
<li>直接或间接导致现金和现金等价物流入企业的潜力</li>
<li>不具备该特征的资源不能再确认为企业资产，如报废的设备等</li>
</ul>
</blockquote>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>资产分类：</p>
<blockquote>
<ul>
<li>流动资产：企业能够在1年或一个营业周期内变现或耗用的资产；营业周期：企业根据其经营活动的特点而划分的经营期间</li>
<li>非流动资产：不能在1年货一个营业周期内变现或耗用的资产</li>
</ul>
</blockquote>
<p>流动资产：</p>
<blockquote>
<ul>
<li>库存现金：存于财务处库房中</li>
<li>银行存款：存放在银行中的资金</li>
<li>应收及预付款：（非长期）应收账款、应收票据、预付账款等；此时，该资产对对方企业来说是负债</li>
<li>存货：原材料、生产成本（在产半成品）、库存商品（产成品）等</li>
</ul>
</blockquote>
<p>非流动资产：</p>
<blockquote>
<ul>
<li>长期股权投资：持有时间超过1年，不变现或不准备变现或收回的股权投资；目的是为了获得稳定的投资收益、对被投资企业实施控制或影响</li>
<li>固定资产：为生产产品、提供劳务、出租或经营管理而持有，使用寿命超过一个会计年度的资产；如房屋、机器设备等</li>
<li>无形资产：企业拥有或控制的没有实物形态 的可辨认非货币资产；如专利权、商标权等</li>
<li>投资性房产：企业为赚取租金或资本增值，或两者兼有而持有的房地产（非自用，否则为固定资产）</li>
<li>生物资产：企业拥有的具有生命的动物和植物；如畜牧、农作物、森林等</li>
<li>其他资产：除以上资产以外的各项资产；如长期待摊费用（如企业开办时发生的筹建费等）（区别于待摊费用）</li>
</ul>
</blockquote>
<h2 id="负债"><a href="#负债" class="headerlink" title="负债"></a>负债</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>定义：负债是一种满足如下两个条件的现实义务</p>
<blockquote>
<ul>
<li>企业过去的交易、事项所形成的现实义务</li>
<li>预期会导致经济利益流出企业的现时义务</li>
</ul>
</blockquote>
<p>过去交易或事项所形成的现时义务：</p>
<blockquote>
<p>企业现行条件下（过去已签订借款合同或收到应付款账单）已承担的义务</p>
</blockquote>
<p>预期会导致经济利益流出企业：</p>
<blockquote>
<p>履行现时义务（偿还债务）时会直接或间接导致现金或等价物流出企业</p>
</blockquote>
<h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><p>分类：</p>
<blockquote>
<ul>
<li>流动负债：偿还期不超过1年</li>
<li>非流动负债：偿还期超过1年</li>
</ul>
</blockquote>
<p>流动负债：</p>
<blockquote>
<ul>
<li>短期借款：还款期一年以内，临时周转需要</li>
<li>应付及预收款项：应付账款、预收账款、应交税费等</li>
<li>应付利息</li>
</ul>
</blockquote>
<p>注意：有时在资产负债表上只有应收和预付两项，注意区分资产和负债</p>
<p>非流动负债：</p>
<blockquote>
<ul>
<li>长期借款：还款期在1年以上，如工程项目建设</li>
<li>应付债券：企业发行的债券到期后应付给购买者的本金和利息</li>
<li>长期应付款：需要在1年以上偿还期内偿还的应付款项；如长期租赁</li>
</ul>
</blockquote>
<h2 id="所有者权益"><a href="#所有者权益" class="headerlink" title="所有者权益"></a>所有者权益</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>定义：所有者权益是企业资产扣除负债后由所有者享有的剩余权益，是投资者对企业净资产的所有权</p>
<blockquote>
<ul>
<li>所有者：投资者、即企业资本的提供者；在股份企业中指股东</li>
<li>权益：权利</li>
<li>剩余权益：资产扣除负债后由所有者享有的权利</li>
</ul>
</blockquote>
<h3 id="组成内容"><a href="#组成内容" class="headerlink" title="组成内容"></a>组成内容</h3><p>所有者权益组成：</p>
<blockquote>
<ul>
<li>投入资本：包括实收资本（股本）和资本公积（溢价）</li>
<li>利得和损失：非日常活动形成的经济利益的流入和流出</li>
<li>留存收益：盈余公积和未分配利润</li>
</ul>
</blockquote>
<h3 id="所有者权益和负债的区别"><a href="#所有者权益和负债的区别" class="headerlink" title="所有者权益和负债的区别"></a>所有者权益和负债的区别</h3><blockquote>
<ul>
<li>是否需要偿还：所有者权益一般不需归还；负债必须偿还</li>
<li>享有权益内容：所有者权益具有参与利润分配和企业经营管理的权利；负债只有按期收回本息权</li>
<li>企业清算时求偿权的区别：所有者权益没有优先求偿权；负债拥有优先求偿权（第一权益）</li>
</ul>
</blockquote>
<h2 id="收入"><a href="#收入" class="headerlink" title="收入"></a>收入</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>定义：收入是一种符合如下三种经济利益的总流入</p>
<blockquote>
<ul>
<li>企业在日常活动中形成的</li>
<li>导致所有者权益增加</li>
<li>与所有者投入资本无关</li>
</ul>
</blockquote>
<p>日常活动：</p>
<blockquote>
<ul>
<li>企业所进行的主要的、基本的业务活动</li>
<li>企业在日常活动中产生的经济利益的流入</li>
<li>严格区分于非日常活动产生的利得（固定资产盘盈（指数值增加）等）</li>
</ul>
</blockquote>
<p>导致所有者权益增加：</p>
<blockquote>
<ul>
<li>是由收入、费用及利润与所有者权益之间的关系所决定的</li>
<li>如：预收款不是收入；第三方代收款项不是收入</li>
</ul>
</blockquote>
<p>收入与收入与所有者投资无关：</p>
<blockquote>
<ul>
<li>所有者投资属于企业的筹资业务，不属于日常活动收入</li>
</ul>
</blockquote>
<h3 id="收入组成内容"><a href="#收入组成内容" class="headerlink" title="收入组成内容"></a>收入组成内容</h3><p>组成：企业日常活动产生的经济利益流入</p>
<blockquote>
<ul>
<li>主营业务收入</li>
<li>其他业务收入（和主营业务收入合称营业收入）</li>
<li>投资收益：如购买其他企业的股票、债券所获得的收入</li>
<li>营业外收入：广义的收入组成内容；如处置报废固定资产、对员工的罚款等</li>
</ul>
</blockquote>
<h2 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>费用：满足下列三条件的经济利益的总流出</p>
<blockquote>
<ul>
<li>日常活动中发生的</li>
<li>导致所有者权益减少的</li>
<li>与向所有者分配利益无关的</li>
</ul>
</blockquote>
<p>成本和费用的区别：广义上一致，狭义上成本和生产产品直接相关</p>
<p>企业在日常活动中产生的经济利益流出：</p>
<blockquote>
<ul>
<li>导致现金或等价物流出企业</li>
<li>严格区别于非日常活动发生的损失，如处置损毁、报废固定资产发生的净损失</li>
</ul>
</blockquote>
<h3 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h3><blockquote>
<ul>
<li>主营业务成本</li>
<li>其他业务成本</li>
<li>税金及附加：除增值税、所得税之外的其他税费</li>
<li>投资损失：投资活动发生的损失</li>
<li>期间费用：销售费用（广告）、管理费用（高管工资）、财务费用（借贷款利息等）</li>
<li>资产减值损失：应收账款坏账、固定资产减值损失和存货跌价损失等</li>
<li>所得税费用</li>
<li>营业外支出：罚款支出、捐赠支出等</li>
</ul>
</blockquote>
<h2 id="利润"><a href="#利润" class="headerlink" title="利润"></a>利润</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>利润是指企业在一定会计期间（月、季度、半年或年度）的经营成果</p>
<p>利润的特征：狭义收入-狭义费用+营业外收入-营业外支出</p>
<h2 id="会计等式"><a href="#会计等式" class="headerlink" title="会计等式"></a>会计等式</h2><p>会计等式（会计平衡公式）是描述会计要素之间的基本关系的恒等式：</p>
<blockquote>
<ul>
<li>第一会计等式：资产=负债+所有者权益</li>
<li>动态会计等式：收入-费用=利润</li>
<li>扩展会计等式：资产=负债+(去年)所有者权益+(收入-费用)（即未分配利润）</li>
</ul>
</blockquote>
<h3 id="经济业务对基本会计等式的影响P24"><a href="#经济业务对基本会计等式的影响P24" class="headerlink" title="经济业务对基本会计等式的影响P24"></a>经济业务对基本会计等式的影响P24</h3><p>资产=负债+所有者权益</p>
<blockquote>
<ul>
<li>资产项目此增彼减，总额不变</li>
<li>负债项目此增彼减，总额不变：借新债还旧债</li>
<li>所有者权益此增彼减，总额不变：股份回购</li>
<li>负债增加，所有者权益减少</li>
<li>所有者权益增加，负债项目减少：债转股</li>
<li>资产增加，负债增加：贷款购买设备</li>
<li>资产增加，所有者权益增加</li>
<li>资产减少，负债减少</li>
<li>资产减少，所有者权益减少：撤资</li>
</ul>
</blockquote>
<h1 id="三、会计核算基础"><a href="#三、会计核算基础" class="headerlink" title="三、会计核算基础"></a>三、会计核算基础</h1><h2 id="会计假设"><a href="#会计假设" class="headerlink" title="会计假设"></a>会计假设</h2><p>会计假设是会计核算的基本前提，是为了保证会计工作正常进行和会计信息的质量，而对会计核算所处的空间范围、时间范围、基本程序和计量方法所做的合理设定。</p>
<h3 id="会计主体假设"><a href="#会计主体假设" class="headerlink" title="会计主体假设"></a>会计主体假设</h3><p>定义：企业应当对其本身发生的交易或者事项进行会计确认、计量和报告。</p>
<p>意义：</p>
<blockquote>
<ul>
<li>明确了会计工作的空间范围，解决了核算谁的经济业务、为谁记账的问题。</li>
</ul>
</blockquote>
<p>会计所服务的特定单位或组织：</p>
<blockquote>
<ul>
<li>法人主体是一个会计主体，会计主体则不一定是法律主体（如企业集团）</li>
</ul>
</blockquote>
<h3 id="持续经营假设"><a href="#持续经营假设" class="headerlink" title="持续经营假设"></a>持续经营假设</h3><p>定义：企业会计确认、计量和报告应当以持续经营为前提</p>
<p>意义：</p>
<blockquote>
<ul>
<li>明确了会计工作的时间范围——企业正常经营期间所发生的交易或事项。</li>
<li>是合理选择会计程序及方法的基础。如跨期费用摊销、固定资产折旧的计提等。</li>
<li>是“会计分期”假设等建立的基础。</li>
</ul>
</blockquote>
<h3 id="会计分期假设"><a href="#会计分期假设" class="headerlink" title="会计分期假设"></a>会计分期假设</h3><p>定义：企业应当划分会计期间，分期结算账目和编制财务会计报告</p>
<p>意义：</p>
<blockquote>
<ul>
<li>明确了会计核算的基本程序，明确了何时记账、算账和报账问题</li>
<li>界定了本期、前期和后期等概念，可以准确提供各期财务状况、经营成果资料，<br>也便于进行各期会计信息的对比。</li>
</ul>
</blockquote>
<h3 id="货币计量假设"><a href="#货币计量假设" class="headerlink" title="货币计量假设"></a>货币计量假设</h3><p>定义：企业会计应当以货币计量</p>
<blockquote>
<ul>
<li>以货币为主要计量单位记录和报告企业的经营情况</li>
<li>采用币值稳定的货币为前提</li>
</ul>
</blockquote>
<h2 id="会计信息质量特征"><a href="#会计信息质量特征" class="headerlink" title="会计信息质量特征"></a>会计信息质量特征</h2><ul>
<li>可靠性：所有会计的确认计量和报告必须真实可靠</li>
<li>相关性（有用性）：企业提供的会计信息应当与财务会计报告使用者的经济决策需要相关；有助于使用者对企业过去、现在或将来的情况做出评价或预测</li>
<li>可理解性（明晰性）：企业提供的信息应当清晰明了，便于财务会计报告使用者理解和运用</li>
<li>可比性：企业提供的会计信息应当具有可比性；同一企业在不同时间纵向可比，不同企业同一期间横向可比</li>
<li>实质重于形式：企业应当按照交易或者事项的经济实质进行会计确认、计量和报告，不应仅以交易或者事项的法律形式作为依据。</li>
<li>重要性：企业提供的会计信息应当反映与企业财务状况、经营成果和现金流量有关的所有重要交易或者事项。</li>
<li>谨慎性（稳健性、保守性）：企业对交易或者事项进行会计确认、计量和报告应当保持应有的谨慎，不应高估资产或者收益、不应低估负债或费用。计预期损失而不计预期收入</li>
<li>及时性：企业对于已经发生的交易或者事项，应当及时进行会计确认、计量和报告，不得提提前或者延后。</li>
</ul>
<h2 id="会计要素确认、计量及要求"><a href="#会计要素确认、计量及要求" class="headerlink" title="会计要素确认、计量及要求"></a>会计要素确认、计量及要求</h2><p>交易或事项-会计确认-会计计量-会计记录-会计报告-会计信息</p>
<p>会计确认：将发生的交易或事项与一定会计要素联系起来加以认定的过程</p>
<blockquote>
<ul>
<li>初始确认条件（记入账户）：符合定义、有利益的流入流出、可计量</li>
<li>最终确认条件（列入报表）：符合（要素）定义、符合要素确认条件</li>
</ul>
</blockquote>
<p>会计计量：对交易或事项引起的会计要素增减变动的金额加以认定的过程</p>
<ul>
<li>计量单位：以货币做主要计量单位</li>
<li>计量属性：<blockquote>
<ul>
<li>历史成本：购置时的金额</li>
<li>重置成本：按现实购买的金额</li>
<li>可变现净值：按现时销售的金额</li>
<li>现值：按照将来的金额折现</li>
<li>公允价值：有序交易中出售资产能收到的价格</li>
</ul>
<p>计量属性选择原则：计量必须可靠，一般企业采用历史成本</p>
</blockquote>
</li>
</ul>
<h2 id="权责发生制与收付实现制"><a href="#权责发生制与收付实现制" class="headerlink" title="权责发生制与收付实现制"></a>权责发生制与收付实现制</h2><p>企业在进行交易的过程中，与收入和费用有关的款项收支时间和归属时间往往不一致</p>
<p>权责发生制与收付实现制是确认交易或事项的两种基础</p>
<blockquote>
<ul>
<li>收付实现制：以货币资金的实收实付作为确认收入和费用的唯一标准（计实收实付）</li>
<li>权责发生制：以权利已经形成或义务已经发生（责任应当承担）作为确认收入和费用的标准（计应收应付）</li>
</ul>
</blockquote>
<p>企业应当以权责发生制为基础进行会计确认、计量和报告</p>
<h1 id="四、账户与复式记账"><a href="#四、账户与复式记账" class="headerlink" title="四、账户与复式记账"></a>四、账户与复式记账</h1><h2 id="账户与会计科目"><a href="#账户与会计科目" class="headerlink" title="账户与会计科目"></a>账户与会计科目</h2><p>账户：账户是根据会计科目设置的，具有专门<strong>格式</strong>，用以分类、连续的记录经济业务对工具；具有一定的格式的会计科目是称为会计账户</p>
<p>账户记录内容：</p>
<blockquote>
<ul>
<li>业务发生时间</li>
<li>记录依据</li>
<li>业务内容</li>
<li>增减金额</li>
<li>余额方向</li>
<li>余额</li>
</ul>
</blockquote>
<p>会计科目的分类：</p>
<blockquote>
<ul>
<li>总分类科目：严格按照会计准则规范设置</li>
<li>二级分类科目</li>
<li>明细科目：根据核算和管理管理的需要设置</li>
</ul>
</blockquote>
<h2 id="复式记账原理"><a href="#复式记账原理" class="headerlink" title="复式记账原理"></a>复式记账原理</h2><p>基本含义：对任何一项经济业务（交易或事项）都以相等的金额在<strong>两个或两个以上</strong>有关账户中相互联系的进行登记，借以反映会计对象具体内容增减变化的一种记账方法</p>
<p>例：企业用银行存款3000元购买原材料</p>
<blockquote>
<ul>
<li>原材料账户增加3000</li>
<li>银行存款减少3000</li>
</ul>
</blockquote>
<p>复式记账能够更加全面系统地反映经济业务对实质</p>
<p>复式记账的理论依据：第一会计等式的存在</p>
<p>基本原则：</p>
<blockquote>
<ul>
<li>以反映资金运动的内在规律的会计等式为记账基础</li>
<li>对每项业务必须在两个或两个以上相互联系的账户中等额记录</li>
<li>必须按经济业务对会计等式的类型（四种）记录</li>
<li>定期汇总的全部账户记录必须平衡</li>
</ul>
</blockquote>
<h2 id="借贷记账法"><a href="#借贷记账法" class="headerlink" title="借贷记账法"></a>借贷记账法</h2><ul>
<li>对于资产、费用而言：借，增加；贷，减少；余额=借-贷</li>
<li>对于负债、所有者权益、收入和利润而言：借，减少；贷，增加；余额=贷-借</li>
</ul>
<p>记账规则：有借必有贷，借贷必相等</p>
<p>例：公司收到投资者8000，存入银行</p>
<blockquote>
<ul>
<li>银行存款（资产）：借，8000</li>
<li>实收资本（所有者权益）：贷，8000</li>
</ul>
</blockquote>
<p>例：公司用银行存款偿还银行账户1000元</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">借：  短期贷款 1000</span><br><span class="line">    贷：  银行存款 1000</span><br></pre></td></tr></table></figure>

<p>会计分录：会计的初始确认，会计信息的入口</p>
<blockquote>
<ul>
<li>讲经济业务登记账户前预先确定的应记账户的名称、方向和金额的记录形式</li>
<li>在实物中，会计分录的载体是记账凭证</li>
</ul>
</blockquote>
<h1 id="五、企业主要经济业务的核算"><a href="#五、企业主要经济业务的核算" class="headerlink" title="五、企业主要经济业务的核算"></a>五、企业主要经济业务的核算</h1><h2 id="企业主要经济业务概述"><a href="#企业主要经济业务概述" class="headerlink" title="企业主要经济业务概述"></a>企业主要经济业务概述</h2><p>企业是以产品生产和销售或劳务提供为主要内容的经济组织，主要业务如下</p>
<blockquote>
<ul>
<li>资金筹集业务</li>
<li>供应过程业务</li>
<li>生产过程业务</li>
<li>销售过程业务</li>
<li>财务成果形成与分配业务等</li>
</ul>
</blockquote>
<h2 id="资金筹集的业务"><a href="#资金筹集的业务" class="headerlink" title="资金筹集的业务"></a>资金筹集的业务</h2><p>资金投入：资金一般以货币资金形态进入企业</p>
<blockquote>
<ul>
<li>实收资本业务核算：企业投资者按照章程、合同、协议的规定将资本金实际投入企业</li>
<li>资本公积业务核算：由投资者投入企业，所有权仍属于投资者，但在金额上超过其法定注册资本</li>
<li>负债资金筹集业务核算：企业从债权人（银行、应付账款等）处筹集到资金</li>
</ul>
</blockquote>
<h3 id="实收资本业务核算"><a href="#实收资本业务核算" class="headerlink" title="实收资本业务核算"></a>实收资本业务核算</h3><p>实收资本分类：</p>
<blockquote>
<ul>
<li>（按投资主体划分）国家资本金</li>
<li>法人资本金</li>
<li>个人资本金</li>
<li>外商资本金</li>
<li>（按投资形式划分）货币资金投资</li>
<li>非货币资产投资</li>
</ul>
</blockquote>
<p>会计计量：实收资本入账价值的确定</p>
<blockquote>
<ul>
<li>货币资金投资： 现金或银行存款方式投资，按实际收到的货币资金金额入账</li>
<li>非货币资产投资：以按投资各方确认的价值入账</li>
<li>实际收到的超过投资方在注册资本中的占有份额部分不计入实收资本，记入资本公积</li>
</ul>
</blockquote>
<p>收到投资：实收资本-&gt;资产类账户（银行存款、固定资产、无形资产…）</p>
<p>相关账户：</p>
<blockquote>
<ul>
<li>实收资本：退还投资数 | 收到投资数</li>
<li>银行存款、固定资产…</li>
<li><img src="/2020/11/07/accountancy/image-20201113172629892.png" alt="image-20201113172629892"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">收到货币投资：</span><br><span class="line">借：  银行存款</span><br><span class="line">    贷：  实收资本</span><br><span class="line">    </span><br><span class="line">收到确认了价值的设备投资：</span><br><span class="line">借：  固定资产</span><br><span class="line">    贷：  实收资本</span><br></pre></td></tr></table></figure>

<h3 id="资本公积业务核算"><a href="#资本公积业务核算" class="headerlink" title="资本公积业务核算"></a>资本公积业务核算</h3><p>资本公积来源：</p>
<blockquote>
<ul>
<li>有投资者投入企业的在金额上超过其法定注册资本的部分</li>
<li>直接计入资本公积的利得和损失</li>
</ul>
</blockquote>
<p>相关账户：</p>
<blockquote>
<ul>
<li>实收资本（若为股份有限公司则为股本）</li>
<li>资本公积</li>
<li>银行存款</li>
<li><img src="/2020/11/07/accountancy/image-20201113173010460.png" alt="image-20201113173010460"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">收到货币投资、部分作为资本公积：</span><br><span class="line">借：  银行存款</span><br><span class="line">    贷：  实收资本</span><br><span class="line">        资本公积-资本溢价</span><br><span class="line"></span><br><span class="line">将资本公积转为实收资本：</span><br><span class="line">借：  资本公积</span><br><span class="line">    贷：  实收资本</span><br></pre></td></tr></table></figure>

<h3 id="负债资金筹集业务核算"><a href="#负债资金筹集业务核算" class="headerlink" title="负债资金筹集业务核算"></a>负债资金筹集业务核算</h3><h4 id="短期借款"><a href="#短期借款" class="headerlink" title="短期借款"></a>短期借款</h4><p>短期借款：偿还期在一年以内（含一年）的借款（流动负债）</p>
<p>短期借款本金及利息的确认与计量:</p>
<blockquote>
<ul>
<li>本金的确认与计量：按借款单据上的金额确认</li>
<li>利息的确认与计量：借款利息＝借款本金×利率×时间（按月、日）</li>
<li>短期借款利息应当按月确认为借款使用期间的财务费用（利率转换为月利率计算）</li>
</ul>
</blockquote>
<p>短期借款相关账户</p>
<blockquote>
<ul>
<li>短期借款：负债类账户</li>
<li>应付利息：负债类账户</li>
<li>财务费用</li>
<li>银行存款等</li>
<li><img src="/2020/11/07/accountancy/image-20201113173204675.png" alt="image-20201113173204675"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">向（银行）借入短期借款：</span><br><span class="line">借：  银行存款</span><br><span class="line">    贷：  短期贷款</span><br><span class="line"></span><br><span class="line">确认利息：</span><br><span class="line">借：  财务费用</span><br><span class="line">    贷：  应付利息</span><br><span class="line"></span><br><span class="line">支付利息：</span><br><span class="line">借：  应付利息</span><br><span class="line">    贷：  银行存款</span><br></pre></td></tr></table></figure>

<h3 id="长期借款"><a href="#长期借款" class="headerlink" title="长期借款"></a>长期借款</h3><p>长期借款：偿还期在1年以上的借款（非流动负债）</p>
<p>长期借款本金与利息的确认与计量：</p>
<blockquote>
<ul>
<li>本金的确认与计量：按申请借款时实际收到的借款金额确认与计量</li>
<li>利息的确认与计量：按月确认，未完工时资本化、完工后费用化</li>
<li>工程建设期的利息计入工程成本</li>
<li>工程完工投入使用后的利息计入财务费用</li>
</ul>
</blockquote>
<p>相关账户：（注意，没有应付利息）</p>
<blockquote>
<ul>
<li>长期借款：负债类账户；归还数 | 借入数</li>
<li>银行存款</li>
<li>在建工程</li>
<li>财务费用</li>
<li><img src="/2020/11/07/accountancy/image-20201113173339859.png" alt="image-20201113173339859"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">借入长期借款：</span><br><span class="line">借：  银行存款</span><br><span class="line">    贷：长期借款</span><br><span class="line"></span><br><span class="line">工程未完成时利息计量：</span><br><span class="line">借：  在建工程</span><br><span class="line">    贷：  长期借款（由于是非流动负债，因此不能写应付利息）</span><br><span class="line"></span><br><span class="line">工程完成时的利息计量：</span><br><span class="line">借：  财务费用</span><br><span class="line">    贷：  长期借款</span><br><span class="line"></span><br><span class="line">偿还本息：</span><br><span class="line">借：  长期借款</span><br><span class="line">    贷：  银行存款</span><br></pre></td></tr></table></figure>

<h2 id="供应过程业务核算"><a href="#供应过程业务核算" class="headerlink" title="供应过程业务核算"></a>供应过程业务核算</h2><p>供应过程业务发生在资金使用阶段</p>
<h3 id="固定资产（设备）购置业务的核算"><a href="#固定资产（设备）购置业务的核算" class="headerlink" title="固定资产（设备）购置业务的核算"></a>固定资产（设备）购置业务的核算</h3><p>固定资产的确认：</p>
<blockquote>
<ul>
<li>为生产商品、提供劳务、出租或经营管理所持有（非出售）</li>
<li>使用寿命超过一个会计年度</li>
<li>（定义以外）资产包括的经济利益可能流入企业、资产包括的成本能够可靠计量</li>
</ul>
</blockquote>
<p>固定资产的计量：</p>
<blockquote>
<ul>
<li>购置的固定资产：按发生的实际支出计算（购买+包装+运输+安装+借款利息等，但不包括进项税）</li>
<li>建造的固定资产：按估计价值计算（包括人工、材料、机械费等）</li>
</ul>
</blockquote>
<p>相关账户：</p>
<blockquote>
<ul>
<li>固定资产、在建工程、固定资产清理</li>
<li>（购置时）银行存款、应付账款</li>
<li>（建造时）原材料、应付职工薪酬等</li>
<li>应交税费：进项税额</li>
<li><img src="/2020/11/07/accountancy/image-20201113173514931.png" alt="image-20201113173514931"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">购入含税设备：</span><br><span class="line">借：  固定资产</span><br><span class="line">    应交税费-应交增值税（进项税）</span><br><span class="line">    贷：  银行存款 &#x2F; 应付账款（若账款未付）</span><br><span class="line"></span><br><span class="line">安装设备期间费用：</span><br><span class="line">借：  在建工程</span><br><span class="line">    贷：  原材料</span><br><span class="line">        应付职工薪酬</span><br><span class="line"></span><br><span class="line">安装设备完成（工程建设完成）：</span><br><span class="line">借：  固定资产</span><br><span class="line">    贷：  在建工程</span><br></pre></td></tr></table></figure>

<h3 id="材料采购业务核算"><a href="#材料采购业务核算" class="headerlink" title="材料采购业务核算"></a>材料采购业务核算</h3><p>企业对材料采购业务等核算通常有实际成本计价和计划成本计价</p>
<h4 id="原材料按实际成本计价的核算"><a href="#原材料按实际成本计价的核算" class="headerlink" title="原材料按实际成本计价的核算"></a>原材料按实际成本计价的核算</h4><p>费用和资产的计量：</p>
<blockquote>
<ul>
<li>购买时支付的商业汇票是‘应付票据’，其后期需要用‘银行存款’进行兑付</li>
<li>增值税记入‘应交税费’</li>
<li>其他税金算采购成本，计入‘在途物资’</li>
<li>发生采购的费用，包括运杂费等，也计入‘在途物资’</li>
<li>小额零星采购费（市内运输费）不算采购成本，可计入‘管理费用’</li>
</ul>
</blockquote>
<p>相关账户：</p>
<blockquote>
<ul>
<li>（结算）银行存款/库存现金、应付账款/票据、预付账款</li>
<li>在途物资：采购实际成本 | 入库实际成本</li>
<li>原材料</li>
<li>生产成本</li>
<li><img src="/2020/11/07/accountancy/image-20201113173658355.png" alt="image-20201113173658355"></li>
<li><img src="/2020/11/07/accountancy/image-20201113173636253.png" alt="image-20201113173636253"></li>
</ul>
</blockquote>
<p>关于增值税：</p>
<blockquote>
<ul>
<li>进项税额：不含税买价*税率；注意含税价款计税需要除以(1+税率)</li>
<li>销项税额：不含税销售额*税率</li>
<li>企业应当缴纳税额：销项税额-进项税额</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">购入材料甲乙：</span><br><span class="line">借： 在途物资   -甲材料</span><br><span class="line">            -乙材料</span><br><span class="line">    应交税费-应交增值税（进项税）</span><br><span class="line">    贷：  银行存款 &#x2F; 应付账款	-某工厂 &#x2F; 预付账款 	-某工厂</span><br><span class="line"></span><br><span class="line">公司向企业预付购货款：</span><br><span class="line">借：  预付账款  -某工厂</span><br><span class="line">    贷：  银行存款</span><br><span class="line"></span><br><span class="line">材料验收入库，结转实际采购成本：</span><br><span class="line">借：  原材料 -某材料</span><br><span class="line">    贷：  在途物资</span><br><span class="line"></span><br><span class="line">领用原材料进行生产：</span><br><span class="line">借：  生产成本</span><br><span class="line">    贷：  原材料-某材料</span><br></pre></td></tr></table></figure>

<h4 id="原材料按计划成本计价的核算"><a href="#原材料按计划成本计价的核算" class="headerlink" title="原材料按计划成本计价的核算"></a>原材料按计划成本计价的核算</h4><p>计划成本：企业在指定材料采购计划时所确定的成本；在日常收、发材料时均采用计划成本而非实际成本</p>
<p>相关账户：</p>
<blockquote>
<ul>
<li>银行存款、应交税费等、原计划</li>
<li>材料采购： 材料采购（实际成本） | 材料入库（计划成本）</li>
<li>原材料：收入材料 | 发出材料</li>
<li>生产成本等</li>
<li>材料成本差异：结转差异 | 分配差异</li>
<li><img src="/2020/11/07/accountancy/image-20201113223053438.png" alt="image-20201113223053438"></li>
<li><img src="/2020/11/07/accountancy/image-20201113223112243.png" alt="image-20201113223112243"></li>
<li><img src="/2020/11/07/accountancy/image-20201113223407916.png" alt="image-20201113223407916"></li>
</ul>
</blockquote>
<p>材料成本差异 = 实际成本-计划成本<br>生产实际成本 = 领用材料计划成本+相应材料成本差异</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">购入材料（一般不编制多借多贷的会计分录）：</span><br><span class="line">借：  材料采购</span><br><span class="line">    应交税费-应交增值税</span><br><span class="line">    贷：  银行存款</span><br><span class="line">        库存现金</span><br><span class="line"></span><br><span class="line">材料验收入库并结转差异（此处购买超支，材料成本差异为借）：</span><br><span class="line">借：  原材料-某材料</span><br><span class="line">     材料成本差异-某材料</span><br><span class="line">    贷：材料采购-某材料</span><br><span class="line"></span><br><span class="line">领用材料（按计划成本计算）：略</span><br><span class="line"></span><br><span class="line">结转领用材料的成本差异（此时购买超支，材料成本差异为贷）；注意差异值的计算：</span><br><span class="line">借：  原材料</span><br><span class="line">    贷：材料成本差异</span><br></pre></td></tr></table></figure>

<h2 id="生产过程业的核算"><a href="#生产过程业的核算" class="headerlink" title="生产过程业的核算"></a>生产过程业的核算</h2><p>资金使用：生产过程业务</p>
<h3 id="材料费用的归集与分配"><a href="#材料费用的归集与分配" class="headerlink" title="材料费用的归集与分配"></a>材料费用的归集与分配</h3><p>费用的确认：</p>
<blockquote>
<ul>
<li>费用按照权责发生制，划分收益性支出和资本性支出</li>
<li>制造费用：制造企业在生产产品过程中发生的用货币表现的广义上的生产耗费；包括人工、材料和设备损耗</li>
<li>生产成本（制造成本）：企业为生产一定<strong>种类和数量</strong>的产品所发生的<strong>生产费用总和</strong>的对象化</li>
<li>为生产特定产品的费用计入生产成本；一般普遍性耗费计入制造费用</li>
</ul>
</blockquote>
<p>相关账户：</p>
<blockquote>
<ul>
<li>原材料：贷方包括生产领用和一般耗用</li>
<li>生产成本</li>
<li>制造费用</li>
<li><img src="/2020/11/07/accountancy/image-20201113224827329.png" alt="image-20201113224827329"></li>
</ul>
</blockquote>
<h3 id="人工费用的归集与分配"><a href="#人工费用的归集与分配" class="headerlink" title="人工费用的归集与分配"></a>人工费用的归集与分配</h3><p>人工费用：包括短期薪酬、离职后福利、辞退福利、其他长期职工福利等</p>
<p>相关账户：</p>
<blockquote>
<ul>
<li>银行存款、库存现金（提取现金准备发放工资）</li>
<li>应付职工薪酬： 实付数 | 应付数（工人工资等）</li>
<li>生产成本、制造费用、管理费用</li>
</ul>
</blockquote>
<p>制造费用和管理费用的区别：</p>
<blockquote>
<ul>
<li>制造费用：在产品生产场所发生的费用</li>
<li>管理费用：在企业领导机构，如董事会、人力/技术/统计部门、办公室发生的费用</li>
<li><img src="/2020/11/07/accountancy/image-20201113233738473.png" alt="image-20201113233738473"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分配生产工人（生产成本）、车间管理人员（制造费用）和企业管理人员（管理费用）的工资：</span><br><span class="line">借：  生产成本 -A产品</span><br><span class="line">           -B产品</span><br><span class="line">    制造费用 -工资</span><br><span class="line">    管理费用 -工资</span><br><span class="line">    贷：  应付职工薪酬 -工资</span><br><span class="line"></span><br><span class="line">提取现金备发工资：</span><br><span class="line">借：  库存现金</span><br><span class="line">    贷：  银行存款</span><br><span class="line"></span><br><span class="line">用现金发放工资：</span><br><span class="line">借：  应付职工薪酬  -工资</span><br><span class="line">    贷：  库存现金</span><br></pre></td></tr></table></figure>

<h3 id="制造费用的归集与分配"><a href="#制造费用的归集与分配" class="headerlink" title="制造费用的归集与分配"></a>制造费用的归集与分配</h3><p>制造费用是企业生产管理部门（如生产车间）为阻止和管理产品生产活动而发生的各种间接费用：</p>
<blockquote>
<ul>
<li>车间管理人员工资</li>
<li>办公费</li>
<li>设备使用费</li>
</ul>
</blockquote>
<p>相关账户：</p>
<blockquote>
<ul>
<li>原材料、应付职工薪酬、累计折旧、（长期）待摊费用、预提费用、银行存款等</li>
<li>制造费用</li>
<li>生产成本</li>
<li>库存商品</li>
<li><img src="/2020/11/07/accountancy/image-20201113234045053.png" alt="image-20201113234045053"></li>
<li><img src="/2020/11/07/accountancy/image-20201113234055017.png" alt="image-20201113234055017"></li>
</ul>
</blockquote>
<p>注意：制造费用在月末时一般无余额，会被计入生产成本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用银行存款预付明后年度车间房租：</span><br><span class="line">借：  长期待摊费用</span><br><span class="line">    贷：  银行存款</span><br><span class="line">&#x2F;&#x2F;（待摊费用的使用）</span><br><span class="line">借：  制造费用</span><br><span class="line">    贷：  长期待摊费用</span><br><span class="line">    </span><br><span class="line">设备维修产生费用：</span><br><span class="line">借：  制造费用</span><br><span class="line">    贷： 银行存款</span><br></pre></td></tr></table></figure>

<p>关于固定资产的后续计算（折旧）：</p>
<blockquote>
<ul>
<li>固定资产的折旧：固定资产在使用过程的中价值损耗，提取折旧是为了固定资产的更新</li>
<li>折旧的计算提取方法：月末计算折旧额并按照资产的用途计入当月成本或费用；每月计提折旧额=历史成本（账面原值）*折旧率</li>
<li>折旧核算：设立‘累计折旧’账户，专门记录已计提的折旧额；而非贷固定资产</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计提本月车间、厂部固定资产折旧：</span><br><span class="line">借：  制造费用</span><br><span class="line">    管理费用</span><br><span class="line">    贷：  累计折旧</span><br><span class="line"></span><br><span class="line">月末按标准分配制造费用，计入生产成本：</span><br><span class="line">借：  生产成本 -A产品</span><br><span class="line">    生产成本 -B产品</span><br><span class="line">    贷：  制造费用</span><br></pre></td></tr></table></figure>

<h3 id="完工产品生产成本的计算与结转"><a href="#完工产品生产成本的计算与结转" class="headerlink" title="完工产品生产成本的计算与结转"></a>完工产品生产成本的计算与结转</h3><p>成本的构成和计算：</p>
<blockquote>
<ul>
<li>直接材料</li>
<li>直接人工</li>
<li>制造费用</li>
</ul>
</blockquote>
<p>完工产品生产成本的结转：商品完工，变成库存商品</p>
<p>相关账户：</p>
<blockquote>
<ul>
<li>生产成本： … | 完工成本</li>
<li>库存商品： 入库成本 | 销售成本</li>
<li><img src="/2020/11/07/accountancy/image-20201113234156332.png" alt="image-20201113234156332"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结转完工产品的生产成本：</span><br><span class="line">借：  库存商品 -某商品</span><br><span class="line">    贷：  生产成本 -某商品</span><br></pre></td></tr></table></figure>

<h2 id="销售过程业务的核算"><a href="#销售过程业务的核算" class="headerlink" title="销售过程业务的核算"></a>销售过程业务的核算</h2><p>资金使用：销售过程</p>
<h3 id="主营业务收支的核算"><a href="#主营业务收支的核算" class="headerlink" title="主营业务收支的核算"></a>主营业务收支的核算</h3><h4 id="商品销售收入的确认和计量"><a href="#商品销售收入的确认和计量" class="headerlink" title="商品销售收入的确认和计量"></a>商品销售收入的确认和计量</h4><p>确认销售收入的过程：</p>
<blockquote>
<ul>
<li>识别与客户定立的合同</li>
<li>识别合同中点单项履约义务</li>
<li>确定交易价格</li>
<li>将交易价格分摊为义务</li>
<li>履行每一项义务时确认收入</li>
</ul>
</blockquote>
<p>相关账户：</p>
<blockquote>
<ul>
<li>主营业务收入： 期末结转（向利润结转） | 实现数</li>
<li>预收账款（负债类账户）</li>
<li>应收账款</li>
<li>应交税费、本年利润、银行存款等</li>
<li><img src="/2020/11/07/accountancy/image-20201113234230588.png" alt="image-20201113234230588"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">销售商品，收到商业汇票（含税）：</span><br><span class="line">借：  应收票据</span><br><span class="line">    贷：  主营业务收入</span><br><span class="line">        应交税费 -应交增值税</span><br><span class="line"></span><br><span class="line">预收账款（按权责发生制计收入）：</span><br><span class="line">借：  银行存款</span><br><span class="line">    贷：  预收账款 -某工厂</span><br><span class="line"></span><br><span class="line">赊销（应收账款）产品（含税）：</span><br><span class="line">借：  应收账款 -某厂</span><br><span class="line">    贷：  主营业务收入</span><br><span class="line">        应交税费 -应交增值税（销项税）</span><br><span class="line"></span><br><span class="line">退款（含税）：</span><br><span class="line">借：  主营业务收入</span><br><span class="line">    应交税费 -应交增值税（销项税）</span><br><span class="line">    贷：  银行存款</span><br></pre></td></tr></table></figure>

<h3 id="主营业务成本核算"><a href="#主营业务成本核算" class="headerlink" title="主营业务成本核算"></a>主营业务成本核算</h3><p>主营业务成本：</p>
<blockquote>
<ul>
<li>为取得主营业务收入而发生的商品成本：产品的生产成本、库存成本等</li>
<li>不包括产品销售时发生的费用</li>
<li>应结转的主营业务成本=销售商品的单位生产成本*销售该产品的数量</li>
<li>单位成本的计算：FIFO法、一次加权平均法、个别计价法</li>
</ul>
</blockquote>
<p>相关账户：</p>
<blockquote>
<ul>
<li>库存商品： 入库成本 | 销售成本</li>
<li>主营业务成本</li>
</ul>
</blockquote>
<ul>
<li><img src="/2020/11/07/accountancy/image-20201113234436479.png" alt="image-20201113234436479"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算并结转销售产品成本</span><br><span class="line">借：  主营业务成本</span><br><span class="line">    贷：  库存商品-某商品</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="税金及附加的核算"><a href="#税金及附加的核算" class="headerlink" title="税金及附加的核算"></a>税金及附加的核算</h3><p>税金及附加：</p>
<blockquote>
<ul>
<li>企业日常经营活动应负担的税金及附加</li>
<li>应交消费税=应税销售额*消费税税率</li>
<li>应交城建税=(当期消费税+增值税)*城建税税率</li>
<li>应交教育税附加=(当期消费税+增值税)*教育附加税率</li>
</ul>
</blockquote>
<p>相关账户：</p>
<blockquote>
<ul>
<li>银行存款</li>
<li>应交税费</li>
<li>税金及附加</li>
<li>本年利润</li>
<li><img src="/2020/11/07/accountancy/image-20201113234526918.png" alt="image-20201113234526918"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算结转主营业务的税金及附加</span><br><span class="line">借：  税金及附加</span><br><span class="line">    贷：  应交税费-应交xx税</span><br><span class="line"></span><br><span class="line">支付税金及附加</span><br><span class="line">借：  税金及附加</span><br><span class="line">    贷：  银行存款</span><br></pre></td></tr></table></figure>

<h3 id="其他业务收入、成本的核算"><a href="#其他业务收入、成本的核算" class="headerlink" title="其他业务收入、成本的核算"></a>其他业务收入、成本的核算</h3><p>其他业务收入和成本是企业在日常经营活动中发生的主营业务以外的其他业务收入和成本。如销售材料、出租包装物和固定资产等实现的收入和发生的成本，属于企业的日常经营活动业务。</p>
<p>相关账户：</p>
<blockquote>
<ul>
<li>原材料等</li>
<li>其他业务成本</li>
<li>本年利润</li>
<li>其他业务收入</li>
<li>银行存款</li>
<li><img src="/2020/11/07/accountancy/image-20201113234722985.png" alt="image-20201113234722985"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">销售材料（含税），款项存入银行：</span><br><span class="line">借：  银行存款</span><br><span class="line">    贷：  其他业务收入</span><br><span class="line">        应交税费-应交增值税（销项税）</span><br><span class="line"></span><br><span class="line">结转销售材料成本：</span><br><span class="line">借：  其他业务成本</span><br><span class="line">    贷：  原材料</span><br><span class="line"></span><br><span class="line">出租包装物，租金存入银行</span><br><span class="line">借：  银行存款</span><br><span class="line">    贷：  其他业务收入</span><br><span class="line">        应交税费-应交增值税（销项税）</span><br><span class="line"></span><br><span class="line">结转出租包装物成本：</span><br><span class="line">借：  其他业务成本</span><br><span class="line">    贷：  周转材料</span><br><span class="line"></span><br><span class="line">转让商标使用权：</span><br><span class="line">借：  银行存款</span><br><span class="line">    贷：  其他业务收入</span><br></pre></td></tr></table></figure>

<h2 id="财务成果形成与分配业务"><a href="#财务成果形成与分配业务" class="headerlink" title="财务成果形成与分配业务"></a>财务成果形成与分配业务</h2><p>财务成果：企业在一定会计期间所实现的最终经营成果，即实现的利润或发生亏损的总额</p>
<h3 id="利润的构成和简单计算"><a href="#利润的构成和简单计算" class="headerlink" title="利润的构成和简单计算"></a>利润的构成和简单计算</h3><ul>
<li><p>营业利润=营业收入-营业成本-税金及附加-销售费用-管理费用-财务费用-资产减值损失 +- 公允价值变动损益 +- 投资净损益 +- 资产处置净损益</p>
</li>
<li><p>利润（亏损）总额 = 营业利润 + 营业外收入（利得） - 营业外支出（损失）</p>
</li>
<li><p>净利润 = 利润总额 - 所得税费用</p>
</li>
</ul>
<p>净利润的核算: 设置本年利润账户</p>
<blockquote>
<ul>
<li>费用类账户: 主营业务成本,税金及附加,销售费用,管理费用,财务费用,其他业务成本,营业外支出,所得税费用</li>
<li>收入类账户: 主营业务收入,其他业务收入,投资收益,营业外收入</li>
<li><img src="/2020/11/07/accountancy/image-20201113235556998.png" alt="image-20201113235556998"></li>
</ul>
</blockquote>
<h3 id="营业利润的计算"><a href="#营业利润的计算" class="headerlink" title="营业利润的计算"></a>营业利润的计算</h3><p>期间费用的核算：</p>
<blockquote>
<ul>
<li>期间费用：在发生后不能直接归属于某种特定产品成本，而应直接计入发生期损益的各种费用</li>
<li>相关账户：银行存款等；销售、管理、财务费用；本年利润</li>
<li><img src="/2020/11/07/accountancy/image-20201113234824023.png" alt="image-20201113234824023"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出差人员报销差旅费，余款540交回财会，原借款3000元</span><br><span class="line">&#x2F;&#x2F;这是对出差人员的预借款的冲销</span><br><span class="line">借：  管理费用    2460</span><br><span class="line">    库存现金    540  &#x2F;&#x2F; 若自己垫付了多余的钱，则库存现金在贷方</span><br><span class="line">    贷：  其他应收款-某人    3000  &#x2F;&#x2F;借款</span><br><span class="line">    </span><br><span class="line">借款时的分录如下：  &#x2F;&#x2F;该项为临时记录</span><br><span class="line">借：  其他应收款-某人    3000</span><br><span class="line">    贷：  库存现金    3000</span><br><span class="line"></span><br><span class="line">用现金支付董事会成员津贴</span><br><span class="line">借：  管理费用</span><br><span class="line">    贷：  库存现金</span><br><span class="line">    </span><br><span class="line">月末摊销以前期间已付款、本月应由企业管理部门承担的房租</span><br><span class="line">借：  管理费用</span><br><span class="line">    贷：  长期待摊费用</span><br><span class="line"></span><br><span class="line">用银行存款支付应由企业负担的销售产品运费：</span><br><span class="line">借：  销售费用</span><br><span class="line">    贷：  银行存款</span><br></pre></td></tr></table></figure>

<h3 id="投资收益的核算"><a href="#投资收益的核算" class="headerlink" title="投资收益的核算"></a>投资收益的核算</h3><p>投资收益：企业用资金购买债券、股票等对外投资获得的收益（或产生的损失）</p>
<p>相关账户：</p>
<blockquote>
<ul>
<li>交易性金融资产,应收股利</li>
<li>投资收益,银行存款</li>
<li>本年利润</li>
<li><img src="/2020/11/07/accountancy/image-20201113234913579.png" alt="image-20201113234913579"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">企业购买交易性金融资产:</span><br><span class="line">借:  交易性金融资产</span><br><span class="line">    贷:  银行存款</span><br><span class="line"></span><br><span class="line">企业高于购买价售出以交易为目的而购入的股票，获款579 280元。该股票购入时的买价为550 000。款项已存入银行:</span><br><span class="line">借：  银行存款  579 280（卖出价）</span><br><span class="line">    贷：交易性金融资产  550 000（原购买价）</span><br><span class="line">        投资收益  29 280（净收益）</span><br><span class="line"></span><br><span class="line">企业采用成本法核算其长期股权投资，现从被投资企业分得本年现金股利50 000元，款项暂未收到。</span><br><span class="line">借：应收股利  50 000</span><br><span class="line">    贷：投资收益  50 000</span><br><span class="line"></span><br><span class="line">实际收到现金股利：</span><br><span class="line">借：银行存款  50 000</span><br><span class="line">    贷：应收股利  50 000</span><br></pre></td></tr></table></figure>

<h3 id="营业外收支的核算"><a href="#营业外收支的核算" class="headerlink" title="营业外收支的核算"></a>营业外收支的核算</h3><p>营业外收支:</p>
<blockquote>
<ul>
<li>与企业日常经营活动没有直接关系的各项收入和支出(利得和损失)</li>
<li>营业外收入: 报废损毁非流动资产利得,债务重组利得,政府补助,流动资产盘盈利得,接受捐赠利得等</li>
<li>营业外指出: 非流动资产报废损毁损失,债务重组损失,非常损失,盘亏损失,公益性捐赠支出等</li>
</ul>
</blockquote>
<p>相关账户:</p>
<blockquote>
<ul>
<li>营业外收入,营业外支出</li>
<li>本年利润</li>
<li>银行存款等</li>
<li><img src="/2020/11/07/accountancy/image-20201113235054463.png" alt="image-20201113235054463"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">企业收到政府补助,存入银行:</span><br><span class="line">借:  银行存款</span><br><span class="line">    贷:  营业外收入</span><br><span class="line">    </span><br><span class="line">用银行存款知福公益性捐赠:</span><br><span class="line">借:  营业外支出</span><br><span class="line">    贷:  银行存款</span><br></pre></td></tr></table></figure>

<h3 id="所得税费用的核算"><a href="#所得税费用的核算" class="headerlink" title="所得税费用的核算"></a>所得税费用的核算</h3><p>所得税费用:</p>
<blockquote>
<ul>
<li>企业按照国家税法的有关规定，根据企业某一经营年度实现的经营所得，按照规定的税率计算缴纳的税款</li>
<li>应交所得税=利润总额*所得税税率</li>
</ul>
</blockquote>
<p>相关账户:</p>
<blockquote>
<ul>
<li>应交税费,所得税费用</li>
<li>银行存款</li>
<li>本年利润</li>
<li><img src="/2020/11/07/accountancy/image-20201113235412573.png" alt="image-20201113235412573"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">企业计算出本期应交所得税额:</span><br><span class="line">借:  所得税费用</span><br><span class="line">    贷:  应交税费</span><br><span class="line"></span><br><span class="line">实际缴纳所得税:</span><br><span class="line">借:  应交税费</span><br><span class="line">    贷:  银行存款</span><br></pre></td></tr></table></figure>

<h3 id="利润分配业务的核算"><a href="#利润分配业务的核算" class="headerlink" title="利润分配业务的核算"></a>利润分配业务的核算</h3><p>利润分配: 企业根据法律、董事会等决议提请股东大会批准，对企业可供分配利润指定其特定用途，或分配给投资者的行为。包括企业按规定提取法定公积金和分配给投资者等</p>
<p>相关账户:</p>
<blockquote>
<ul>
<li>银行存款</li>
<li>盈余公积,应付股利</li>
<li>本年利润</li>
<li>利润分配: -未分配利润,-提取法定盈余公积,-应付现金股利</li>
<li><img src="/2020/11/07/accountancy/image-20201113235641758.png" alt="image-20201113235641758"></li>
<li><img src="/2020/11/07/accountancy/image-20201113235740424.png" alt="image-20201113235740424"></li>
<li><img src="/2020/11/07/accountancy/image-20201113235750453.png" alt="image-20201113235750453"></li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">企业提取法定盈余公积金(按净利润比例提取)</span><br><span class="line">借:  利润分配-提取法定盈余公积</span><br><span class="line">    贷:  盈余公积-法定盈余公积</span><br><span class="line"></span><br><span class="line">分配现金股利,股票股利</span><br><span class="line">借:  利润分配-应付现金股利</span><br><span class="line">    贷:  应付股利</span><br><span class="line">借:  利润分配-转作资本的股利</span><br><span class="line">    贷:  实收资本(股份有限公司为股本)</span><br><span class="line"></span><br><span class="line">用盈余公积弥补以前年度亏损</span><br><span class="line">借:  盈余公积</span><br><span class="line">    贷:  利润分配-盈余公积补亏</span><br><span class="line"></span><br><span class="line">会计期末结转本期实现的净利润</span><br><span class="line">借:  本年利润</span><br><span class="line">    贷:  利润分配-未分配利润</span><br></pre></td></tr></table></figure>

<h1 id="六、账户分类"><a href="#六、账户分类" class="headerlink" title="六、账户分类"></a>六、账户分类</h1><h2 id="账户按经济内容分类"><a href="#账户按经济内容分类" class="headerlink" title="账户按经济内容分类"></a>账户按经济内容分类</h2><p>分类:</p>
<blockquote>
<ul>
<li>资产类账户</li>
<li>负债类账户</li>
<li>所有者权益类账户</li>
<li>收入类账户</li>
<li>费用类账户</li>
<li>利润类账户</li>
</ul>
</blockquote>
<h2 id="账户按用途和结构分类"><a href="#账户按用途和结构分类" class="headerlink" title="账户按用途和结构分类"></a>账户按用途和结构分类</h2><p>分类:</p>
<blockquote>
<ul>
<li>基本账户</li>
<li>调整账户: 抵减账户, 抵减附加账户</li>
<li>成本账户</li>
<li>损益计算</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>辅修</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>会计</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络（性质和概念解释）</title>
    <url>/2020/11/05/computer-network1/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>计算机网络: 一些相互连接、自治的计算机的集合;具有独立功能的计算机、终端、设备用通信线路连接起来，按一定方式进行通信并实现资源共享的系统</li>
<li>Internet：互联网；由数量极大的各种计算机网络互连起来的系统；<strong>特点：</strong>连通性和共享</li>
</ul>
<p>网络接入:</p>
<ul>
<li>NAP: Network Access Point网络接入点</li>
<li>ISP: Internet Service Provider网络服务提供商</li>
<li>NCP: Network Control Protocol网络控制协议</li>
<li>HOST: 宿主机</li>
</ul>
<p>网络边缘端系统之间的通信方式: </p>
<ul>
<li>C/S: Client/Server主机客户端(模式)</li>
<li>P2P: 对等方式</li>
</ul>
<p>网络分类:</p>
<ul>
<li>分组交换: 将报文进行切割并发传输，到目标主机再进行组合的一种信息交换方式</li>
<li>LAN,MAN,WAN,AN: 局域网,城域网,广域网,Access Network接入网</li>
</ul>
<a id="more"></a>

<p>网络指标:</p>
<ul>
<li>带宽: 本指信号具有的频带宽度(Hz); 现指数字信号所能传送的最高数据率(bit/s)</li>
<li>发送时延（传输时延）: 主机或路由器发送数据帧所需要的时间</li>
<li>传播时延: 电磁波在信道中传播一定的距离需要花费的时间</li>
<li>RTT: 往返时延,从发送数据开始到发送端接收到确认信息的时延</li>
<li>信道利用率: 某信道在某段时间内有百分之几的时间是被利用的（有数据通过）</li>
<li>网络利用率: 全网络的信道利用率的加权平均值</li>
</ul>
<p>服务、接口和协议：</p>
<ul>
<li>实体：每一个网络层中的活动元素,可以是硬件或软件进程</li>
<li>对等实体：不同计算机上同一层的实体</li>
<li>协议：为进行计算机网络中的数据交换而建立的规则、标准或约定的集合</li>
<li>接口：相邻两层之间的边界</li>
<li>服务访问点SAP：接口上相邻两层实体交换信息之处</li>
<li>服务：某一层向上层提供的功能，下层是服务提供者、上层是服务用户</li>
<li>网络体系结构：计算机网络各层级及其协议的集合</li>
<li>协议栈：网络各层协议按照层次顺序排列而形成的协议序列</li>
</ul>
<p>服务原语的种类:</p>
<ul>
<li>请求Request: 服务用户向服务提供者请求服务</li>
<li>指示Indication: 服务提供者向用户回复指示性的消息</li>
<li>响应Response: 用户对提供者的指示原语进行相应</li>
<li>证实Confirm: 提供者向用户报告先前请求的答复</li>
</ul>
<p>网络参考模型:</p>
<ul>
<li>OSI/RM: Open System Interconnection Reference Model开放系统互联参考模型; 物理层-数据链路层-网络层-运输层-会话层-表示层-应用层</li>
<li>TCP/IP: 网络接口层-网络互连层(网际层)-传输层-应用层</li>
<li>五层结构: 物理层-数据链路层-网络互连层(网际层)-传输层-应用层</li>
</ul>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul>
<li>物理层: 其功能是在物理媒体上传输原始的数据比特流; 其任务是确定与传输媒体的接口的一些特性</li>
</ul>
<p>一些术语:</p>
<ul>
<li>数据: 运送信息的实体</li>
<li>信号: 数据的电气特性或电磁表示; 模拟信号是连续变化的信号,数字信号是取值离散的信号</li>
<li>调制: 将数字信号转换成模拟信号的过程</li>
<li>解调: 将模拟信号转换成数字信号的过程</li>
<li>单工通信: 只能有一个方向的通信</li>
<li>半双工通信: 通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)</li>
<li>全双工通信: 通信的双方可以同时发送和接收信息</li>
</ul>
<p>基带和宽带信号:</p>
<ul>
<li>基带信号: 将数字信号1或0直接用两种不同的电压来表示，然后送到线路上去传输</li>
<li>宽带信号: 将基带信号进行调制后形成的频分复用的模拟信号</li>
</ul>
<p>码元和波特率:</p>
<ul>
<li>码元: 时间轴上的一个信号编码单位</li>
<li>波特率: 每秒钟发送的码元数(baud)</li>
<li>比特率: 每秒能传送的二进制位数(bps),S=B*log2N(N为一个码元中的状态数)</li>
</ul>
<p>信道:</p>
<ul>
<li>信道: 向某一个信号传送信息的媒体</li>
<li>奈氏准则: 理想低通信道最高码元传输速率为两倍的波特率</li>
<li>香农定理: 信道的极限传输速率C=W*log2(1+S/N) b/s</li>
</ul>
<p>传输媒体:</p>
<ul>
<li>STP: Shielded Twisted Pair屏蔽双绞线</li>
<li>UTP: Unshielded Twisted Pair无屏蔽双绞线</li>
<li>CC: Coaxial Cable同轴电缆</li>
</ul>
<p>连续波数字调制方式:数字信号-&gt;模拟信号</p>
<ul>
<li>ASK: Amplitude-shift Keying振幅键控(调幅),载波的振幅随基带数字信号变化而变化</li>
<li>FSK: Frequency-..频移键控(调频),载波的频率随..</li>
<li>PSK: Phase-..相移监控(调相),载波的初始相位随..</li>
<li>QAM: Quadrature Amplitude Modulation正交振幅调制(APSK)</li>
<li>PCM: Pulse Code Modulate脉冲编码调制,(三个步骤:采样,量化,编码)</li>
</ul>
<p>数字数据的数字信号编码:数字数据-&gt;数字信号</p>
<ul>
<li>NRZ: 不归零码;正电平0,负电平1,一个码元时间内电平恒定,不归零</li>
<li>Manchester编码: 在一个码元时间内进行电平跳变,从高到底为1,从低到高为0</li>
<li>差分Manchester编码: 码元时间内的跳变为同步信号;位起始处电平无跳变为0,跳变为1</li>
</ul>
<p>多路复用技术:</p>
<ul>
<li>FDM: Frequency Division Multiplexing频分复用; 将多个模拟信号调制在不同的载波频率上</li>
<li>TDM: Time..时分复用; 将物理信道按时间片轮换地分配给多路数字信号使用; STDM:统计时分复用</li>
<li>WDM: Wavelength..波分复用: 不同信源在同一个光纤上使用不同波长的光来传输数据; DWDM:密集型波分复用</li>
<li>CDMA: Code Division Multiple Access码分复用; 多个正交的码型在一个比特时间内的多个码片上异或后进行传输</li>
</ul>
<p>光纤网:</p>
<ul>
<li>SONET: Synchronous Optical Network同步光纤网</li>
</ul>
<p>宽带接入技术: </p>
<ul>
<li>xDSL: Digital Subscriber Line数字用户线; 经过改造的,能承载宽带业务的模拟电话用户线<ul>
<li>ADSL: Asymmetric..非对称数字用户线,32-640K~32K-6.4M下载速率</li>
<li>HDSL: High speed..高速数字用户线</li>
<li>SDSL: Symmetric..1对线的数字用户线</li>
<li>VDSL: Very high speed..甚高速数字用户线; 短距离,1.5-2.5M~50-55M</li>
</ul>
</li>
<li>HFC: Hybrid Fiber Coax光纤同轴混合网; 在有线电视网CATV的基础上开发的一种居民宽带接入网</li>
<li>FTTx: Fiber to x光纤到终端技术<ul>
<li>FTTH:..Home光纤到户;FTTB:..Building光纤到大楼:FTTC:光纤到路边</li>
</ul>
</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ul>
<li>链路link: 一条无源的点到点物理线路段,中间没有其他的交换节点</li>
<li>数据链路: 链路与实现了通信协议的硬件和软件的结合, 其传输单位是帧</li>
</ul>
<p>帧定界:</p>
<ul>
<li>字节计数法: 帧同步标志后紧跟着帧长度</li>
<li>字符填充法: 面向字符的通信协议,以STX标记帧文本开始,ETX结束; 透明传输时,使用DLE对帧首位的STX和ETX进行转义</li>
<li>比特填充法: 以特殊比特(如01111110同步序列)标记帧的开始和结束; 透明传输时, 帧正文中连续的5个1后必须插入一个0</li>
<li>编码违例法: 利用违反编码规律的策略来标志帧的边界</li>
</ul>
<p>差错控制:</p>
<ul>
<li>CheckSum: 校验和; 以16位为单位进行累加,最后结果取反码得到校验和一起发送</li>
<li>CRC: 循环冗余校验码; 将数据用除数d来相除，产生的余数作为CRC码，附加在数据后发送</li>
</ul>
<p>差错控制:</p>
<ul>
<li>FEC: Forward Error Correction前向纠错; 发送端使用纠错码,接收端检出错误并纠正</li>
<li>ARQ: Automatic Repeat Request自动重发请求; 发送端使用检错码,接收方收到数据,检验确认后进行反馈,否则发送端定时重发</li>
<li>FCS: Frame Check Sequence帧检验序列; 在后面添加了冗余码的数据</li>
</ul>
<p>数据链路层协议:</p>
<ul>
<li>PPP协议: 点对点协议</li>
<li>CSMA/CD: 带冲突检测的载波侦听多路存取协议</li>
</ul>
<p>局域网结构:</p>
<ul>
<li>MESH: 无线网格网络</li>
<li>星形网,总线网,环形网,树形网…</li>
</ul>
<p>传统以太网:</p>
<ul>
<li>两个标准: DIX Ethernet V2; IEEE802.3</li>
<li>IEEE 802/OSI RM: 分为MAC层和LLC层</li>
<li>MAC层: Media Access Control介质访问控制子层; 解决设备使用共享信道的问题</li>
<li>LLC层: Logical Link Control逻辑链路控制子层; 完成通常意义下的数据链路层功能,如差错控制,流量控制等</li>
<li>802.3：CSMA/CD总线网的 MAC 和 PHY 规范</li>
<li>802.4：令牌总线网的 MAC 和 PHY 规范</li>
<li>802.5：令牌环网的 MAC 和 PHY 规范</li>
<li>802.6： 城域网 DQDB 的接入方法和物理层规范</li>
<li>802.7： 宽带技术</li>
<li>802.8： 光纤技术</li>
<li>802.9： 综合话音数据局域网（Voice/Data Integration）</li>
<li>802.10：可互操作的 LAN / MAN 安全</li>
<li>802.11：无线局域网（WLAN）的 MAC 和 PHY 规范</li>
<li>802.12：优先级高速局域网（100BaseVG AnyLan）</li>
<li>802.14：电缆电视（Cable-TV）网上的数据传输</li>
<li>802.15：无线个人网（WPAN / Bluetooth）</li>
</ul>
<p>网卡:</p>
<ul>
<li>NIC: Network Interface Card网络接口卡</li>
</ul>
<p>10Mbps以太网:</p>
<ul>
<li>3-4-5原则:<ul>
<li>任意两个站点最多有3个网段有站点连接</li>
<li>任意两个站点间最多有4个中继器</li>
<li>任意两个站点间最多有5个以太网网段</li>
</ul>
</li>
<li>10BASE-5: 使用粗同轴电缆,CSMA/CD冲突检测,Manchester编码/译码的总线网</li>
<li>10BASE-2: 使用细同轴电缆的总线网</li>
<li>10BASE-T: 使用一对无屏蔽双绞线的星形网,使用集线器</li>
</ul>
<p>扩展的局域网:</p>
<ul>
<li>中继器/集线器: 中继器用于在物理层上实现局域网网段的互连，主要起到信号再生放大、延长网络距离; 集线器时一个多端口的中继器</li>
<li>网桥: 一种数据链路层的中继设备</li>
<li>以太网交换机: 多端口网桥</li>
</ul>
<p>高速以太网:</p>
<ul>
<li>100BASE-T: 快速以太网; 使用802.3标准帧格式,全双工下CSMA/CD<ul>
<li>100BASE-TX: 使用2对UTP5类线或屏蔽双绞线 STP; 1/2发送3/6接收,传输距离小于100m</li>
<li>100BASE-FX: 使用2对光纤 </li>
<li>100BASE-T4: 使用4对UTP3类线或5类线; 3对收发线,不能全双工,传输距离小于100m </li>
</ul>
</li>
<li>1000BASE-T: 千兆以太网; 使用4对UTP5类线,用802.3标准帧格式,半双工下CSMA/CD(使用载波延伸)</li>
<li>1000BASE-X  基于光纤通道的物理层</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>微观经济学</title>
    <url>/2020/11/05/microeconomics/</url>
    <content><![CDATA[<h1 id="一、导言"><a href="#一、导言" class="headerlink" title="一、导言"></a>一、导言</h1><p>效率-经济学的灵魂</p>
<p>自然科学-文学-哲学-美学-玄学</p>
<p>人生艺术化？</p>
<h2 id="1-经济学：关于稀缺性与选择的学问"><a href="#1-经济学：关于稀缺性与选择的学问" class="headerlink" title="1 经济学：关于稀缺性与选择的学问"></a>1 经济学：关于稀缺性与选择的学问</h2><p>经济学：研究稀缺性的资源在竞争者中如何分配的学科</p>
<p>稀缺是经济学的显著现象，因此选择是必要的</p>
<blockquote>
<ul>
<li>在各种可能的选择（机会集合）之间进行权衡（tradeof）f作出取舍，以尽可能地有效利用资源。 </li>
<li>必须作出选择不仅是针对个人而言，而且是针对整个经济而言。</li>
<li>个人和社会的选择决定了各种资源是如何被利用，以及利用效率低高低</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="2-经济学的基本问题"><a href="#2-经济学的基本问题" class="headerlink" title="2 经济学的基本问题"></a>2 经济学的基本问题</h2><p>如何进行选择，何种选择造成何种影响？</p>
<blockquote>
<ul>
<li>生产什么，产量多大</li>
<li>如何生产</li>
<li>为谁生产</li>
<li>谁做决策</li>
</ul>
</blockquote>
<p>衍生问题：</p>
<blockquote>
<ul>
<li>这种经济效率高吗</li>
<li>是否可以在不减少一种物品同时增加另一种物品</li>
<li>是否可以在不损害一部分人的情况下使另一部分人生活更好</li>
</ul>
</blockquote>
<h3 id="生产多少什么商品"><a href="#生产多少什么商品" class="headerlink" title="生产多少什么商品"></a>生产多少什么商品</h3><p>供给问题</p>
<p>市场经济条件下：</p>
<blockquote>
<ul>
<li>供给主要决定于厂商和消费者之间的相互作用</li>
<li>政府也起一定作用</li>
</ul>
</blockquote>
<p>价格因素是决定产量的关键</p>
<h3 id="产品如何生产"><a href="#产品如何生产" class="headerlink" title="产品如何生产"></a>产品如何生产</h3><p>市场经济条件下：</p>
<blockquote>
<ul>
<li>生产方式由厂商决定</li>
<li>有政府参与制定条文规范和执行法规</li>
</ul>
</blockquote>
<h3 id="产品为谁生产"><a href="#产品为谁生产" class="headerlink" title="产品为谁生产"></a>产品为谁生产</h3><p>分配问题：高收入者消费更多产品</p>
<p>收入问题：</p>
<blockquote>
<ul>
<li>收入是指要素的收入：将要素投入到具有价值增值特点的生产过程中所获得的回报</li>
<li>要素的占有量直接影响收入高低</li>
<li>一般情况下，收入主要取决于家庭和厂商之间的相互作用</li>
<li>劳动力市场的供需求状况影响不同职业的收入差别</li>
<li>政府用税收和收入重新分配进行参与</li>
</ul>
</blockquote>
<h3 id="谁做决策"><a href="#谁做决策" class="headerlink" title="谁做决策"></a>谁做决策</h3><p>一个社会的经济体制决定社会如何进行生产、消费和分配</p>
<p>两个极端：</p>
<blockquote>
<ul>
<li>完全的计划经济体制</li>
<li>完全的市场经济体制</li>
<li>混合经济：公众（政府）决策和私人决策混合在一起</li>
</ul>
</blockquote>
<h2 id="3-市场经济中市场与政府的作用"><a href="#3-市场经济中市场与政府的作用" class="headerlink" title="3 市场经济中市场与政府的作用"></a>3 市场经济中市场与政府的作用</h2><h3 id="市场及其作用"><a href="#市场及其作用" class="headerlink" title="市场及其作用"></a>市场及其作用</h3><p>市场：</p>
<blockquote>
<ul>
<li>交易发生的场合</li>
<li>市场包括各类交易及其过程</li>
</ul>
</blockquote>
<p>在市场中：</p>
<blockquote>
<ul>
<li>个人做出的决策反映他们的愿望</li>
<li>厂商的决策则是以追求最大限度的利润为目的</li>
</ul>
</blockquote>
<p>因此：</p>
<blockquote>
<ul>
<li>厂商应当生产消费者需要的产品</li>
<li>消费者在厂商竞争中在产品种类和价格上获得好处</li>
</ul>
</blockquote>
<p>市场经济对经济学问题的回答：</p>
<blockquote>
<ul>
<li>资源的配置和使用因厂商之间激烈的竞争而变得更有效率。</li>
<li>为了在竞争中处于领先地位或不致被淘汰出局，企业必须不间断地进行产品创新、技术革新、管理创新、制度创新和组织创新。</li>
<li>市场把产品分配给那些愿意并且能够付出最高价格的人，但人们愿意并且能够付出多少取决于他们的收入高低。</li>
</ul>
</blockquote>
<h3 id="政府的作用"><a href="#政府的作用" class="headerlink" title="政府的作用"></a>政府的作用</h3><p>政府不可替代的作用：</p>
<blockquote>
<ul>
<li>是政府建立了一种法律体系使私有厂商和个人能在此体系下运作</li>
<li>政府制定法律、法规并保证其得到公正地执行，是经济活动得以有秩序地进行的前提条件。</li>
<li>政府负责提供公共产品和服务，如教育、国防、消防、道路等。</li>
<li>政府通过各种福利计划来构建一个安全网</li>
</ul>
</blockquote>
<h3 id="四个主要市场"><a href="#四个主要市场" class="headerlink" title="四个主要市场"></a>四个主要市场</h3><blockquote>
<ul>
<li>产品市场</li>
<li>劳动市场</li>
<li>资本市场</li>
<li>土地市场</li>
</ul>
</blockquote>
<h2 id="4-经济学的分支"><a href="#4-经济学的分支" class="headerlink" title="4 经济学的分支"></a>4 经济学的分支</h2><p>宏观经济学与微观经济学：</p>
<blockquote>
<ul>
<li>两种视点：整体与个体</li>
<li>两种视角：自上而下和自下而上</li>
</ul>
</blockquote>
<h2 id="5-经济学方法论"><a href="#5-经济学方法论" class="headerlink" title="5 经济学方法论"></a>5 经济学方法论</h2><h3 id="经济学的研究方式"><a href="#经济学的研究方式" class="headerlink" title="经济学的研究方式"></a>经济学的研究方式</h3><p>研究方式：混合推理</p>
<blockquote>
<ul>
<li>考察资料</li>
<li>分析推理</li>
<li>形成假说</li>
<li>检验假说</li>
</ul>
</blockquote>
<h3 id="理论和模型"><a href="#理论和模型" class="headerlink" title="理论和模型"></a>理论和模型</h3><p>理论：描述了一种因果关系，是对现实世界的抽象，是逻辑的演练</p>
<p>经济模型：用文字、图解或方程来描述的经济特性</p>
<p>模型是一种理论框架，我们可以在这个框架中进行相关的推演，从而得到一些符合假设情况的结论</p>
<p>经济学模型中的变量：</p>
<blockquote>
<ul>
<li>常用变量：价格、利润、收益、成本、国民收入、消费、投资、进口、出口…</li>
<li>内生变量：该变量的值由该模型内部因素决定</li>
<li>外生变量：由该模型外部因素决定的变量</li>
</ul>
</blockquote>
<p>经济学模型中的方程：</p>
<blockquote>
<ul>
<li>定义方程：同一个概念的不同表达式（恒等式、定义式）</li>
<li>行为方程：在一定假设情况下，某几个变量之间的变化关系</li>
<li>均衡条件：用于描述模型中某一均衡能够得到实现所满足的方程条件</li>
</ul>
</blockquote>
<h2 id="6-经济思维"><a href="#6-经济思维" class="headerlink" title="6 经济思维"></a>6 经济思维</h2><blockquote>
<ul>
<li>理性行为</li>
<li>机会集合</li>
<li>成本与收益的权衡</li>
<li>假设前提的重要性</li>
<li>决策的风险：环境的改变、相关关系和因果关系的判断、合成谬误需要被注意</li>
</ul>
</blockquote>
<p>理性人假定：假定人是自私的，其自觉程度不高</p>
<blockquote>
<ul>
<li>在道德底限上行事</li>
<li>在局限下争取最大的个人利益</li>
<li>简而言之：利己但不损人</li>
</ul>
</blockquote>
<p>斯密悖论：个人利益和社会利益能否一致（看不见的手）（一般均衡轮）</p>
<blockquote>
<p>无法证明一般均衡轮的唯一性和稳定性</p>
</blockquote>
<p>决策：成本和收益的权衡</p>
<blockquote>
<ul>
<li>机会成本：使用资源的代价，该资源不能被用于其他用途</li>
<li>沉没成本：该资源使用后无法被收回，此时，理性的人应当忽视沉没成本</li>
<li>边际成本</li>
</ul>
</blockquote>
<p>理性选择的步骤：</p>
<blockquote>
<ul>
<li>明确机会集合</li>
<li>确定替换</li>
<li>正确计算机会成本、沉没成本和边际成本</li>
</ul>
</blockquote>
<h1 id="二、需求供给和均衡价格"><a href="#二、需求供给和均衡价格" class="headerlink" title="二、需求供给和均衡价格"></a>二、需求供给和均衡价格</h1><p>微观经济学的核心：价格理论</p>
<h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1 需求"></a>1 需求</h2><h3 id="需求的概念"><a href="#需求的概念" class="headerlink" title="需求的概念"></a>需求的概念</h3><p>需求量：在某一特定时间内，对应某一商品的各种价格，人们愿意且能够购买的数量</p>
<p>需求的分类：</p>
<blockquote>
<ul>
<li>个人需求：单个消费者或家庭对某种商品的需求</li>
<li>市场需求：某一商品的所有个人需求的总和</li>
</ul>
</blockquote>
<p>需求的影响（条件）：</p>
<blockquote>
<ul>
<li>收入</li>
<li>偏好</li>
<li>商品价格</li>
<li>同类商品的价格</li>
<li>对商品未来的价格预期</li>
</ul>
</blockquote>
<p>需求、消费和购买是有区别的：</p>
<blockquote>
<ul>
<li>如，购买者不一定是消费者</li>
<li>但，经济学中将这三种等同</li>
</ul>
</blockquote>
<h3 id="需求规律"><a href="#需求规律" class="headerlink" title="需求规律"></a>需求规律</h3><p>Law of Demand：其他条件不变的情况下，商品需求量与其价格存在着反向的依存关系</p>
<blockquote>
<ul>
<li>前提：其他条件不变（重要）</li>
<li>结论：当商品价格上升时需求量下降，当价格下降时需求量上升，需求曲线是向下倾斜的。</li>
</ul>
</blockquote>
<p>需求规律存在的合理性：消费者是理性人</p>
<p>需求函数：$P=a-bQ$</p>
<blockquote>
<ul>
<li>$P$：价格</li>
<li>$Q$：需求量</li>
<li>注意，这里面价格是因变量</li>
</ul>
</blockquote>
<p>需求曲线：</p>
<blockquote>
<ul>
<li>纵坐标：价格</li>
<li>横坐标：需求量</li>
<li>曲线走势：向下倾斜</li>
</ul>
</blockquote>
<h3 id="需求曲线的移动"><a href="#需求曲线的移动" class="headerlink" title="需求曲线的移动"></a>需求曲线的移动</h3><p>当其他条件变化导致前提条件改变时，需求曲线会发生移动</p>
<blockquote>
<ul>
<li>收入：收入增加，同等价格需求量更高；需求曲线向右移动</li>
<li>替代品：替代品价格升高，同等价格该商品需求量更高；需求曲线向右移动</li>
<li>互补品：互补品价格升高，同等价格商品需求量更少；需求曲线向左移动</li>
<li>替代效应SE和收入效应IE</li>
</ul>
</blockquote>
<p>需求和需求量：</p>
<blockquote>
<ul>
<li>需求（曲线）变动：$P(Q)=f(I,T,E,P_i,…)$；$(I,T,E,P_i,…)$表示收入，偏好，其他商品价格…</li>
<li>需求量变动：$P=a-bQ$</li>
<li>需求变动是需求曲线的移动，而需求量的变动是需求量在曲线上的移动</li>
</ul>
</blockquote>
<h2 id="2-供给"><a href="#2-供给" class="headerlink" title="2 供给"></a>2 供给</h2><h3 id="供给的概念"><a href="#供给的概念" class="headerlink" title="供给的概念"></a>供给的概念</h3><p>供给量：厂商在一定时期一定价格水平下愿意而且提供某种商品的数量</p>
<p>供给量分类：</p>
<blockquote>
<ul>
<li>个别供给</li>
<li>市场供给</li>
</ul>
</blockquote>
<p>供给的影响因素：</p>
<blockquote>
<ul>
<li>生产成本</li>
<li>厂商能够生产的其他产品</li>
<li>未来价格低预期</li>
</ul>
</blockquote>
<h3 id="供给规律"><a href="#供给规律" class="headerlink" title="供给规律"></a>供给规律</h3><p>Law of Sypply:在影响供给的其他因素既定的条件下，商品的供给量与价格之间存在着正向的依存关系</p>
<blockquote>
<ul>
<li>前提条件：影响供给的其他因素确定</li>
<li>结论：价格上升，供给量增加；价格下降，供给量减少</li>
</ul>
</blockquote>
<p>供给函数：$P=c+dQ_s$</p>
<blockquote>
<ul>
<li>$P$：商品价格</li>
<li>$Q_s$：供给量</li>
<li>注意，这里面价格是因变量</li>
</ul>
</blockquote>
<p>供给曲线：</p>
<blockquote>
<ul>
<li>纵坐标：价格</li>
<li>横坐标：供给量</li>
<li>曲线走势：向上倾斜</li>
</ul>
</blockquote>
<h3 id="供给曲线的移动"><a href="#供给曲线的移动" class="headerlink" title="供给曲线的移动"></a>供给曲线的移动</h3><p>供给曲线的移动：相同价格下供给量减少，供给曲线向左移动</p>
<blockquote>
<ul>
<li>生产成本上升，同价格供给减少</li>
<li>厂商能够生产的其他产品价格上升，同价格供给减少</li>
<li>未来价格将会上涨，当前情况下同价格供给量减少</li>
</ul>
</blockquote>
<p>供给曲线与供给量的变动与需求曲线类似：</p>
<blockquote>
<ul>
<li>供给变动：影响供给的其他因素变动导致整条供给曲线的变动</li>
<li>供给量变动：价格变化导致供给量眼供给曲线的移动</li>
</ul>
</blockquote>
<h2 id="3-均衡价格"><a href="#3-均衡价格" class="headerlink" title="3 均衡价格"></a>3 均衡价格</h2><h3 id="均衡价格的形成"><a href="#均衡价格的形成" class="headerlink" title="均衡价格的形成"></a>均衡价格的形成</h3><p>需求曲线和供给曲线确定的情况下，某一商品达到均衡价格的过程：</p>
<blockquote>
<ul>
<li>$P&gt;P_E$时，将导致$Q_S&gt;Q_D$，市场处于surplus过剩状态，此时卖方竞争，$P-$，$Q_D+$，$Q_S-$，最终$Q_D=Q_S$</li>
<li>$P&lt;P_E$时，将导致$Q_S&lt;Q_D$，，市场处于shortage短缺状态，此时买方竞争，$P+$，$Q_D-$，$Q_S+$，最终$Q_D=Q_S$</li>
</ul>
</blockquote>
<p>达到均衡价格时，市场处于Market Clearing出清状态</p>
<h3 id="供求规律"><a href="#供求规律" class="headerlink" title="供求规律"></a>供求规律</h3><p>供给（曲线）和需求（曲线）发生变动时，均衡价格会发生变化：</p>
<blockquote>
<ul>
<li>均衡价格和均衡产量与需求（曲线）同方向变动</li>
<li>均衡价格与供给（曲线）反方向变动；均衡产量与供给（价格）同方向变动</li>
</ul>
</blockquote>
<h3 id="价格粘性"><a href="#价格粘性" class="headerlink" title="价格粘性"></a>价格粘性</h3><p>价格粘性用于描述价格对需求曲线和供给曲线的变化的反应速度</p>
<blockquote>
<ul>
<li>如，股票市场价格不具有粘性，住房市场价格具有粘性</li>
<li>价格具有粘性时，均衡分析仍然是有用的</li>
</ul>
</blockquote>
<h3 id="对供求规律的干预"><a href="#对供求规律的干预" class="headerlink" title="对供求规律的干预"></a>对供求规律的干预</h3><p>干预方式：</p>
<blockquote>
<ul>
<li>设立支持价格（最低限价）：此时均衡价格在支持价格之下</li>
<li>设立限制价格（最高限价）：此时均衡价格在限制价格之上</li>
<li>税收</li>
</ul>
</blockquote>
<p>税收对均衡价格的影响：</p>
<blockquote>
<ul>
<li>从量税：对企业征收，提高企业生产成本；供给曲线左移</li>
<li>从价税：对消费者征收，降低消费者的收入；需求曲线向左移动</li>
</ul>
</blockquote>
<h2 id="4-需求与供给的弹性理论"><a href="#4-需求与供给的弹性理论" class="headerlink" title="4 需求与供给的弹性理论"></a>4 需求与供给的弹性理论</h2><p>弹性理论能够预测供求在价格影响下变化的量值</p>
<h3 id="需求弹性"><a href="#需求弹性" class="headerlink" title="需求弹性"></a>需求弹性</h3><p>商品对价格变化的敏感度反映在需求曲线上：</p>
<blockquote>
<ul>
<li>需求曲线平缓：对价格变换反应敏感，富有弹性</li>
<li>需求曲线陡峭：价格变化对需求量变化产生很小的影响，缺乏弹性</li>
</ul>
</blockquote>
<h4 id="需求的价格弹性"><a href="#需求的价格弹性" class="headerlink" title="需求的价格弹性"></a>需求的价格弹性</h4><p>价格弹性定义：需求量变化百分比除以价格变化百分比</p>
<p>$$ E_D = - \frac{\Delta Q}Q *\frac{P}{\Delta P} $$</p>
<p>弧弹性：两点之间的平均弹性</p>
<p>点弹性：曲线斜率倒数作为$\Delta$</p>
<p>中点单位弹性：弹性为1，此时PQ=c</p>
<p>需求弹性与总收益的关系：</p>
<blockquote>
<ul>
<li>价格变化1%时，收益变化百分比为1-需求弹性</li>
</ul>
</blockquote>
<h4 id="需求的收入弹性"><a href="#需求的收入弹性" class="headerlink" title="需求的收入弹性"></a>需求的收入弹性</h4><p>定义：需求量变化百分比除以消费者收入变化百分比</p>
<p>$$ E_M = \frac{\Delta Q}Q *\frac{I}{\Delta I} $$</p>
<p>正常品与劣等品：</p>
<blockquote>
<ul>
<li>E&gt;0,正常品</li>
<li>E&lt;0,劣等品</li>
<li>E&gt;1，奢侈品</li>
</ul>
</blockquote>
<h4 id="需求的交叉弹性"><a href="#需求的交叉弹性" class="headerlink" title="需求的交叉弹性"></a>需求的交叉弹性</h4><p>定义：需求的交叉价格弹性，指一种商品的需求量对另一种商品价格变动的反应程度</p>
<p>$$ E_{1,2} = - \frac{\Delta Q_1}Q_1 *\frac{P_2}{\Delta P_2} $$</p>
<p>互补品和替代品</p>
<blockquote>
<ul>
<li>E&gt;0，替代品</li>
<li>E&lt;0，互补品</li>
<li>E=0，无相关性</li>
</ul>
</blockquote>
<h3 id="供给弹性"><a href="#供给弹性" class="headerlink" title="供给弹性"></a>供给弹性</h3><p>$$ E_S = - \frac{\Delta Q_S}Q_S *\frac{P}{\Delta P} $$</p>
<h1 id="三、消费者行为理论"><a href="#三、消费者行为理论" class="headerlink" title="三、消费者行为理论"></a>三、消费者行为理论</h1><p>理性行为：产生最优化决定的行为</p>
<blockquote>
<p>对于消费者来说，最优化就是在预算约束条件下可达到的最大效用</p>
</blockquote>
<h2 id="1-预算约束"><a href="#1-预算约束" class="headerlink" title="1 预算约束"></a>1 预算约束</h2><p>预算集：消费者机会集合，由一个预算约束定义</p>
<blockquote>
<p>消费者的购买受到可支配收入和价格的制约</p>
</blockquote>
<p>预算约束：预算线</p>
<blockquote>
<ul>
<li>在消费者收入和商品价格一定的条件下，消费者所能购买的两种不同商品的组合</li>
<li>预算线上的点表示个人偏好</li>
<li>以两种商品的购买量为xy轴，预算线为一个斜率为负的直线</li>
</ul>
</blockquote>
<p>预算线的移动：</p>
<blockquote>
<ul>
<li>收入变动而相对价格不变：预算线向内或向外平移</li>
<li>相对价格变动二收入不变：预算线向内或向外旋转</li>
</ul>
</blockquote>
<h2 id="2-偏好与效用"><a href="#2-偏好与效用" class="headerlink" title="2 偏好与效用"></a>2 偏好与效用</h2><p>消费者偏好的一些公理：</p>
<blockquote>
<ul>
<li>完备性：任何两个消费组合都是可比的</li>
<li>传递性：商品比较具有传递性</li>
<li>连续性：偏好不会发生突发性的逆转</li>
<li>非饱和性：多多益善</li>
</ul>
</blockquote>
<p>无差异曲线：其指出了可以给一个人相同（效用）的不同商品的组合</p>
<blockquote>
<ul>
<li>两种商品的购买量为xy轴</li>
<li>无差异曲线类似于一条第一象限的双曲线</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>辅修</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>经济</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机图形学</title>
    <url>/2020/09/10/computer-graphics0/</url>
    <content><![CDATA[<p>姜小峰</p>
<p>研究内容：如何将现实生活中所看到的物体利用数据结构存储在计算机中；并利用显卡将它在屏幕上显示出来。</p>
<blockquote>
<ul>
<li>有一定理论深度，包含许多算法</li>
<li>实践性较强</li>
</ul>
</blockquote>
<p>图形学和图像处理两个研究方向是相反的</p>
<p>内容：</p>
<blockquote>
<ul>
<li>基础：绪论、图形系统、图形几何变换</li>
<li>建模：三维造型</li>
<li>绘制：二维基本图形光栅化与裁剪、真实感图形技术</li>
</ul>
</blockquote>
<a id="more"></a>

<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>图形学的定义：</p>
<blockquote>
<ul>
<li>研究通过计算机将数据转换成图形，并在专门显示设备上显示的原理、方法和技术的学科（注意与数据可视化的区别）</li>
<li>研究通过计算机将场景对象转换成图形并进行显示的一门学科</li>
</ul>
</blockquote>
<p>图形学的作用：</p>
<blockquote>
<ul>
<li>工业生产设计</li>
<li>医学、科学研究</li>
<li>3D电影、动漫、游戏</li>
</ul>
</blockquote>
<h3 id="图形和图像的区别"><a href="#图形和图像的区别" class="headerlink" title="图形和图像的区别"></a>图形和图像的区别</h3><table>
<thead>
<tr>
<th align="center">比较内容</th>
<th align="center">图形</th>
<th align="center">图像</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本元素</td>
<td align="center">点、线、面等几何元素</td>
<td align="center">像素</td>
</tr>
<tr>
<td align="center">存储数据</td>
<td align="center">各个矢量的参数（属性）</td>
<td align="center">各个像素的灰度或颜色分量</td>
</tr>
<tr>
<td align="center">处理方式</td>
<td align="center">旋转、扭曲、拉伸等</td>
<td align="center">对比度增强、边缘检测等</td>
</tr>
<tr>
<td align="center">缩放效果</td>
<td align="center">不会失真，可以适应不同分辨率</td>
<td align="center">放大时会失真，可看到颗粒状像素</td>
</tr>
</tbody></table>
<blockquote>
<ul>
<li>图形是由不同属性的点、线、面等几何元素组合构成的图画，用来表示主客观世界中各物体的几何信息</li>
<li>图像则是对自然界事物的客观反映</li>
</ul>
</blockquote>
<h3 id="图形的处理"><a href="#图形的处理" class="headerlink" title="图形的处理"></a>图形的处理</h3><p>图形的处理有表示和显示两个方面：</p>
<blockquote>
<ul>
<li>用图形来表示场景对象；用图像来显示图形</li>
<li>（另一种说法）用点、线、面来建模形状、大小、位置、材质；用像素来绘制渲染点、线、面、颜色</li>
</ul>
</blockquote>
<p>造型的表示方法：</p>
<blockquote>
<ul>
<li>多边形网格</li>
<li>曲线曲面</li>
<li>细分曲面</li>
</ul>
</blockquote>
<p>渲染：对造型表示后的物体进行可视化，即根据三位物体模型生成二维图像</p>
<h3 id="相关学科"><a href="#相关学科" class="headerlink" title="相关学科"></a>相关学科</h3><blockquote>
<ul>
<li>图像处理</li>
<li>计算几何</li>
<li>计算机视觉</li>
</ul>
</blockquote>
<p>关系和区别：</p>
<blockquote>
<ul>
<li>图像到图像：数字图像处理</li>
<li>图像到知识：计算机视觉</li>
<li>知识到图像：计算机图形学</li>
<li>知识到知识：人工智能</li>
</ul>
</blockquote>
<h3 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h3><blockquote>
<ul>
<li>GPU计算发展迅猛</li>
<li>研究和谐自然的三维模型建模方法</li>
<li>实现高度真实的动态仿真</li>
</ul>
</blockquote>
<h1 id="二、图形系统"><a href="#二、图形系统" class="headerlink" title="二、图形系统"></a>二、图形系统</h1><h2 id="2-1-显示设备"><a href="#2-1-显示设备" class="headerlink" title="2.1 显示设备"></a>2.1 显示设备</h2><blockquote>
<ul>
<li>阴极射线管</li>
<li>液晶显示器</li>
</ul>
</blockquote>
<h2 id="2-2-图形系统体系结构"><a href="#2-2-图形系统体系结构" class="headerlink" title="2.2 图形系统体系结构"></a>2.2 图形系统体系结构</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>图形系统是一个增加了图形输入、输出和显示设备、并配备了相应的图形软件的计算机系统</p>
<p>图形系统的核心结构：图形流水线，其分为三个阶段：</p>
<blockquote>
<ul>
<li>应用程序阶段：生成图元</li>
<li>几何处理阶段：生成二维屏幕坐标（顶点）</li>
<li>像素处理阶段：光栅阶段</li>
</ul>
</blockquote>
<h3 id="应用程序阶段"><a href="#应用程序阶段" class="headerlink" title="应用程序阶段"></a>应用程序阶段</h3><p>将待生成的图形通过应用程序以图元的形式提供给图形硬件，其通过软件实现</p>
<h3 id="几何处理阶段"><a href="#几何处理阶段" class="headerlink" title="几何处理阶段"></a>几何处理阶段</h3><p>几何处理阶段是以每个顶点坐标为基础对几何图元进行处理，并从三维坐标变换为二维屏幕坐标的过程</p>
<p>处理过程举例：</p>
<blockquote>
<ul>
<li>模型与视点变换</li>
<li>光照</li>
<li>投影</li>
<li>裁剪</li>
<li>屏幕映射</li>
</ul>
</blockquote>
<h3 id="光栅阶段"><a href="#光栅阶段" class="headerlink" title="光栅阶段"></a>光栅阶段</h3><p>像素处理阶段，屏幕对象首先被传送到像素处理器进行光栅化，并对每个像素进行着色，然后再输出到帧缓冲器中，最后输出到显示器</p>
<h1 id="三、二维图形生成"><a href="#三、二维图形生成" class="headerlink" title="三、二维图形生成"></a>三、二维图形生成</h1><h2 id="图元的概念"><a href="#图元的概念" class="headerlink" title="图元的概念"></a>图元的概念</h2><p>图元：二维平面内基本的图形元素</p>
<blockquote>
<ul>
<li>点</li>
<li>直线</li>
<li>圆弧</li>
<li>多边形</li>
<li>字体符号和位图</li>
</ul>
</blockquote>
<p>图元通常是指不可再分的独立的图形实体。一个图元中的所有像素点、直线、顶点等是作为一个整体存在的，不再细分为独立的图元。</p>
<p>图元是连续的</p>
<h2 id="直线光栅化"><a href="#直线光栅化" class="headerlink" title="直线光栅化"></a>直线光栅化</h2><p>直线光栅化：输入起点和终点，输出光栅化后的像素点</p>
<blockquote>
<ul>
<li>直接法</li>
<li>数值微分法</li>
<li>中点线算法</li>
<li>Bresenham算法</li>
</ul>
</blockquote>
<p>策略：增量计算，规避浮点数</p>
<h3 id="数值微分法DDA"><a href="#数值微分法DDA" class="headerlink" title="数值微分法DDA"></a>数值微分法DDA</h3><p>假设斜率0&lt;k&lt;1</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">LineDDA(x_0,y_0,x_n,y_n)</span><br><span class="line">	k=(y_n-y_0)/(x_n-x_0)</span><br><span class="line">    y=y_0</span><br><span class="line">    <span class="keyword">for</span> x=x_0 <span class="keyword">to</span> x_n:</span><br><span class="line">    	Pixel(x,int(y+<span class="number">0.5</span>))</span><br><span class="line">        y=y+k</span><br></pre></td></tr></table></figure>

<h3 id="中点画线法"><a href="#中点画线法" class="headerlink" title="中点画线法"></a>中点画线法</h3><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">LineMidpoint(x_0,y_0,x_n,y_n)</span><br><span class="line">	a = y_n-y_0</span><br><span class="line">    b = x_n-x_0</span><br><span class="line">    d1 = a+b</span><br><span class="line">    d2 = a</span><br><span class="line">    d = <span class="number">2</span>a+b <span class="comment">//a+0.5b</span></span><br><span class="line">    x=x_0</span><br><span class="line">    y=y_0</span><br><span class="line">    <span class="keyword">while</span> x &lt;= x_n <span class="keyword">do</span> </span><br><span class="line">    	Pixel(x,y)</span><br><span class="line">    	<span class="keyword">if</span> d&lt;<span class="number">0</span></span><br><span class="line">        	x++;y++</span><br><span class="line">            d+=a+b</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	x++</span><br><span class="line">            d+=a</span><br></pre></td></tr></table></figure>

<h2 id="整圆光栅化"><a href="#整圆光栅化" class="headerlink" title="整圆光栅化"></a>整圆光栅化</h2><p>中点画圆法：</p>
<p>方程：F(X,Y)=X^2+Y^2-R^2从90-45度</p>
<blockquote>
<ul>
<li>若某d大于0，下一步选择右下方点</li>
<li>若某d小于0，下一步选择右边的点</li>
</ul>
</blockquote>
<h2 id="区域填充"><a href="#区域填充" class="headerlink" title="区域填充"></a>区域填充</h2><p>输入：多边形顶点坐标以及连接关系</p>
<p>输出：组成多边形的像素集合</p>
<h3 id="逐点填充法"><a href="#逐点填充法" class="headerlink" title="逐点填充法"></a>逐点填充法</h3><p>判断每个像素是否在多边形内部</p>
<p>判断方法：</p>
<blockquote>
<ul>
<li>射线法</li>
<li>弧长法</li>
</ul>
</blockquote>
<p>射线法：</p>
<blockquote>
<ul>
<li>从判别点v出发发出射线</li>
<li>求射线与多边形交点个数（经过极值点时算两个交点）</li>
<li>交点个数为奇数，则点在内部；偶数，则点在外部</li>
</ul>
</blockquote>
<p>弧长法：</p>
<blockquote>
<ul>
<li>给多边形的边定义一个首尾相接的方向</li>
<li>将每条有向边投影到以判别点（非顶点）为圆心的单位圆上</li>
<li>计算弧长总和，若为2pi则点在多边形内</li>
</ul>
</blockquote>
<h3 id="扫描线填充法"><a href="#扫描线填充法" class="headerlink" title="扫描线填充法"></a>扫描线填充法</h3><p>求水平扫描线与多边形的交点，形成区间并填充</p>
<p>步骤：</p>
<blockquote>
<ul>
<li>求交点</li>
<li>交点排序</li>
<li>配对</li>
<li>填充颜色</li>
</ul>
</blockquote>
<h3 id="活动边表填充法"><a href="#活动边表填充法" class="headerlink" title="活动边表填充法"></a>活动边表填充法</h3><p>ET表是一个链表数组，链表元素为[ymax,xmin,1/m]</p>
<blockquote>
<ul>
<li>数组的每个元素表示扫描线</li>
<li>链表元素表示活动边</li>
<li>ymax为该活动边最大的y值</li>
<li>xmin为当前扫描线和该活动边相交的x值</li>
<li>1/m为该活动边斜率倒数（x值的增量）</li>
</ul>
</blockquote>
<p>AET表是一个数组，表示当前扫描线</p>
<p>方法：</p>
<blockquote>
<ol>
<li>构建ET表（初始化）：每个桶中存储由该扫描线激活的边</li>
<li>构建AET表（空表），y从ET表中第一个非空桶开始迭代</li>
<li>将ET表中相应桶的所有活动边移动到AET表中，并按xmin值排序</li>
<li>配对填充像素值</li>
<li>删除AET表中y&gt;ymax的项（边失去激活）</li>
<li>更新AET表中所有节点的x值：x = x + 1/m</li>
<li>AET表按xmin排序</li>
<li>y+=1 回到3. 直到AET表为空</li>
</ol>
</blockquote>
<p>排序开销较大，适合软件实现，不适合硬件实现</p>
<h3 id="种子填充算法"><a href="#种子填充算法" class="headerlink" title="种子填充算法"></a>种子填充算法</h3><p>输入：区域，区域内一点</p>
<p>输出：填充图形</p>
<p>使用递归法（栈）来填充</p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>字符分类：</p>
<blockquote>
<ul>
<li>矢量字符</li>
<li>点阵字符</li>
</ul>
</blockquote>
<h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p>输入：矩形窗口、对象</p>
<h3 id="点的裁剪"><a href="#点的裁剪" class="headerlink" title="点的裁剪"></a>点的裁剪</h3><p>判断点是否在窗口内</p>
<h3 id="直线裁剪"><a href="#直线裁剪" class="headerlink" title="直线裁剪"></a>直线裁剪</h3><p>直线段和裁剪窗口的可能关系：</p>
<blockquote>
<ul>
<li>完全落在窗口内</li>
<li>完全落在窗口外</li>
<li>与窗口边界相交</li>
</ul>
</blockquote>
<p>Cohen-Sutherland算法</p>
<blockquote>
<p>(1)输入直线段的两端点坐标：p1(x1,y1)、p2(x2,y2)，以及窗口的四条边界坐标：wyt、wyb、wxl和wxr。</p>
<p>(2)对p1、p2进行编码：点p1的编码为code1，点p2的编码为code2。</p>
<p>(3)若code1|code2=0，对直线段应简取之，转(6)；否则，若code1&amp;code2≠0，对直线段可简弃之，转(7)；当上述两条均不满足时，进行步骤(4)。</p>
<p>(4)确保p1在窗口外部：若p1在窗口内，则交换p1和p2的坐标值和编码</p>
<p>(5)<strong>按左、右、上、下的顺序求出直线段与窗口边界的交点</strong>，并用该交点的坐标值替换p1的坐标值。也即在交点s处把线段一分为二，并去掉p1s这一段。考虑到p1是窗口外的一点，因此可以去掉p1s, 转(2)</p>
<p>(6)用直线扫描转换算法绘制当前的直线段p1p2</p>
<p>(7)算法结束</p>
</blockquote>
<h1 id="四、图形几何变化"><a href="#四、图形几何变化" class="headerlink" title="四、图形几何变化"></a>四、图形几何变化</h1><p>类型：平移、旋转、缩放、反射、错切、复合变换</p>
<h2 id="二维几何变换"><a href="#二维几何变换" class="headerlink" title="二维几何变换"></a>二维几何变换</h2><h3 id="变换通式"><a href="#变换通式" class="headerlink" title="变换通式"></a>变换通式</h3><p>$$<br>\mathbf{P[2,1]’=M[2,2]_1\cdot P[2,1]+M[2,2]_2}<br>$$<br>其中，$\mathbf M_1$用于旋转缩放，$\mathbf M_2$用于平移</p>
<p>若将二维向量表示成三维向量，变换矩阵$\mathbf {M_1,M_2}$可以合二为一</p>
<h3 id="齐次坐标表示法"><a href="#齐次坐标表示法" class="headerlink" title="齐次坐标表示法"></a>齐次坐标表示法</h3><p>齐次坐标表示法：用$n+1$维向量表示$n$维向量<br>$$<br>[a_1,a_2,…a_n] \to [ha_1,ha_2,…ha_n,h]<br>$$</p>
<blockquote>
<ul>
<li>$h$为哑坐标，$h=1$时其为规格化坐标</li>
<li>同一点的齐次坐标不唯一</li>
</ul>
</blockquote>
<h3 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h3><p>$$<br>\begin{bmatrix}<br>x’ \ y’ \ 1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1&amp;0&amp;t_x\<br>0&amp;1&amp;t_y\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>x\ y\ 1<br>\end{bmatrix}<br>$$</p>
<h3 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h3><p>$$<br>\begin{bmatrix}<br>x’ \ y’ \ 1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>cos\theta&amp;-sin\theta&amp;0\<br>sin\theta&amp;cos\theta&amp;0\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>x\ y\ 1<br>\end{bmatrix}<br>$$</p>
<h3 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h3><p>$$<br>\begin{bmatrix}<br>x’ \ y’ \ 1<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>s_x&amp;0&amp;0\<br>0&amp;s_y&amp;0\<br>0&amp;0&amp;1<br>\end{bmatrix}<br>\cdot<br>\begin{bmatrix}<br>x\ y\ 1<br>\end{bmatrix}<br>$$</p>
<h3 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h3><p>$$<br>\mathbf {P’=M_2\cdot M_1\cdot P}<br>$$<br>先进行$\mathbf{M_1}$后进行$\mathbf{M_2}$</p>
<h2 id="三维几何变换"><a href="#三维几何变换" class="headerlink" title="三维几何变换"></a>三维几何变换</h2><p>三维几何变换是二维几何变换的扩展</p>
<h2 id="图形几何变换的模式"><a href="#图形几何变换的模式" class="headerlink" title="图形几何变换的模式"></a>图形几何变换的模式</h2><h3 id="固定坐标系模式（图形模式）"><a href="#固定坐标系模式（图形模式）" class="headerlink" title="固定坐标系模式（图形模式）"></a>固定坐标系模式（图形模式）</h3><p>先调用的变换先执行，后调用的变换后执行</p>
<p>实际上，该变换变换的是图形</p>
<h3 id="活动坐标系模式（空间模式）"><a href="#活动坐标系模式（空间模式）" class="headerlink" title="活动坐标系模式（空间模式）"></a>活动坐标系模式（空间模式）</h3><p>openGL采用空间模式</p>
<p>先调用的变换后执行，后调用的变换先执行</p>
<p>实际上，该变换变换的是坐标系，这在三维观察中十分有用</p>
<h1 id="五、三维观察"><a href="#五、三维观察" class="headerlink" title="五、三维观察"></a>五、三维观察</h1><h2 id="坐标系的变换"><a href="#坐标系的变换" class="headerlink" title="坐标系的变换"></a>坐标系的变换</h2><p>将世界坐标系中的物体转换到观察坐标系中</p>
<blockquote>
<ul>
<li>世界坐标系为球面坐标系，右手系</li>
<li>观察坐标系为左手系，z轴为视线方向（朝向原点），x轴为视线正右方，y轴为视线正上方</li>
</ul>
</blockquote>
<p>从世界坐标系到观察坐标系的过程：</p>
<blockquote>
<ul>
<li>平移原点</li>
<li>旋转（两次）</li>
<li>反射（变换左右手系）</li>
</ul>
</blockquote>
<h2 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h2><h3 id="平行投影"><a href="#平行投影" class="headerlink" title="平行投影"></a>平行投影</h3><p>平行投影实际上是投影中心在无穷远处的透视投影</p>
<p>三视图</p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>投影平面、视距、视点</p>
<p>观察坐标系为左手坐标系，投影屏幕坐标系也是左手坐标系，而且它们z轴同向（重合）</p>
<p>视点（观察坐标系原点）和视心（投影屏幕坐标系原点）距离为视距d</p>
<p>投影过程：模型坐标-世界坐标系-观察坐标系-投影屏幕坐标系（包含伪深度）-屏幕坐标</p>
<p>一个观察坐标系的点到投影屏幕坐标系的点的变换过程如下：</p>
<blockquote>
<ul>
<li>透视变换（相似三角形）</li>
<li>正投影</li>
</ul>
</blockquote>
<p>一些结论：</p>
<blockquote>
<ul>
<li>与屏幕平行的直线，其透视仍与屏幕保持平行</li>
<li>与投影屏幕相交的直线，其透视为一条直线，无穷远处为灭点</li>
<li>与视点相交的直线，其透视为平行于z轴的一条直线，透视投影为一个点</li>
</ul>
</blockquote>
<h2 id="CG发展趋势"><a href="#CG发展趋势" class="headerlink" title="CG发展趋势"></a>CG发展趋势</h2><p>目前我国 CG 行业的发展主要集中于以下四个领域：建筑信息可视化、影视制作、动漫设计和游戏美术。</p>
<p>（1）建筑信息可视化</p>
<p>建筑信息可视化，是以建筑产品为对象的设计、表现方式。建筑信息可视化可以辅助传统建筑设计师虚构三维环境，用动态交互的方式全方位展示建筑作品，让施工方、检验人员、消费者身临其境的观赏建筑实物。CG 技术带动的建筑信息可视化业务，拥有着广阔的市场前景。目前我国建筑的三维效果图、建筑动画动漫市场竞争较为激烈，中小型公司较多。而 BIM 技术的兴起，使建筑信息可视技术直接带动了建筑行业各领域的变革和发展，使建筑行业的思维模式及习惯方法产生深刻变化。目前，公司主要专注于建筑信息可视化领域，其中 BIM技术服务业务将成为公司未来重点发展的方向之一。</p>
<p>（2）影视制作</p>
<p>CG 影视制作主要应用于影视后期加工、栏目包装和电视广告设计等方面，即运用电脑合成特效实现摄像机和人工道具无法实现效果的过程，在达到制作者意愿的同时，也给电影电视观众带来前所未有的视觉享受。CG 影视制作业务成本极高，市场容量有限，再加上影视观众口味的日益挑剔，其带来的商业盈利效果在逐步弱化。</p>
<p>（3）动漫艺术</p>
<p>动漫艺术是 CG 行业中最为人熟知的领域。近些年来，随着国外电影类动画大片在国内火热上映，精彩逼真的视觉效果带来的巨大盈利引发了我国动漫艺术产业的巨大变革。在政府的大力扶持下，我国培养出了大批动漫艺术专业人才，与此同时，从事动漫艺术开发创作的企业也日益增多，国产动漫作品也如同雨后春笋般相继诞生。然而，由于入行门槛较低，市场机制不健全等，国产动漫作品盈利空间有限。</p>
<p>（4）游戏美术</p>
<p>我国网络行业飞速发展的最好证明，是国产网游交出的漂亮成绩单。除了游戏研发、运营两大核心业务产值攀升之外，国内许多游戏厂商开始尝试平台服务，以“娱乐互动化”为核心理念，更大限度地挖掘游戏玩家带来的价值。无论单纯的游戏画面，还是延伸的 SNS 等互动社交平台运营，都需要 CG 行业的支持，CG游戏美术业务在未来将会有广阔的市场前景。</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>专业选修</category>
      </categories>
      <tags>
        <tag>计算机图形学，learning</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析</title>
    <url>/2020/09/09/numeric-analysis0/</url>
    <content><![CDATA[<p>数值计算是沟通数学和计算机之间的桥梁</p>
<p>作业考试：每章作业</p>
<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1-1-计算方法的意义和特点"><a href="#1-1-计算方法的意义和特点" class="headerlink" title="1.1 计算方法的意义和特点"></a>1.1 计算方法的意义和特点</h2><p>无法采用传统数学方法获得所需解的三种有代表性的情形：</p>
<blockquote>
<ul>
<li>所涉及的数学模型无系统的求解析解的方法</li>
<li>所涉及数学模型的解法计算量大，只适用于规模较小的情形</li>
<li>基于离散数据建立的数学模型</li>
</ul>
</blockquote>
<p>计算方法（数值分析）是研究如何对给定的问题构建只需进行<strong>有限步</strong>的<strong>四则运算</strong>的计算模型，以便有效地借助计算机<strong>迅速</strong>求出所需要的数值解的任务</p>
<blockquote>
<ul>
<li>上述这种计算模型又称为计算格式</li>
</ul>
</blockquote>
<p>问题的解决过程：工程问题-数学模型-<strong>数值模型</strong>-程序-计算机运行</p>
<p>计算方法相比于数学学科的特点：</p>
<blockquote>
<ul>
<li>形式多样、内容分散，但有自己的一些研究原则；如相容性、（误差）稳定性、计算复杂性和并行性</li>
<li>计算方法是理论分析的严谨性和实用准则的近似性的对立统一<blockquote>
<ul>
<li>（严谨性）算法误差应当具有收敛性（趋近于0）</li>
<li>（实用性）计算成本的约束使得实际应用中的误差并不是越小越好</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>数值模型的一些基本概念：</p>
<blockquote>
<ul>
<li>误差：分为算法（方法）误差和舍入误差</li>
<li>迭代：一种建立数值模型的重要策略；多次迭代可以降低算法误差</li>
<li>收敛性：用于描述迭代过程中算法误差变化的性质；有时也用收敛速度来描述</li>
<li>稳定性：用于描述舍入误差的一种性质</li>
<li>计算复杂度：又称计算成本，分为计算量和存贮量</li>
<li>并行性</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="1-2-计算格式的相容性与稳定性"><a href="#1-2-计算格式的相容性与稳定性" class="headerlink" title="1.2 计算格式的相容性与稳定性"></a>1.2 计算格式的相容性与稳定性</h2><h3 id="相容性"><a href="#相容性" class="headerlink" title="相容性"></a>相容性</h3><p>如果一个计算格式在取某种极限后可还原成某种数学模型，那么这个计算格式和此数学模型相容</p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>如果在用某一计算格式进行数值计算（迭代）的过程中，舍入误差不会严重积累（扩大），从而能够保证最终解满足所要求的精度，则称该计算格式数值稳定</p>
<blockquote>
<ul>
<li>稳定性分析通常基于对初始误差的传播状况的讨论</li>
<li>计算格式无法阻止舍入误差的传播，但能够防止舍入误差的扩大</li>
</ul>
</blockquote>
<h1 id="二、非线性方程的数值解法"><a href="#二、非线性方程的数值解法" class="headerlink" title="二、非线性方程的数值解法"></a>二、非线性方程的数值解法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>方程$f(x)=0$是非线性方程，则$f(x)$不满足下列条件：<br>$$f(x+y)=f(x)+f(y)$$</p>
<p>一般情况下，非线性方程难以求出精确解，一般只能求出数值解</p>
<p>非线性方程的数值计算策略：</p>
<blockquote>
<ul>
<li>区间收缩法：确定含根区间并不停收缩（二分法）</li>
<li>迭代法：选定初始值，然后通过迭代策略使其无限接近精确解（牛顿迭代法和弦截法）</li>
</ul>
</blockquote>
<h2 id="2-1-二分法"><a href="#2-1-二分法" class="headerlink" title="2.1 二分法"></a>2.1 二分法</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>在给定闭区间$[a,b]$上$f(x)$连续且$f(a)f(b)&lt;0$</p>
<blockquote>
<p>该条件可以充分推导出$f(x)=0$在$[a,b]$上至少有一解$x=x^*$</p>
</blockquote>
<h3 id="二分法的计算步骤"><a href="#二分法的计算步骤" class="headerlink" title="二分法的计算步骤"></a>二分法的计算步骤</h3><p>对方程$f(x)=0$输入：</p>
<blockquote>
<ul>
<li>区间$[a,b]$</li>
<li>精度$\epsilon$：告诉程序何时停止，即$|\overline x-x^*|&lt;\epsilon$时程序应当返回结果</li>
</ul>
</blockquote>
<p>过程：</p>
<blockquote>
<ol>
<li>输入$a,b,\epsilon$</li>
<li>令$[a_0,b_0]=[a,b],\ 且对 k=0,1,2…,\ x_k=\frac12(a_k+b_k)$，检验如果$|b_k-a_k|&lt;\epsilon$，则令$\overline x=x_k$,停止运算  </li>
<li>做如下判断，并令$k=k+1$，返回2.：</li>
</ol>
<p>$$f(a_k)f(x_k)=\begin{cases}<br>0 &amp;then\ let\ [a_{k+1},b_{k+1}]=[x_{k+1},b_k] \<br>&lt;0 &amp;then\ let\ [a_{k+1},b_{k+1}]=[a_k,x_{k+1}] \<br>=0 &amp;then\ end \<br>\end{cases}$$</p>
</blockquote>
<h3 id="二分法的收敛性与事前误差估计"><a href="#二分法的收敛性与事前误差估计" class="headerlink" title="二分法的收敛性与事前误差估计"></a>二分法的收敛性与事前误差估计</h3><p>收敛性：二分法总是收敛的，因为</p>
<blockquote>
<p>$\lim_{k \to \infty} b_k-a_k = 0$<br>$|\overline x-x^*| \le \frac 12 (b_k-a_k) = \frac 1{2^{k+1}}(b-a)$</p>
</blockquote>
<p>误差分析（事前误差分析法）：</p>
<blockquote>
<ul>
<li>对给定的精度要求$|\overline x-x^*|&lt;\epsilon$,取$\epsilon= \frac 1{2^{k+1}}(b-a)$解得k的值 </li>
<li>此时k向下取整即为循环（迭代）次数</li>
<li>一般地，当$\epsilon=10^{-m},\ 则 \ k=[\frac{lg(b-a)+m}{lg2}]$</li>
</ul>
</blockquote>
<h3 id="二分法评述"><a href="#二分法评述" class="headerlink" title="二分法评述"></a>二分法评述</h3><blockquote>
<ul>
<li>算法简单</li>
<li>收敛速度不高</li>
<li>无法求复数根，偶数个重根不能求</li>
</ul>
</blockquote>
<h2 id="2-2-一般迭代法"><a href="#2-2-一般迭代法" class="headerlink" title="2.2 一般迭代法"></a>2.2 一般迭代法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><blockquote>
<ul>
<li>$f(x)=0 \to x=g(x)$</li>
<li>建立迭代格式$x_{k+1}=g(x_k),\ k-0,1…$</li>
<li>选取$x_0$，进行迭代$x_0 \to x_1 \to…$<br>若无说明，$x_0$具有任意性</li>
</ul>
</blockquote>
<p>此时：</p>
<blockquote>
<ul>
<li>若${ x_k }$收敛，即$\lim_{k \to \infty} x^k = x^<em>$，此时$f(x^</em>)=0$</li>
<li>若${ x_k }$不收敛，迭代失败</li>
</ul>
</blockquote>
<h3 id="迭代算法的收敛性"><a href="#迭代算法的收敛性" class="headerlink" title="迭代算法的收敛性"></a>迭代算法的收敛性</h3><p>一个定义：<br>$$<br>在区间\Delta内,g(x)满足下列李普希兹条件：\<br>|g(x)-g(y)| \le L|x-y| 对 \forall x,y \in \delta, 常数0&lt;L&lt;1成立 \<br>则称g(x) 在 \Delta 内李普希兹连续<br>$$<br>可以知道：<br>$$<br>若g’(x)在闭区间\Delta内连续且|g’(x)|\le L&lt;1对\forall x \in \Delta连续 \<br>则g(x)在\Delta内李普希兹连续<br>$$<br>此时，得到如下定理：<br>$$<br>在方程x^<em>=g(x^</em>)中，若\<br>g(x)在闭区间\Delta内李普希兹连续，则\<br>对\forall x_0 \in \Delta，由迭代格式x_{k+1}=g(x_k)计算得到的解序列{x_k}收敛于x^<em>\<br>此时称迭代格式x_{k+1}=g(x_k)在x^</em>的邻域\Delta上局部收敛<br>$$</p>
<blockquote>
<ul>
<li>此时，$|x^*-x_k| \le \frac L{1-L}|x_k-x_{k-1}|$（误差估计）</li>
<li>$g(x)$在$\Delta$内李普希兹连续保证了$x^*为f(x)=0在\Delta内的唯一根$</li>
</ul>
</blockquote>
<p>实际判断方法：</p>
<blockquote>
<ul>
<li>设$x_0$是$x^*$的一个近似</li>
<li>若$|g’(x_0)|&lt;1$，则判断收敛；反之不收敛</li>
</ul>
</blockquote>
<h3 id="收敛情况下的误差估计"><a href="#收敛情况下的误差估计" class="headerlink" title="收敛情况下的误差估计"></a>收敛情况下的误差估计</h3><blockquote>
<ul>
<li>事前估计法（常量估计）：$|x_k-x^*|&lt;\epsilon_1$</li>
<li>事前估计法（差值估计）：$|x_k-x_{k-1}|&lt;\epsilon_2$</li>
<li>事后估计法：$|f(x_k)|&lt;\epsilon_3$</li>
</ul>
</blockquote>
<p>一般迭代法需要构造的$g(x)$没有固定的格式，这在计算机上几乎无法实现</p>
<h2 id="2-3-牛顿迭代法"><a href="#2-3-牛顿迭代法" class="headerlink" title="2.3 牛顿迭代法"></a>2.3 牛顿迭代法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>设$f(x)$在$x^<em>$附近连续可微，记$x_k$为$x^</em>$的第k个近似值，则：<br>$$<br>f(x)=f(x_k)+f’(x_k)(x-x_k)+O((x-x_k)^2) \ \approx<br>f(x_k)+f’(x_k)(x-x_k) = P_1(x)<br>$$<br>实际上，$P_1(x)=0$就是$f(x)$在点$(x_k,f(x_k))$的切线方程</p>
<p>取$P_1(x)=0$的根作为$x^*$的第$k+1$次近似值$x_{k+1}$,解得如下迭代格式：<br>$$<br>x_{k+1}=x_k-\frac{f(x_k)}{f’(x)}<br>$$</p>
<h3 id="牛顿迭代法收敛性和收敛速度"><a href="#牛顿迭代法收敛性和收敛速度" class="headerlink" title="牛顿迭代法收敛性和收敛速度"></a>牛顿迭代法收敛性和收敛速度</h3><p>$$<br>设 {x_k} 收敛于x^* \<br>如果 e_k=|x_k-x^*| 在 k \to \infty 时满足：\<br>\frac{e_{k-1}}{e_k^P} \to C \ (C为常数且不为零) ，则：<br>$$</p>
<blockquote>
<ul>
<li>P=1时：序列为线性收敛</li>
<li>P=2时：序列为平方收敛</li>
<li>1&lt;P&lt;2时：序列为超线性收敛</li>
</ul>
</blockquote>
<p>定理：<br>$$<br>若 F(x) 在x^<em>附近二阶连续，且x^</em>为f(x)=0的单根，\<br>则牛顿迭代法在x^*附近至少是平方收敛的<br>$$</p>
<blockquote>
<ul>
<li>牛顿迭代法需要求出$f(x)$的导函数，这对于计算机来说不好处理</li>
<li>牛顿迭代法收敛速度快，但对初值要求比较高，可以和二分法结合使用</li>
</ul>
</blockquote>
<h2 id="2-4-弦截法"><a href="#2-4-弦截法" class="headerlink" title="2.4 弦截法"></a>2.4 弦截法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>要点：在牛顿迭代法的基础上以差商代替微商，即<br>$$<br>以\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}代替f’(x_k)<br>$$<br>有：<br>$$<br>f(x) \approx f(x_k) + \frac{f(x_k)}{f(x_k)－f(x_{k-1})}(x_k-x_{k-1})<br>$$<br>实际上，该弦线为点$P(x_k,f(x_k))$和$Q(x_{k-1},f(x_{k-1}))$的连线；用其与$x$轴的交点作为$x^*$的近似值$x_{k+1}$</p>
<p>解得弦截法的迭代格式：<br>$$<br>x_{k+1} = x_k - \frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1})<br>$$</p>
<blockquote>
<p>此迭代格式为多步迭代，需要$x_0,x_1$两个初始值</p>
</blockquote>
<h3 id="弦截法的收敛性"><a href="#弦截法的收敛性" class="headerlink" title="弦截法的收敛性"></a>弦截法的收敛性</h3><p>$$<br>设f(x)在其零点x^<em>的领域 \Delta=[x^</em>-\delta,x^*+\delta] 内二阶连续，且 \<br>对\forall x \in \Delta有f’(x) \neq 0,则 \<br>对\forall x_0,x_{-1} \in \Delta，弦截法是p \approx 1.618(超线性)收敛的<br>$$</p>
<h1 id="三、线性代数方程组的数值解法"><a href="#三、线性代数方程组的数值解法" class="headerlink" title="三、线性代数方程组的数值解法"></a>三、线性代数方程组的数值解法</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><p>线性方程组的形式如下：<br>$$<br>\mathbf {Ax} = b \<br>\mathbf A = [a_{ij}]; x = [a_{1k}]<br>$$</p>
<p>解法策略：</p>
<blockquote>
<ul>
<li>直接法：消元法，矩阵分解法</li>
<li>迭代法：$ \mathbf {Ax} =b \to \mathbf x^{k+1} = \mathbf {Mx}^k + f $</li>
</ul>
</blockquote>
<h2 id="3-2-消元法"><a href="#3-2-消元法" class="headerlink" title="3.2 消元法"></a>3.2 消元法</h2><h3 id="高斯消去法"><a href="#高斯消去法" class="headerlink" title="高斯消去法"></a>高斯消去法</h3><p>基本原理：使用初等行变化将增广矩阵左部$\mathbf A$化为上三角矩阵$\mathbf U$<br>$$ [\mathbf A|b] \to [\mathbf U|\overline b]$$</p>
<p>初等行变换：这里不包括行交换</p>
<blockquote>
<ul>
<li>倍乘</li>
<li>倍加</li>
</ul>
</blockquote>
<p>过程：归一，消元，回代</p>
<blockquote>
<ol>
<li>$i=1$</li>
<li>将第$i$行的第$i$个未知数系数化为1</li>
<li>将第$i$行倍乘加到第$i+1,…n$行中，将各行的第$i$个未知数系数化为0</li>
<li>若$i \neq n-1$,$i = i+1$，返回2.</li>
<li>回代，解得结果</li>
</ol>
</blockquote>
<p>运算量：$\frac{n^3}3$</p>
<h3 id="高斯-若当消去法"><a href="#高斯-若当消去法" class="headerlink" title="高斯-若当消去法"></a>高斯-若当消去法</h3><p>基本原理：使用初等行变化将增广矩阵左部$\mathbf A$化为单位矩阵$\mathbf I$<br>$$ [\mathbf A|b] \to [\mathbf I|\overline b]$$</p>
<p>过程：</p>
<blockquote>
<ol>
<li>$i=1$</li>
<li>将第$i$行的第$i$个未知数系数化为1</li>
<li>将第$i$行倍乘加到第$1,…i-1,i+1…n$行中，将各行的第$i$个未知数系数化为0</li>
<li>若$i \neq n$,$i = i+1$，返回2.</li>
<li>得到结果$x = [b]^T$</li>
</ol>
</blockquote>
<p>运算量：$\frac{n^3}2$</p>
<h3 id="消去法的可行性条件"><a href="#消去法的可行性条件" class="headerlink" title="消去法的可行性条件"></a>消去法的可行性条件</h3><p>线性代数中，方程组有解的条件</p>
<blockquote>
<ul>
<li>阶不为0，有解</li>
<li>阶等于秩，解唯一</li>
<li>本质：行列式不为零</li>
</ul>
</blockquote>
<p>若$\mathbf A$的各阶顺序主子式均不为零，则消去法可行</p>
<blockquote>
<ul>
<li>$n$阶子式：任选$n$行和$n$列交叉点元素构成的行列式</li>
<li>主子式：子式元素依对角线对称</li>
<li>$n$阶顺序主子式：选取的$n$行和$n$列必须为$1,…n$</li>
</ul>
</blockquote>
<p>推论：若$\mathbf A$严格对角占优，则消去法可行，此即：<br>$$ |a_{ii}|&gt;\sum_{j=1 \ j\neq i}^n|a_{ij}|,(i = 1,2,…n) $$</p>
<h3 id="列主元高斯消去法（常用）"><a href="#列主元高斯消去法（常用）" class="headerlink" title="列主元高斯消去法（常用）"></a>列主元高斯消去法（常用）</h3><p>基本原理：通过选择主元，进行行变换来防止主元为零（此时之前的消去法不可行）或主元很小（会导致小数除法造成较大的误差累积）的情形</p>
<p>过程</p>
<blockquote>
<ol>
<li>k=1</li>
<li>在第k列主对角线及以下的元素中选取绝对值最大的元素为主元$A[i]<a href="i>=k;j>=k;i>=j">j</a>$</li>
<li>交换i，j两行，将主元调到主对角线上</li>
<li>进行一次归一消元，此时消去的是第j列元素</li>
<li>k+=1，返回2.，直到k=n</li>
<li>回代得到解</li>
</ol>
</blockquote>
<h3 id="全主元高斯-若当消去法"><a href="#全主元高斯-若当消去法" class="headerlink" title="全主元高斯-若当消去法"></a>全主元高斯-若当消去法</h3><p>原理：进行行列变换来选择主元</p>
<p>过程：</p>
<blockquote>
<ol>
<li>开始循环</li>
<li>划去前面主元所在的行列后，在余下的元素中选择主元$A[i]<a href="i>=k;j>=k">j</a>$</li>
<li>交换i，j两行，将主元调到主对角线上</li>
<li>进行一次归一消元，此时消去的是第j列元素</li>
<li>划去该主元所在的行和列</li>
<li>循环上述操作n次</li>
<li>直接得到结果</li>
</ol>
</blockquote>
<h2 id="3-3-矩阵分解法"><a href="#3-3-矩阵分解法" class="headerlink" title="3.3 矩阵分解法"></a>3.3 矩阵分解法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>思想：对$\mathbf Ax=b$进行变换，得<br>$$<br>\mathbf A = \mathbf {LU}，其中\mathbf L为下三角矩阵；\mathbf U为上三角矩阵，得 \<br>(\mathbf{LU})x = b，即 \<br>\mathbf Ly = b ；\mathbf Ux =y<br>$$</p>
<blockquote>
<ul>
<li>分解后，只需要两次简单回代就可以解的y和x，得到最终结果</li>
<li>注意：$\mathbf {LU}$并非唯一存在</li>
</ul>
</blockquote>
<p>为使得$\mathbf {LU}$分解唯一存在，可以如下规定：</p>
<blockquote>
<ul>
<li>克洛特(Crout)分解：$\mathbf U$为单位上三角矩阵</li>
<li>杜利特尔(Doolittle)分解：$\mathbf L$为单位下三角矩阵</li>
</ul>
</blockquote>
<p>矩阵分解法的计算量、稳定性和消去法大致相等；但对于相同的系数矩阵的一批方程组，矩阵分解法处理效率较高</p>
<h3 id="克洛特分解"><a href="#克洛特分解" class="headerlink" title="克洛特分解"></a>克洛特分解</h3><p>思想：$\mathbf U$为单位上三角矩阵，有<br>$$\begin{align}<br>a_{ij} &amp;= l_{ij} + \sum_{k=1}^{j-1}l_{ik}u_{kj} ;i \le j\<br>a_{ij} &amp;= l_{ii}u_{ij} + \sum_{k=1}^{i-1}l_{ik}u_{kj} ;i&gt;j<br>\end{align}$$<br>得到：<br>$$\begin{align}<br>l_{ij} &amp;= a_{ij} - \sum_{k=1}^{j-1}l_{ik}u_{kj} \<br>u_{ij} &amp;=\frac{a_{ij}-\sum_{k=1}^{i-1}l_{ik}u_{kj}}{l_{ii}}<br>\end{align}$$</p>
<p>计算顺序如下：$\mathbf L$第一列，$\mathbf U$第一行，$\mathbf L$第二列，$\mathbf U$第二行，….</p>
<h2 id="3-4-迭代法"><a href="#3-4-迭代法" class="headerlink" title="3.4 迭代法"></a>3.4 迭代法</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>思想：将$\mathbf Ax=b$化为如下格式<br>$$<br>x = \mathbf Mx+f<br>$$</p>
<p>则迭代格式如下（雅可比迭代）：<br>$$<br>x^{(k+1)}=\mathbf Mx^{(k)}+f<br>$$</p>
<h3 id="矩阵的分解"><a href="#矩阵的分解" class="headerlink" title="矩阵的分解"></a>矩阵的分解</h3><p>矩阵分解用于迭代格式收敛的分析</p>
<p>将$\mathbf A$进行如下分解<br>$$<br>\mathbf A = \mathbf D - \mathbf L - \mathbf U<br>$$</p>
<blockquote>
<ul>
<li>$\mathbf D$为原矩阵的对角线部分（可逆）</li>
<li>$-\mathbf L$和$-\mathbf U$为元矩阵以对角线为界的下三角和上三角部分（对角线为0）</li>
</ul>
</blockquote>
<p>则雅可比迭代法迭代格式如下：（同步迭代）<br>$$\begin{align}<br>x^{(k+1)} &amp;= \mathbf M_Jx^{(k)}+f_J \<br>\mathbf M_J &amp;= \mathbf D^{-1}(\mathbf L + \mathbf U) \<br>f_J &amp;= \mathbf D^{-1}b<br>\end{align}$$</p>
<blockquote>
<p>$\mathbf M_J$为雅可比的迭代矩阵，用于做收敛分析</p>
</blockquote>
<p>高斯-塞德尔迭代法迭代格式如下：（异步迭代）<br>$$<br>x^{(k+1)} = \mathbf D^{-1}(b + \mathbf Lx^{(k+1)} + \mathbf Ux^{(k)})<br>$$<br>即：<br>$$\begin{align}<br>x^{(k+1)} &amp;= \mathbf M_Gx^{(k)}+f_G \<br>\mathbf M_G &amp;= (\mathbf D - \mathbf L)^{-1} \mathbf U \<br>f_G &amp;= (\mathbf D - \mathbf L)^{-1}b<br>\end{align}$$</p>
<blockquote>
<p>$M_G$为高斯-塞德尔的迭代矩阵</p>
</blockquote>
<p>高斯-塞德尔迭代法有助于提高收敛速度</p>
<h3 id="其他迭代法"><a href="#其他迭代法" class="headerlink" title="其他迭代法"></a>其他迭代法</h3><p>SOR迭代法、投影类算法：现代迭代法</p>
<p>SOR迭代法:<br>$$\begin{align}<br>&amp;\mathbf Ax = b \<br>&amp;\Rightarrow \sum_{j=1}^n a_{ij}x_j = b_i, \ (i=1,2,…n) \<br>&amp;\Rightarrow a_{ii}x_i = a_{ii}x_i+\omega(b_i-\sum_{j=1}^n a_{ij}x_j)\<br>&amp;\Rightarrow x_i=x_i+\frac \omega a_{ii}(b_i-\sum_{j=1}^n a_{ij}x_j)<br>\end{align}$$</p>
<p>建立类似高斯-赛德尔迭代格式:<br>$$<br>x_i^{(k+1)}=x_i^{(k)} + \frac \omega a_{ii}(b_i  - \sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i}^n a_{ij}x_j^{(k)})<br>$$<br>即<br>$$<br>x_i^{(k+1)}=(1-\omega)x_i^{(k)} + \frac \omega a_{ii}(b_i  - \sum_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum_{j=i+1}^n a_{ij}x_j^{(k)})<br>$$</p>
<h3 id="迭代法的收敛性"><a href="#迭代法的收敛性" class="headerlink" title="迭代法的收敛性"></a>迭代法的收敛性</h3><p>若：<br>$$<br>\lim_{k\to \infty} \max_{1\le i \le n}|x_i^{k}-x_i^<em>|<br>$$<br>则$\lim_{k\to \infty} |x_i^{k}-x_i^</em>|=0$</p>
<p>对于迭代格式，其迭代矩阵$\mathbf M$满足如下条件，则迭代格式对任何初始向量均收敛<br>$$<br>\rho(\mathbf M) = \max_{1\le i \le n}|\lambda_i| &lt;1<br>$$</p>
<h1 id="四、函数的插值与拟合法"><a href="#四、函数的插值与拟合法" class="headerlink" title="四、函数的插值与拟合法"></a>四、函数的插值与拟合法</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>若函数$f(x)$存在点列$&lt;x_0,y_0&gt;,&lt;x_1,y_1&gt;…&lt;x_n,y_n&gt;$，若函数$P(n)$有<br>$$<br>P(x_i)=y_i<br>$$<br>则$P(x)$为原函数$f(x)$的插值函数，上述条件为插值条件</p>
<blockquote>
<ul>
<li>$P(x)$为多项式时，该插值法为多项式插值</li>
<li>还有三角插值、分段插值等</li>
</ul>
</blockquote>
<p>多项式插值的插值函数为：<br>$$<br>P_n(x) = \sum_{k=0}^n a_kx^k<br>$$</p>
<p>此时，在$n+1$个互异点$x_0…x_n$上满足插值条件的次数不超过$n$的插值多项式$P_n(x)$存在且唯一</p>
<h2 id="4-2-插值多项式的构造"><a href="#4-2-插值多项式的构造" class="headerlink" title="4.2 插值多项式的构造"></a>4.2 插值多项式的构造</h2><h3 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h3><p>Largrange插值多项式基函数：<br>$$<br>l_i(x) = \prod_{j=0,j\neq i}^n \frac {x-x_j}{x_i-x_j} \ (i = 0,1,…n)<br>$$</p>
<p>则$n$次Largrange插值多项式：<br>$$<br>L_i(x) = \sum_{i=0}^ny_il_i(x)<br>$$</p>
<p>此时，$L_i(x)$是满足条件的插值多项式</p>
<blockquote>
<ul>
<li>$L_1(x)$：线性插值</li>
<li>$L_2(x)$：抛物插值</li>
</ul>
</blockquote>
<p>插值函数和原函数的关系：</p>
<p>$f^{(n)}(x)$在$[a,b]$上连续，$f^{(n+1)}(x)$在$(a,b)$上存在，$x_i \in [a,b]$，$L_n(x)$为满足插值条件的Largrange插值多项式，则存在<br>$$<br>\xi = \xi(x) \in [a,b]<br>$$<br>使得插值余项<br>$$<br>f(x)-L_n(x)=R_n(x) = \frac {f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x), x\in[a,b] \<br>\omega_{n+1}(x)=\prod_{j=0}^n(x-x_j)<br>$$</p>
<p>做误差估计时，取$M_{(n+1)} = \max_{a\le x\le b}|f^{(n+1)}(x)|$，此时误差<br>$$<br>|R_n(x)| \le \frac{M_{n+1}}{(n+1)!}|\omega_{n+1}(x)|<br>$$</p>
<h3 id="牛顿均差值"><a href="#牛顿均差值" class="headerlink" title="牛顿均差值"></a>牛顿均差值</h3><p>对于$f(x)$在$[a,b]$上的互异点$x_0,…x_{k-1}$，有：<br>$$<br>g_k(x)=\frac{g_{k-1}(x)-g_{k-1}(x_{k-1})}{x-x_{k-1}}<br>$$<br>其中：<br>$$<br>g_k(x) = f[x_0,…,x_{k-1},x]\<br>g_1(x) = \frac{f(x)-f(x_0)}{x-x_0},\ x \neq x_0<br>$$<br>此时$g_k(x)$为$f(x)$在$[a,b]$上关于点$x_0,…x_{k-1}$的$k$阶均差函数</p>
<p>$f[x_0,…,x_k-1,x_k]$为$f(x)$在均差节点$x_0,…,x_k$上的$k$阶均差（差商），且</p>
<p>$$<br>\begin{align}<br>f[x_0,x_1,…,x_k]&amp;=\frac{f[x_1,…x_k]-f[x_0,…x_{k-1}]}{x_k-x_0} \ (构造均差表)\<br>&amp;=\sum_{i=0}^k\frac{f(x_i)}{\prod_{j=i\ j\neq 0}^k(x_i-x_j)} \<br>&amp;=\frac{f^{(k)}(\eta)}{k!}, \ \eta \in (x_0,x_k)<br>\end{align}<br>$$</p>
<p>则插值多项式构造如下：<br>$$<br>\begin{align}<br>N_n(x) &amp;= f(x_0) + \sum_{k=1}^nf[x_0,x_1,…,x_k]\omega_k(x) \<br>&amp;= N_{n-1} + f[x_0,x_1,…x_n]\omega_n(x) \<br>\omega_{k}(x)&amp;=\prod_{j=0}^{k-1}(x-x_j)<br>\end{align}<br>$$</p>
<p>可知，余项$R_n(x) = f[x_0,x_1,…,x_n,x]\omega_{n+1}(x)$</p>
<h2 id="4-3-分段低次插值"><a href="#4-3-分段低次插值" class="headerlink" title="4.3 分段低次插值"></a>4.3 分段低次插值</h2><p>龙格现象：有时高次多项式插值的误差、稳定性较差</p>
<h2 id="4-4-最小二乘拟合法"><a href="#4-4-最小二乘拟合法" class="headerlink" title="4.4 最小二乘拟合法"></a>4.4 最小二乘拟合法</h2><p>插值使用$n-1$阶的多项式来近似$n$个数据点；拟合则使用更少的$m(m&lt;n-1)$阶多项式来近似原函数</p>
<p>目标：构造$m$次多项式$P_m(x)=\sum_{k=0}^m\alpha_kx^k$使得在拟合点$(x_1,y_1),…(x_n,y_n)$上，方差和<br>$$<br>\sum_{i=1}^nR_i^2 =\sum_{i=1}^n(P_m(x_i)-y_i)^2<br>$$<br>最小，即<br>$$<br>F(\alpha_0,…,\alpha_m)=\sum_{i=1}^n(\sum_{k=0}^m\alpha_ix_i^k-y_i)^2<br>$$<br>最小，其条件为<br>$$<br>\frac{\partial F}{\partial\alpha_0}=\frac{\partial F}{\partial\alpha_1}=…=\frac{\partial F}{\partial\alpha_n}=0<br>$$<br>整理可得$m+1$阶方程组</p>
<p>$$<br>\begin{bmatrix}<br>S_0&amp;S_1&amp;\cdots&amp;S_m \<br>S_1&amp;S_2&amp;\cdots&amp;S_{m+1} \<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots \<br>S_m&amp;S_{m+1}&amp;\cdots&amp;S_{2m}<br>\end{bmatrix}<br>\begin{bmatrix}<br>\alpha_0 \ \alpha_1 \ \vdots \ \alpha_m<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>T_0 \ T_1 \ \vdots \ T_m<br>\end{bmatrix}<br>$$<br>其中：<br>$$<br>\begin{align}<br>S_k&amp;=\sum_{i=1}^nx_i^k \<br>T_k&amp;=\sum_{i=1}^nx_i^ky_i<br>\end{align}<br>$$</p>
<blockquote>
<ul>
<li>$m&lt;n$时，方程组存在唯一解使得目标函数最小化</li>
<li>$m=n-1$时，目标函数最小值为0，此时拟合函数为插值多项式</li>
</ul>
</blockquote>
<p>最小二乘法的应用：P93</p>
<blockquote>
<ul>
<li>数据的指数拟合</li>
<li>超定方程组的最小二乘解</li>
</ul>
</blockquote>
<h1 id="五、插值型数值微分与数值积分"><a href="#五、插值型数值微分与数值积分" class="headerlink" title="五、插值型数值微分与数值积分"></a>五、插值型数值微分与数值积分</h1><p>对于函数$y=f(x)$，其插值多项式为<br>$$<br>f(x) \approx Ln(x)<br>$$</p>
<p>则有<br>$$<br>f’(x) \approx Ln’(x) \<br>\int_a^b f(x)dx \approx \int_a^b Ln(x) dx<br>$$</p>
<h2 id="5-1-数值微分"><a href="#5-1-数值微分" class="headerlink" title="5.1 数值微分"></a>5.1 数值微分</h2><p>$$<br>f’(x_i) = \frac{y_{i+1}-y_{i-1}}{2\delta}\<br>f’’(x_i) = \frac{y_{i+1}-2y_i+y_{i-1}}{\delta^2}<br>$$</p>
<p>数值微分误差通常用泰勒公式估计</p>
<h2 id="5-2-数值积分"><a href="#5-2-数值积分" class="headerlink" title="5.2 数值积分"></a>5.2 数值积分</h2><p>牛顿-柯林斯公式（等距采样）<br>$$<br>\mathbf I_n = (b-a)\sum_{i=0}^nC_i^{(n)}f(x_i)<br>$$<br>其中：<br>$$<br>C_i^{(n)} = \frac{(-1)^{n-i}}{i!(n-i)!n}\int_0^n\prod_{j=0\ j\neq i}^n (t-j)dt<br>$$</p>
<h2 id="5-3-复合求积公式"><a href="#5-3-复合求积公式" class="headerlink" title="5.3 复合求积公式"></a>5.3 复合求积公式</h2><p>牛顿-柯林斯公式在低次插值误差较大、高次插值不稳定</p>
<p>基于分段低次插值来构造求积公式：对$[a,b]$做等距分割$x_k=a+kh$，其中$k=0,1,…n; h=\frac{b-a}{h}$，然后在$[x_{k-1},x_k]$上求积</p>
<p>复合梯形公式：<br>$$<br>\begin{align}<br>T_n &amp;= \sum_{k=1}^n \frac h2 [f(x_{k-1})+f(x_k)] \<br>&amp;= \frac {b-a}{2n}[f(a)+f(b)+2\sum_{k=1}^{n-1}f(x_k)]<br>\end{align}<br>$$</p>
<h2 id="数值积分误差分析"><a href="#数值积分误差分析" class="headerlink" title="数值积分误差分析"></a>数值积分误差分析</h2><p>要使得积分结果达到目标精度，需要修改上述方法，使得误差能够得到计算</p>
<p>P109，过于复杂<br><img src="/2020/09/09/numeric-analysis0/P109.jpg" alt></p>
<p>步长减半算法：<br><img src="/2020/09/09/numeric-analysis0/P111.jpg" alt></p>
<p>龙贝格积分法：高次插值可由低次插值等线性组合构成<br><img src="/2020/09/09/numeric-analysis0/P114.jpg" alt></p>
<h1 id="六、常微分方程的数值解"><a href="#六、常微分方程的数值解" class="headerlink" title="六、常微分方程的数值解"></a>六、常微分方程的数值解</h1><p>一阶常微分方程初值问题：<br>$$<br>\begin{cases}<br>y’ = f(x,y) \<br>y(x_0)=y_0<br>\end{cases}<br>x \in [x_0,b]<br>$$</p>
<p>此时，求解的结果为$[x_0,b]$上的一组等距分割的离散点</p>
<h2 id="欧拉方法"><a href="#欧拉方法" class="headerlink" title="欧拉方法"></a>欧拉方法</h2><p>$$ y_{i+1}=y_i+hf(x_i,y_i) $$</p>
<h3 id="改进欧拉方法"><a href="#改进欧拉方法" class="headerlink" title="改进欧拉方法"></a>改进欧拉方法</h3><p>做积分时采用梯形公式<br>$$ y_{i+1} = y_i + \frac h2[f(x_i,y_i)+f(x_{i+1},y_{i+1})] $$</p>
<p>可先用欧拉方法进行预估，然后用改进方法（梯形公式）进行校正</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>专业选修</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title>算法设计与分析基础知识</title>
    <url>/2020/09/08/algorithm0/</url>
    <content><![CDATA[<p>权丽君：<a href="mailto:ljquan@suda.edu.cn">ljquan@suda.edu.cn</a></p>
<p>为什么要学习算法：</p>
<blockquote>
<ul>
<li>算法是计算机科学的基石，是改造世界的有力工具</li>
<li>学习算方法可以开发人们的分析能力</li>
<li>算法进步是计算机技术进步的关键</li>
<li>算法应用无处不在</li>
<li>算法是计算机软件的灵魂：软件=数据结构+算法</li>
<li>即使计算机的速度和存储空间都是无限的，算法的研究仍然是必要的</li>
</ul>
</blockquote>
<p>数据结构着重于算法的实现；算法导论着重于算法设计的指导思想</p>
<p>课程目的：</p>
<blockquote>
<ul>
<li>偏向理论，掌握算法设计与分析的基本理论和方法，培养算法设计和分析的能力</li>
<li>培养实践能力、独立思考和创新能力</li>
<li>教学内容：基础知识、排序和顺序统计学、高级数据结构、算法设计策略</li>
</ul>
</blockquote>
<p>期末考试70%闭卷，论文汇报10%，作业考勤20%</p>
<a id="more"></a>

<h1 id="一、算法在计算机中的应用"><a href="#一、算法在计算机中的应用" class="headerlink" title="一、算法在计算机中的应用"></a>一、算法在计算机中的应用</h1><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>算法是：</p>
<blockquote>
<ul>
<li>将输入转换成输出的计算步骤的一个序列（非形式化定义）</li>
<li>问题的程序化解决方案，是一个在时间和空间上的有穷的规则</li>
</ul>
</blockquote>
<p>算法的形式：包括算术、逻辑、全息、赋值、过程调用等运算形式</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>算法的特征<strong>重要</strong>：</p>
<blockquote>
<ul>
<li>具有输入，输出</li>
<li>具有（步骤）的确定性</li>
<li>有限性：算法必须是步骤有限的，这是算法和计算过程的本质区别</li>
<li>正确性：算法对问题每一个输入实例，都能产生正确的输出并停止</li>
<li>通用性</li>
</ul>
</blockquote>
<p>算法的正确性：</p>
<blockquote>
<ul>
<li>不正确的算法可能不会停止，或者在停止时给出的不是预期的结果</li>
<li>如果算法的错误率可以控制，也是有用的</li>
</ul>
</blockquote>
<h3 id="一些其他概念"><a href="#一些其他概念" class="headerlink" title="一些其他概念"></a>一些其他概念</h3><p>问题和问题实例的区别：</p>
<blockquote>
<ul>
<li>问题规定了输入和输出之间的关系，可以用通用语言来描述</li>
<li>某一个问题的实例包含了求解该问题所需的输入</li>
<li>问题的规模：算法输入的实际大小</li>
</ul>
</blockquote>
<p>算法和策略：</p>
<blockquote>
<ul>
<li>算法（规则）的设计可以总结出设计策略</li>
<li>设计策略可以指导规则的设计</li>
</ul>
</blockquote>
<h1 id="二、算法基础"><a href="#二、算法基础" class="headerlink" title="二、算法基础"></a>二、算法基础</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h2><h3 id="问题求解基础"><a href="#问题求解基础" class="headerlink" title="问题求解基础"></a>问题求解基础</h3><blockquote>
<ul>
<li>理解问题</li>
<li>决定计算方法、精确或近似解法、数据结构、算法设计技术</li>
<li>设计算法（并修改）</li>
<li>正确性证明（并修改）</li>
<li>分析算法（时间分析、空间分析；并修改）</li>
<li>根据算法编写代码</li>
</ul>
</blockquote>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>算法描述方法：伪代码</p>
<blockquote>
<ul>
<li>块结构用缩进表示</li>
<li>判断、循环、赋值语句及数组访问、注释等遵循C++风格</li>
<li>一般不设全局变量</li>
<li>复合数据用对象表示，对象赋值为指针赋值（浅拷贝）</li>
<li>参数按值传递（对象则传递指针）</li>
<li>return语句可以返回多个值</li>
<li>逻辑运算符是短路的</li>
<li>NIL表示空；error表示报错（无需异常处理）</li>
</ul>
</blockquote>
<h3 id="循环不变式证明算法正确性"><a href="#循环不变式证明算法正确性" class="headerlink" title="循环不变式证明算法正确性"></a>循环不变式证明算法正确性</h3><p><strong>重要</strong></p>
<p>循环不变式是在循环体每次执行前后都为真的谓词，它体现了循环程序中循环变量的变化规律</p>
<p>通常，算法所需要达到的目标在循环过程中是部分成立的，这与循环不变式密切相关</p>
<p>循环不变式性质：</p>
<blockquote>
<ul>
<li>初始化：循环不变式在循环开始之前为真</li>
<li>保持：若循环某次迭代之前它为真，这下次循环之前它仍然为真</li>
<li>终止：循环终止时，不变式为我们提供了一个有助于证明算法正确性的性质</li>
</ul>
</blockquote>
<h2 id="2-2-算法分析"><a href="#2-2-算法分析" class="headerlink" title="2.2 算法分析"></a>2.2 算法分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>算法分析通常是对时间和空间都预测</p>
<p>目的：预测算法需要资源的程度</p>
<blockquote>
<ul>
<li>有助于算法选择和算法优化</li>
</ul>
</blockquote>
<p>算法分析基于的假设：RAM模型</p>
<blockquote>
<ul>
<li>指令逐条执行，没有并发</li>
<li>包含常用指令，每条指令执行时间为常量</li>
<li>数据类型有整数类型和浮点数类型</li>
<li>不对存储层次进行建模</li>
</ul>
</blockquote>
<p>实例：插入排序P9－P11</p>
<blockquote>
<ul>
<li>插入排序的思想、性质和排序过程</li>
<li>插入排序的时间复杂度计算，且能用渐进记号表示</li>
</ul>
</blockquote>
<h3 id="执行时间"><a href="#执行时间" class="headerlink" title="执行时间"></a>执行时间</h3><p>算法的执行时间是算法中所有运算执行时间的总和</p>
<p>运算的分类：</p>
<blockquote>
<ul>
<li>时间囿界于常数的运算：运算的执行时间与操作数无关，每次执行时间是一个常数</li>
<li>时间非囿界于常数的运算：运算的执行时间与输入有关</li>
</ul>
</blockquote>
<p>算法的执行时间与输入数据有关：</p>
<blockquote>
<ul>
<li>与输入数据规模有关，一般规模越大，执行时间越长</li>
<li>与输入数据的配置有关，可分最好、最坏和平均情况等讨论；一般情况下，我们更关心算法的最坏情况执行时间</li>
</ul>
</blockquote>
<p>运行时间的增长量级：</p>
<blockquote>
<ul>
<li>运行时间的增长量级是对算法执行时间的抽象</li>
<li>此时，我们只考虑公式中最重要的项，并且忽略该项的常系数和其他项</li>
<li>此概念在后续会进行具体的描述</li>
</ul>
</blockquote>
<h3 id="算法正确性的证明"><a href="#算法正确性的证明" class="headerlink" title="算法正确性的证明"></a>算法正确性的证明</h3><p>分析结论的证明方法：</p>
<blockquote>
<ul>
<li>直接推导法</li>
<li>数学归纳法</li>
<li>反证法</li>
<li>反例法</li>
</ul>
</blockquote>
<h2 id="2-3-算法分析设计实例：分治法"><a href="#2-3-算法分析设计实例：分治法" class="headerlink" title="2.3 算法分析设计实例：分治法"></a>2.3 算法分析设计实例：分治法</h2><h3 id="分治法分析"><a href="#分治法分析" class="headerlink" title="分治法分析"></a>分治法分析</h3><p>归并排序中MERGE操作的正确性：P19</p>
<p>时间复杂度分析：</p>
<blockquote>
<p>当一个算法含有对其自身的递归调用时，其运行时间可以用如下一个递归方程来表示：<br>$$<br>T(n)=<br>\begin{cases}<br>\Theta(1) , &amp;n \le c \<br>aT(n/b) + D(n) + C(n) , &amp;other\ casese<br>\end{cases}<br>$$</p>
<p>其中：</p>
<ul>
<li>$T(n)$是规模为n的一个问题的运行时间</li>
<li>$D(n)$是将问题分解（Divide）成子问题所需的时间</li>
<li>$C(n)$是将子问题合并成原问题所需的时间</li>
<li>此时，算法将这个规模为n的问题分解成$a$个规模为$1/b$的子问题进行递归求解，所以运行时间为$aT(n/b)$</li>
<li>注意，有时当规模$n \le c$时，算法无需递归，直接求解只需常量时间，记为$\Theta(1)$</li>
</ul>
</blockquote>
<p>在归并排序中，上述$a=b=2$;分解问题为常量时间$\Theta(1)$；合并问题需要一个n的线性函数时间$\Theta(n)$<br>即：<br>$$<br>T(n)=<br>\begin{cases}<br>c , &amp;n = 1 \<br>2T(n/2) + cn , &amp;n &gt; 1<br>\end{cases}<br>$$</p>
<p>求解这个递归式时，我们需要画出它的递归树进行分析，此时我们发现，树的每一层执行时间都为cn，树高为lgn  </p>
<p>所以：<br>$$<br>T(n) = cnlgn+cn = \Theta(nlgn)<br>$$</p>
<h1 id="三、函数的增长"><a href="#三、函数的增长" class="headerlink" title="三、函数的增长"></a>三、函数的增长</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>对于足够大的输入规模，算法精确运行时间中的倍增常量和低阶项被输入规模本身刚到影响所支配</p>
<blockquote>
<p>此时，我们要研究算法的渐进效率；即在极限中，算法的运行时间如何随着输入规模的变大而增加</p>
</blockquote>
<h2 id="3-1-渐进记号"><a href="#3-1-渐进记号" class="headerlink" title="3.1 渐进记号"></a>3.1 渐进记号</h2><h3 id="渐近上界记号-O"><a href="#渐近上界记号-O" class="headerlink" title="渐近上界记号$O$"></a>渐近上界记号$O$</h3><p>定义：对于给定函数$g(n)$，$\Theta(g(n))$定义如下：<br>$$<br>O(g(n))=\lbrace f(n) | \exists c,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le f(n) \le cg(n) \rbrace<br>$$</p>
<blockquote>
<ul>
<li>此时，$f(n) \in O(g(n))$也可以表示成$f(n) = O(g(n))$</li>
<li>此时，我们称$g(n)$是$f(n)$的一个渐近上界</li>
<li>渐进上界用于描述算法最坏情况下的运行时间</li>
<li>紧确上界：最小的渐近上界</li>
</ul>
<p>渐近上界具有自反性、传递性,且满足加法法则和乘法法则</p>
</blockquote>
<p>非渐近紧确上界$o$:渐近上界除去紧确上界，定义如下<br>$$o(g(n))=\lbrace f(n) | \exists c,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le f(n) &lt; cg(n) \rbrace$$</p>
<blockquote>
<ul>
<li>此时可称$f(n)$渐近小于$g(n)$，当n足够大时，$f(n)$相比于$g(n)$来说变得微不足道，可以这样来证明：<br>$$\lim_{n \to \infty} \cfrac {f(n)}{g(n)} = 0$$</li>
<li>非渐近紧确上界具有传递性</li>
</ul>
</blockquote>
<h3 id="渐近下界记号-Omega"><a href="#渐近下界记号-Omega" class="headerlink" title="渐近下界记号$\Omega$"></a>渐近下界记号$\Omega$</h3><p>定义：对于给定函数$g(n)$，$\Omega(g(n))$定义如下：<br>$$<br>\Omega(g(n))=\lbrace f(n) | \exists c,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le cg(n) \le f(n) \rbrace<br>$$</p>
<blockquote>
<ul>
<li>此时，$f(n) \in \Omega(g(n))$也可以表示成$f(n) = \Omega(g(n))$</li>
<li>此时，我们称$g(n)$是$f(n)$的一个渐近下界</li>
<li>渐进下界用于描述算法最好情况下的运行时间</li>
<li>紧确下界：最大的渐近下界</li>
</ul>
<p>渐近下界具有自反性、传递性</p>
</blockquote>
<p>非渐近紧确下界$\omega$：渐近下界除去紧确下界，定义如下<br>$$<br>\omega(g(n))=\lbrace f(n) | \exists c,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le cg(n) &lt; f(n) \rbrace<br>$$</p>
<blockquote>
<ul>
<li>此时可称$f(n)$渐近大于$g(n)$，当n足够大时，$g(n)$相比于$f(n)$来说变得微不足道</li>
<li>非渐近紧确下界具有传递性</li>
</ul>
</blockquote>
<p>由定义可知，$O,\Omega$、$o,\omega$具有转置对称性（互为逆运算）</p>
<h3 id="渐近紧确界记号-Theta"><a href="#渐近紧确界记号-Theta" class="headerlink" title="渐近紧确界记号$\Theta$"></a>渐近紧确界记号$\Theta$</h3><p>定义：对于给定函数$g(n)$，$\Theta(g(n))$定义如下：<br>$$<br>\Theta(g(n))=\lbrace f(n) | \exists c_1,c_2,n_0 &gt; 0 \ 对 \ \forall n \ge n_0 \ 有 \ 0 \le c_1g(n) \le f(n) \le c_2g(n) \rbrace<br>$$</p>
<blockquote>
<ul>
<li>此时，$f(n) \in \Theta(g(n))$也可以表示成$f(n) = \Theta(g(n))$</li>
<li>此时，我们称$g(n)$是$f(n)$的一个渐近紧确界</li>
<li>$g(n)$是$f(n)$的一个渐近紧确界 等价于 $g(n)$是$f(n)$的一个渐近上界（紧确上界）且$g(n)$是$f(n)$的一个渐近下界（紧确下界）</li>
</ul>
<p>渐近紧确具有自反、传递、对称性</p>
</blockquote>
<h3 id="一些性质"><a href="#一些性质" class="headerlink" title="一些性质"></a>一些性质</h3><blockquote>
<ul>
<li>算法实际执行时间$f(n)$与执行世纪情况有关</li>
<li>分析所得限界函数$g(n)$是一个与机器无关的函数</li>
<li>一般地，对于任意多项式$p(n) = \sum_{i=0}^da_in^i,a_d &gt; 0$有$p(n)=\Theta(n^d)$</li>
<li>并非所有函数之间都是渐近可比较的，如$n$和$n^{1+sin(n)}$</li>
</ul>
</blockquote>
<p>当等式或不等式中出现渐近记号</p>
<blockquote>
<ul>
<li>等式中的渐近记号表示另一边的函数属于某一个函数集合</li>
<li>渐近记号可以替代公式中的一些无关紧要的细节，我们将其解释为匿名函数</li>
</ul>
</blockquote>
<h1 id="四、分治策略"><a href="#四、分治策略" class="headerlink" title="四、分治策略"></a>四、分治策略</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><h3 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h3><blockquote>
<ul>
<li>核心思想：分而治之，各个击破</li>
<li>递归结构：为解决一个给定的问题，算法一次或多次地调用自身</li>
<li>分治策略：将原问题划分为n个规模较小而结构相似的子问题进行求解</li>
<li>步骤：分解、解决、合并</li>
</ul>
</blockquote>
<h3 id="递归式求解方法"><a href="#递归式求解方法" class="headerlink" title="递归式求解方法"></a>递归式求解方法</h3><ul>
<li>代入法<blockquote>
<ul>
<li>猜测解的形式：换元、放缩等等，注意避免陷阱</li>
<li>用数学归纳法证明</li>
</ul>
</blockquote>
</li>
<li>递归树法（用于猜想递归式的解）<blockquote>
<ul>
<li>树中每一个节点都代表递归函数调用集合中一个子问题的代价；将树中每一层内的代价相加，再层层叠加得到总代价</li>
<li>考虑树的深度、每层节点数、（合并）节点的代价</li>
</ul>
</blockquote>
</li>
<li>主方法</li>
</ul>
<blockquote>
<p>主定理:考虑递归式$T(n)=aT(n/b)+f(n) ;\ (a\ge1,b&gt;1)$,有如下规则:</p>
<ol>
<li>若存在正常数$\epsilon&gt;0$有$f(n)=O(n^{log_b^{a-\epsilon}})$,则$T(n)=\Theta(n^{log_b^a})$</li>
<li>若$f(n)=\Theta(n^{log_b^a})$,则$T(n)=\Theta(n^{log_b^a}lgn)$</li>
<li>若存在正常数$\epsilon&gt;0$有$f(n)=\Omega(n^{log_b^{a+\epsilon}})$,且存在$c&lt;1$对任意足够大的$n$有$af(n/b)\le cf(n)$,则$T(n)=\Theta(f(n))$</li>
</ol>
</blockquote>
<h2 id="4-1-最大子数组问题"><a href="#4-1-最大子数组问题" class="headerlink" title="4.1 最大子数组问题"></a>4.1 最大子数组问题</h2><p>炒股问题：最大子数组问题</p>
<blockquote>
<p>即，已知数组A，需要寻找A的和最大的非空连续子数组</p>
</blockquote>
<p>策略：</p>
<blockquote>
<ol>
<li>递归寻找子数组A[low…high]的最大子数组</li>
<li>递归寻找子数组A[low…mid]和A[mid…high]的最大子数组</li>
<li>寻找跨越中点mid的最大子数组(线性时间)</li>
<li>比较最大子数组的大小,返回最大子数组</li>
</ol>
</blockquote>
<h2 id="4-2-矩阵乘法的Straseen算法"><a href="#4-2-矩阵乘法的Straseen算法" class="headerlink" title="4.2 矩阵乘法的Straseen算法"></a>4.2 矩阵乘法的Straseen算法</h2><p>朴素矩阵乘法(分治算法)：$T(n) = O(nˆ3)$</p>
<p>Strassen算法:$T(n) = O(n^{lg7})$</p>
<h3 id="算法策略"><a href="#算法策略" class="headerlink" title="算法策略"></a>算法策略</h3><blockquote>
<ol>
<li>递归计算A,B矩阵的乘积</li>
<li>若阶等于1,直接返回A,B的数值乘积</li>
<li>将A,B两个矩阵分块为$A_{11}…A_{22},B_{11}…B_{22}$几个 $\frac n2$阶矩阵</li>
<li>创建$S_1,…S_{10}$10个$\frac n2$阶矩阵,每个矩阵都为上述分块矩阵的和差($O(n^2)$)</li>
<li>创建$P_1,…P_7$7个$\frac n2$阶矩阵,每个矩阵都为上述3.4.中两矩阵的乘积; 递归计算这些矩阵</li>
<li>创建$C_{11}…C_{22}$4个$\frac n2$阶分块矩阵,每个矩阵都为上述P矩阵的和差($O(n^2)$)</li>
<li>返回结果矩阵C</li>
</ol>
</blockquote>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>Strassen算法通过加减,减少了一次矩阵乘法的运算,减少了算法运行的时间复杂度  </p>
<p>Strassen算法运行时间的递归式<br>$$<br>T(n)=<br>\begin{cases}<br>\Theta(1) , &amp;n = 1 \<br>7T(n/2) + \Theta(n^2) , &amp;n &gt; 1<br>\end{cases}<br>$$</p>
<h1 id="五、概率分析和随机算法"><a href="#五、概率分析和随机算法" class="headerlink" title="五、概率分析和随机算法"></a>五、概率分析和随机算法</h1><h2 id="5-1-雇佣问题"><a href="#5-1-雇佣问题" class="headerlink" title="5.1 雇佣问题"></a>5.1 雇佣问题</h2><p>雇佣问题：P65</p>
<blockquote>
<ul>
<li>输入：应聘者的水平数组</li>
<li>输出：雇佣/辞退助理的总费用</li>
</ul>
</blockquote>
<h2 id="概率分析"><a href="#概率分析" class="headerlink" title="概率分析"></a>概率分析</h2><p>概率分析：可用于时间分析或其他量的分析</p>
<blockquote>
<ul>
<li>需要已知或假定输入的概率分布，求得算法的运行时间（或其他的量）</li>
<li>此时求得的结果即期望</li>
<li>无法描述输入的分布情况时</li>
</ul>
</blockquote>
<h2 id="指示器随机变量"><a href="#指示器随机变量" class="headerlink" title="指示器随机变量"></a>指示器随机变量</h2><p>作用：建立概率和期望之间的联系</p>
<p>定义：$I(A) = 1 if A occurs else 0$</p>
<p>定理：期望的和等于和的期望</p>
<h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><p>RANDOM(a,b)函数能产生一个a到b之间的随机整数</p>
<ul>
<li><p>为每个元素赋予一个随机的优先级，然后根据优先级对数组进行排序</p>
</li>
<li><p>从前往后扫描数组，将该元素与后面的一个随机元素交换</p>
</li>
</ul>
<p>区别：</p>
<blockquote>
<ul>
<li>假设输入随机，概率分析求得平均运行时间</li>
<li>套上随机算法，概率分析求得运行时间期望</li>
</ul>
</blockquote>
<h1 id="六七八、排序算法"><a href="#六七八、排序算法" class="headerlink" title="六七八、排序算法"></a>六七八、排序算法</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><blockquote>
<ul>
<li>输入：n个数的序列</li>
<li>输出：序列的一个有序排列</li>
</ul>
</blockquote>
<p>稳定和不稳定：</p>
<blockquote>
<ul>
<li>稳定排序：关键字相同的记录按原顺序输出</li>
<li>不稳定排序：关键字记录的相对次序发生变化</li>
</ul>
</blockquote>
<p>排序算法比较：</p>
<blockquote>
<ul>
<li>规模较小：简单排序，插入、选择等</li>
<li>数组初态基本有序：简单排序，插入、冒泡等</li>
<li>规模较大：速度快点排序算法，快排等</li>
</ul>
</blockquote>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>操作：</p>
<blockquote>
<ul>
<li>MAX-HEAPIFY：维护堆，O(lgn)</li>
<li>BUILD-MAX-HEAP：构造堆，O(n)</li>
<li>HEAPSORT：堆排序，O(nlgn)</li>
</ul>
</blockquote>
<p>应用：优先级队列</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>原址排序，分而治之</p>
<p>分析：</p>
<blockquote>
<ul>
<li>最佳情况：$\Theta(nlogn)$</li>
<li>最坏情况：$\Theta(n^2)$</li>
<li>平均情况：$\Theta(n^2)$</li>
</ul>
</blockquote>
<p>引入随机化，避免最坏情况发生：</p>
<blockquote>
<ul>
<li>对输入序列进行随机排列</li>
<li>对PARTITION元素随机取样</li>
</ul>
</blockquote>
<h2 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序"></a>线性时间排序</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>要求：所有待排序元素均为整数，介于1到k之间（元素有重复）</p>
<blockquote>
<ul>
<li>时间复杂度$O(n+k)$</li>
<li>排序算法稳定，为基数排序做铺垫</li>
</ul>
</blockquote>
<p>C数组：长度为k，临时存储</p>
<blockquote>
<ul>
<li>每一次迭代时，C[i]表示余下数组中小于值i的元素的个数</li>
<li>该轮迭代遇到的值为i时，将其放在C[i]位，然后C[i]–</li>
</ul>
</blockquote>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">INPUT: A[<span class="number">1</span>,..n]; A[i] <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,..k)</span><br><span class="line">OUTPUT: B[<span class="number">1</span>,..n]</span><br><span class="line">COUNTING-SORT(A,B,k)</span><br><span class="line">	let C[<span class="number">0</span>,..k] be a new <span class="keyword">array</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">0</span> <span class="keyword">to</span> k <span class="comment">// 初始化数组（数组长度为k+1）</span></span><br><span class="line">    	C[i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> A.length <span class="comment">// 统计每个数值的个数</span></span><br><span class="line">    	C[A[i]] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> k <span class="comment">// 统计小于等于该数值的元素个数</span></span><br><span class="line">    	C[i] = C[i] + C[i-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i = A.length <span class="keyword">downto</span> <span class="number">1</span> <span class="comment">// 元素归位排序（从后往前扫描，稳定排序）</span></span><br><span class="line">    	B[C[A[i]]] = A[i]</span><br><span class="line">        C[A[i]] --</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>要求：待排序元素均为整数，至多d位</p>
<blockquote>
<ul>
<li>时间复杂度：$\Theta(d(n+k))$</li>
</ul>
</blockquote>
<p>过程：按有效位从低到高进行计数排序</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>要求：元素均匀分布在某个区间内</p>
<blockquote>
<ul>
<li>最差情况：$O(n^2)$</li>
<li>平均情况：$O(n)$</li>
</ul>
</blockquote>
<p>过程：</p>
<blockquote>
<ul>
<li>将区间划分成n个相同大小的子区间（桶）</li>
<li>将n个输入数分布到各个桶中去</li>
<li>对各桶中点元素进行排序，再依次将桶中元素列出</li>
</ul>
</blockquote>
<pre><code class="pascal">BUCKET-SORT(A)
    n = A.length
    <span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> n
        insert A[i] into B[floor(nA(i))]
    <span class="keyword">for</span> i = <span class="number">0</span> <span class="keyword">to</span> n-<span class="number">1</span>
        sort linklist B[i]
    concatenate the list B together <span class="keyword">in</span> order</code></pre>
<h1 id="九、中位数和顺序统计量"><a href="#九、中位数和顺序统计量" class="headerlink" title="九、中位数和顺序统计量"></a>九、中位数和顺序统计量</h1><p>最小值和最大值</p>
<p>期望为线性时间的选择算法</p>
<p>最坏情况为线性时间的选择算法</p>
<h1 id="十一、散列表"><a href="#十一、散列表" class="headerlink" title="十一、散列表"></a>十一、散列表</h1><p>何时用散列表</p>
<p>散列函数</p>
<p>冲突解决</p>
<blockquote>
<ul>
<li>链表法</li>
<li>开放寻址法</li>
</ul>
</blockquote>
<h1 id="十二、二叉搜索树"><a href="#十二、二叉搜索树" class="headerlink" title="十二、二叉搜索树"></a>十二、二叉搜索树</h1>]]></content>
      <categories>
        <category>学位课程</category>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统原理概论</title>
    <url>/2020/09/08/operating-system0/</url>
    <content><![CDATA[<p>李培峰：<a href="mailto:pfli_suda@126.com">pfli_suda@126.com</a>; 13606216291</p>
<p>课程内容和要求：</p>
<blockquote>
<ul>
<li>掌握操作系统的基本原理和组成结构</li>
<li>掌握基本概念和相关新概念、名词及术语</li>
<li>理解各组成部分之间的关系、结构和综合工作原理</li>
<li>分析、修改和设计操作系统的功能</li>
<li>使用基本的操作系统</li>
<li>学习内容：导论、进程管理、内存管理、存储管理；会穿插案例研究内容</li>
</ul>
</blockquote>
<p>广义上，操作系统是数据结构的衍生，涵盖数据结构、算法和编程</p>
<blockquote>
<ul>
<li>先修课程：汇编语言程序设计、c和java、计算机组成、数据结构、面向对象程序设计</li>
</ul>
</blockquote>
<p>参考书目：《现代操作系统Andrew.S》（偏向实例）、《操作系统精髓与设计原理》（更偏向实例系统）</p>
<p>一个视频<a href="https://vo.youku.com/v_show/id_XMTAwNTg5MzA0.html" target="_blank" rel="noopener">https://vo.youku.com/v_show/id_XMTAwNTg5MzA0.html</a></p>
<p>平时成绩20%、期中考试20%、期末考试60%</p>
<a id="more"></a>

<h2 id="主流操作系统介绍"><a href="#主流操作系统介绍" class="headerlink" title="主流操作系统介绍"></a>主流操作系统介绍</h2><p>主流PC操作系统：</p>
<blockquote>
<ul>
<li>1969 UNIX：C和汇编语言编写，世界上用途最广泛的操作系统</li>
<li>1974 CP/M：第一个微机操作系统</li>
<li>1981 MS－DOS：为用户上机操作和应用软件开发提供良好的用户外部环境</li>
<li>1984 MAC OS：第一款成功的含有图形化用户界面的操作系统</li>
<li>1985 Windows：最成功的个人微机操作系统</li>
<li>1991 LINUX：未来最有前途的操作系统之一</li>
</ul>
</blockquote>
<p>主流手机操作系统：</p>
<blockquote>
<ul>
<li>1999 SYMBIAN：实时的，多任务的纯32位操作系统；智能手机开创者</li>
<li>2007.11.5 ANDROID: 开放的操作系统</li>
<li>2007 IOS：优秀的封闭的操作系统</li>
<li>2008 BLACKBERRY：加密性更强，更安全；融入了办公商务功能</li>
<li>Windows Phone：从Pocket PC到Windows Mobile到Windows Phone;和Windows兼容性好</li>
</ul>
</blockquote>
<h1 id="一、导论"><a href="#一、导论" class="headerlink" title="一、导论"></a>一、导论</h1><h2 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h2><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><p>操作系统是沟通计算机硬件和系统程序与应用程序的桥梁</p>
<p>操作系统的目标：</p>
<blockquote>
<ul>
<li>核心目标：运行用户程序</li>
<li>面相用户：更方便使用计算机（方便性）</li>
<li>面相系统：更高效使用计算机（高效性）</li>
</ul>
</blockquote>
<h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h3><p>操作系统没有一个清晰的定义</p>
<blockquote>
<ul>
<li>极大化：当你预定一个操作系统时零售商所装的所有东西</li>
<li>极小化：内核是操作系统（一直运行在计算机上的程序）</li>
</ul>
</blockquote>
<p>内核Kernel：</p>
<blockquote>
<ul>
<li>内核是一个一直运行在计算机上的程序</li>
<li>内核是计算机运行必不可少的组成部分</li>
</ul>
</blockquote>
<h3 id="操作系统的硬件结构"><a href="#操作系统的硬件结构" class="headerlink" title="操作系统的硬件结构"></a>操作系统的硬件结构</h3><blockquote>
<ul>
<li>一个或多个CPU和内存</li>
<li>若干通过总线相连的设备控制器及其设备</li>
<li>总线</li>
<li>CPU和设备控制器可并行工作，并竞争内存</li>
</ul>
</blockquote>
<h2 id="1-2-多道程序设计和分时"><a href="#1-2-多道程序设计和分时" class="headerlink" title="1.2 多道程序设计和分时"></a>1.2 多道程序设计和分时</h2><h3 id="简单批处理系统"><a href="#简单批处理系统" class="headerlink" title="简单批处理系统"></a>简单批处理系统</h3><p>从无操作系统（EANIC）到简单批处理系统</p>
<blockquote>
<ul>
<li>批处理：一批无需人机交互的作业批量运行</li>
<li>简单批处理系统的核心是一个常驻监控程序，以作业为单位自动调度程序执行</li>
</ul>
</blockquote>
<p>过程：</p>
<blockquote>
<ul>
<li>程序员在小型机上编程</li>
<li>操作员将程序装入大型机运行</li>
<li>操作员将结果取出</li>
<li>程序员将结果在小型机上打印出来</li>
</ul>
</blockquote>
<p>简单批处理系统大大提高了计算机运行的效率，但没有充分利用cpu的IO并行性</p>
<h3 id="多道程序系统"><a href="#多道程序系统" class="headerlink" title="多道程序系统"></a>多道程序系统</h3><blockquote>
<ul>
<li>单用户同城不能总使得CPU和设备在所有时间内都忙碌</li>
<li>多道程序在内存中同时存在多道作业，在管理程序控制下相互穿插运行</li>
</ul>
</blockquote>
<p>策略：</p>
<blockquote>
<ul>
<li>通过作业调度(Job Scheduling)选中一个作业并运行</li>
<li>当该作业必须等待时 (如等待I/O), 切换到另一个作业运行</li>
</ul>
</blockquote>
<p>目的：提高CPU利用率，充分发挥计算机系统部件的并行性</p>
<p>并行和并发：</p>
<blockquote>
<ul>
<li>并行：两个或多个作业在同一时刻运行</li>
<li>并发：两个或多个作业在同一时间间隔内依次运行，同一时间点只有一个作业在处理机上运行</li>
</ul>
<blockquote>
<ul>
<li>并发在微观上相当于串行，在宏观上相当于并行</li>
<li>随着多核处理器的出现，并行和并发两个概念并不严格区分</li>
</ul>
</blockquote>
</blockquote>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>分时系统(或多任务)是多道程序设计的延伸</p>
<p>作业分类：</p>
<blockquote>
<ul>
<li>批处理作业：不需要人为干预</li>
<li>交互作业：需要人为干预；交互作业要求较高的响应时间，需要使用多道程序设计技术</li>
<li>响应时间：用户提交操作到操作系统执行操作之间的时间</li>
</ul>
</blockquote>
<p>时间片：</p>
<blockquote>
<ul>
<li>把一段CPU时间按照固定单位进行分割，每个分割得到的时间段称为一个时间片</li>
<li>每个任务依次轮流使用时间片</li>
</ul>
</blockquote>
<p>分时系统是一种联机的多用户交互式操作系统：</p>
<blockquote>
<ul>
<li>一般采用时间片轮转的方式使一台计算机为多个用户服务；在单位时间内，每个用户获得一个时间片运行</li>
<li>若某个作业在分配的时间片用完之前计算还未完成，该作业就暂时中断，等待下一轮；此时，处理机让给另一个作业使用。</li>
<li>这样能保证用于获得足够小的响应时间，并提供交互能力；此时，每个用户好像独占一台计算机</li>
</ul>
</blockquote>
<p>分时系统开销较大，需要一定的资源来管理和切换用户程序；一般来说，（时间）开销应当小于时间片的1/10</p>
<h2 id="1-3-操作系统的类型"><a href="#1-3-操作系统的类型" class="headerlink" title="1.3 操作系统的类型"></a>1.3 操作系统的类型</h2><blockquote>
<ul>
<li>大型机系统：前面所述的简单批处理系统、多道程序系统以及分时系统最早都应用于大型机上</li>
<li>桌面系统：应用于个人计算机PC上</li>
<li>手持（移动）系统：资源有限、具有导航等扩展功能</li>
<li>嵌入式系统：完全潜入受控器件内部；内核较小、专用性强、系统精简、高实时性</li>
<li>分布式系统：松耦合系统，通过网络操作系统；较难实现，目前多为数据分布式系统</li>
<li>多处理器系统：紧耦合系统，有多个紧密通信的处理器的系统，处理器之间共享内存</li>
<li>多核处理器系统：一个芯片多个核，现在一般不与多处理器系统区分<blockquote>
<ul>
<li>对称多处理器SMP：桌面PC处理器</li>
<li>非对称多处理器系统ASMP：高通骁龙</li>
</ul>
</blockquote>
</li>
<li>集群系统：面相超级计算，通过专用网络连接一群计算机，将它们虚拟化为一台有超强能力的计算机给用户使用</li>
<li>实时系统：实时性很高的系统（5G网络设备）</li>
</ul>
</blockquote>
<h2 id="1-4-操作系统的操作和功能"><a href="#1-4-操作系统的操作和功能" class="headerlink" title="1.4 操作系统的操作和功能"></a>1.4 操作系统的操作和功能</h2><h3 id="双模式"><a href="#双模式" class="headerlink" title="双模式"></a>双模式</h3><p>目的：防止程序崩溃或死循环造成整个操作系统崩溃</p>
<p>解决方式：双模式，即用户模式和内核模式</p>
<blockquote>
<ul>
<li>双模式需要CPU硬件支持</li>
<li>允许系统保护自身和其他系统部件</li>
<li>设置特权指令，这些指令只能在内核模式下运行；这些指令通常可能会造成系统崩溃</li>
<li>当用户程序需要使用特权指令特权指令时，可以进行系统调用（一种软件中断）</li>
</ul>
</blockquote>
<p>系统调用过程：</p>
<blockquote>
<ul>
<li>用户程序挂起，申请系统调用</li>
<li>CPU从用户模式切换到内核模式，执行特权指令</li>
<li>CPU从内核模式切换成用户模式，用户程序继续执行</li>
</ul>
</blockquote>
<h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>保护有I/O操作保护和内存保护</p>
<blockquote>
<ul>
<li>I/O保护防止用户程序执行非法I/O；内存保护防止内存的非法访问</li>
<li>IO保护策略：所有IO指令都是特权指令</li>
<li>内存保护策略：建立存储保护机制（硬件支持）</li>
</ul>
</blockquote>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>目的：使得操作系统能够随时获得CPU控制权，从而对系统进行管理</p>
<blockquote>
<ul>
<li>用户程序死循环会造成CPU控制权不能回到操作系统手中</li>
<li>用户程序不调用系统调用也会造成操作系统不能获得CPU控制器</li>
</ul>
</blockquote>
<p>解决方法：定时器</p>
<blockquote>
<ul>
<li>在用户程序运行一段时间后发生中断，CPU控制权返回到操作系统手中</li>
<li>定时器利用时钟和计数器实现，有固定时间和可变时间定时器</li>
</ul>
</blockquote>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>进程：运行中的程序</p>
<p>操作系统的核心目标：运行程序</p>
<p>CPU/进程管理：对CPU进行管理</p>
<blockquote>
<ul>
<li>创建和删除用户和系统进程</li>
<li>暂停和恢复进程</li>
<li>提供进程同步机制</li>
<li>提供进程通信机制</li>
<li>提供死锁处理机制</li>
</ul>
</blockquote>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>内存管理：提供内存的分配、回收、地址转换、共享和保护等功能，从而提高计算机运行效率</p>
<blockquote>
<ul>
<li>提高内存利用率</li>
<li>提高内存访问速度</li>
</ul>
</blockquote>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>解决信息在计算机中存储问题</p>
<p>以文件为单位，以目录为组织方式构建文件系统</p>
<p>对文件内容管理：</p>
<blockquote>
<ul>
<li>文件逻辑结构</li>
<li>文件物理结构</li>
</ul>
</blockquote>
<p>对文件目录管理：</p>
<blockquote>
<ul>
<li>文件检索方法</li>
<li>文件操作</li>
<li>空闲空间管理</li>
<li>存储设备管理</li>
</ul>
</blockquote>
<h3 id="I-O设备管理"><a href="#I-O设备管理" class="headerlink" title="I/O设备管理"></a>I/O设备管理</h3><p>管理种类繁多的各种I/O设备，解决计算机中信息的输入和输出问题</p>
<p>关键：设备无关性(独立性)</p>
<blockquote>
<ul>
<li>所有物理设备按照物理特性抽象为逻辑设备</li>
<li>应用程序针对逻辑设备编程</li>
<li>应用程序和物理设备无关</li>
</ul>
</blockquote>
<p>内容</p>
<blockquote>
<ul>
<li>设备管理</li>
<li>设备驱动</li>
</ul>
</blockquote>
<h1 id="二、操作系统结构"><a href="#二、操作系统结构" class="headerlink" title="二、操作系统结构"></a>二、操作系统结构</h1><h2 id="2-1-操作系统的服务和接口"><a href="#2-1-操作系统的服务和接口" class="headerlink" title="2.1 操作系统的服务和接口"></a>2.1 操作系统的服务和接口</h2><h3 id="操作系统服务"><a href="#操作系统服务" class="headerlink" title="操作系统服务"></a>操作系统服务</h3><p>操作系统以服务的形式向程序和用户提供环境执行程序</p>
<blockquote>
<ul>
<li>基本服务：如用户界面、程序执行、I/O操作等</li>
<li>增值服务：资源分配、统计、保护和安全等</li>
</ul>
</blockquote>
<p>操作系统服务形式：</p>
<blockquote>
<ul>
<li>系统调用</li>
<li>用户接口</li>
<li>系统程序</li>
</ul>
</blockquote>
<h3 id="操作系统程序接口：系统调用"><a href="#操作系统程序接口：系统调用" class="headerlink" title="操作系统程序接口：系统调用"></a>操作系统程序接口：系统调用</h3><p>系统调用是操作系统服务面相程序的接口</p>
<blockquote>
<ul>
<li>它们通常由高级语言编写</li>
<li>程序通过应用程序接口API访问</li>
</ul>
</blockquote>
<p>系统调用的参数传递：通过寄存器传递</p>
<p>常见APIs：</p>
<blockquote>
<ul>
<li>Windows中的Win32 API</li>
<li>POSIX系统中断POSIX API</li>
<li>Java虚拟机JVM的Java API</li>
</ul>
</blockquote>
<h3 id="操作系统用户界面"><a href="#操作系统用户界面" class="headerlink" title="操作系统用户界面"></a>操作系统用户界面</h3><p>命令行接口CLI：</p>
<blockquote>
<ul>
<li>字符模式</li>
</ul>
</blockquote>
<p>图形化接口GUI：</p>
<blockquote>
<ul>
<li>用户界面友好的桌面接口</li>
<li>现在还有触摸屏GUI</li>
</ul>
</blockquote>
<p>未来人机接口：</p>
<blockquote>
<ul>
<li>语音操控</li>
<li>体感操控</li>
<li>…</li>
</ul>
</blockquote>
<h3 id="系统程序"><a href="#系统程序" class="headerlink" title="系统程序"></a>系统程序</h3><p>用于管理、维护操作系统</p>
<p>为用户使用操作系统服务</p>
<p>功能：</p>
<blockquote>
<ul>
<li>文件管理</li>
<li>状态信息</li>
<li>文件处理</li>
<li>程序语言支持</li>
<li>程序装入和执行</li>
<li>通信</li>
</ul>
</blockquote>
<h2 id="2-2-操作系统的结构"><a href="#2-2-操作系统的结构" class="headerlink" title="2.2 操作系统的结构"></a>2.2 操作系统的结构</h2><h3 id="简单结构（无结构）"><a href="#简单结构（无结构）" class="headerlink" title="简单结构（无结构）"></a>简单结构（无结构）</h3><blockquote>
<ul>
<li>规模小、简单、功能有限</li>
<li>混乱、不易维护和更新、不适合大规模开发</li>
</ul>
</blockquote>
<p>MS-DOS：不划分模块</p>
<p>早期UNIX：分为系统程序和内核</p>
<h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>操作系统划分为若干层</p>
<blockquote>
<ul>
<li>在低层上构建高层</li>
<li>底层（0层）为硬件</li>
<li>最高层（N层）为用户层</li>
<li>每层只使用低层次的功能和服务</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<p>简化系统设计和实现，便于调试和升级系统</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>层定义困难</li>
<li>效率差</li>
</ul>
</blockquote>
<p>例子：WindowsNT，iOS</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>问题：内核越来越大，越来越难管理</p>
<p>内核微型化：核内移出尽可能多功能到用户空间</p>
<p>好处:</p>
<blockquote>
<ul>
<li>便于扩充微内核</li>
<li>便于移植操作系统到新架构系统上</li>
<li>更稳定 (更少的代码运行在核心态)</li>
<li>更安全</li>
</ul>
</blockquote>
<p>坏处:</p>
<blockquote>
<ul>
<li>用户空间和内核空间通信的系统开销增加</li>
<li>解决方法：提出消息传递机制</li>
</ul>
</blockquote>
<h3 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><p>大部分现代操作系统采用模块结构</p>
<blockquote>
<ul>
<li>使用面向对象方法</li>
<li>每个核心部件分开</li>
<li>每个与其他模块的会话被称为接口</li>
<li>每个模块在需要时被加载到内核</li>
</ul>
</blockquote>
<p>总体而言，类似于分层方法，但更灵活</p>
<blockquote>
<ul>
<li>任两个模块之间都能相互调用</li>
<li>层次结构只能相邻两层之间调用</li>
</ul>
</blockquote>
<p>当然，现代操作系统不是单一结构的，它会采取多种混合结构来获取性能、安全、使用等方面的需求（Mac OS X）</p>
<h2 id="2-3-虚拟机"><a href="#2-3-虚拟机" class="headerlink" title="2.3 虚拟机"></a>2.3 虚拟机</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>虚拟机：一种通过软件模拟实现，具有完整硬件系统功能，并运行在一个完全隔离环境中的完整计算机系统</p>
<blockquote>
<ul>
<li>物理计算机资源共享以创建虚拟机</li>
<li>每个虚拟机同其他虚拟机隔离</li>
<li>由于需要对物理机器进行精确复制，虚拟机实现困难</li>
<li>上个世纪60年代，虚拟机用于大型机（IBM VM系统）</li>
</ul>
</blockquote>
<p>分类：</p>
<blockquote>
<ul>
<li>高级语言虚拟机</li>
<li>工作站虚拟机</li>
<li>服务器虚拟机</li>
</ul>
</blockquote>
<h3 id="JAVA虚拟机"><a href="#JAVA虚拟机" class="headerlink" title="JAVA虚拟机"></a>JAVA虚拟机</h3><p>JVM：JAVA语言的解释器</p>
<blockquote>
<ul>
<li>可运行Java代码的假想计算机</li>
<li>只要根据JVM规格将解释器移植到特定的操作系统上，就能运行经过编译的任何Java代码</li>
<li>特点：平台无关性，是运行在操作系统上的虚拟机</li>
</ul>
</blockquote>
<h3 id="工作站虚拟机"><a href="#工作站虚拟机" class="headerlink" title="工作站虚拟机"></a>工作站虚拟机</h3><p>工作站虚拟机：操作系统上的虚拟机</p>
<blockquote>
<ul>
<li>宿主操作系统（Host OS）：安装在硬件上的OS</li>
<li>客户操作系统（Guest OS）安装在操作系统上的操作系统</li>
<li>工作站虚拟机安装在宿主操作系统上，在工作站虚拟机中可以安装客户操作系统</li>
</ul>
</blockquote>
<p>好处：</p>
<blockquote>
<ul>
<li>同时在一个计算机上使用多个操作系统</li>
<li>一个宿主操作系统，若干个客户操作系统</li>
</ul>
</blockquote>
<h3 id="服务器虚拟机"><a href="#服务器虚拟机" class="headerlink" title="服务器虚拟机"></a>服务器虚拟机</h3><p>服务器虚拟化：将服务器物理资源抽象成逻辑资源，让一台服务器变成几台甚至上百台相互隔离的虚拟服务器</p>
<p>常用模式：</p>
<blockquote>
<ul>
<li>一虚多：一台服务器虚拟成多台服务器虚拟机</li>
<li>多虚一：多个独立物理服务器虚拟为一个服务器虚拟机</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>安全性好</li>
<li>资源共享</li>
<li>可扩展性好</li>
<li>便于隔离</li>
</ul>
</blockquote>
<p>和工作站虚拟机区别：没有宿主操作系统</p>
<h3 id="连接模式"><a href="#连接模式" class="headerlink" title="连接模式"></a>连接模式</h3><blockquote>
<ul>
<li>软件模式：远程桌面、ssh等</li>
<li>硬件模式：虚拟机终端（硬件）等</li>
</ul>
</blockquote>
<h1 id="三、进程"><a href="#三、进程" class="headerlink" title="三、进程"></a>三、进程</h1><h2 id="3-1-进程概念"><a href="#3-1-进程概念" class="headerlink" title="3.1 进程概念"></a>3.1 进程概念</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程：</p>
<blockquote>
<ul>
<li>执行中的程序；进程的执行必须以顺序方式执行</li>
<li>一个程序在一个数据集上的一次运行</li>
</ul>
</blockquote>
<p>进程、作业和任务：</p>
<blockquote>
<ul>
<li>作业：狭义上认为是被组装成一个整体运行的一组计算步骤</li>
<li>任务：狭义上认为进程或线程</li>
</ul>
</blockquote>
<h3 id="内存中的进程"><a href="#内存中的进程" class="headerlink" title="内存中的进程"></a>内存中的进程</h3><p>进程的组成部分：</p>
<blockquote>
<ul>
<li>程序代码</li>
<li>当前活动（以下举例）</li>
<li>程序计数器</li>
<li>堆栈：存放函数参数、临时变量等</li>
<li>数据：全局变量</li>
<li>堆：动态内存分配</li>
</ul>
</blockquote>
<h3 id="进程和程序到关系"><a href="#进程和程序到关系" class="headerlink" title="进程和程序到关系"></a>进程和程序到关系</h3><blockquote>
<ul>
<li>进程是程序的一个实例，是程序的一次执行</li>
<li>一个程序可对应一个或多个进程，同样一个进程可对应一个或多个程序</li>
<li>程序是进程的代码部分</li>
<li>进程是活动实体，程序静止（被动）实体</li>
<li>进程在内存，程序在外存</li>
</ul>
</blockquote>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程执行时，有如下几个状态：</p>
<blockquote>
<ul>
<li>新建态：在创建进程 </li>
<li>运行态：指令在执行</li>
<li>等待态：进程等待某些事件发生 </li>
<li>就绪：进程等待分配处理器 </li>
<li>终止：进程执行完毕</li>
</ul>
</blockquote>
<p>进程状态的转换：<br><img src="/2020/09/08/operating-system0/process0.jpg" alt="Process"></p>
<blockquote>
<ul>
<li>新建-就绪：操作系统能够同时执行的进程是有限的，新进程需要被允许才能就绪</li>
<li>就绪-运行：通过调度程序控制</li>
<li>运行-就绪：中断发生，如分时系统中切换任务；而多道程序中这个状态转换通常是程序自愿发生的</li>
<li>运行-等待：进程需要等待某个操作（如按下任意键继续）才能继续执行</li>
<li>等待-就绪：事件发生，进程可以（在调度程序的控制下）继续执行了（就绪）<br>注意区分等待和就绪两种状态</li>
</ul>
</blockquote>
<h3 id="进程控制快PCB"><a href="#进程控制快PCB" class="headerlink" title="进程控制快PCB"></a>进程控制快PCB</h3><p>PCB包含同进程有关的信息，包括：</p>
<blockquote>
<ul>
<li>进程状态</li>
<li>程序计数器</li>
<li>CPU寄存器</li>
<li>CPU调度信息</li>
<li>内存管理信息</li>
<li>计账信息</li>
<li>I/O状态信息</li>
</ul>
</blockquote>
<h3 id="CPU在进程之间切换"><a href="#CPU在进程之间切换" class="headerlink" title="CPU在进程之间切换"></a>CPU在进程之间切换</h3><p>进程的并发执行需要PCB保存和恢复现场</p>
<h2 id="3-2-进程操作"><a href="#3-2-进程操作" class="headerlink" title="3.2 进程操作"></a>3.2 进程操作</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>父进程创建子进程，如此轮流创建进程下去，构成一棵进程树</p>
<p>父子进程之间的关系：</p>
<ul>
<li><p>资源共享：</p>
<blockquote>
<ul>
<li>父进程子进程共享所有的资源：并行计算</li>
<li>子进程共享父进程资源的子集（部分共享）：windows创建的进程</li>
<li>父进程和子进程无资源共享</li>
</ul>
</blockquote>
</li>
<li><p>执行：</p>
<blockquote>
<ul>
<li>父进程和子进程并发执行，两者不相干（操作系统默认模式）</li>
<li>父进程等待，直到子进程终止（需要程序员控制）</li>
</ul>
</blockquote>
</li>
<li><p>地址空间：</p>
<blockquote>
<ul>
<li>子女复制双亲</li>
<li>子女执行一个外部程序</li>
</ul>
</blockquote>
</li>
</ul>
<p>进程的创建是一个原子操作：</p>
<blockquote>
<ul>
<li>执行这种原子操作的语句也被称为原语</li>
<li>这是一个不会被打断的操作</li>
<li>一旦开始就一直运行到结束，中间不会有任何上下文切换</li>
<li>该特性需要硬件支持：总线加锁（x86）</li>
</ul>
</blockquote>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><ul>
<li><p>进程执行最后一项并退出</p>
<blockquote>
<ul>
<li>子进程通过wait向父进程输出数据，处于终止状态</li>
<li>父进程处理子进程的终止状态（区分需要回收的资源等）</li>
<li>操作系统回收进程的资源</li>
</ul>
</blockquote>
</li>
<li><p>父进程终止子进程执行</p>
<blockquote>
<ul>
<li>子进程超量分配资源</li>
<li>赋予子进程的任务不再需要</li>
<li>父进程结束导致的级联操作；当然，父进程结束后子进程也可以链到更上级进程下面</li>
<li>父进程可以通过wait()系统调用等待子进程结束</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="进程调用举例"><a href="#进程调用举例" class="headerlink" title="进程调用举例"></a>进程调用举例</h3><h4 id="Linux的fork"><a href="#Linux的fork" class="headerlink" title="Linux的fork()"></a>Linux的fork()</h4><p>策略：</p>
<blockquote>
<ul>
<li>fork()的子进程和父进程几乎一模一样</li>
<li>进程创建时两者代码和数据空间一样，但pid不一样</li>
<li>当子进程修改数据空间时，将该空间拷贝并进行修改（写时复制策略）</li>
</ul>
</blockquote>
<p>区分父子进程：</p>
<blockquote>
<ul>
<li>父进程调用fork()的返回值是子进程的ID（并创建子进程）</li>
<li>子进程调用fork()的返回值是-1（不会创建其他进程）</li>
<li>可以在同一个代码中插入fork()值的判断来使父子进程运行不同的代码</li>
</ul>
</blockquote>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>exec用于执行其他程序，子进程和父进程不共享任何资源</p>
<h4 id="创建进程的模式"><a href="#创建进程的模式" class="headerlink" title="创建进程的模式"></a>创建进程的模式</h4><blockquote>
<ul>
<li>先用fork创建一个镜像</li>
<li>执行exec覆盖这个镜像</li>
</ul>
</blockquote>
<h2 id="3-3-进程间的通信"><a href="#3-3-进程间的通信" class="headerlink" title="3.3 进程间的通信"></a>3.3 进程间的通信</h2><h3 id="进程间的关系"><a href="#进程间的关系" class="headerlink" title="进程间的关系"></a>进程间的关系</h3><p>独立进程：进程之间的执行不会互相影响<br>协同进程：进程间的执行可能会相互影响</p>
<p>目前，大多数进程都是协同进程</p>
<p>协同进程优点：</p>
<blockquote>
<ul>
<li>信息共享</li>
<li>加速运算</li>
<li>模块化</li>
<li>方便：单个用户也可以执行多个任务</li>
</ul>
</blockquote>
<p>进程间的通信方式：</p>
<blockquote>
<ul>
<li>共享内存</li>
<li>消息传递</li>
</ul>
</blockquote>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>生产者-消费者模型：</p>
<blockquote>
<ul>
<li>生产者进程生产供消费者消费的信息</li>
<li>无界缓冲(Unbounded-buffer)没有对缓冲区大小的限制</li>
<li>有界缓冲(Bounded-buffer)对缓冲区大小作了限定</li>
</ul>
</blockquote>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>消息传递是通信模式中的常用机制</p>
<blockquote>
<ul>
<li>适合用于传递少量的信息</li>
<li>远程通信无法采用共享内存</li>
</ul>
</blockquote>
<p>直接通信：两个进程之间建立一个直接通信的链路</p>
<blockquote>
<ul>
<li>每个链路只有两个进程相关</li>
<li>信息发送必须明确指定接收者</li>
<li>共享内存实际上也是一种直接通信</li>
</ul>
</blockquote>
<p>间接通信：消息被导向至信箱并从信箱接受</p>
<blockquote>
<ul>
<li>每个信箱有一个唯一的id</li>
<li>仅当共享一个信箱时进程才能通信</li>
<li>信息的发送者可以无需指定接收者（广播）</li>
<li>其他有第三方参与（如剪贴板）的通信也是一种简介通信</li>
</ul>
</blockquote>
<p>消息传递的同步性：</p>
<blockquote>
<ul>
<li>阻塞发送</li>
<li>阻塞接收</li>
<li>非阻塞发送</li>
<li>非阻塞接收：接收者收到一个有效消息或无效消息</li>
<li>一般默认非阻塞发送和阻塞接收</li>
</ul>
</blockquote>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="Windows进程通信"><a href="#Windows进程通信" class="headerlink" title="Windows进程通信"></a>Windows进程通信</h4><ul>
<li>网络通信：命名管道等</li>
<li>本地通信：剪贴板等</li>
</ul>
<p>Windows消息传递的主体是窗口</p>
<h4 id="Linux进程通信"><a href="#Linux进程通信" class="headerlink" title="Linux进程通信"></a>Linux进程通信</h4><ul>
<li>管道</li>
<li>信号</li>
<li>消息</li>
<li>…</li>
</ul>
<h1 id="四、线程"><a href="#四、线程" class="headerlink" title="四、线程"></a>四、线程</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><p>线程的合理性：</p>
<blockquote>
<ul>
<li>性能要求：进程是重量级的，进程操作开销大</li>
<li>应用要求：进程内也有代码并行执行的需求</li>
<li>硬件要求：多核处理器已经是主流硬件，能加速进程的运行</li>
</ul>
</blockquote>
<p>线程：</p>
<blockquote>
<ul>
<li>线程是一个轻量级的进程，切换代价小</li>
<li>进程内的一个代码片段可以被创建为一个线程</li>
<li>线程状态：就绪、运行、等待等</li>
<li>进程依旧是资源分配的基本单位；线程撤销不会影响进程，但进程撤销会导致所有线程的撤销</li>
<li>线程自己不拥有完整的系统资源，需要通过进程来申请资源</li>
</ul>
</blockquote>
<h2 id="4-2-线程结构"><a href="#4-2-线程结构" class="headerlink" title="4.2 线程结构"></a>4.2 线程结构</h2><p>线程控制块TCB</p>
<blockquote>
<ul>
<li>线程ID</li>
<li>线程计数器PC</li>
<li>寄存器集合</li>
<li>栈空间</li>
</ul>
</blockquote>
<h2 id="4-3-单线程和多线程"><a href="#4-3-单线程和多线程" class="headerlink" title="4.3 单线程和多线程"></a>4.3 单线程和多线程</h2><p>单线程：</p>
<blockquote>
<ul>
<li>单线程：一个进程只有一个线程</li>
<li>多线程：一个进程可以有多个线程</li>
</ul>
</blockquote>
<p>线程优点：</p>
<blockquote>
<ul>
<li>创建、上下文切换开销小，速度快</li>
<li>资源共享</li>
<li>充分利用硬件资源</li>
</ul>
</blockquote>
<h2 id="4-4-多线程模型"><a href="#4-4-多线程模型" class="headerlink" title="4.4 多线程模型"></a>4.4 多线程模型</h2><p>用户线程：</p>
<blockquote>
<ul>
<li>用户线程为用户自己管理的线程</li>
<li>用户线程的创建和调度在用户空间中，无需内核干预</li>
<li>应用于只支持进程的操作系统</li>
</ul>
</blockquote>
<p>内核线程</p>
<blockquote>
<ul>
<li>内核线程为由内核管理的线程</li>
<li>由内核完成线程调度、创建和撤销</li>
</ul>
</blockquote>
<h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>映射多个用户线程到一个内核线程：</p>
<blockquote>
<ul>
<li>内核中实际上只有进程，内核能够看到的只有一个进程</li>
<li>此时多线程不能运行在多个处理器上（因此该模型目前不常使用）</li>
<li>用户线程由进程自己管理</li>
</ul>
</blockquote>
<h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><p>每个用户线程都映射到内核线程中：</p>
<blockquote>
<ul>
<li>用于支持线程的操作系统</li>
<li>操作系统来管理这些线程</li>
<li>可以并行运行在多个处理器上，并发性好</li>
<li>内核开销大</li>
</ul>
</blockquote>
<h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p>多个用户线程映射为相等或更小数码的内核线程：</p>
<blockquote>
<ul>
<li>兼顾并发性和效率（实际上多对多指的是多个用户线程运行在多个核上）</li>
<li>用户线程和内核线程之间需要添加一个映射层，增加了系统复杂度（该模型不常使用）</li>
</ul>
</blockquote>
<p>两级模型：将多对一模型和一对一模型混合使用</p>
<h3 id="4-4-线程库"><a href="#4-4-线程库" class="headerlink" title="4.4 线程库"></a>4.4 线程库</h3><p>用户库和内核库</p>
<p>线程库：为程序员提供创建和管理线程的API</p>
<blockquote>
<ul>
<li>无内和支持线程库：java线程库</li>
<li>内核支持线程库：Windows线程库</li>
</ul>
</blockquote>
<h3 id="4-5-隐式多线程"><a href="#4-5-隐式多线程" class="headerlink" title="4.5 隐式多线程"></a>4.5 隐式多线程</h3><p>线程池：</p>
<blockquote>
<ul>
<li>从池中创建一批线程，任务来临时，从线程池中取出线程进行处理，处理完后在将线程放回池中</li>
<li>若池中没有可以使用等线程，则任务进入等待状态</li>
</ul>
</blockquote>
<h3 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h3><p>利用Pthreads线程库（第三方线程库）一种用户线程库</p>
<p>Pthreads：</p>
<blockquote>
<ul>
<li>pthread_exit()结束线程运行</li>
<li>pthread_cancel(thread)利用消息终止其他线程</li>
</ul>
</blockquote>
<h1 id="五、进程调度"><a href="#五、进程调度" class="headerlink" title="五、进程调度"></a>五、进程调度</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>调度分类：</p>
<blockquote>
<ul>
<li>长程调度（作业/高级调度）：道（内存中可以同时运行的最大进程数）不够时，选择哪些进程可以新建进入等待状态</li>
<li>中程调度：严格来说属于内存管理，负责将内存中长时间不运行的进程调出到外存中（内存交换）</li>
<li>短程调度（CPU/低级调度）：CPU空闲时，从就绪队列中选择一个进程让其运行</li>
</ul>
</blockquote>
<p>区别：</p>
<blockquote>
<ul>
<li>长程调度在每个进程的生命周期中只出现一次，频率低、速度慢；有些操作系统没有长程调度</li>
<li>短程调度可能出现成千上万次，开销小；操作系统必须有短程调度，一般进程调度指短程调度</li>
</ul>
</blockquote>
<p>进程调度队列：</p>
<blockquote>
<ul>
<li>作业队列：系统中所有进程的队列集合</li>
<li>就绪队列：在主内存中就绪请等待执行的所有进程的队列集合</li>
<li>设备队列：等待某一IO设备的进程队列集合</li>
</ul>
</blockquote>
<p>调度过程：</p>
<blockquote>
<ul>
<li>调度程序：选择进程来执行</li>
<li>分派程序：做进程的上下文切换</li>
</ul>
</blockquote>
<p>调度方式：</p>
<blockquote>
<ul>
<li>非抢占式调度：系统不能抢占已分配进程的CPU（批处理）</li>
<li>抢占式调度：调度程序可以根据某种原则暂停某个正在执行的进程</li>
</ul>
</blockquote>
<p>调度时机：</p>
<blockquote>
<ul>
<li>进程等待（非抢占）</li>
<li>进程就绪（抢占）</li>
<li>进程终止运行（非抢占）</li>
</ul>
</blockquote>
<h2 id="5-2-调度准则"><a href="#5-2-调度准则" class="headerlink" title="5.2 调度准则"></a>5.2 调度准则</h2><p>基本指标：</p>
<blockquote>
<ul>
<li>CPU利用率：固定时间CPU运行时间的比例</li>
<li>吞吐量：单位时间运行完的进程数</li>
<li>周转时间：进程从提交到运行结束需要的全部时间；</li>
<li>等待时间：进程等待调度（不在运行）的时间片总和</li>
<li>响应时间：从进程提出请求到第一次响应（运行）的时间</li>
<li>周转时间=运行时间+等待时间；带权周转时间=周转时间/运行时间</li>
</ul>
</blockquote>
<h2 id="5-3-调度算法"><a href="#5-3-调度算法" class="headerlink" title="5.3 调度算法"></a>5.3 调度算法</h2><h3 id="FCFS先来先服务"><a href="#FCFS先来先服务" class="headerlink" title="FCFS先来先服务"></a>FCFS先来先服务</h3><p>First-Come First-Served：非抢占式</p>
<blockquote>
<ul>
<li>策略：按照进程请求CPU的先后顺序来使用CPU</li>
<li>依据：进入就绪队列的时间</li>
<li>方法：选取队头进程执行</li>
</ul>
</blockquote>
<p>优点：策略简单，理解容易</p>
<p>缺点：平均等待时间往往很长</p>
<h3 id="SJF短作业优先"><a href="#SJF短作业优先" class="headerlink" title="SJF短作业优先"></a>SJF短作业优先</h3><p>Shortest-Job-First：</p>
<blockquote>
<ul>
<li>策略：关联到每个进程下次运行的CPU脉冲长度，调度最短的进程</li>
<li>依据：每个进程下次运行的CPU脉冲长度</li>
<li>方法：选择最短的进程运行</li>
</ul>
</blockquote>
<p>SJF有抢占式调度和非抢占式调度两种：新来的进程比当前执行的进程短</p>
<p>抢占式SJF适合交互式系统，切换开销较大，但会出现饥饿现象</p>
<blockquote>
<p>饥饿：长作业一直得不到运行</p>
</blockquote>
<p>问题：无法准确得到程序将要运行的时间，算法难以实现</p>
<blockquote>
<ul>
<li>使用过往CPU运行时间的指数平均来预测下一次CPU运行时间</li>
</ul>
</blockquote>
<h3 id="PS优先级调度"><a href="#PS优先级调度" class="headerlink" title="PS优先级调度"></a>PS优先级调度</h3><p>优先级高的进程先运行</p>
<p>PS有抢占式调度和非抢占式调度</p>
<p>抢占式PS会出现饥饿问题</p>
<blockquote>
<p>解决方案：老化，即逐渐增加等待时间长的进程优先级</p>
</blockquote>
<p>优先级可以自定义</p>
<h3 id="RR时间片轮转算法"><a href="#RR时间片轮转算法" class="headerlink" title="RR时间片轮转算法"></a>RR时间片轮转算法</h3><p>Rount-Robin：</p>
<blockquote>
<ul>
<li>原理：将一段时间分割成若干个小时间片，每个需要运行的进程获得一个碎片执行</li>
<li>策略：每个进程获得不超过p的时间来运行，执行完或时间用完时切换下一个进程</li>
<li>若进程在时间片结束之前运行完，立刻运行下一个进程</li>
</ul>
</blockquote>
<h3 id="MLQ多级队列调度"><a href="#MLQ多级队列调度" class="headerlink" title="MLQ多级队列调度"></a>MLQ多级队列调度</h3><p>对于不同类型的进程需要不同的调度策略：</p>
<blockquote>
<ul>
<li>交互进程需要短的响应时间</li>
<li>批处理进程需要短的等待时间</li>
</ul>
</blockquote>
<p>多级队列调度：系统中存在多个就绪队列，每个队列有自己的调度算法</p>
<blockquote>
<ul>
<li>队列个数</li>
<li>各队列的调度算法</li>
<li>决定新进程进入哪个队列</li>
</ul>
</blockquote>
<p>例子：前台RR，后台FCFS</p>
<p>优先调度哪个队列中的进程：</p>
<blockquote>
<ul>
<li>固定优先级：前台运行完再运行后台，有可能产生饥饿</li>
<li>给定时间片</li>
</ul>
</blockquote>
<h3 id="MLFQ多级反馈队列调度"><a href="#MLFQ多级反馈队列调度" class="headerlink" title="MLFQ多级反馈队列调度"></a>MLFQ多级反馈队列调度</h3><p>多级反馈队列：进程能在不同队列中移动</p>
<blockquote>
<ul>
<li>多级队列调度算法</li>
<li>进程升级的方法</li>
<li>进程降级的方法</li>
</ul>
</blockquote>
<h2 id="5-4-多处理器调度"><a href="#5-4-多处理器调度" class="headerlink" title="5.4 多处理器调度"></a>5.4 多处理器调度</h2><blockquote>
<ul>
<li>SMP：每个处理器决定自己的调度方案</li>
<li>ASMP：仅一个处理器能处理系统数据结</li>
</ul>
</blockquote>
<p>多处理器调度算法和单处理器相似</p>
<blockquote>
<ul>
<li>负载平衡：将任务平均分配给各个处理器</li>
<li>亲和性：进程在某个CPU上运行尽量长的时间而不被迁移</li>
</ul>
</blockquote>
<h3 id="SQMP单队列多核调度算法"><a href="#SQMP单队列多核调度算法" class="headerlink" title="SQMP单队列多核调度算法"></a>SQMP单队列多核调度算法</h3><p>系统有一个就绪队列，当任意一个CPU空闲时，就从就绪队列中选择一个进程到该CPU上运行</p>
<blockquote>
<ul>
<li>实现简单，负载均衡</li>
<li>不具有亲和性</li>
<li>加锁问题</li>
</ul>
</blockquote>
<h4 id="MQMP多队列调度方法"><a href="#MQMP多队列调度方法" class="headerlink" title="MQMP多队列调度方法"></a>MQMP多队列调度方法</h4><p>系统有多个就绪队列，一般每个CPU一个。每个就绪队列相对独立，有自己的调度算法</p>
<blockquote>
<ul>
<li>亲和性好，不需要加锁</li>
<li>负载不均衡，策略是偷进程</li>
</ul>
</blockquote>
<h1 id="六、同步"><a href="#六、同步" class="headerlink" title="六、同步"></a>六、同步</h1><h2 id="竞争条件和临界区"><a href="#竞争条件和临界区" class="headerlink" title="竞争条件和临界区"></a>竞争条件和临界区</h2><p>多个进程并发或并行执行会导致数据不一致：</p>
<blockquote>
<ul>
<li>不可再现性：同一进程在同一批数据上多次运行结果不一样</li>
<li>原因：进程的并发或并行执行（并且之间有协作）</li>
<li>解决方案：同步（互斥）机制</li>
</ul>
</blockquote>
<p>原子操作：</p>
<blockquote>
<p>一个在执行期间不能被中断的操作</p>
</blockquote>
<p>竞争条件：</p>
<blockquote>
<ul>
<li>多个进程并发访问同一共享数据</li>
<li>共享数据的最终结果取决于最后操作的进程（写覆盖）</li>
</ul>
</blockquote>
<h3 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h3><p>同步：</p>
<blockquote>
<ul>
<li>协调进程的执行次序，使并发进程间能有效地共享资源和相互合作，保证数据一致性</li>
<li>同步用于协调执行次序</li>
</ul>
</blockquote>
<p>互斥：</p>
<blockquote>
<ul>
<li>进程排他性地运行某段代码，任何时候只有一个进程能够运行</li>
<li>互斥可以访问独占资源</li>
</ul>
</blockquote>
<p>互斥是同步的一种特例</p>
<h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>临界资源是一次只允许一个进程使用的资源</p>
<blockquote>
<ul>
<li>又称互斥资源、独占资源或共享变量</li>
<li>反义词：共享资源，一次允许多个进程使用等资源</li>
</ul>
</blockquote>
<p>例子：输入机、打印机、磁带机等</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区是涉及临界资源的代码段</p>
<blockquote>
<ul>
<li>临界区是代码片段，是进程内的代码</li>
<li>每个进程有一个或多个临界区</li>
<li>临界区的设置方法由程序员来确定</li>
</ul>
</blockquote>
<p>对临界资源的互斥访问可以保证进程互斥地进入关联到临界区</p>
<p>临界区使用准则：</p>
<blockquote>
<ul>
<li>互斥：有相同临界资源的临界区需要互斥；无相同临界资源的临界区不需要互斥</li>
<li>有空让进：临界区内无进程执行时，不能无限期延长下一个要进入临界区进程的等待时间</li>
<li>有限等待：每个进程进入临界区前的等待时间必须有限</li>
</ul>
</blockquote>
<p>访问临界区的过程：</p>
<blockquote>
<ul>
<li>进入区：互斥准则</li>
<li>临界区：有限等待准则（临界区不能过大）</li>
<li>退出区：有空让进准则</li>
<li>其他区</li>
</ul>
</blockquote>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>早期同步和互斥采用硬件解决方案，设计起来十分复杂</p>
<p>信号量是同步和互斥的一种软件解决方案</p>
<blockquote>
<ul>
<li>保证两个或多个代码段不被并发调用</li>
<li>在进入关键代码段前，进程必须获取一个信号量，否则不能运行</li>
<li>执行完该关键代码段，必须释放信号量</li>
<li>信号量有值，为正说明它空闲，为负说明其忙碌</li>
</ul>
</blockquote>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>信号量S是一个整型变量，它有两个原子操作</p>
<blockquote>
<ul>
<li>wait(S)：P(S)，通过while等待S大于等于0，然后令S–</li>
<li>signal(S)：V(S)，S++</li>
<li>会出现wait忙等问题</li>
</ul>
</blockquote>
<p>改进：记录型信号量，使用原子操作将等待进程加入队列</p>
<blockquote>
<ul>
<li>记录型信号量可以为负数，绝对值表示等待信号量的进程个数</li>
<li>执行原子操作本身其实也有忙等待问题</li>
</ul>
</blockquote>
<h3 id="信号量类型"><a href="#信号量类型" class="headerlink" title="信号量类型"></a>信号量类型</h3><p>计数信号量：</p>
<blockquote>
<ul>
<li>没有限制的整型值</li>
<li>计数信号量为同步信号量</li>
</ul>
</blockquote>
<p>二值信号:</p>
<blockquote>
<ul>
<li>变化范围为0和1（整型）</li>
<li>二值信号量为互斥信号量</li>
<li>记录型二进制信号量可以为负</li>
</ul>
</blockquote>
<p>信号量S的使用：</p>
<blockquote>
<ul>
<li>S仅且只能设置一次初始值</li>
<li>S的初始值不能为负数</li>
<li>除了初始化，只能通过PV操作来访问S</li>
</ul>
</blockquote>
<h3 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h3><p>互斥信号量的使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore *S; &#x2F;&#x2F;S&#x3D;1</span><br><span class="line">wait(S);</span><br><span class="line">CriticalSection();</span><br><span class="line">signal(S);</span><br></pre></td></tr></table></figure>

<p>同步信号量的使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore S &#x3D; 0;</span><br><span class="line">P1: &#x2F;&#x2F; process 1</span><br><span class="line">	C1;</span><br><span class="line">    signal(S);</span><br><span class="line">P2: &#x2F;&#x2F; process 2</span><br><span class="line">    wait(S);</span><br><span class="line">    C2;</span><br></pre></td></tr></table></figure>

<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>本质：协同进程共享有限缓冲区</p>
<blockquote>
<ul>
<li>M个生产产品放入固定大小的缓冲区</li>
<li>N个消费者从缓冲区中取出产品进行消费</li>
</ul>
</blockquote>
<p>两个指针：in和out；in&gt;out</p>
<p>一个计数值：count，用于记录缓冲区中点产品个数</p>
<h3 id="互斥分析"><a href="#互斥分析" class="headerlink" title="互斥分析"></a>互斥分析</h3><p>临界资源：</p>
<blockquote>
<ul>
<li>所有生产者对in指正互斥</li>
<li>所有消费者对out指正互斥</li>
<li>生产者和消费者多count互斥</li>
</ul>
</blockquote>
<p>临界区：</p>
<blockquote>
<ul>
<li>将产品放入缓冲区</li>
<li>从缓冲区中取出产品</li>
</ul>
</blockquote>
<p>互斥机制：此时可以只设置一个信号量，比较简单，但稍微拉长了临界区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore *buffer &#x3D; new Semaphore(1); &#x2F;&#x2F; 互斥信号量</span><br><span class="line"></span><br><span class="line">Producer&#123;</span><br><span class="line">	producing;</span><br><span class="line">    </span><br><span class="line">    wait(buffer);</span><br><span class="line">    putting production;</span><br><span class="line">    signal(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer&#123;</span><br><span class="line">	wait(buffer);</span><br><span class="line">    feching production;</span><br><span class="line">    signal(buffer);</span><br><span class="line">    </span><br><span class="line">    consuming production;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p>查找需要按次序运行的代码和其执行顺序</p>
<blockquote>
<ul>
<li>缓冲区为空，消费者进行消费，此时消费者阻塞直到生产者生产</li>
<li>缓冲区为满，生产者进行生产，此时生产者阻塞直到消费者消费</li>
</ul>
</blockquote>
<p>同步机制：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore *buffer &#x3D; new Semaphore(1);</span><br><span class="line">Semaphore *full &#x3D; new Semaphore(0); &#x2F;&#x2F; 有0个已填充</span><br><span class="line">Semaphore *empty &#x3D; new Semaphore(N); &#x2F;&#x2F; 有N个空位</span><br><span class="line"></span><br><span class="line">Producer&#123;</span><br><span class="line">	producing;</span><br><span class="line">    </span><br><span class="line">    wait(empty); &#x2F;&#x2F; 等待空位</span><br><span class="line">    wait(buffer);</span><br><span class="line">    puting production;</span><br><span class="line">    signal(buffer);</span><br><span class="line">    signal(full); &#x2F;&#x2F; 进行填充</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Consumer&#123;</span><br><span class="line">	wait(full); &#x2F;&#x2F; 等待填充</span><br><span class="line">    wait(buffer);</span><br><span class="line">    feching production;</span><br><span class="line">    signal(buffer);</span><br><span class="line">    signal(empty); &#x2F;&#x2F;给出空位</span><br><span class="line">    </span><br><span class="line">    consuming production;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>读者和写者共享一组数据区进行读写：</p>
<blockquote>
<ul>
<li>允许多个读者同时读</li>
<li>不允许读者和写者同时读写</li>
<li>不允许多个写者同时写</li>
</ul>
</blockquote>
<h3 id="读者优先模式"><a href="#读者优先模式" class="headerlink" title="读者优先模式"></a>读者优先模式</h3><p>极端情况：设置一个互斥锁：</p>
<blockquote>
<p>违背了读者共享读的功能</p>
</blockquote>
<p>进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore M&#x3D;1；</span><br><span class="line">Semaphore W&#x3D;1;</span><br><span class="line">int rc&#x3D;0;</span><br><span class="line"></span><br><span class="line">Readers&#123;</span><br><span class="line">	P(M);</span><br><span class="line">    rc++;</span><br><span class="line">    if(rc&#x3D;&#x3D;1) P(W);</span><br><span class="line">    V(M);</span><br><span class="line">    reading;</span><br><span class="line">    P(M);</span><br><span class="line">    rc--;</span><br><span class="line">    if(rc&#x3D;&#x3D;0) V(W);</span><br><span class="line">    V(M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Writers&#123;</span><br><span class="line">	P(W);</span><br><span class="line">    writing;</span><br><span class="line">    V(W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：一直有读者进行读的话，写者可能会长期饥饿</p>
<h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>共享资源竞争问题：</p>
<blockquote>
<ul>
<li>5根筷子和5个哲学家间隔排成环</li>
<li>每个哲学家左右各有一根筷子</li>
<li>每个哲学家只有拿起左右两个筷子才能吃饭</li>
</ul>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>为每个筷子设置一个互斥信号量：死锁问题</p>
<p>防止死锁发生：</p>
<blockquote>
<ul>
<li>最多允许4个哲学家同时坐在桌子周围</li>
<li>一次封锁法：当且仅当哲学家左右两边筷子都可用时，才允许拿筷子（较好）</li>
<li>顺序封锁法：给哲学家编号，奇数号哲学家必须首先拿左边筷子，偶数号反之</li>
</ul>
</blockquote>
<h3 id="最多4个哲学家入座"><a href="#最多4个哲学家入座" class="headerlink" title="最多4个哲学家入座"></a>最多4个哲学家入座</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore *chopstick[5]</span><br></pre></td></tr></table></figure>

<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>信号量灵活，但维护困难，容易出错</p>
<p>管程：</p>
<blockquote>
<ul>
<li>管程定义了一个数据结构和一组能在该数据结构上并发执行的一组操作</li>
<li>该操作能同步进程和改变管程中点数据</li>
</ul>
</blockquote>
<p>管程功能：</p>
<blockquote>
<ul>
<li>（互斥）管程中的变量只能被管程中的操作访问</li>
<li>任何时候只有一个进程在管程中操作</li>
<li>类似临界区</li>
<li>由编译器完成</li>
<li>（同步）条件变量</li>
<li>唤醒和阻塞操作</li>
</ul>
</blockquote>
<h2 id="Linux同步机制"><a href="#Linux同步机制" class="headerlink" title="Linux同步机制"></a>Linux同步机制</h2><ul>
<li>短临界区：禁止中断</li>
<li>自旋锁</li>
<li>互斥锁：快速锁、递归锁</li>
<li>条件变量</li>
<li>信号量</li>
</ul>
<h2 id="Windows同步机制"><a href="#Windows同步机制" class="headerlink" title="Windows同步机制"></a>Windows同步机制</h2><ul>
<li>事件</li>
<li>临界区</li>
<li>互斥锁</li>
<li>自旋锁</li>
<li>信号量</li>
</ul>
<p>事件：</p>
<blockquote>
<ul>
<li>HANDLE CreatEvent创建事件</li>
<li>Open Event打开事件</li>
<li>SetEvent</li>
<li>WaitForSignalObject</li>
</ul>
</blockquote>
<p>临界区：</p>
<blockquote>
<ul>
<li>EnterCriticalSection</li>
<li>LeaveCriticalSection</li>
</ul>
</blockquote>
<p>互斥量：</p>
<blockquote>
<ul>
<li>相比于不能命名的临界区，互斥量可以跨进程使用</li>
</ul>
</blockquote>
<p>信号量：</p>
<blockquote>
<ul>
<li>CreateSemaphore</li>
<li>ReleaseSemaphore</li>
</ul>
</blockquote>
<h1 id="七、死锁"><a href="#七、死锁" class="headerlink" title="七、死锁"></a>七、死锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>死锁：一组等待的进程，其中每一个进程都等待资源，并且该资源被组中其他进程所持有</p>
<blockquote>
<ul>
<li>所有死锁进程无法推进</li>
<li>原因：竞争互斥资源或进程推进不当</li>
</ul>
</blockquote>
<p>死锁必要条件：</p>
<blockquote>
<ul>
<li>互斥</li>
<li>占有并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ul>
</blockquote>
<p>注意，所有访问死锁资源的进程都会死锁</p>
<h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>组成部分：</p>
<blockquote>
<ul>
<li>进程：圆形节点</li>
<li>资源：方形区域</li>
<li>资源实例：区域内的节点</li>
<li>P请求一个R的实例：P-&gt;资源区域</li>
<li>P持有一个R的实例：资源实例-&gt;P</li>
</ul>
</blockquote>
<p>死锁判断：</p>
<blockquote>
<ul>
<li>图中无环，则无死锁发生</li>
<li>图中有环：若每一种资源类型只有一个实例，那么死锁发生，否则死锁可能发生</li>
</ul>
</blockquote>
<h3 id="处理死锁的方式"><a href="#处理死锁的方式" class="headerlink" title="处理死锁的方式"></a>处理死锁的方式</h3><p>确保系统不会进入死锁状态：</p>
<blockquote>
<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</blockquote>
<p>允许系统进入死锁状态，然后加以检测恢复</p>
<blockquote>
<ul>
<li>死锁检测</li>
<li>死锁恢复</li>
</ul>
</blockquote>
<p>忽略此问题：一般采用</p>
<blockquote>
<ul>
<li>通用做法（Windows、UNIX）</li>
<li>开发人员自行处理死锁</li>
</ul>
</blockquote>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>死锁预防是一种事先的静态策略，它是一组方法，确保发生死锁的四个必要条件之一不成立</p>
<ul>
<li>将互斥资源虚拟化成共享资源，不涉及互斥</li>
<li>保证进程申请资源时没有占有其他资源<blockquote>
<ul>
<li>一次封锁法：要求进程在执行前一次性申请全部资源</li>
<li>利用率低，可能出现饥饿</li>
</ul>
</blockquote>
</li>
<li>保证非抢占<blockquote>
<ul>
<li>若一个进程的申请没有实现，它要释放所有的占有资源</li>
<li>进程容易饥饿</li>
</ul>
</blockquote>
</li>
<li>保证不会循环等待<blockquote>
<ul>
<li>顺序封锁法：对所有资源进行排序编号，要求进程按顺序申请资源</li>
<li>资源事先排序编号较为困难</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>死锁避免需要系统有一些额外的信息</p>
<blockquote>
<ul>
<li>一个简单而有效的模型要求每一个进程声明它所需要的资源的最大数</li>
<li>死锁避免算法动态检查资源分配状态以确保循环等待条件不可能成立</li>
<li>资源分配状态定义为可用与已分配的资源数，和进程所需的最大资源量所决定</li>
</ul>
</blockquote>
<p>安全状态：当进程申请一个有效的资源的时候，系统必须确定分配后是安全等</p>
<blockquote>
<ul>
<li>如果存在一个安全序列，则系统处于安全状态</li>
<li>进程序列是安全等，如果每一个进程所申请的可以被满足的资源数加上其他进程所持有的资源数小于系统的总数</li>
</ul>
</blockquote>
<p>基本事实：</p>
<blockquote>
<ul>
<li>如果系统处于安全状态，那么就没有死锁</li>
<li>如果系统处于不安全状态，那么有可能发生死锁</li>
</ul>
</blockquote>
<h3 id="单实例资源：资源分配图法"><a href="#单实例资源：资源分配图法" class="headerlink" title="单实例资源：资源分配图法"></a>单实例资源：资源分配图法</h3><ul>
<li>需求边：P-&gt;R用虚线表示，表明P以后需要申请R</li>
<li>请求边：P-&gt;R用实线表示</li>
<li>分配边：R-&gt;P用实线表示，资源释放后分配边转换为需求边</li>
</ul>
<p>需求能满足的前提：需求边转化为分配边之后不会导致环的存在；若存在环，则系统处于不安全状态（不一定发生死锁），该需求不能被满足</p>
<h3 id="多实例资源：银行家算法"><a href="#多实例资源：银行家算法" class="headerlink" title="多实例资源：银行家算法"></a>多实例资源：银行家算法</h3><p>前提：</p>
<blockquote>
<ul>
<li>每一个进程必须事先声明使用的最大量</li>
<li>当一个进程请求资源、它可能等待</li>
<li>当一个进程得到所有的资源，它必须在有限的时间内释放它们</li>
</ul>
</blockquote>
<p>数据结构：</p>
<blockquote>
<ul>
<li>Available：长度为m的向量；每个维度i的量表示资源i有的实例个数</li>
<li>Max：n*m矩阵；表示n个进程对m个资源的最大请求数</li>
<li>Allocation：n*m矩阵； 表示n个进程对m个资源的当前分配（占有）数</li>
<li>Need：n*m矩阵；表示n个进程对m个资源还能进行的最大需求数</li>
<li>Need = Max - Allociation</li>
</ul>
</blockquote>
<p>算法过程：若安全，此时访问i的顺序就是一个安全序列</p>
<blockquote>
<ol>
<li>Work[1..m] = Available[1..m]; Finish[1..n] = false</li>
<li>while exist i if(Finish[i] == false &amp;&amp; Need[i]&lt;=Work[]) Work[]=Work[]+Allociation[i][]; Finish[i]=true</li>
<li>if forall i Finish[i]=true System is safe</li>
</ol>
</blockquote>
<p>判断进程i的请求是否能被满足：</p>
<blockquote>
<ol>
<li>input Request[1..m]; for all i do 2.,3.</li>
<li>if(Request[i]&lt;=Need[i]) pass else ERROR</li>
<li>if(Request[i]&lt;=Available[i]) pass else progress wait()</li>
<li>Given that progress is satisfied, do</li>
</ol>
<ul>
<li>Available[] = Available[]-Request[]</li>
<li>Allociation[progress][] = Allociation[progress][] + Request</li>
<li>Need[progress][] = Need[progress][]-Request[]</li>
</ul>
</blockquote>
<h2 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h2><p>等待图的维护：</p>
<blockquote>
<ul>
<li>等待图：P-&gt;R表示P等待R</li>
<li>若图中有环，则死锁发生</li>
</ul>
</blockquote>
<p>死锁恢复：</p>
<blockquote>
<ul>
<li>人工恢复</li>
<li>自动恢复：终止进程、抢占资源</li>
</ul>
</blockquote>
<h1 id="八、内存管理策略"><a href="#八、内存管理策略" class="headerlink" title="八、内存管理策略"></a>八、内存管理策略</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>内存管理单元MMU</p>
<p>目的：</p>
<blockquote>
<ul>
<li>提高内存利用率</li>
<li>提高指令执行速度</li>
<li>保证指令安全运行</li>
</ul>
</blockquote>
<p>功能：</p>
<blockquote>
<ul>
<li>内存分配</li>
<li>内存回收</li>
<li>地址转换</li>
<li>存储保护</li>
<li>内存共享</li>
</ul>
</blockquote>
<h3 id="内存的地址"><a href="#内存的地址" class="headerlink" title="内存的地址"></a>内存的地址</h3><p>逻辑地址和物理地址</p>
<blockquote>
<ul>
<li>逻辑地址：由CPU产生，在进程内的相对地址</li>
<li>物理地址：由所有内存统一编址的内存地址</li>
<li>内存管理单元MMU是将虚拟地址映射到物理地址的硬件</li>
</ul>
</blockquote>
<p>进程独立的运行空间：</p>
<blockquote>
<ul>
<li>基址寄存器：进程最小的合法物理内存地址</li>
<li>界限寄存器：进程地址的长度</li>
<li>CPU在执行指令时，需要进行地址合法性验证</li>
</ul>
</blockquote>
<h3 id="指令和数据绑定到内存"><a href="#指令和数据绑定到内存" class="headerlink" title="指令和数据绑定到内存"></a>指令和数据绑定到内存</h3><p>地址绑定（重定位）：程序装入内存时，将程序中的相对地址转换为绝对地址的过程，其绑定时机有三种</p>
<blockquote>
<ul>
<li>编译时期绑定：内存位置已知，生成的代码是绝对代码</li>
<li>加载时期绑定：可以装在内存任意位置；但每次装载时都需要绑定；静态重定位</li>
<li>执行时期绑定：运行时进行地址绑定（不运行的代码不会被绑定）；需要硬件对地址映射的支持；动态重定位</li>
</ul>
</blockquote>
<h3 id="动态加载和动态链接"><a href="#动态加载和动态链接" class="headerlink" title="动态加载和动态链接"></a>动态加载和动态链接</h3><p>例程序在调用之前并不加载，优点：</p>
<blockquote>
<ul>
<li>更好的内存空间利用率</li>
<li>没有被使用的例程序不被载入</li>
<li>当需要大量代码来处理不常使用的功能时非常有用</li>
</ul>
</blockquote>
<p>动态链接：</p>
<blockquote>
<ul>
<li>链接：将各种代码和数据片段收集并组合成为一个单一文件的过程</li>
<li>动态链接：将组成程序的目标文件保存在库文件中，需要时进行链接</li>
</ul>
</blockquote>
<h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><p>为一个用户程序分配一个连续的内存空间，是运用于内存较少的系统，是一种早期的内存分配模式</p>
<p>分类：</p>
<blockquote>
<ul>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li>可变分区分配</li>
</ul>
</blockquote>
<p>连续内存分配难以实现内存共享</p>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>在单道程序环境下，仅装载一道用户程序，整个内存空间由其独占</p>
<p>特点：</p>
<blockquote>
<ul>
<li>内存分配管理简单，内存利用率低</li>
<li>不采用存储器保护措施，节省硬件</li>
</ul>
</blockquote>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>在多道程序系统中，将可分配主存空间分割成若干个连续区域，若有空闲分区，则分配给进程</p>
<p>划分分区方法：</p>
<blockquote>
<ul>
<li>分区大小一样</li>
<li>分区大小不等</li>
</ul>
</blockquote>
<h3 id="可变分区分配"><a href="#可变分区分配" class="headerlink" title="可变分区分配"></a>可变分区分配</h3><p>记录所有可用内存块的起始地址和长度，当一个进程到来的时候，它将从一个足够容纳它分区中分配内存。</p>
<p>存储分配算法：</p>
<blockquote>
<ul>
<li>首次适应</li>
<li>最佳适应</li>
<li>最差适应</li>
</ul>
</blockquote>
<p>内存回收：修改相应空闲块的起始地址和长度</p>
<p>需要考虑内存碎片问题，可以通过紧缩来整理碎片：</p>
<blockquote>
<ul>
<li>外碎片：未分配内存中的不连续空间</li>
<li>内碎片：内存已分配，但其大小比程序申请的内存大，剩余部分不能被使用</li>
</ul>
</blockquote>
<h2 id="分页内存管理"><a href="#分页内存管理" class="headerlink" title="分页内存管理"></a>分页内存管理</h2><p>解决内存外碎片问题，提高内存利用率</p>
<p>离散内存管理方案</p>
<blockquote>
<ul>
<li>分页内存（常用）</li>
<li>分段内存</li>
<li>段页式内存</li>
</ul>
</blockquote>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>思想：</p>
<blockquote>
<ul>
<li>将物理内存分成大小固定的块，称为帧（大小为2的幂）</li>
<li>将逻辑内存分为同样大小的块，称为页</li>
<li>建立页表，将逻辑地址转换为物理地址</li>
<li>系统保留所有空闲帧的记录</li>
</ul>
</blockquote>
<p>对于一个程序而言，其分配的最后一个页中存在内碎片</p>
<h3 id="地址转换机制"><a href="#地址转换机制" class="headerlink" title="地址转换机制"></a>地址转换机制</h3><p>过程：</p>
<blockquote>
<ul>
<li>逻辑地址：页号-页偏移</li>
<li>地址转换：页号-&gt;帧号</li>
<li>物理地址：帧号-页偏移</li>
</ul>
</blockquote>
<p>硬件支持：</p>
<blockquote>
<ul>
<li>感觉逻辑地址的页号到页表中找到项，取出项中的页框号</li>
<li>将页框号和页偏移组合成物理地址</li>
</ul>
</blockquote>
<p>TLB快表：快表只存储当前运行程序的页号映射</p>
<blockquote>
<ul>
<li>并行查找</li>
<li>若页号在TLB中，则取出相应帧号</li>
<li>若不在，则从内存中的页表里取出帧号</li>
</ul>
</blockquote>
<p>EAT：有效（评均访问时间）</p>
<blockquote>
<ul>
<li>EAT = $\lambda(a+b)+(1-\lambda)(a+2b)$</li>
</ul>
</blockquote>
<h3 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h3><p>内存保护方法：</p>
<blockquote>
<ul>
<li>将页号和限长寄存器比较</li>
<li>将有效-无效位附在页表的每个表项中</li>
</ul>
</blockquote>
<h3 id="页共享"><a href="#页共享" class="headerlink" title="页共享"></a>页共享</h3><p>如果代码是可重入代码（只读），则可以在进程之间共享</p>
<p>共享代码必须出现在所有进程逻辑地址空间的相同位置</p>
<h2 id="页表结构"><a href="#页表结构" class="headerlink" title="页表结构"></a>页表结构</h2><p>页表通常很大，需要采用不同的页表结构</p>
<p>组织页表的常用技术：</p>
<blockquote>
<ul>
<li>层次页表</li>
<li>哈希页表</li>
<li>反向页表</li>
</ul>
</blockquote>
<h3 id="层次页表"><a href="#层次页表" class="headerlink" title="层次页表"></a>层次页表</h3><p>两级页表：将32位地址分为外页表(10)-页偏移(10)-页内偏移(12)</p>
<blockquote>
<ul>
<li>若页大小4KB(2^12)，每条目4B，为保证所有页偏移存在同一个页表中，页偏移最大位数为10位</li>
<li>程序访问一次数据需要3次内存访问</li>
</ul>
</blockquote>
<p>三级页表，四级页表…</p>
<h3 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h3><p>对于地址空间大于32位的系统，通常使用哈希页表</p>
<blockquote>
<ul>
<li>虚拟页号被散列到一个页表中。</li>
<li>页表的每一个条目都包括了一个链表元素，这些元素哈希成同一位置。</li>
<li>虚拟页号与链表中的每个元素相比较，找到匹配项。如果匹配，则相应的物理帧被取出。</li>
</ul>
</blockquote>
<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h3><p>反向页表一般用于小内存中</p>
<blockquote>
<ul>
<li>对于每个真正的内存页或帧有一个条目。</li>
<li>每个条目保存在真正内存位置的页的虚拟地址，以及包括拥有这个页的进程的信息。</li>
<li>每个进程无需再有自己的页表，减少了存储空间，但时间性能很差</li>
<li>可以使用哈希表来将查找限制在一个或少数几个页表条目中</li>
<li>实现共享内存困难</li>
</ul>
</blockquote>
<h2 id="分段内存管理"><a href="#分段内存管理" class="headerlink" title="分段内存管理"></a>分段内存管理</h2><p>段：一个逻辑单位，一个程序是一些段的集合</p>
<blockquote>
<ul>
<li>逻辑地址由段号和偏移构成</li>
<li>段表由基址STBR和限长STLR构成</li>
<li>寻址时，由段号找到基址，然后验证偏移是否超过限长，最后将基址和偏移组合成物理地址</li>
<li>编译用户程序时，编译器会自动根据输入来构造段</li>
</ul>
</blockquote>
<h3 id="段页式原理"><a href="#段页式原理" class="headerlink" title="段页式原理"></a>段页式原理</h3><p>段页是分段和分页原理的结合</p>
<blockquote>
<ul>
<li>先将用户程序分段，再讲每个段分为若干个页，并为每个段赋予一个段号</li>
<li>逻辑地址由段号-页号-页内偏移组成</li>
</ul>
</blockquote>
<h2 id="内存扩充技术"><a href="#内存扩充技术" class="headerlink" title="内存扩充技术"></a>内存扩充技术</h2><p>常用技术：</p>
<blockquote>
<ul>
<li>紧缩Compaction（可变分区）</li>
<li>覆盖技术Overlaying</li>
<li>交换技术Swapping</li>
<li>虚拟内存Virtual Memory</li>
</ul>
</blockquote>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>程序大小超过物理内存总和时：</p>
<blockquote>
<ul>
<li>程序执行时只在内存中保留那些在任何时间都需要的指令和数据</li>
<li>程序的不同部分在内存中相互替换</li>
<li>覆盖结构由程序员声明，不需要操作系统特别声明</li>
</ul>
</blockquote>
<p>覆盖结构的程序设计很复杂，应用于早期操作系统</p>
<h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><p>策略：</p>
<blockquote>
<ul>
<li>一个进程可以暂时被交换到内存外的一个备份区，随后可以被换回内存继续执行</li>
<li>备份区是一个固定的足够大的可以容纳所有用户内存映像拷贝的快速磁盘</li>
<li>系统必须提供对这些内存映像的直接访问</li>
</ul>
</blockquote>
<h1 id="九、虚拟存储技术"><a href="#九、虚拟存储技术" class="headerlink" title="九、虚拟存储技术"></a>九、虚拟存储技术</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>问题：代码必须装入内存才能执行；但并不是所有代码必须装入内存</p>
<blockquote>
<ul>
<li>错误代码</li>
<li>不常用函数</li>
<li>大的数据结构</li>
</ul>
</blockquote>
<p>程序部分装入：</p>
<blockquote>
<ul>
<li>局部性原理：一个程序只要部分装入内存就可以运行</li>
<li>进程大小不再受到物理内存大小限制</li>
<li>每个进程需要的内存更小</li>
<li>更多进程可以并发运行</li>
<li>I/O更少</li>
</ul>
</blockquote>
<p>虚拟存储技术：</p>
<blockquote>
<ul>
<li>当程序运行时，先将其一部分装入内存，另一部分咱留在磁盘</li>
<li>当要执行的指令或访问的数据不在内存时，有操作系统自动完成将它们从磁盘调入内存执行</li>
<li>虚拟地址空间：分配给进程的虚拟内存</li>
<li>虚拟地址：在虚拟内存中指令或数据的位置</li>
<li>虚拟内存：把内存和磁盘有机结合起来使用，得到一个容量很大的“内存”，即虚存</li>
<li>虚存空间是可变的，但不能超过操作系统子长和内外存容量限制</li>
</ul>
</blockquote>
<p>虚拟内存区别于逻辑内存的要点：</p>
<blockquote>
<ul>
<li>只有部分运行的程序需要在内存中</li>
<li>逻辑地址空间能够比物理地址空间大</li>
<li>允许多个进程共享同一地址空间</li>
<li>允许更有效的进程创建</li>
</ul>
</blockquote>
<p>使用虚拟内存的共享库：</p>
<blockquote>
<ul>
<li>进程共享地址空间：写时复制（fork）</li>
</ul>
</blockquote>
<p>虚拟内存的实现：</p>
<blockquote>
<ul>
<li>虚拟页式：请求式分页（主要使用）；预调页</li>
<li>虚拟段式</li>
</ul>
</blockquote>
<h2 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h2><h3 id="虚拟页式存储管理"><a href="#虚拟页式存储管理" class="headerlink" title="虚拟页式存储管理"></a>虚拟页式存储管理</h3><p>基本思想：</p>
<blockquote>
<ul>
<li>进程开始运行之前，不是装入全部页面，而是装入一个或零个页面</li>
<li>运行之后，根据进程运行需要，动态装入其他页面</li>
<li>当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面</li>
</ul>
</blockquote>
<h3 id="请求分页（按需调页）"><a href="#请求分页（按需调页）" class="headerlink" title="请求分页（按需调页）"></a>请求分页（按需调页）</h3><p>只有在一个页需要的时候才把它调入内存：</p>
<blockquote>
<ul>
<li>需要很少的I/O</li>
<li>需要很少的内存</li>
<li>快速响应</li>
<li>多用户</li>
</ul>
</blockquote>
<p>请求分页是一种懒惰的交换，和交换相比</p>
<blockquote>
<ul>
<li>交换程序(swapper)对整个进程进行操作</li>
<li>调页程序(pager)只是对进程的单个页进行操作</li>
</ul>
</blockquote>
<p>有效-无效位：</p>
<blockquote>
<ul>
<li>每一个页表的表项有一个有效-无效位相关联</li>
<li>1表示在内存，0表示不内存</li>
<li>在所有的表项中，这个位被初始化为0</li>
<li>一个页表映象的例子</li>
</ul>
</blockquote>
<h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><p>缺页中断：若访问的页不在内存中，则会陷入缺页中断，过程如下</p>
<blockquote>
<ul>
<li>访问指令或数据</li>
<li>查看另一个表来决定:无效引用，终止；仅仅不在内存，继续</li>
<li>找到页在后备存储上的位置</li>
<li>得到空的页框，把页换入页框</li>
<li>重新设置页表，把有效位设为v</li>
<li>重启指令</li>
</ul>
</blockquote>
<p>请求分页需要硬件支持：</p>
<blockquote>
<ul>
<li>带有效无效位的页表</li>
<li>交换空间</li>
<li>指令重启</li>
</ul>
</blockquote>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>性能分析：</p>
<blockquote>
<ul>
<li>有效访问时间EAT = (1-p)*memoryT+p*errorT</li>
<li>p为缺页率</li>
<li>memoryT为内存访问时间；errorT为页错误时间（处理缺页中断时间）</li>
</ul>
</blockquote>
<p>请求分页性能优化</p>
<blockquote>
<ul>
<li>页面转换时采用交换空间而不是文件系统</li>
<li>在进程装在是将整个进程拷贝到交换区</li>
</ul>
</blockquote>
<h2 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>系统没有空闲帧来读取外存中的页面，此时需要页面置换</p>
<blockquote>
<ul>
<li>页置换找到内存中没有使用的一些页，将其换出</li>
<li>同一个页可能会被装入内存多次</li>
</ul>
</blockquote>
<p>页置换基本想法：</p>
<blockquote>
<ul>
<li>查找所需页在磁盘上的位置</li>
<li>查找空闲页框，若有空闲页框，直接使用</li>
<li>若无空闲页框，使用页置换算法选择一个待牺牲页框</li>
<li>将待牺牲帧内容写到磁盘上，更新页表和帧表</li>
<li>将所需页读入空闲页框，更新页表和帧表</li>
<li>重启用户进程</li>
</ul>
</blockquote>
<p>页置换加倍了缺页时间的处理，但完善了逻辑内存和物理内存的划分</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>页面置换算法：</p>
<blockquote>
<ul>
<li>先进先出置换算法FIFO</li>
<li>最右置换算法OPT</li>
<li>最近最少使用算法LRU</li>
<li>LRU近似算法：最不经常使用算法、附加引用位算法、二次机会算法</li>
</ul>
</blockquote>
<h3 id="先进先出置换算法"><a href="#先进先出置换算法" class="headerlink" title="先进先出置换算法"></a>先进先出置换算法</h3><p>置换在内存中驻留时间最长的页面</p>
<blockquote>
<ul>
<li>实现：使用FIFO队列管理内存中的所有页</li>
<li>容易理解和实现、但性能不总是很好</li>
</ul>
</blockquote>
<p>belady异常：对于某特定访问序列更多页框可能导致更多的缺页</p>
<h3 id="最优置换算法"><a href="#最优置换算法" class="headerlink" title="最优置换算法"></a>最优置换算法</h3><p>被置换的页是将来不再需要的或最远的将来才会被使用等页</p>
<blockquote>
<ul>
<li>无法实现，但可以作为一种标准来衡量其他算法的性能</li>
<li>无belady异常</li>
</ul>
</blockquote>
<h3 id="最近最少使用算法"><a href="#最近最少使用算法" class="headerlink" title="最近最少使用算法"></a>最近最少使用算法</h3><p>置换最长时间没有使用的页</p>
<blockquote>
<ul>
<li>性能接近OPT算法</li>
<li>实现需要为每个页添加一个计数器（时间戳）或维护一个访问栈，开销大、需硬件支持，难以实现</li>
</ul>
</blockquote>
<h3 id="LRU近似算法"><a href="#LRU近似算法" class="headerlink" title="LRU近似算法"></a>LRU近似算法</h3><p>在没有硬件支持的系统中，可使用LRU近似算法</p>
<p>二次机会算法：</p>
<blockquote>
<ul>
<li>为每个页设置一个访问位，设为1</li>
<li>查找交换页中，若访问位为0，直接置换</li>
<li>若访问位为1，将其设为0（给第二次机会），然后寻找其他的页</li>
</ul>
</blockquote>
<p>NFU不经常使用算法：跟踪每页被访问到频繁程度</p>
<blockquote>
<ul>
<li>需要一个初值为0的计数器与每页相关联</li>
<li>每次中断时，将每内存中页的R位加到其计数器上</li>
<li>缺页是淘汰计数器值最小的页</li>
</ul>
</blockquote>
<h2 id="页框分配与系统颠簸"><a href="#页框分配与系统颠簸" class="headerlink" title="页框分配与系统颠簸"></a>页框分配与系统颠簸</h2><h3 id="页框分配"><a href="#页框分配" class="headerlink" title="页框分配"></a>页框分配</h3><p>页框分配需要在各个进程之间分配固定数量的可用内存</p>
<blockquote>
<ul>
<li>分配的页框数需满足：每个进程所需要的最少页数</li>
<li>分配策略：固定分配和优先级分配</li>
</ul>
</blockquote>
<p>分配算法：</p>
<blockquote>
<ul>
<li>平均分配（均分法）：将可用页框平均分配给所有进程</li>
<li>按比例分配：根据每个进程的大小来分配</li>
<li>优先级分配：根据进程优先级来使用比例分配策略</li>
</ul>
</blockquote>
<p>替换算法：</p>
<blockquote>
<ul>
<li>全局置换：进程在所有页框中选择一个替换页面；比如一个进程可以从一个较低优先级的进程中选择一个页面来替换</li>
<li>局部替换：每个进程只从属于它自己的页框中选择替换页框</li>
</ul>
</blockquote>
<h3 id="系统颠簸"><a href="#系统颠簸" class="headerlink" title="系统颠簸"></a>系统颠簸</h3><p>如果一个进程没有足够的页，那么缺页率将很高，这将导致：</p>
<blockquote>
<ul>
<li>CPU利用低下</li>
<li>操作系统人为需要增加多道程序的道数</li>
<li>系统中将加入一个新的进程</li>
</ul>
</blockquote>
<p>颠簸：一个进程的页面经常被换入换出</p>
<p>原因分析：</p>
<blockquote>
<ul>
<li>在局部模型中，局部可能重叠，进程也会从一个局部移动到另一个局部</li>
<li>颠簸发生：进程分配的页框数&lt;局部大小之和</li>
</ul>
</blockquote>
<p>解决方案：</p>
<blockquote>
<ul>
<li>WSS工作集模型（Windows使用）</li>
<li>PFF缺页率策略（Linux使用）</li>
</ul>
</blockquote>
<p>工作集模型：</p>
<blockquote>
<ul>
<li>设置工作集窗口Δ，其包含固定数目的页的引用</li>
<li>工作集WSS表示最近Δ中所有页的引用</li>
<li>$D = \sum WSS_i$表示所有进程总的页框需求量</li>
<li>若可用页框数m&lt;D，则系统发生颠簸；这时系统可以暂停一个进程，将其页写入缓存中，释放其页框</li>
</ul>
</blockquote>
<p>工作集模型要点：</p>
<blockquote>
<ul>
<li>若Δ太小，则其不能包含整个局部</li>
<li>若Δ太大，则它可能包含多个局部；无穷大是工作集为进程执行所接触到的所有页的集合</li>
<li>工作集模型的问题：跟踪工作集困难</li>
</ul>
</blockquote>
<p>缺页率策略：</p>
<blockquote>
<ul>
<li>设置一个可接受的缺页率上限和下限</li>
<li>如果缺页率比较低，则回收一些进程的页框</li>
<li>如果缺页率太高，就分给进程一些页框</li>
</ul>
</blockquote>
<h2 id="内核内存分配"><a href="#内核内存分配" class="headerlink" title="内核内存分配"></a>内核内存分配</h2><p>内核内存分配不同于用户内存，其通常从空闲内存池中获取，原因如下：</p>
<blockquote>
<ul>
<li>内核需要为不同大小的数据结构分配内存；可以不受分页的限制</li>
<li>一些内核需要连续的物理页</li>
</ul>
</blockquote>
<p>特点：</p>
<blockquote>
<ul>
<li>内存块的尺寸比较小；</li>
<li>占用内存块的时间比较短；</li>
<li>要求快速完成分配和回收；</li>
<li>不参与交换。</li>
<li>频繁使用尺寸相同的内存块，存放同一结构的数据；</li>
<li>要求动态分配和回收。</li>
</ul>
</blockquote>
<h3 id="Buddy-System伙伴系统"><a href="#Buddy-System伙伴系统" class="headerlink" title="Buddy System伙伴系统"></a>Buddy System伙伴系统</h3><p>主要用于早期Linux内核底层内存管理</p>
<blockquote>
<ul>
<li>它从物理上连续的大小固定的段上分配内存</li>
<li>内存按2的幂为大小进行划分，即4KB、8KB组成若干空闲链表块，查找链表满足进程需求的最佳匹配块</li>
</ul>
</blockquote>
<p>匹配算法：</p>
<blockquote>
<ul>
<li>满足要求是以2的幂为单位的</li>
<li>如果请求不为2的幂，则需要调整到下一个更大的2的幂</li>
<li>当分配需求小于现在可用内存时，当前段就分为两个更小的2的幂段，继续上述操作直到合适的段大小</li>
</ul>
</blockquote>
<p>优点：内存回收简单</p>
<p>缺点：可能会产生接近50%的内碎片</p>
<h3 id="Slab分配"><a href="#Slab分配" class="headerlink" title="Slab分配"></a>Slab分配</h3><p>概念：</p>
<blockquote>
<ul>
<li>Slab有一个或多个物理上连续的页组成</li>
<li>cache中含有一个或多个slab，这个cache非CPUcache</li>
<li>每个内核数据结构都有一个cache，每个cache含有内核数据结构的对象实例</li>
</ul>
</blockquote>
<p>Slab分配：</p>
<blockquote>
<ul>
<li>当创建 cache 时, 包括若干个标记为空闲的对象</li>
<li>当内核对象时，从cache上直接获取，并标识对象为使用</li>
<li>当一个slab充满了已使用的对象时，下一个对象的分配从空的slab开始分配</li>
<li>如果没有空的slab, 则从物理连续页上分配新的slab</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>没有因内碎片而引起的内存浪费</li>
<li>内存请求可以快速满足</li>
</ul>
</blockquote>
<h2 id="虚拟内存的其他考量"><a href="#虚拟内存的其他考量" class="headerlink" title="虚拟内存的其他考量"></a>虚拟内存的其他考量</h2><h3 id="预调页面"><a href="#预调页面" class="headerlink" title="预调页面"></a>预调页面</h3><p>预调页特点：</p>
<blockquote>
<ul>
<li>在进程启动初期，减少大量的缺页中断</li>
<li>在引用前，调入进程的所有或一些需要的页面</li>
<li>如果预调入的页面没有被使用，则内存被浪费</li>
</ul>
</blockquote>
<p>页面尺寸的选择：总的来说，取向更大的页</p>
<blockquote>
<ul>
<li>减少碎片：需要小的页</li>
<li>减少页表大小：需要大的页</li>
<li>减少IO开销：大</li>
<li>保证局部性操作：小</li>
<li>减少缺页次数：大</li>
<li>其他因素：页大小和调页设备的扇区关系</li>
</ul>
</blockquote>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>TLB范围：通过TLB能够访问到内存量，其值为TLB大小*页大小</p>
<p>理想情况下，一个进程的工作集应存放在TLB中，否则会有大量的缺页中断</p>
<p>增加TLB范围的方法：</p>
<blockquote>
<ul>
<li>增加页的大小：会导致内碎片增加</li>
<li>提供多种页大小</li>
</ul>
</blockquote>
<h3 id="反向页表-1"><a href="#反向页表-1" class="headerlink" title="反向页表"></a>反向页表</h3><p>反向页表降低了保存的物理内存</p>
<p>不再包括进程逻辑地址空间的完整信息</p>
<p>为了提供这种信息，进程必须保留一个外部页表</p>
<p>外部页表可根据需要换进或换出内存</p>
<h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><p>程序结构可能影响到系统性能</p>
<blockquote>
<ul>
<li>栈具有良好的局部性</li>
<li>哈希表具有较差的局部性</li>
</ul>
</blockquote>
<p>其他因素（编译器、载入器、程序设计语言）对调页都有影响</p>
<h3 id="IO互锁"><a href="#IO互锁" class="headerlink" title="IO互锁"></a>IO互锁</h3><p>IO互锁允许某些页在内存中被锁住</p>
<p>IO时，正在进行IO的页面不允许被置换算法置换出内存</p>
<h2 id="Linux和Windows存储管理技术"><a href="#Linux和Windows存储管理技术" class="headerlink" title="Linux和Windows存储管理技术*"></a>Linux和Windows存储管理技术*</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux内存映像：</p>
<blockquote>
<ul>
<li>内存低端：kernel Memory</li>
<li>内存高端：user Memory</li>
</ul>
</blockquote>
<p>Linux分页：</p>
<blockquote>
<ul>
<li>四级分页</li>
<li>页全局目录、页上级目录、页中间目录、页表</li>
</ul>
</blockquote>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows采用工作集模型</p>
<h1 id="十、文件系统"><a href="#十、文件系统" class="headerlink" title="十、文件系统"></a>十、文件系统</h1><p>操作系统功能：信息处理、信息存储、输入输出</p>
<h2 id="文件系统接口"><a href="#文件系统接口" class="headerlink" title="文件系统接口"></a>文件系统接口</h2><p>文件系统接口是面相用户的</p>
<p>文件：</p>
<blockquote>
<ul>
<li>文件是计算机中信息存储的基本形式</li>
<li>文件是相关信息的结合</li>
<li>文件具有文件名</li>
</ul>
</blockquote>
<p>文件名：文件在计算机中存储位置是由数字表示的</p>
<blockquote>
<ul>
<li>按名存取：用户可以通过文件名来访问文件存储位置</li>
<li>文件名由一串ASCII码或（和）汉字构成</li>
<li>Linux文件名大小写敏感，Windows文件名大小写不敏感</li>
</ul>
</blockquote>
<p>文件结构：文件结构由操作系统和程序决定</p>
<blockquote>
<ul>
<li>无结构：文字流、字节流等</li>
<li>简单记录结构：线性、固定长度、可变长度等</li>
<li>复杂结构：格式化文档、多媒体文件等</li>
</ul>
</blockquote>
<p>文件类型：文件类型一般由扩展名决定</p>
<blockquote>
<ul>
<li>文件类型也称文件后缀名</li>
<li>是标识文件类型的一种机制</li>
<li>其扩展名跟在主文件名后面，由一个分隔符“.”分隔</li>
</ul>
</blockquote>
<p>文件属性：文件名、文件位置、文件类型、文件大小、保护、时间等…</p>
<p>文件操作：创建文件、写文件、读文件、文件内重定位、删除文件、截断文件、打开文件、关闭文件</p>
<p>打开文件操作：其需要一个数据结构，用于方便文件共享、提高文件存取效率</p>
<blockquote>
<ul>
<li>打开文件表：跟踪打开文件</li>
<li>文件指针:指向最后一次读写的位置，每个进程1个</li>
<li>打开文件计数器：打开文件次数（调用open次数）</li>
<li>文件存储位置：文件存放在存储设备上的位置信息</li>
<li>访问权限：每个进程的访问权限</li>
</ul>
</blockquote>
<h2 id="逻辑文件及其访问方法"><a href="#逻辑文件及其访问方法" class="headerlink" title="逻辑文件及其访问方法"></a>逻辑文件及其访问方法</h2><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><blockquote>
<ul>
<li>逻辑文件：呈现在用户面前的组织结构，其决定了文件访问方法</li>
<li>目录：文件组织方式，是物理文件和逻辑文件之间的桥梁</li>
<li>物理文件：面相系统的问价存储方式</li>
</ul>
</blockquote>
<h3 id="文件访问方式"><a href="#文件访问方式" class="headerlink" title="文件访问方式"></a>文件访问方式</h3><p>顺序（遍历）是访问：磁带</p>
<blockquote>
<ul>
<li>顺序文件：依次访问数据，不能直接跳转到文件的指定位置</li>
<li>顺序文件特点：节省存储空间但访问效率差</li>
</ul>
</blockquote>
<p>直接（随机）访问：磁盘</p>
<blockquote>
<ul>
<li>直接文件：直接通过计算得到需要读写记录的位置，直接跳转进行文件读写</li>
<li>直接文件特点：浪费存储空间，访问效率好</li>
</ul>
</blockquote>
<p>索引文件：为顺序文件建立索引表</p>
<h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件控制块FCB"><a href="#文件控制块FCB" class="headerlink" title="文件控制块FCB"></a>文件控制块FCB</h3><p>FCB存放操控文件所需的各类文件属性信息：</p>
<blockquote>
<ul>
<li>文件名、长度、创建时间、存放位置、访问控制权限等</li>
<li>FCB类似一个索引项</li>
</ul>
</blockquote>
<h3 id="目录项和目录"><a href="#目录项和目录" class="headerlink" title="目录项和目录"></a>目录项和目录</h3><p>目录项：</p>
<blockquote>
<ul>
<li>存放一个文件等各类属性</li>
<li>在一些系统中，目录项相当于FCB</li>
<li>每个目录项都是等长的</li>
</ul>
</blockquote>
<p>目录：</p>
<blockquote>
<ul>
<li>其包含着所有文件信息的节点集合</li>
<li>目录是根据文件名检索文件的桥梁</li>
<li>目录是目录项的有序集合</li>
</ul>
</blockquote>
<p>目录文件：</p>
<blockquote>
<ul>
<li>目录文件是目录的组织形式</li>
<li>实际上，目录也是作为一个文件存在于文件系统</li>
</ul>
</blockquote>
<h3 id="目录和文件"><a href="#目录和文件" class="headerlink" title="目录和文件"></a>目录和文件</h3><p>每个目录项中存放了文件在存储设备上的地址</p>
<p>目录和文件都驻留在存储设备中</p>
<p>目录相关操作：</p>
<blockquote>
<ul>
<li>搜索文件</li>
<li>创建文件（其和文件本身没有关系，不会为文件分配空间）</li>
<li>删除文件（其和文件本身没有关系，不会修改文件的FCB和数据，仅回收其在目录中的位置）</li>
<li>截断文件（其和文件数据没有关系，仅修改其在目录中的FCB）</li>
<li>重命名文件、跟踪文件系统、列出目录、打开/创建/删除/遍历/读/切换目录…</li>
</ul>
</blockquote>
<h3 id="文件检索过程"><a href="#文件检索过程" class="headerlink" title="文件检索过程"></a>文件检索过程</h3><p>文件检索过程为一个遍历目录项的过程：</p>
<blockquote>
<ul>
<li>打开目录文件</li>
<li>从磁盘读入该目录文件的1个(物理)块，该块包含若干个目录项</li>
<li>根据文件名遍历内存中的该块，如找到则结束</li>
<li>判断该目录文件是否还有物理块没有读入，如果是转2；否则，结束。表示该目录中没有此文件名的文件</li>
</ul>
</blockquote>
<h3 id="目录性能"><a href="#目录性能" class="headerlink" title="目录性能"></a>目录性能</h3><p>物理块：内存和存储设备数据交换到基本单位</p>
<p>目录性能目标：读入尽可能少的物理块</p>
<blockquote>
<ul>
<li>降低目录项大小ds</li>
<li>降低目录中的文件数n</li>
</ul>
</blockquote>
<p>i Node目录项（Linux使用）：</p>
<blockquote>
<ul>
<li>使用仅存储文件名指向FCB(i node)，FCB再指向文件数据</li>
<li>目录文件将变小</li>
</ul>
</blockquote>
<h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><p>文件等所有者/创建者应有的控制权：</p>
<blockquote>
<ul>
<li>能做什么</li>
<li>由谁来做</li>
</ul>
</blockquote>
<p>文件访问控制：读R、写W、执行X</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>目录结构的设计目标：</p>
<blockquote>
<ul>
<li>效率：快速定位文件位置，提高文件访问效率</li>
<li>命名：方便用户使用，并对同名不同文件和不同名的相同文件（共享）提供解决方案</li>
<li>分组：提供文件分组（子目录），兼顾效率和方便性</li>
</ul>
</blockquote>
<h3 id="单层目录"><a href="#单层目录" class="headerlink" title="单层目录"></a>单层目录</h3><p>所有文件在同一个目录中，只有一级根目录</p>
<blockquote>
<ul>
<li>根目录/：最顶层的目录</li>
<li>应用在早期文件数量较少的操作系统中</li>
<li>优点：结构简单</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>检索效率查：目录下文件过多</li>
<li>不能有同名文件</li>
<li>不能分组</li>
</ul>
</blockquote>
<h3 id="双层目录"><a href="#双层目录" class="headerlink" title="双层目录"></a>双层目录</h3><p>每个用户有自己的目录结构</p>
<blockquote>
<ul>
<li>缺点：1）无法分组；2）同一用户不能有相同文件名的文件</li>
<li>优点：1）不同用户可有相同文件名的文件；2）比单层目录提高检索效率（文件分布在多个用户目录中）</li>
</ul>
</blockquote>
<p>同名文件问题解决方案：路径名</p>
<h3 id="树形目录"><a href="#树形目录" class="headerlink" title="树形目录"></a>树形目录</h3><p>特点：</p>
<blockquote>
<ul>
<li>检索高效：子目录增多，每个目录下文件减少</li>
<li>可以分组</li>
<li>允许重名</li>
</ul>
</blockquote>
<p>当前目录：工作目录，用”.”表示</p>
<blockquote>
<ul>
<li>绝对路径：用根目录开始的路径名</li>
<li>相对路径：从当前目录开始的路径名，其能够提高检索效率</li>
</ul>
</blockquote>
<p>树形目录不能实现文件共享，需要使用图目录</p>
<h3 id="无环图目录"><a href="#无环图目录" class="headerlink" title="无环图目录"></a>无环图目录</h3><p>无环图目录中：有向无环</p>
<p>文件共享方式：</p>
<blockquote>
<ul>
<li>硬链接（Linux）：在同一个卷/磁盘中，创建多个i Node指向同一个文件的FCB</li>
<li>符号链接/软链接（Win/Linux）：创建一个含有文件绝对路径的符号链接文件（快捷方式）</li>
</ul>
</blockquote>
<p>相比于硬连接，符号链接可以跨文件系统、实现简单但效率稍差</p>
<h3 id="通用图目录"><a href="#通用图目录" class="headerlink" title="通用图目录"></a>通用图目录</h3><p>通用图目录中存在环（广泛采用）</p>
<p>遍历时需要解决无穷递归问题</p>
<h1 id="十一、文件系统实现"><a href="#十一、文件系统实现" class="headerlink" title="十一、文件系统实现"></a>十一、文件系统实现</h1><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文教系统是在存储设备上组织文件的方法和数据结构</p>
<p>文件系统层次架构：</p>
<blockquote>
<ul>
<li>应用程序</li>
<li>逻辑文件系统（第十章所述）：管理目录结构、FCB等</li>
<li>文件组织模块：管理物理块、可用空间、文件分配</li>
<li>基本文件系统：向驱动器发送命令</li>
<li>I/O控制</li>
<li>设备</li>
</ul>
</blockquote>
<h3 id="文件系统基本概念"><a href="#文件系统基本概念" class="headerlink" title="文件系统基本概念"></a>文件系统基本概念</h3><p>物理块（簇）：一个或多个（2^n）扇区组成，是基本的文件读写单位</p>
<p>（物理）分区Partition：磁盘所分割成的若干个独立的空间</p>
<blockquote>
<ul>
<li>分区的类别：主分区、扩展分区</li>
<li>主分区：能够安装操作系统的启动分区，现在操作系统中一个盘最多可分为4个主分区</li>
<li>扩展分区：不能够直接使用，必须分为若干个逻辑分区</li>
</ul>
</blockquote>
<p>（卷）逻辑磁盘Volume：建立在物理分区上的逻辑分区，每个卷可以使用不同的文件系统</p>
<h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3><p>磁盘文件系统：</p>
<blockquote>
<ul>
<li>引导控制块：只有安装操作系统的分区才有，包含系统应到操作系统的各种信息</li>
<li>分区控制块：包含分区信息，UFS中为超级块</li>
<li>目录和FCB</li>
<li>用户文件</li>
</ul>
</blockquote>
<p>磁盘结构：MBR-BPT分区表-主分区-扩展分区</p>
<blockquote>
<ul>
<li>UFS的主分区：引导块-超级块-空闲区表-i node-根目录-文件</li>
<li>FAT主分区：引导区-FAT1-FAT2恢复-根目录-文件</li>
</ul>
</blockquote>
<p>内存文件系统：通过缓冲技术提高文件系统性能</p>
<blockquote>
<ul>
<li>分区表：所有安装分区信息</li>
<li>目录缓冲结构：保存最近访问的目录信息</li>
<li>系统打开文件表</li>
<li>进程打开文件表</li>
</ul>
</blockquote>
<p>虚拟文件系统VFS（Linux）：一个操作系统可能会读取不同的文件系统，需要为它们统一访问接口</p>
<blockquote>
<ul>
<li>为各类不同的文件系统定义VFS接口</li>
<li>符合该接口的文件系统都可以接入VFS</li>
</ul>
</blockquote>
<p>网络文件系统NFS</p>
<h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><h3 id="物理块和逻辑块"><a href="#物理块和逻辑块" class="headerlink" title="物理块和逻辑块"></a>物理块和逻辑块</h3><p>物理块：</p>
<blockquote>
<ul>
<li>读写存储设备的基本单位</li>
<li>存储设备的基本分配单位</li>
<li>物理块和内存的页面大小相对应（一般为页面大小的整数倍）</li>
<li>每个物理块可以有一个一维的物理块块号</li>
</ul>
</blockquote>
<p>逻辑块：</p>
<blockquote>
<ul>
<li>逻辑块是在文件空间中的块，应当是一个相对地址块</li>
<li>大小和物理块一致</li>
<li>一个逻辑块存储在一个物理块中</li>
<li>逻辑块号和物理块号应当是一一对应的</li>
</ul>
</blockquote>
<h3 id="连续分配概念"><a href="#连续分配概念" class="headerlink" title="连续分配概念"></a>连续分配概念</h3><p>连续分配：</p>
<blockquote>
<ul>
<li>每个文件在磁盘上占用一组连续的物理块</li>
<li>文件的FCB仅给出文件等起始块号和长度</li>
</ul>
</blockquote>
<p>地址映射方式：</p>
<blockquote>
<ul>
<li>逻辑地址为文件内的相对地址LA</li>
<li>物理地址为某物理块中的某个地址(B,D)</li>
<li>物理块大小为S，逻辑块号为D=LA/S，则映射方式为：LA-&gt;(Q,D)-&gt;(B,D)</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>支持随机访问（可直接访问 指定块号的物理块）</li>
<li>存取速度块（连续访问性能高）</li>
<li>适用于一次性写入操作</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>浪费空间（存在外碎片，小空间无法分配）</li>
<li>文件不能动态增长（如日志文件需要动态增长）</li>
<li>不利于文件的插入和删除（需要移动数据）</li>
</ul>
</blockquote>
<p>改进：局部连续</p>
<h2 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>离散物理块的分配方式：</p>
<blockquote>
<ul>
<li>链接分配</li>
<li>索引分配</li>
</ul>
</blockquote>
<p>链接分配：</p>
<blockquote>
<ul>
<li>文件信息存放在若干个不连续的物理块中</li>
<li>文件的所有物理块通过指针链接形成链表结构</li>
<li>链接分配有显式链接和隐式链接</li>
</ul>
</blockquote>
<h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>策略：</p>
<blockquote>
<ul>
<li>链表的指针隐藏在物理块中</li>
<li>每个物理块中的指针指向下一个物理块</li>
<li>文件结束于空指针</li>
<li>FCB给出文件的首块地址（也可能包括结束地址）</li>
</ul>
</blockquote>
<p>地址映射方式：</p>
<blockquote>
<ul>
<li>逻辑地址为LA，物理块大小为S，指针大小为P</li>
<li>逻辑块号Q = LA/(S-P) … D</li>
<li>映射过程：LA-&gt;(Q,D)-&gt;(B,D)</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>文件离散存放，提高磁盘利用率</li>
<li>支持动态扩充文件大小</li>
<li>便于文件的插入和删除</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>不支持随机访问，访问一个指针的同时也需要读入整个物理块</li>
<li>每个物理块实际可用空间变小</li>
<li>可靠性较差，中间块的丢失可能造成后续块无法找到</li>
</ul>
</blockquote>
<p>缓解方案：可以多块集合成组</p>
<h3 id="显式链接"><a href="#显式链接" class="headerlink" title="显式链接"></a>显式链接</h3><p>策略：</p>
<blockquote>
<ul>
<li>所有指针单独为一张链接表，数据跟在指针之后，指针不和物理块挂钩</li>
<li>链接表一般在文件系统装载时装入内存</li>
<li>检索时，先访问链接表，再访问物理块；提高检索速度</li>
</ul>
</blockquote>
<p>缺点：不适合大容量磁盘；大容量磁盘的链接表也很大</p>
<h3 id="文件分配表FAT"><a href="#文件分配表FAT" class="headerlink" title="文件分配表FAT"></a>文件分配表FAT</h3><p>FAT文件系统是链接分配的一个重要变种</p>
<p>FAT32：</p>
<blockquote>
<ul>
<li>引导扇区(1)-保留扇区(31)-FAT1-FAT2(备份)-根文件夹首簇-其他文件夹及所有文件</li>
<li>每个簇（物理块）固定为4-32KB</li>
<li>FAT表的表项占据32位，在块大小为4KB时，FAT最大管理的磁盘空间为2TB</li>
<li>FAT带个文件不能大于4G</li>
</ul>
</blockquote>
<p>Ext3文件系统：Linux和Unix使用（采用索引分配，结合位示图）</p>
<h2 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>索引分配类似一种分散的FAT</p>
<blockquote>
<ul>
<li>其为每个文件建立一张文件分配表，即索引表</li>
<li>索引块：存放指向文件每个物理块块号的物理块</li>
<li>索引块中的第i项为第i个逻辑块对应的物理块块号</li>
<li>FCB指向索引块</li>
</ul>
</blockquote>
<p>地址映射方式和连续分配一样，中间加入一个指针地址转换</p>
<p>优点：</p>
<blockquote>
<ul>
<li>支持随机访问</li>
<li>离散存放，没有碎片</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>需要额外的空间存放索引表</li>
<li>磁盘访问时间增加</li>
</ul>
</blockquote>
<p>大文件无法用单级索引实现，可以采用多级索引或链接策略，注意地址映射的计算问题</p>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><h3 id="空闲表"><a href="#空闲表" class="headerlink" title="空闲表"></a>空闲表</h3><p>空闲表适用于连续分配</p>
<blockquote>
<ul>
<li>将连续的未分配的物理块集合成空闲区</li>
<li>空闲区由首块块号和空闲块数目（长度）组成</li>
<li>空闲表的每个表项对应一个空闲区</li>
</ul>
</blockquote>
<p>空闲表的分配和额回收方式和内存的连续分配类似</p>
<p>空闲表需要占据额外的存储空间</p>
<h3 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h3><p>空闲链表将磁盘上的所有空闲块链接在一个链表中</p>
<blockquote>
<ul>
<li>分配空间：从链表头依次取出适当数目的空闲块</li>
<li>回收空间：将空闲块加入链表尾部</li>
</ul>
</blockquote>
<p>优点：不需要专用块存放管理信息</p>
<p>缺点：增加IO操作，得到连续空间难</p>
<h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><p>利用一个二进制位来表示一个块的使用情况</p>
<blockquote>
<ul>
<li>1：块空闲；0：块已分配</li>
<li>所有块都有一个二进制位与之对应</li>
<li>所有块对应的位集合成位示图<br>n<br>位示图需要额外的空间，其占用一些物理块</li>
<li>比较容易得到连续的物理块</li>
<li>是Linux和Windows的常用空闲空间管理方式</li>
</ul>
</blockquote>
<h3 id="成组链接"><a href="#成组链接" class="headerlink" title="成组链接"></a>成组链接</h3><p>成组链接结合了空闲表和空闲链表</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>一致性检查和磁盘整理</p>
<h1 id="十二、大容量存储器"><a href="#十二、大容量存储器" class="headerlink" title="十二、大容量存储器"></a>十二、大容量存储器</h1><h2 id="磁盘结构和管理"><a href="#磁盘结构和管理" class="headerlink" title="磁盘结构和管理"></a>磁盘结构和管理</h2><p>磁盘结构：</p>
<blockquote>
<ul>
<li>盘片</li>
<li>磁头</li>
<li>主轴</li>
<li>接口、磁盘控制器、缓冲区</li>
</ul>
</blockquote>
<p>盘片结构：</p>
<blockquote>
<ul>
<li>磁道</li>
<li>扇区</li>
<li>柱面</li>
</ul>
</blockquote>
<p>磁盘访问时间</p>
<blockquote>
<ul>
<li>寻道时间：平均1/3磁道移动时间</li>
<li>旋转时间：平均1/2磁道旋转一周时间</li>
<li>传输时间：传输总字数/传输率</li>
</ul>
</blockquote>
<p>磁盘管理：</p>
<blockquote>
<ul>
<li>低级格式化（物理格式化）：将磁盘分成扇区</li>
<li>分区：将磁盘分成分区</li>
<li>高级格式化：逻辑格式化，创建文件系统</li>
<li>引导块</li>
</ul>
</blockquote>
<p>分区：MBR主引导记录，512字节</p>
<p>坏块检查和标记</p>
<h2 id="磁盘调度和RAID"><a href="#磁盘调度和RAID" class="headerlink" title="磁盘调度和RAID"></a>磁盘调度和RAID</h2><p>磁盘调度：缺省一般为SSTF和LOOK，请求多时采用SCAN或C-SCAN提高性能</p>
<blockquote>
<ul>
<li>FCFS：先来先服务；寻道时间长</li>
<li>SSTF：最短寻道时间优先；从请求序列中寻找离磁头最近的；存在饥饿、磁头频繁变换方向、增加寻道时间</li>
<li>SCAN：扫描算法（电梯算法）；磁头来回在柱面上扫描，处理每个请求</li>
<li>C-SCAN：仅正向扫描处理请求，等待时间更均匀</li>
<li>LOOK：双向扫描时仅移动到方向最远的请求为止（C-LOOK同理）</li>
</ul>
</blockquote>
<p>RAID结构：磁盘冗余阵列</p>
<h1 id="十三、IO系统"><a href="#十三、IO系统" class="headerlink" title="十三、IO系统"></a>十三、IO系统</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>计算机两个主要任务：</p>
<blockquote>
<ul>
<li>IO操作</li>
<li>计算</li>
</ul>
</blockquote>
<p>IO系统主要管理对象：IO设备和对应的设备控制器</p>
<p>IO系统主要任务：</p>
<blockquote>
<ul>
<li>完成用户提出的IO请求</li>
<li>提高IO速率</li>
<li>改善IO设备的利用率</li>
</ul>
</blockquote>
<p>IO系统基本功能：</p>
<blockquote>
<ul>
<li>IO驱动：对IO设备进行控制；确保对设备的正确共享</li>
<li>IO管理：提高处理机和IO设备的利用率；提供错误处理</li>
<li>隐藏物理设备的细节，与设备的无关系性</li>
</ul>
</blockquote>
<p>设备独立性：提高了操作系统的可适应性和可扩展性</p>
<blockquote>
<ul>
<li>应用程序独立于具体使用的物理设备</li>
<li>实现方法（抽象）：引入逻辑设备和物理设备，应用程序使用逻辑设备名来请求某设备；系统执行时使用物理设备名</li>
</ul>
</blockquote>
<h3 id="内核IO结构"><a href="#内核IO结构" class="headerlink" title="内核IO结构"></a>内核IO结构</h3><blockquote>
<ul>
<li>IO应用接口：内核和应用程序通信（系统调用），确保设备无关性</li>
<li>内核、内核IO子系统</li>
<li>IO驱动接口：硬件（驱动）和内核通信</li>
<li>硬件驱动程序、硬件控制器、硬件</li>
</ul>
</blockquote>
<h3 id="IO硬件"><a href="#IO硬件" class="headerlink" title="IO硬件"></a>IO硬件</h3><p>每个IO设备都有：</p>
<blockquote>
<ul>
<li>端口</li>
<li>一起共享的总线</li>
<li>设备控制器</li>
</ul>
</blockquote>
<p>控制器之间可以并行，有些设备可能由多个控制器（串行）控制</p>
<h2 id="IO控制方式"><a href="#IO控制方式" class="headerlink" title="IO控制方式"></a>IO控制方式</h2><p>IO硬件控制（通过设备地址）：</p>
<blockquote>
<ul>
<li>直接IO指令：不会占用内存空间，实现成本低</li>
<li>内存映射IO（显卡）：速度快，但会占用一部分内存</li>
</ul>
</blockquote>
<p>直接IO指令的控制方式：</p>
<blockquote>
<ul>
<li>轮询方式（早期使用）</li>
<li>中断方式</li>
<li>直接存储器访问（DMA）方式</li>
<li>IO通道控制方式（大型机器使用）</li>
</ul>
</blockquote>
<h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>流程：</p>
<blockquote>
<ul>
<li>由CPU定时发出询问，询问设备是否忙，进程进入忙等</li>
<li>不忙即进行IO</li>
</ul>
</blockquote>
<p>设备状态有就绪、忙、出错</p>
<p>特点：</p>
<blockquote>
<ul>
<li>轮询法容易实现，但效率偏低</li>
<li>CPU会长期处于忙等待</li>
<li>通信方式一般需要由应用程序实现</li>
</ul>
</blockquote>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>CPU硬件有一根中断请求线IRL，在CPU发出任务指令之后，完成任务中断由硬件发出（相当于硬件询问CPU）</p>
<p>基本中断工作机制</p>
<blockquote>
<ul>
<li>CPU执行完每条指令后，检测IRL</li>
<li>如检测到信号，CPU保存当前状态，并跳转到中断处理程序。</li>
<li>执行中断处理程序</li>
<li>执行完后，清除中断，返回</li>
</ul>
</blockquote>
<p>中断类型：</p>
<blockquote>
<ul>
<li>硬件中断</li>
<li>软中断（陷入trap）：由CPU内部事件引起的中断</li>
</ul>
</blockquote>
<p>中断处理程序：</p>
<blockquote>
<ul>
<li>检测是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复CPU的现场并退出中断</li>
</ul>
</blockquote>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>不使用DMA时，数据从设备缓冲区到内存的操作是由CPU完成的</p>
<p>DMA可以避免用程序来控制IO传输大量数据</p>
<p>DMA可以接受CPU的指令，直接在IO设备和内存之间传输数据，然后通过中断通知CPU</p>
<h3 id="IO通道控制方式"><a href="#IO通道控制方式" class="headerlink" title="IO通道控制方式"></a>IO通道控制方式</h3><p>通道是一个专门处理IO指令的处理器，它的性能介于控制器和CPU之间</p>
<h2 id="内核IO子系统"><a href="#内核IO子系统" class="headerlink" title="内核IO子系统"></a>内核IO子系统</h2><p>内核提供了许多IO有关的服务，其建立在硬件和设备驱动程序结构之上，还负责保护自己免受错误进程和恶意用户的危害</p>
<p>某些IO请求需要按设备队列排序</p>
<p>操作系统为每个设备设置一个设备请求队列，并为其设置调度算法</p>
<p>P408请求生命周期</p>
<h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p>在现代操作系统中，几乎所有的I/O设备在与CPU交换数据时，都用了缓冲区。</p>
<p>缓冲区是一个存储区域，可以由专门的硬件组成；更多的是利用内存。</p>
<p>引入缓冲的理由</p>
<blockquote>
<ul>
<li>解决设备之间的速度差异</li>
<li>协调传输数据大小不一致</li>
<li>支持应用程序IO的“复制语义”（防止读脏数据）</li>
</ul>
</blockquote>
<h3 id="高速缓存Cache"><a href="#高速缓存Cache" class="headerlink" title="高速缓存Cache"></a>高速缓存Cache</h3><p>Cache－ 保留数据拷贝的高速内存</p>
<blockquote>
<ul>
<li>仅仅是一个拷贝</li>
<li>关键是性能</li>
</ul>
</blockquote>
<p>与缓冲的区别</p>
<blockquote>
<ul>
<li>缓冲可能是数据的唯一一个副本</li>
<li>高速缓存是其他地方数据在高速存储上的一个副本</li>
</ul>
</blockquote>
<h3 id="假脱机SPOOLing"><a href="#假脱机SPOOLing" class="headerlink" title="假脱机SPOOLing"></a>假脱机SPOOLing</h3><p>为了缓和CPU的高速性与I/O设备的低速性间的矛盾而引入了脱机输入、脱机输出技术。</p>
<blockquote>
<ul>
<li>程序模拟脱机输入，把低速I/O设备上的数据传送到高速磁盘上</li>
<li>另一程序模拟脱机输出，把数据从磁盘传送到低速输出设备</li>
<li>此时，外围操作与CPU对数据的处理同时进行，这种在联机情况下实现的同时外围操作称为 假脱机技术SPOOLing。</li>
</ul>
</blockquote>
<p>优点</p>
<blockquote>
<ul>
<li>提高了I/O的效率（本质没有提升速度）</li>
<li>将独占设备改造为共享设备</li>
<li>实现了虚拟设备功能</li>
</ul>
</blockquote>
<p>假脱机打印技术：</p>
<blockquote>
<ul>
<li>磁盘缓冲区</li>
<li>打印缓冲区</li>
<li>假脱机管理进程和假脱机打印进程</li>
</ul>
</blockquote>
<h3 id="错误与保护"><a href="#错误与保护" class="headerlink" title="错误与保护"></a>错误与保护</h3><p>…</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/09/06/computer-network0/</url>
    <content><![CDATA[<p>钱龙华：<a href="mailto:qianglonghua@suda.edu.cn">qianglonghua@suda.edu.cn</a></p>
<p><a href="http://nlp.suda.edu.cn/˜qianlonghua" target="_blank" rel="noopener">http://nlp.suda.edu.cn/˜qianlonghua</a></p>
<p>课程目标：理解网络工作的原理以及实现</p>
<p>没有多少理论，但课程课程的实践性很强</p>
<p>参考教材：《数据通信与网络》、《计算机网络技术Andrew S.》、《计算机网络自顶向下方法（从宏观到微观的设计）》</p>
<a id="more"></a>

<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-1-计算机网络的发展过程"><a href="#1-1-计算机网络的发展过程" class="headerlink" title="1.1 计算机网络的发展过程"></a>1.1 计算机网络的发展过程</h2><h3 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h3><p>ENAIC - TSS分时系统 - 计算机网络</p>
<p>从以主机为中心到以分组交换网为中心</p>
<p>萌芽：1969第一个分组交换网络ARPANET</p>
<blockquote>
<ul>
<li>路径选择（路由）</li>
<li>信息的发送和接收：通讯协议NCP（网络通讯协议）</li>
<li>基本思想：分组交换</li>
<li>原理：将报文分组进行传送</li>
<li>目的：提高传输效率和减小延迟</li>
</ul>
</blockquote>
<p>从NCP到TCP/IP：</p>
<blockquote>
<ul>
<li>1974年TCP/IP参考模型，1983年TCP/IP模型</li>
</ul>
</blockquote>
<p>LAN（局域网）的兴起</p>
<p>发展：公共网络的繁衍</p>
<blockquote>
<ul>
<li>从军事网络到民用科研网络</li>
<li>1986年，ARPANET改名为Internet</li>
</ul>
</blockquote>
<p>繁荣：网络商业化</p>
<blockquote>
<ul>
<li>通讯公司开始投入构建主干网络ISP</li>
<li>网络应用发展和推广（www、即时通讯、邮件、MOBA游戏）</li>
</ul>
<p>关于计算模式的演变：HOST模式（主机模式）；C/S模式（主机客户端模式）；P2P模式（双端计算任务平等）；网格计算模式-云计算模式</p>
</blockquote>
<h3 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h3><p>互联网工程部IETF、互联网研究部IRTF</p>
<p>互联网标准的形式：RFC文档</p>
<p>互联网正式标准的制定：</p>
<blockquote>
<ul>
<li>互联网草案</li>
<li>建议标准</li>
<li>互联网标准</li>
</ul>
</blockquote>
<h2 id="1-2-计算机网络的分类"><a href="#1-2-计算机网络的分类" class="headerlink" title="1.2 计算机网络的分类"></a>1.2 计算机网络的分类</h2><h3 id="计算机网络的不同定义"><a href="#计算机网络的不同定义" class="headerlink" title="计算机网络的不同定义"></a>计算机网络的不同定义</h3><blockquote>
<ul>
<li>具有独立功能的计算机、终端、设备用通信线路连接起来，按一定方式进行通信并实现资源共享的系统</li>
<li>简单定义：一些相互连接、自治的计算机的集合</li>
<li>因特网是“网络的网络”</li>
</ul>
</blockquote>
<h3 id="信息的交换"><a href="#信息的交换" class="headerlink" title="信息的交换"></a>信息的交换</h3><p>电路交换：从人工控制到程序交换</p>
<blockquote>
<ul>
<li>这种连接是一条专用的物理通路</li>
<li>步骤：建立连接（占用通信资源）、通话（一直占用资源）、释放连接（归还通信资源）</li>
</ul>
</blockquote>
<p>报文交换：存储转发技术</p>
<blockquote>
<ul>
<li>过程：报文整体通过结点的转发达到目标主机</li>
<li>延迟较长</li>
</ul>
</blockquote>
<p>分组交换：将报文整体切割传输</p>
<blockquote>
<ul>
<li>步骤：报文进行切割并发传输，到目标主机再进行组合</li>
<li>主机发送的数据不是独占的，一个用户可以并发的发送或接受数据</li>
<li>可靠性好，网络中结点的损坏对整个网络影响很小</li>
<li>优点: 高效,灵活,迅速,可靠</li>
</ul>
</blockquote>
<h3 id="其他分类"><a href="#其他分类" class="headerlink" title="其他分类"></a>其他分类</h3><p>网络的覆盖范围：</p>
<blockquote>
<ul>
<li>局域网LAN</li>
<li>城域网MAN：有线电视网络</li>
<li>广域网WAN</li>
</ul>
</blockquote>
<p>网络的使用者</p>
<blockquote>
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</blockquote>
<p>传输技术</p>
<blockquote>
<ul>
<li>点对点网络</li>
<li>广播网络：涉及寻址、冲突问题</li>
</ul>
</blockquote>
<h2 id="1-3-计算机网络主要性能指标"><a href="#1-3-计算机网络主要性能指标" class="headerlink" title="1.3 计算机网络主要性能指标"></a>1.3 计算机网络主要性能指标</h2><h3 id="带宽和速率"><a href="#带宽和速率" class="headerlink" title="带宽和速率"></a>带宽和速率</h3><p>带宽：原指信号具有的频带宽度（差值）；在数字信号中，带宽是最高数据传输速率，单位是比特每秒</p>
<p>速率：数据的传送速率</p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>发送时延（传输时延）：主机或路由器发送数据帧所需要的时间</p>
<blockquote>
<ul>
<li>发送时延 = 数据快长度/带宽</li>
</ul>
</blockquote>
<p>传播时延：电磁波在信道中传播一定的距离需要花费的时间</p>
<blockquote>
<ul>
<li>传播时延 = 信道长度/信号在信道上的传播速率</li>
</ul>
</blockquote>
<p>四种时延产生的地方：</p>
<blockquote>
<ul>
<li>发送结点中的处理时延和排队时延</li>
<li>数据的发送时延和传播时延</li>
</ul>
</blockquote>
<p>往返时延RTT：从发送端发送数据开始，到发送端收到来自接收端的确认信息，总经历的时延</p>
<p>时延带宽积：表示管道中能同时容纳的数据量</p>
<blockquote>
<ul>
<li>时延带宽积 = 传播时延*带宽</li>
</ul>
</blockquote>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率：某信道在某段时间内有百分之几的时间是被利用的（有数据通过）</p>
<p>网络利用率：全网络的信道利用率的加权平均值</p>
<p>信道或网络利用率过高会产生非常大的时延，且随着利用率的升高时延</p>
<h2 id="1-4-计算机网络的体系结构"><a href="#1-4-计算机网络的体系结构" class="headerlink" title="1.4 计算机网络的体系结构"></a>1.4 计算机网络的体系结构</h2><h3 id="网络通信的分层"><a href="#网络通信的分层" class="headerlink" title="网络通信的分层"></a>网络通信的分层</h3><p>网络通信过程十分复杂：</p>
<blockquote>
<ul>
<li>需要简化网络设计</li>
<li>采用结构化的设计方法</li>
<li>使用层次化的分而治之的策略</li>
</ul>
<p>需要提高网络互联的标准化程度</p>
</blockquote>
<p>原理：</p>
<blockquote>
<ul>
<li>网络按功能分成一系列层次，每一层完成一个特定的功能</li>
<li>相邻层中较高层直接使用较低层的服务实现本层功能，然后向更高层提供服务</li>
<li>层之间的通信用接口实现</li>
</ul>
</blockquote>
<p>服务、接口和协议：</p>
<blockquote>
<ul>
<li>实体：一个特定的网络模块、软件</li>
<li>对等实体：不同计算机上同一层的实体</li>
<li>协议：为进行计算机网络中的数据交换而建立的对等实体间的通信规则、标准或约定的集合</li>
<li>接口：相邻两层之间的边界；规定了下层向上层提供的服务</li>
<li>服务：某一层向上层提供的功能</li>
<li>网络体系结构：计算机网络各层级及其协议的集合</li>
<li>协议栈：网络各层协议按照层次顺序排列而形成的协议序列</li>
</ul>
</blockquote>
<p>多层通信的实质：</p>
<blockquote>
<ul>
<li>发送段将数据一层一层向下封装（直到实体通信层）</li>
<li>接收端将数据一层一层向上解封</li>
<li>这样，对等实体层之间形成虚拟通信</li>
</ul>
</blockquote>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>网络协议的三个要素：</p>
<blockquote>
<ul>
<li>语义：设计需要发出何种控制信息，以及如何回应的规范</li>
<li>语法：设计数据与控制信息的结构与格式</li>
<li>时序：设计速度匹配与事件顺序</li>
</ul>
</blockquote>
<p>协议的困惑：无法设计一个100%可靠的协议（山头进攻问题）</p>
<h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>面相连接的服务：面向连接服务具有连接建立、数据传输和连接释放三个阶段<br>那你<br>无连接服务：两个实体之间通信不需要先建立好连接</p>
<h3 id="网络参考模型"><a href="#网络参考模型" class="headerlink" title="网络参考模型"></a>网络参考模型</h3><p>OSI参考模型：开放系统互联模型</p>
<blockquote>
<ul>
<li><p>从下到上分为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层</p>
</li>
<li><p>前三层为网络支持层，解决数据如何传输的问题</p>
</li>
<li><p>第四层解决可靠性问题</p>
</li>
<li><p>后三层为用户子网络，决定传输什么数据</p>
</li>
<li><p>物理层：在<strong>物理媒体</strong>上传输原始数据的<strong>比特流</strong></p>
</li>
<li><p>数据链路层：在<strong>相邻节点</strong>间无差错地传输一<strong>帧</strong>数据</p>
</li>
<li><p>网络层：将<strong>分组</strong>穿过<strong>通信子网</strong>从信源传输到信宿，包括路由选择等；这一层的通讯不一定可靠</p>
</li>
<li><p>传输层：提供端到端的数据传输服务，强调可靠性，往往采用面相连接的传输服务，进行差错控制（开始面相用户）</p>
</li>
<li><p>会话层：在两个互相通信的进程之间建立、组织和同步会话以及会话管理和控制</p>
</li>
<li><p>表示层：提供数据或信息语法的表示变换，以确保不同表示方法（加密算法等）之间的计算机能够相互通讯</p>
</li>
<li><p>应用层：直接面相用户（或应用进程，如DNS）提供服务</p>
</li>
</ul>
</blockquote>
<p>缺点：层次过多传送少量数据时效率极其低下</p>
<p>TCP/IP参考模型：</p>
<blockquote>
<ul>
<li>从下到上分为网络接口层、网络互联层（网际层）、传输层、应用层</li>
<li>网络接口层：负责传输数据帧，类似物理层和数据链路层</li>
<li>网际层（IP）：相当于网络层</li>
<li>传输层（TCP或UDP）：相当于OSI中的传输层</li>
<li>应用层：各种应用服务，相当于会话层、表示层和应用层</li>
</ul>
</blockquote>
<p>IP体系的沙漏模型：核心是IP网际层</p>
<p>每层的协议</p>
<blockquote>
<ul>
<li>应用层：HTTP</li>
<li>运输层：TCP/UDP</li>
<li>网际层：IP</li>
<li>网络接口层：ETHERNET（以太网）</li>
</ul>
</blockquote>
<h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><blockquote>
<ul>
<li>功能：在物理媒体上传输原始的数据比特流</li>
<li>任务：确定与传输媒体的接口的一些特性</li>
</ul>
</blockquote>
<h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><p>几个术语：</p>
<blockquote>
<ul>
<li>数据：运送信息的实体</li>
<li>信号：数据的电气或电磁的表现</li>
<li>模拟的：连续变化的</li>
<li>数字的：取值是离散数值</li>
<li>调制：将数字信号转换为模拟信号的过程</li>
<li>解调：将模拟信号转换成数字信号的过程</li>
</ul>
</blockquote>
<p>有关信号的几个基本概念：</p>
<blockquote>
<ul>
<li>单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。</li>
<li>双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li>双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。</li>
</ul>
</blockquote>
<p>基带信号和宽带信号：</p>
<blockquote>
<ul>
<li>基带信号就是将数字信号1或0直接用两种不同的电压来表示，然后送到线路上去传输。 </li>
<li>宽带信号则是将基带信号进行调制后形成的频分复用模拟信号</li>
</ul>
</blockquote>
<p>码和波特率：</p>
<blockquote>
<ul>
<li>码元：时间轴上的一个信号编码单位</li>
<li>波特率：每秒钟发送的码元数（每秒钟电压变化的次数）</li>
<li>比特率：比特率S=波特率B*log2(N)；N为一个码元中的状态数</li>
<li>奈氏准则：理想低通信道最高码元传输速率为两倍的信道带宽</li>
</ul>
</blockquote>
<p>信道的极限信息传输速率：</p>
<blockquote>
<ul>
<li>信道：向某一个方向传送信息的媒体</li>
<li>C = Wlog2(1+S/N) b/s</li>
<li>W为信道带宽(Hz)</li>
<li>S为信道内所传信号的平均功率</li>
<li>N为信道内部的高斯噪声功率</li>
</ul>
</blockquote>
<h2 id="2-3-物理层的传输媒体"><a href="#2-3-物理层的传输媒体" class="headerlink" title="2.3 物理层的传输媒体"></a>2.3 物理层的传输媒体</h2><p>导向传输介质：</p>
<blockquote>
<ul>
<li>双绞线：双绞线既可以传输数字信号，又可以传输模拟信号</li>
<li>同轴电缆</li>
<li>光纤：抗干扰，不容易腐蚀；多模光纤（短距离小容量传输）；单模光纤（大容量长距离传输）</li>
</ul>
</blockquote>
<p>非导向传输媒体：</p>
<blockquote>
<ul>
<li>视线介质：微波、红外线和激光</li>
<li>无线电传输</li>
<li>地球同步卫星</li>
<li>低轨系统</li>
</ul>
</blockquote>
<h2 id="2-4-模拟传输与数字传输"><a href="#2-4-模拟传输与数字传输" class="headerlink" title="2.4 模拟传输与数字传输"></a>2.4 模拟传输与数字传输</h2><h3 id="模拟传输系统"><a href="#模拟传输系统" class="headerlink" title="模拟传输系统"></a>模拟传输系统</h3><p>连续波数字调制方法：</p>
<blockquote>
<ul>
<li>ASK(AM)：调幅</li>
<li>FSK：调频</li>
<li>PSK：调相;4-PSK;16-APSK(QAM)</li>
<li>QAM能将4K带宽的电话线传输64Kbps的数字信号</li>
</ul>
</blockquote>
<h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><p>数字数据的数字信号编码：</p>
<blockquote>
<ul>
<li>NRZ：正负电平表示0和1；要求收发双方时钟严格同步</li>
<li>Manchester：电平从正到负、从负到正的变化表示0和1；解决时钟同步问题</li>
<li>差分Manchester：两个时钟信号之间电平变化表示0，不变表示1</li>
</ul>
</blockquote>
<p>同步光纤网SONET：各级时钟都来自于一个非常精确的主时钟</p>
<h3 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h3><blockquote>
<ul>
<li>模拟信号-PAM-采样模拟数据（水平采样频率是最高频率的两倍即可）</li>
<li>采样模拟数据-量化-量化数据</li>
<li>量化数据-二进制编码-二进制数据</li>
<li>二进制数据-线性编码-数字信号</li>
</ul>
</blockquote>
<h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><p>信道复用：多个信息源共享一个公共信道</p>
<blockquote>
<ul>
<li>频分复用FDM：不同频率叠加然后恢复（传统电话、有线电视）</li>
<li>同步时分复用TDM：不同终端严格分时使用信道（有可能造成线路利用率降低）</li>
<li>统计时分复用TDM：分时使用信道，每个数据包前加头地址文件来区分（ATM，但使用复杂，现已弃用）</li>
<li>波分复用WDM：光的频分复用；DWDM，高密度波分复用</li>
<li>码分复用CDMA：各用户经过特殊挑选的不同码型，彼此之间不会干扰（抗干扰能力强，频谱类似白噪声）；每个码片序列必须正交</li>
</ul>
</blockquote>
<p>T1信道：</p>
<blockquote>
<ul>
<li>每秒8000次采样；24路信号，每路8位，每帧有1位同步比特</li>
<li>数据速率：1.544Mbps</li>
</ul>
</blockquote>
<p>E1信道：</p>
<blockquote>
<ul>
<li>32路信号（2路同步信号）</li>
<li>数据速率：2.048Mbps</li>
</ul>
</blockquote>
<h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><blockquote>
<ul>
<li>ADSL：非对称数字用户线</li>
<li>HFC：光纤同轴混合网</li>
<li>FTTx：光纤到x（终端）</li>
</ul>
</blockquote>
<h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><p>链路：一条无源的点到点的物理线路段，中间没有任何其他的交换节点</p>
<blockquote>
<p>一条链路只是一条通路的一个组成部分</p>
</blockquote>
<p>数据链路：链路和通信协议与软件的组合</p>
<p>数据链路传送的数据单位：帧</p>
<p>主要功能：</p>
<blockquote>
<ul>
<li>链路管理</li>
<li>帧定界：如何确定帧的开始和结束</li>
<li>流量控制：保证发送的速度不会超过接收端的最大接收速度</li>
<li>差错控制</li>
</ul>
</blockquote>
<h2 id="3-2-帧定界"><a href="#3-2-帧定界" class="headerlink" title="3.2 帧定界"></a>3.2 帧定界</h2><ul>
<li>字节计数法：帧同步-帧长度-帧内容-校验位；若帧长度出错则整个帧丢失</li>
<li>字符填充法：面相字符的通信协议，STX-帧内容-ETX；兼容性差，发送文本中不能出现STX和ETX（通过插入转义符DLE来进行区分）</li>
<li>使用比特填充的首尾标记法：连续6个二进制1来界定帧的开始和结束（需要解决通明性）</li>
<li>编码违例法：利用违反编码规律的策略来标志帧的边界；无需填充，需要物理层支持</li>
</ul>
<h2 id="3-3-差错控制"><a href="#3-3-差错控制" class="headerlink" title="3.3 差错控制"></a>3.3 差错控制</h2><p>附加监督位：通过在数据快中加入一些冗余信息来验证关联关系是否存在</p>
<ul>
<li>奇偶校验码：效率不高</li>
<li>校验和：数据按比特位加和取补形成校验位发送；验证时校验位和前面加和，结果应为补码0</li>
<li>循环冗余校验码CRC：利用除法计算（异或）；可检测出几乎所有错误，除非差错和除数变化规律相同；易于硬件实现</li>
</ul>
<p>差错控制策略：</p>
<blockquote>
<ul>
<li>ARQ自动重发请求：发送方发送完一帧后一段时间没有收到应答，便进行重发</li>
<li>前向纠错：发送端使用纠错码，接收端检出错误并纠正错误；纠错机制复杂，适合用于没有应答的单工通信中</li>
</ul>
</blockquote>
<h2 id="3-4-PPP点对点协议"><a href="#3-4-PPP点对点协议" class="headerlink" title="3.4 PPP点对点协议"></a>3.4 PPP点对点协议</h2><p>组成部分：</p>
<blockquote>
<ul>
<li>将IP数据报封装成串行链路的方法</li>
<li>链路控制协议LCP</li>
<li>网络控制协议NCP</li>
</ul>
</blockquote>
<p>协议帧格式：F(1)-A(1)-C(1)-协议(2)-IP数据报(不超过1500字节)-FCS(2)-F(1)</p>
<blockquote>
<ul>
<li>由01111110，7E来界定开始和结束</li>
<li>A为地址，全1表示广播（不启用）；C为差错控制（不启用）</li>
<li>通明传输问题：同步时进行比特填充；异步时进行字符填充</li>
<li>FCS：检错位，帧检验序列</li>
</ul>
</blockquote>
<p>特点：</p>
<blockquote>
<ul>
<li>透明性，支持多个网络协议</li>
<li>提供检错而非纠错机制，也没有ARQ超时重发机制</li>
</ul>
</blockquote>
<h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><p>拓扑结构：</p>
<blockquote>
<ul>
<li>总线结构：一根电缆连接所有节点</li>
<li>环形结构：所有设备一个输入，一个输出</li>
</ul>
</blockquote>
<p>信道分配策略：</p>
<blockquote>
<ul>
<li>静态分配：站点少且固定；数据量大</li>
<li>动态分配：抢占、分时或预约</li>
</ul>
</blockquote>
<p>HLOHA NET：第一个局域网（无线）</p>
<blockquote>
<ul>
<li>争用协议：想说就说</li>
<li>边说边听</li>
<li>随机重发</li>
<li>时隙ALOHA：分时间片进行发送</li>
</ul>
</blockquote>
<p>CSMA：监听多点接入局域网</p>
<blockquote>
<ul>
<li>先听后说：先进行监听，信道空闲时进行发送</li>
<li>坚持CSMA：一直监听信道，空闲即立马发送</li>
<li>P坚持CSMA：监听信道，空闲之后隔概率发送</li>
</ul>
</blockquote>
<p>CSMA/CD：载波监听多点接入/碰撞检测</p>
<blockquote>
<ul>
<li>边发送边检测，2t之后没有发现冲突，便认为成功发送；否则发生冲突、停止发送（截断的二进制指数退避算法）</li>
<li>发送后的一小段时间内存在着遭遇碰撞的不确定性</li>
<li>半双工通信</li>
<li>整个以太网平均通信速率远小于网络最大通信速率</li>
</ul>
</blockquote>
<p>传统以太网：</p>
<blockquote>
<ul>
<li>DIX Ethernet和IEEE 802协议（分为LLC帧和MAC帧）</li>
<li>连接方法：铜缆、铜线（双绞线）、光缆</li>
<li>10BASE-1、10BASE-2：同轴线、总线结构</li>
<li>10BASE-T双绞线连接、物理上星型结构（逻辑上总线结构）</li>
</ul>
</blockquote>
<h2 id="以太网的MAC层"><a href="#以太网的MAC层" class="headerlink" title="以太网的MAC层"></a>以太网的MAC层</h2><p>以太网V2 MAC帧：</p>
<blockquote>
<ul>
<li>目的地址（6）</li>
<li>源地址（6）</li>
<li>类型（2）</li>
<li>数据（46-1500）：IP数据报，46字节长度保证整个MAC帧不能少于64字节，保证2t的冲突检测时间</li>
<li>FCS（4）</li>
</ul>
</blockquote>
<p>EUI-48地址：16位</p>
<blockquote>
<ul>
<li>网卡从网络上每收到一个MAC帧，首先用硬件检查目的地址</li>
<li>如果是发往本站的帧则收下并进行处理，否则将帧丢弃</li>
</ul>
</blockquote>
<h2 id="扩展的局域网"><a href="#扩展的局域网" class="headerlink" title="扩展的局域网"></a>扩展的局域网</h2><p>物理层的扩展：中继器Repeater</p>
<ul>
<li>用于双向信号复原放大、延长网络距离</li>
<li>不能无限制扩展网络长度（有时延）</li>
<li>处理单位是数据比特，不能识别链路层或网络层的协议，不提供网段之间的隔离</li>
<li>集线器：多端口中继器；用多个集线器可以链接成更大的局域网；扩大了碰撞域</li>
</ul>
<p>数据链路层的扩展：网桥Bridge</p>
<ul>
<li>能够扩大网络地址范围，进行数据帧的过滤（同侧过滤）和转发（异侧转发）</li>
<li>网桥内部有地址端口映射表，可以检测某个地址在网桥哪一侧的端口上</li>
<li>优点：没有扩大碰撞域；扩大了网络的物理范围、提高了可靠性</li>
<li>缺点：存储转发增加了时延（但不会对CSMA/CD产生影响）；隔离了冲突域但不能隔离广播域（过大的广播域会造成广播风暴）</li>
<li>透明网桥的逆向学习法：<ul>
<li>透明网桥是一种即插即用设备，刚接入时其不知道所发送的帧经过哪些网桥</li>
<li>逆向学习法：有设备发送数据包时，网桥可以将其地址和所在端口进行绑定，学习到设备的地址</li>
</ul>
</li>
<li>透明网桥的支撑树算法：避免两个局域网中存在多个网桥而造成的帧回路转发问题</li>
</ul>
<p>多端口网桥：以太网交换机</p>
<blockquote>
<ul>
<li>交换机是一种快速多端口网桥</li>
<li>其利用一个电子开关高速背板作为总线交换部件，可以进行硬件级别的数据并行传输</li>
</ul>
<p>转发方式：</p>
<ul>
<li>存储转发：将整个帧接受后进行差错校验然后进行转发；交换延迟较大</li>
<li>穿通转发：接收到帧的前6个地址字节就进行转发；交换延迟小；但无法进行差错校验</li>
<li>无碎片穿通：检查帧的前64字节（帧不满64字节表明其为冲突碎片，需要丢弃）然后直接进行转发；交换延迟相对较小；但无法检测长度大于64字节的错误帧</li>
</ul>
</blockquote>
<p>虚拟局域网技术VLAN：解决广播风暴问题</p>
<blockquote>
<ul>
<li>分割广播域</li>
<li>原理：扩展交换机功能（两层交换机），在MAC帧中插入一个4字节的VLAN标记，用于在交换机之间进行传输（对于终端而言帧格式不变）</li>
<li>不同虚拟局域网（子网）之间通信需要经过路由器；当然也有集成了路由功能的交换机（三层交换机）</li>
</ul>
</blockquote>
<h2 id="3-5-高速以太网"><a href="#3-5-高速以太网" class="headerlink" title="3.5 高速以太网"></a>3.5 高速以太网</h2><p>100BASE-T为快速以太网</p>
<p>在高速以太网中仍可使用CSMA/CD模式：</p>
<blockquote>
<ul>
<li>帧时间间隔从9.6us减少为0.96us</li>
</ul>
</blockquote>
<p>100BASE-T的物理层标准：</p>
<blockquote>
<ul>
<li>100BASE-TX：2对UTP5类线，4B/5B编码，全双工通信</li>
<li>100BASE-FX：2对光纤</li>
<li>100BASE-T4：4对UTP3类线，8B/6T-NRZ编码，3对发送，只能半双工通信</li>
</ul>
</blockquote>
<p>吉比特（千兆）以太网：</p>
<blockquote>
<ul>
<li>半双工下使用CSMA/CD协议，全双工不需使用CSMA/CD</li>
<li>半双工下的CSMA/CD需要增大逻辑帧的最小长度，需要进行载波延伸，争用时间增加为512字节，但保持最小帧长为64字节（分组突发，可以使用一次同时发多个帧的方式来延长检测时间）</li>
</ul>
</blockquote>
<p>10吉比特以太网：使用光纤，无需CSMA/CD</p>
<h1 id="四、网络互联"><a href="#四、网络互联" class="headerlink" title="四、网络互联"></a>四、网络互联</h1><p>网际层、IP层</p>
<h2 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h2><p>直接交付和间接交付：</p>
<blockquote>
<ul>
<li>直接交付：将数据交付到局域网，通过数据链路层即可</li>
<li>间接交付：将数据交付到另外一个网络，需要路由器</li>
</ul>
</blockquote>
<p>网络层提供的服务：</p>
<blockquote>
<ul>
<li>虚电路服务：保证双方通信所需的一切网络资源（主要用于电话服务）</li>
<li>数据报服务：无需预留资源，按需分配但不可靠（广泛用于网络服务）</li>
</ul>
</blockquote>
<h2 id="4-2-网际协议IP"><a href="#4-2-网际协议IP" class="headerlink" title="4.2 网际协议IP"></a>4.2 网际协议IP</h2><p>IP协议的配套协议：</p>
<blockquote>
<ul>
<li>ARP：地址解析协议；IP地址-&gt;MAC地址</li>
<li>RARP：逆地址解析协议；MAC地址-&gt;IP地址</li>
<li>ICMP：因特网控制报文协议</li>
<li>IGMP：因特网组管理协议</li>
</ul>
</blockquote>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>表示方法：32bit的标识符</p>
<p>编址方法：</p>
<blockquote>
<ul>
<li>分类的IP地址</li>
<li>子网的划分</li>
<li>构成超网</li>
</ul>
</blockquote>
<p>分类的IP地址：分为网络号和主机号：</p>
<blockquote>
<ul>
<li>A类地址(0-127)：第一位为0，取前8位为网络号，后面为主机号</li>
<li>B类地址(128-191)：开头为10，取前16位为网络号</li>
<li>C类地址(192-223)：开头为110，取前24位为网络号</li>
<li>D类地址(224-239)：开头为1110，整个IP地址为多播地址</li>
<li>E类地址(240-255)：开头为11110，保留地址</li>
</ul>
</blockquote>
<p>IP地址分配原则：</p>
<blockquote>
<ul>
<li>同一个网络中网络号必须一样</li>
<li>路由器总是具有两个或以上的IP地址，其每一个接口都有一个不同网络号的IP地址</li>
</ul>
</blockquote>
<p>IP地址与硬件地址：IP数据报首部为IP地址，IP数据报作为数据分装在MAC帧中</p>
<p>数据报的转发：</p>
<blockquote>
<ul>
<li>数据链路层：MAC帧的转发；每经过一个路由器时MAC地址都会改变</li>
<li>网际层：IP数据报的转发；转发过程中IP源地址和目标地址不会改变</li>
</ul>
</blockquote>
<h3 id="ARP和RARP协议"><a href="#ARP和RARP协议" class="headerlink" title="ARP和RARP协议"></a>ARP和RARP协议</h3><p>ARP协议：在数据链路层中传输数据帧时需要用到MAC地址</p>
<blockquote>
<ul>
<li>主机A广播发送ARP请求分组：使用广播MAC帧，其中包含A主机的IP和MAC地址与主机B的IP地址</li>
<li>主机B向A发送ARP相应分组：使用单播MAC帧，其中包含B主机的IP地址和MAC地址</li>
<li>获得到相应的IP地址后，主机将各IP地址和硬件地址的映射存入ARP高速缓存中，定期更新（地址解析是自动进行的）</li>
<li>安全性问题：ARP攻击，主机C伪装成主机B提前对A进行回应</li>
<li>性能问题：网络风暴</li>
</ul>
</blockquote>
<p>RARP协议（目前少用）：</p>
<blockquote>
<ul>
<li>主机A广播发送RARP请求，查询自己的IP地址：其中包括自己的MAC地址</li>
<li>RARP服务器相应RARP请求，返回主机A的MAC地址和IP地址</li>
<li>RARP思路的应用：BOOTP网络启动协议、DHCP动态主机配置协议</li>
</ul>
</blockquote>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>数据报的格式：首部(20*8)-数据报</p>
<p><img src="/2020/09/06/computer-network0/IP0.jpg" alt="IP"></p>
<blockquote>
<ul>
<li>首部32位一行，一共6行，最后一行为可选字段和填充</li>
<li>版本：ipv4/ipv6；首部长度：5/6行；总长度：最长64k</li>
<li>当IP数据报较大时，无法传输的路由器需要将其进行分片，到目的地进行组装</li>
<li>标识：产生分片数据报标识</li>
<li>标志：标志是否允许分片以及是否是是最后分片</li>
<li>片偏移：该分组在原数据报中点相对位置，偏移以8个字节为偏移单位</li>
<li>生存时间TTL：计数器，每经过一个路由器减一，值为0时丢弃，防止路由回路；初始值一般为255或128</li>
<li>协议：指明数据部分采用何种协议（ICMP、IGMP、TCP、UDP…），以便上层进一步处理数据</li>
<li>首部检验和：检验和保证首部的校验和恒为0（全1）否则出错；数据部分不参与检验和的计算</li>
<li>源地址：必须为单播地址</li>
</ul>
</blockquote>
<p>IP分组转发：路由表</p>
<blockquote>
<ul>
<li>路由器感觉收到的网络目标地址，查找路由表，找出下一个路由器并将数据从下一个路由器中转发出去</li>
</ul>
</blockquote>
<h2 id="4-3-子网的划分和超网的构造"><a href="#4-3-子网的划分和超网的构造" class="headerlink" title="4.3 子网的划分和超网的构造"></a>4.3 子网的划分和超网的构造</h2><h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>较大的局域网会发生广播风暴，需要对子网进行划分</p>
<p>从主机号中占用若干个比特作为子网号</p>
<blockquote>
<ul>
<li>三级IP地址：网络号-子网号-主机号</li>
<li>子网掩码：用于屏蔽主机号，只取网络号和子网号（取并）</li>
<li>IP地址 AND 子网掩码 = 网络地址</li>
</ul>
</blockquote>
<p>子网的划分会导致实际可用IP地址减少</p>
<h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p>无分类编址CIDR：</p>
<blockquote>
<ul>
<li>IP地址：网络前缀,主机号</li>
<li>CIDR地址快带一个后缀n，表明前n位为CIDR地址块，后32-n位可自行分配</li>
</ul>
</blockquote>
<p>一个CIDR地址块可以包含多个IP地址，这些地址合起来就构成超网</p>
<blockquote>
<ul>
<li>路由聚合使得路由表中点一个项目可以表示多个原来传统分类地址的路由</li>
<li>CIDR一般用于主干网络中</li>
<li>使用最长前缀匹配来查找下一跳地址</li>
</ul>
</blockquote>
<p>一些特殊IP地址：</p>
<blockquote>
<ul>
<li>网络地址 | 00000000：用于标识一个网络，一般不分配给主机</li>
<li>网络地址 | 11111111：直接广播地址，向网络中所有主机广播</li>
<li>全0：本主机，不可作为有效目的地址使用</li>
<li>全1：有限广播地址，不可作为源主机地址</li>
<li>00…00 | 主机地址：表示本网某台主机，不可作为有效目的地址使用</li>
<li>01111111 | …：同送地址，表示本主机(127.0.0.1)，其在IP层会被弹回，不进入数据链路层</li>
</ul>
</blockquote>
<h2 id="4-4-因特网控制报文协议ICMP"><a href="#4-4-因特网控制报文协议ICMP" class="headerlink" title="4.4 因特网控制报文协议ICMP"></a>4.4 因特网控制报文协议ICMP</h2><p>ICMP允许主机或路由器报告差错情况提供有关异常情况的报告</p>
<blockquote>
<ul>
<li>差错报告：终点不可达、源站抑制、超时、参数问题、改变路由（重定向）</li>
<li>询问报文：回送/时间戳/掩码地址请求和回答报文、路由询问和通告报文</li>
</ul>
</blockquote>
<p>ICMP不是高层协议，而是IP层内的协议</p>
<p>报文格式：</p>
<blockquote>
<ul>
<li>类型(8)-代码(8)-检验和(16)-报文类型(32)-数据部分</li>
<li>该报文作为IP报文的数据部分进行封装传输</li>
</ul>
</blockquote>
<p>PING回送请求：用于测试两个主机之间的连通性</p>
<p>Traceroute跟踪路径方法：</p>
<blockquote>
<ul>
<li>假设同一主机到达同一目标主机的IP数据报经过的路径相同</li>
<li>发送一系列ICMP询问报文，其TTL设置为1、2、3等</li>
<li>超时后返回的ICMP差错报告中会包含丢弃包的路由器地址，按顺序收集这些路由器地址即可</li>
</ul>
</blockquote>
<h2 id="4-5-因特网的路由选择协议"><a href="#4-5-因特网的路由选择协议" class="headerlink" title="4.5 因特网的路由选择协议"></a>4.5 因特网的路由选择协议</h2><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><p>理想路由算法：</p>
<blockquote>
<ul>
<li>正确性和完整性</li>
<li>计算的简单性</li>
<li>具有自适应性：能适应通信两和网络拓扑的变化</li>
<li>具有稳定性</li>
<li>算法应是公平、最佳的</li>
</ul>
</blockquote>
<p>代价衡量标准：链路长度、数据率、链路容量、保密性、传播时延等</p>
<p>典型的路由器结构：</p>
<blockquote>
<ul>
<li>检错</li>
<li>确定路由选择/转发</li>
<li>封装IP数据报（修改TTL、并重新计算检验和），发送</li>
</ul>
</blockquote>
<h3 id="路由算法的分类"><a href="#路由算法的分类" class="headerlink" title="路由算法的分类"></a>路由算法的分类</h3><p>静态路由选择策略：</p>
<blockquote>
<ul>
<li>非自适应路由选择</li>
<li>简单、开销小但不能及时适应网络状态的变化</li>
</ul>
</blockquote>
<p>动态路由选择策略：</p>
<blockquote>
<ul>
<li>自适应路由选择</li>
<li>能较好地适应网络状态变化但实现起来较为困难</li>
</ul>
</blockquote>
<h3 id="分层的路由选择协议"><a href="#分层的路由选择协议" class="headerlink" title="分层的路由选择协议"></a>分层的路由选择协议</h3><p>这是动态路由选择</p>
<p>自治系统：</p>
<blockquote>
<ul>
<li>一个自治系统是一个互联网，其有权选择系统内部的路由选择协议</li>
<li>一个自治系统内部的所有网络都属于一个行政单位</li>
<li>一个自治系统的所有路由器在本自治系统内部必须是连通的</li>
</ul>
</blockquote>
<p>路由选择协议：</p>
<blockquote>
<ul>
<li>内部网关协议：自治系统内部使用等路由选择协议</li>
<li>外部网关协议：不同自治系统之间的信息传递的协议</li>
</ul>
</blockquote>
<h4 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h4><p>原理：</p>
<blockquote>
<ul>
<li>距离采用距离矢量算法（DVA）计算最佳路由（Bellman-Ford算法）</li>
<li>每个路由器仅和相邻路由器定期交换自己所知道的全部信息（路由表）</li>
</ul>
</blockquote>
<p>距离（跳数）的定义：</p>
<blockquote>
<ul>
<li>路由器到直连网络的距离为1</li>
<li>路由器到非直连网络的距离为路径所经过的路由器加1</li>
</ul>
</blockquote>
<p>RIP报文：首部-路由部分</p>
<blockquote>
<ul>
<li>RIP协议使用运输层的用户数据报UDP进行传送（端口520）</li>
</ul>
</blockquote>
<p>协议特点：</p>
<blockquote>
<ul>
<li>（优点）实现简单，开销小</li>
<li>（缺点）收敛慢</li>
<li>适合小规模、稳定的网络拓扑结构</li>
<li>路由器和网络之间的最大距离为15（16表示不可达）</li>
<li>没有安全措施</li>
<li>好消息传播得快，坏消息传播得慢</li>
</ul>
</blockquote>
<h4 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h4><p>原理：</p>
<blockquote>
<ul>
<li>构造包含发现信息的L-S报文(LSP)向全网广播</li>
<li>根据收集的LSP建立拓扑数据库LSDB</li>
<li>启动SPF算法以C为源点计算SPF树</li>
<li>建立到达所有信宿的路由表（端口和代价）</li>
</ul>
</blockquote>
<p>要点：</p>
<blockquote>
<ul>
<li>更新发送：只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送信息</li>
<li>洪泛法：向本自治系统中所有的路由器发送信息</li>
</ul>
</blockquote>
<p>协议特点：适合大型网络、提供了安全鉴别信息</p>
<blockquote>
<ul>
<li>定时刷新（30分钟）</li>
<li>通信量少</li>
<li>收敛快</li>
<li>计算复杂</li>
</ul>
</blockquote>
<p>OSPF分组：</p>
<blockquote>
<ul>
<li>直接将OSPF分组封装在IP数据报中进行发送</li>
</ul>
</blockquote>
<h4 id="外部网关协议BGP"><a href="#外部网关协议BGP" class="headerlink" title="外部网关协议BGP"></a>外部网关协议BGP</h4><p>BGP是不同自治系统的路由器之间交换路由信息的协议</p>
<blockquote>
<ul>
<li>目标：力求寻找一条能够到达目的网络且比较好（无环）的路由，而非最佳路由</li>
<li>每个自治系统都有多个边界路由器和其他自治系统相连，其称为BGP发言人</li>
<li>BGP发言人之间可以交换路径向量</li>
</ul>
</blockquote>
<h2 id="4-6-IGMP组管理协议和多播路由选择协议"><a href="#4-6-IGMP组管理协议和多播路由选择协议" class="headerlink" title="4.6 IGMP组管理协议和多播路由选择协议"></a>4.6 IGMP组管理协议和多播路由选择协议</h2><p>IGMP用于标识局域网上某主机是否参加或退出了某个多播组</p>
<h2 id="4-7-IP多播"><a href="#4-7-IP多播" class="headerlink" title="4.7 IP多播*"></a>4.7 IP多播*</h2><p>应用：视频服务器减少网络资源消耗</p>
<p>IP多播特点：</p>
<blockquote>
<ul>
<li>使用组地址：D类地址进行多播</li>
<li>动态的组成员</li>
<li>使用硬件进行多播</li>
</ul>
</blockquote>
<p>局域网上的硬件多播：在MAC层上进行组播</p>
<h2 id="4-8-隧道技术"><a href="#4-8-隧道技术" class="headerlink" title="4.8 隧道技术"></a>4.8 隧道技术</h2><p>对于路由中不支持多播的路由器，需要采用隧道技术</p>
<blockquote>
<ul>
<li>将多播IP数据报封装在普通IP数据报中到支持多播的路由器再解封</li>
</ul>
</blockquote>
<h3 id="虚拟专用网VPN"><a href="#虚拟专用网VPN" class="headerlink" title="虚拟专用网VPN"></a>虚拟专用网VPN</h3><p>本地地址：仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向因特网的管理机构申请。</p>
<p>全球地址：全球惟一的IP地址，必须向因特网的管理机构申请。</p>
<p>专用地址：</p>
<blockquote>
<ul>
<li>这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。</li>
<li>专用地址只能用作本地地址而不能用作全球地址。在因特网中的所有路由器对目的地址是专用地址的数据报一律不进行转发。</li>
</ul>
</blockquote>
<p>VPN使用隧道技术实现：将内部网络的IP数据封装到在外网传输到IP数据报中</p>
<blockquote>
<ul>
<li>需要解决加密、鉴别、安全问题</li>
<li>安全措施：IPsec、SSL</li>
</ul>
</blockquote>
<h3 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h3><p>将内联网地址转换成外联网地址</p>
<blockquote>
<ul>
<li>一对一映射：没有减少IP地址</li>
<li>一对多映射：直接在IP层映射会产生抢占问题</li>
<li>一对多映射的网络端口地址翻译NPAT：在TCP层用端口（套接字Socket）解决一对多映射问题；单一一个全局IP地址可以提供65535个连接</li>
</ul>
</blockquote>
<h2 id="4-9-IPv6，解决IP地址耗尽的措施"><a href="#4-9-IPv6，解决IP地址耗尽的措施" class="headerlink" title="4.9 IPv6，解决IP地址耗尽的措施"></a>4.9 IPv6，解决IP地址耗尽的措施</h2><p>IPv6数据报：基本首部-扩展首部(1-n)-数据部分</p>
<blockquote>
<ul>
<li>目的：扩展地址，提高路由器转发效率</li>
<li>首部：丢弃分片、首部检验和功能；校验和由最后一个扩展首部实现</li>
<li>基本首部：版本-通信两类-流标号-有效在和长度-下一个首部（首部和扩展以链表实现）-下一个首部-跳数限制-源地址(128)-目的地址(128)-其他扩展首部</li>
<li>扩展首部：逐跳选项、路由选择、分配、鉴别、封装安全有效载荷、目的站选项</li>
</ul>
</blockquote>
<p>分片依据：源站在发送数据前完成路径最大传送单元发现，或者采用保证的最小发送单元</p>
<p>特点：</p>
<blockquote>
<ul>
<li>IPv6数据报目的地址可以是单播、多播、任播</li>
<li>IPv6将实现IPv6的主机和路由器均称为结点</li>
<li>IPv6用冒号十六进制进行表示，依然支持CIDR</li>
<li>地址分配</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>更大的地址空间。</li>
<li>扩展的地址层次结构。</li>
<li>灵活的首部格式。</li>
<li>改进的选项。</li>
<li>允许协议继续扩充。</li>
<li>支持即插即用（即自动配置）。</li>
<li>支持资源的预分配。 </li>
</ul>
</blockquote>
<h1 id="五、运输层"><a href="#五、运输层" class="headerlink" title="五、运输层"></a>五、运输层</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><p>运输层（传输层）为相互通信的应用进程提供了逻辑通信方法</p>
<p>功能：</p>
<blockquote>
<ul>
<li>运输层为应用进程之间提供端到端的逻辑通信（网络层则是为主机之间提供逻辑通信）</li>
<li>运输层要对收到的报文进行差错检测</li>
<li>运输协议：面向连接的TCP（可靠），无连接的UDP（不可靠）</li>
</ul>
</blockquote>
<p>传输服务原语：</p>
<blockquote>
<ul>
<li>OSI传输服务原语</li>
<li>Berkeley套接字</li>
</ul>
</blockquote>
<h2 id="5-2-端口"><a href="#5-2-端口" class="headerlink" title="5.2 端口"></a>5.2 端口</h2><p>端口是运输层服务访问点TSAP</p>
<blockquote>
<ul>
<li>端口用来标志应用层的进程</li>
<li>这里得端口是软件端口</li>
<li>端口在京城通信中起到TCP/UDP复用技术</li>
<li>端口号只具有本地意义，用于标识本计算机应用层中的各进程；网络中不同计算机的相同端口号是没有联系的</li>
</ul>
</blockquote>
<p>端口分类：</p>
<blockquote>
<ul>
<li>熟知端口0-1023</li>
<li>登记端口1024-49151</li>
<li>临时端口49152-65535</li>
</ul>
</blockquote>
<p>端口号：</p>
<blockquote>
<ul>
<li>21：FTP</li>
<li>23：telnet</li>
<li>25：SMTP</li>
<li>53：DNS</li>
<li>69：TFTP</li>
<li>161：SNMP</li>
<li>…</li>
</ul>
</blockquote>
<p>插口socket：TCP连接的端点；IP和端口结合形成套接字</p>
<h2 id="5-3-用户数据报协议UDP"><a href="#5-3-用户数据报协议UDP" class="headerlink" title="5.3 用户数据报协议UDP"></a>5.3 用户数据报协议UDP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>UDP只在IP服务之上增加端口功能和差错检测功能</p>
<p>UDP提供不可靠的交付，但简单高效，具有如下优点</p>
<blockquote>
<ul>
<li>发送数据之前不需要建立连接</li>
<li>UDP 的主机不需要维持复杂的连接状态表。</li>
<li>UDP 用户数据报只有8个字节的首部开销。</li>
<li>网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。</li>
</ul>
</blockquote>
<h3 id="UDP格式"><a href="#UDP格式" class="headerlink" title="UDP格式"></a>UDP格式</h3><p>UDP用户数据报：首部-数据</p>
<blockquote>
<ul>
<li>首部：伪首部(12)-源端口(2)-目的端口(2)-长度(2)-检验和(2)</li>
<li>伪首部：源IP地址(4)-目的IP地址(4)-0(1)-17(1)-UDP长度(2)</li>
</ul>
</blockquote>
<h2 id="5-4-传输控制协议TCP"><a href="#5-4-传输控制协议TCP" class="headerlink" title="5.4 传输控制协议TCP"></a>5.4 传输控制协议TCP</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>TCP用于在一个不可靠的互联网中为应用程序提供可靠的端到端的字节流服务</p>
<blockquote>
<ul>
<li>提供缓冲、流量控制、差错控制</li>
<li>全双工、点对点（不支持广播和组播功能）</li>
</ul>
</blockquote>
<h3 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h3><p>停止等待协议SW</p>
<blockquote>
<ul>
<li>发送方发送后等待对方确认回复</li>
<li>若报文产生差错或路由不可达，则对方不会回复</li>
<li>超时后发送方重传信息</li>
<li>停等ARQ：确认丢失和确认迟到</li>
<li>注意，停等是一种流量控制；ARQ是一种差错控制，但两者通常结合使用</li>
</ul>
</blockquote>
<p>停等协议简单，但信道利用率太低</p>
<blockquote>
<ul>
<li>解决方案：流水线传输</li>
<li>流水线传输：发送方连续发送多个分组，不停止等待；然后连续收到对方ARK（有流量控制问题）</li>
</ul>
</blockquote>
<h3 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h3><p>TCP首部（32bit）</p>
<blockquote>
<ul>
<li>源端口(16)-目的端口(16)</li>
<li>序号(32)：表示本报文所发送的数据的第一个字节的序号</li>
<li>确认号ark(32)：表示回复报文中希望收到的下一个字节的序号，即该序号之前的字节已经成功收到</li>
<li>数据偏移/首部长度(4)-保留(6)-标志字段(6)-窗口(16)</li>
<li>检验和(16)-紧急指针(16)</li>
<li>选项(可变长)-填充</li>
</ul>
</blockquote>
<p>字段意义：</p>
<blockquote>
<ul>
<li>数据偏移相当于首部长度</li>
<li>窗口用于流量控制，由对方设置，单位为字节</li>
</ul>
</blockquote>
<p>6个标志字段：</p>
<blockquote>
<ul>
<li>URG：紧急数据，配合紧急指针使用</li>
<li>ACK：确认标志，配合确认号使用</li>
<li>PSH：推送标志，尽快交付而尽量不缓存，常用于交互应用</li>
<li>RST：复位标志，中断然后重新建立连接</li>
<li>SYN：同步标志，请求建立连接</li>
<li>FIN：终止标志，用于释放连接</li>
</ul>
</blockquote>
<h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><p>流量控制本质上是抑制发送端发送数据的速率（窗口大小），以便接收端来得及接收</p>
<p>TCP流量控制使用滑动窗口概念</p>
<p>TCP传输的是字节流，窗口大小单位为字节</p>
<blockquote>
<ul>
<li>窗口大小由双方的接收能力决定、窗口后沿和前沿只能前移</li>
<li>窗口中的数据为未发送、收到和已发送但未确认的数据</li>
<li>窗口前位已发送并确认收到的数据，窗口后为不允许发送/接收数据</li>
</ul>
</blockquote>
<p>滑动窗口：</p>
<blockquote>
<ul>
<li>对于发送端，窗口（通知窗口）内为已发送但未确认与未发送数据（可用窗口）</li>
<li>对于接收端，窗口内为未按顺序收到与未收到的数据</li>
<li>接收端成功收到某个字节数据并成功确认后，发送端和接收端的窗口向前移动</li>
<li>当接收端接受能力提高时，可以请求发送端扩大窗口</li>
</ul>
</blockquote>
<h3 id="差错控制：超时和重传机制"><a href="#差错控制：超时和重传机制" class="headerlink" title="差错控制：超时和重传机制*"></a>差错控制：超时和重传机制*</h3><p>TCP协议要求接收方收到TCP段后必须给予应答，发送方必须采用超时重传的机制来重发久未应答的段</p>
<p>问题：不同网络环境下往返时延差异很大</p>
<blockquote>
<ul>
<li>解决方案：加权平均往返时间、超时重传时间</li>
</ul>
</blockquote>
<p>加权平均往返时间RTTs：</p>
<blockquote>
<ul>
<li>RTTs=(1-a)*oldRTT+a*newRTT</li>
<li>第一次测量得到的RTT值就是加权平均值RTTs，a推荐值为0.125</li>
</ul>
</blockquote>
<p>超时重传时间RTO</p>
<blockquote>
<ul>
<li>RTO=RTTs+4*RTTd；RTTd=(1-b)oldRTTd+b*|RTTs-newRTT|</li>
<li>RTTd为加权偏差平均值，初始值为第一次测量的RTT值的一半，b推荐值为0.25</li>
<li>Karn算法及其修正：对于重传的样本，可能会收到多个ACK，不对其RTT进行采样；报文每重传一次，将RTO增大y倍，y典型值为2</li>
</ul>
</blockquote>
<p>持续计时器：解决接收方掉线问题</p>
<h3 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h3><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，此时会产生拥塞(congestion)。</p>
<blockquote>
<ul>
<li>拥塞控制需要让网络能够承受现有的负荷，其进行读是一个全局控制</li>
<li>不同于流量控制，流量控制只控制发送端和接收端之间的点对点通信量</li>
</ul>
</blockquote>
<p>开环控制和闭环控制：</p>
<blockquote>
<ul>
<li>开环控制：事前控制</li>
<li>闭环控制：反馈控制（常用）</li>
</ul>
</blockquote>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免*"></a>拥塞避免*</h4><p>设置接收端窗口和拥塞窗口，分别用于流量控制和拥塞控制</p>
<blockquote>
<ul>
<li>接收者窗口是接收端用于标志自己接受能力而设置的窗口值</li>
<li>网络窗口是发送端根据自己估计的网络拥塞程度而设置的窗口值</li>
<li>实际窗口大小为两者的较小值</li>
</ul>
</blockquote>
<p>发送窗口的设置：慢开始算法</p>
<blockquote>
<ul>
<li>TCP连接初始化时将拥塞窗口设置为1</li>
<li>成功接收没有丢包后，让拥塞窗口进行指数增长，达到阈值后进行线性增大</li>
<li>发生超时后，说明网络拥塞了，重新进行慢开始，并调整阈值</li>
<li>乘法减小：阈值 = 0.5*拥塞发生时的窗口值</li>
</ul>
</blockquote>
<h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>快重传：发送端每收到一个失序报文就立即发送重复确认。</p>
<blockquote>
<ul>
<li>这样做可以让发送方及早知道有报文段没有到达接收方</li>
<li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</li>
</ul>
</blockquote>
<p>快恢复Reno版本：</p>
<blockquote>
<ul>
<li>发送端连续收到三个重复确认后，重传对方未收到的报文字段，并转入拥塞避免</li>
<li>拥塞避免时，不直接重新进行慢开始，而是从新的阈值开始直接进行加法增大</li>
</ul>
</blockquote>
<h4 id="随机早期检测RED"><a href="#随机早期检测RED" class="headerlink" title="随机早期检测RED"></a>随机早期检测RED</h4><p>随机早期检测算法是由路由器执行的，用于缓解路由器队列溢出所带来的问题</p>
<blockquote>
<ul>
<li>缓冲区最小门限之内的数据不丢弃</li>
<li>在最小门限和最大门限之内的数据以概率p随机丢弃</li>
<li>在最大门限之外的数据全部丢弃（溢出）</li>
</ul>
</blockquote>
<p>该算法可以使得队列长度变化较为平滑</p>
<h3 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h3><p>运输连接的三个阶段：</p>
<blockquote>
<ul>
<li>连接建立</li>
<li>数据传输</li>
<li>连接释放</li>
</ul>
</blockquote>
<h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><p>连接建立需要解决的问题：</p>
<blockquote>
<ul>
<li>知晓对方的存在</li>
<li>协商一些连接参数</li>
<li>对运输实体资源进行分配</li>
</ul>
</blockquote>
<p>三次握手：</p>
<blockquote>
<ul>
<li>客户-&gt;服务器：SYN=1，seq=x（发送连接请求）</li>
<li>服务器-&gt;客户：SYN=1，ACK=1，seq=y，ack=x+1（回复请求）</li>
<li>客户-&gt;服务器：ACK=1，seq=x+1，ack=y+1（已经可以开始传数据量）</li>
</ul>
</blockquote>
<h4 id="连接释放"><a href="#连接释放" class="headerlink" title="连接释放"></a>连接释放</h4><p>数据传输结束后，通信双方都可以释放连接</p>
<p>变化的三次握手（四次挥手）：</p>
<blockquote>
<ul>
<li>A-&gt;B：FIN=1，seq=u（此时A不能主动发送数据，但必须回复B发送的数据）</li>
<li>B-&gt;A：ACK=1，seq=v，ack=u+1（B进行回复，此时B仍可以单方向发送信息）</li>
<li>B-&gt;A：FIN=1，ACK=1，seq=w，ack=u+1（再次对A进行回复，完全释放连接）</li>
<li>A-&gt;B：ACK=1，seq=u+1，ack=w+1</li>
</ul>
</blockquote>
<p>其中，第二、三次挥手可以合并</p>
<h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h1><p>应用层协议许多都是基于客户-服务器方式</p>
<h2 id="6-1-域名系统DNS"><a href="#6-1-域名系统DNS" class="headerlink" title="6.1 域名系统DNS"></a>6.1 域名系统DNS</h2><p>概述：</p>
<blockquote>
<ul>
<li>域名用于通过名称来查找地址</li>
<li>因特网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统DNS</li>
<li>名字到域名的解析是由若干个域名服务器端程序完成的，可以为TCP或UDP</li>
<li>域名服务器程序在专设的结点上运行，运行该程序的机器称为域名服务器。</li>
</ul>
</blockquote>
<p>域名结构：层次树状</p>
<blockquote>
<ul>
<li>…三级域名.二级域名.顶级域名</li>
<li>顶级域域名有三种类型：arpa域、通用域、国家域</li>
<li>反向域名：如121.45.34.132.in.addr.arpa</li>
</ul>
</blockquote>
<p>授权域名服务器：</p>
<blockquote>
<ul>
<li>服务器分为根、顶级、权限、本地域名服务器，其根据域划分管辖区</li>
<li>因特网允许各个单位根据具体情况将本单位的域名划分为若干个域名服务器管辖区</li>
<li>每个管辖区中可以设置相应的授权域名服务器</li>
<li>根域名服务器共有13套装置，每套根域名服务器有多个镜像</li>
</ul>
</blockquote>
<p>域名解析的C/S模型：</p>
<blockquote>
<ul>
<li>本地域名服务器的递归查询：查询由根（结点）域名服务器执行</li>
<li>本地域名服务器的迭代查询：查询由本地域名服务器执行</li>
<li>递归与迭代相结合的查询：结点根据自己负载情况选择不同的查询方式</li>
</ul>
</blockquote>
<p>DNS资源记录*</p>
<blockquote>
<ul>
<li>每个域都有一个相关的资源记录集合，常见的记录是其的IP地址</li>
<li>资源记录类型：A、PTR、CNAME、HINFO、MX、NS…</li>
</ul>
</blockquote>
<p>DNS劫持：攻击DNS服务器来篡改记录、伪造主机</p>
<h2 id="6-2-FTP文件传输协议"><a href="#6-2-FTP文件传输协议" class="headerlink" title="6.2 FTP文件传输协议"></a>6.2 FTP文件传输协议</h2><p>FTP使用两个TCP连接完成：</p>
<blockquote>
<ul>
<li>一个TCP连接为控制进程（命令），服务器端口默认21</li>
<li>一个TCP连接为数据传输进程（数据），服务器端口默认20</li>
<li>数据连接其实可以有多个（多个文件同时传输）</li>
</ul>
</blockquote>
<p>NFS、SMB</p>
<p>TFTP简单文件传输协议：</p>
<blockquote>
<ul>
<li>其为一个小且易于实现的文件传输协议</li>
<li>使用UDP数据报，TFTP自己提供差错控制</li>
<li>只支持文件传输，没有交互</li>
<li>没有庞大的命令集，没有列举目录功能，不能对用户身份鉴别</li>
</ul>
</blockquote>
<h2 id="6-3-远程终端协议TELNET"><a href="#6-3-远程终端协议TELNET" class="headerlink" title="6.3 远程终端协议TELNET"></a>6.3 远程终端协议TELNET</h2><p>TELNET使用TCP连接传输数据</p>
<p>只能进行终端操作，无法进行图形化界面操作</p>
<h2 id="6-4-电子邮件"><a href="#6-4-电子邮件" class="headerlink" title="6.4 电子邮件"></a>6.4 电子邮件</h2><p>优点：普及性、快捷性、廉价性</p>
<p>缺点：非实时性、垃圾邮件</p>
<p>电子邮件组成部分：</p>
<blockquote>
<ul>
<li>发件人用户代理</li>
<li>发送方邮件服务器</li>
<li>接收方邮件服务器</li>
<li>收件人用户代理</li>
</ul>
</blockquote>
<p>邮件格式协议RFC822：邮件头（表明邮件发送者和接收者）、邮件体（邮件实际内容）</p>
<blockquote>
<ul>
<li>邮件地址格式：收信人邮箱名@邮箱所在主机域名</li>
<li>常用邮件标题：From、To、Cc、Date、Subject、Message-id、Received</li>
</ul>
</blockquote>
<p>邮件格式协议MIME</p>
<blockquote>
<ul>
<li>RFC822无法传输二进制文件</li>
<li>MIME由版本（只有1.0）、邮件体类型、编码类型、可读字符串、标识符组成</li>
<li>邮件体类型：文本（text、html、rtf）、图像、音频、视频、应用类型（其他任意二进制字节流）、复合类型</li>
<li>编码类型：ASCII、Extended ASCII、Base64（Outlook）、QP（Foxmail）</li>
</ul>
</blockquote>
<p>简单邮件传送协议SMTP：</p>
<blockquote>
<ul>
<li>SMTP使用TCP连接将邮件从发送者的邮件服务器传输到接收者的邮件服务器中</li>
<li>发送者为客户端、接收者为服务端（默认端口25）</li>
<li>明文传输，不加密；解决方案：SMTP认真、加密</li>
</ul>
</blockquote>
<p>邮件读取协议：POP3和IMAP</p>
<blockquote>
<ul>
<li>POP：邮局协议；POP3负责将邮件从邮箱中取出后传输到接收者的主机上</li>
<li>POP3采用TCP连接，服务器端口默认110</li>
<li>POP3传输过程：认证阶段、传输阶段、确认阶段</li>
<li>POP3用户名和口令明文传输，不加密；解决方案：POP3安全认证（APOP）对口令加密</li>
</ul>
</blockquote>
<p>基于万维网的电子邮件：</p>
<blockquote>
<ul>
<li>对邮件服务器的发件和收件采用HTTP协议</li>
<li>邮件服务器之间采用SMTP协议</li>
<li>缺点：HTTP不适合传输大文件</li>
<li>使用IMAP协议</li>
</ul>
</blockquote>
<h2 id="6-5-万维网"><a href="#6-5-万维网" class="headerlink" title="6.5 万维网"></a>6.5 万维网</h2><p>万维网是一种大规模、分布式的联机信息储藏结构；它并非是某种特殊设计的计算机网络</p>
<p>万维网的基础：超文本-&gt;超媒体</p>
<p>三个问题：</p>
<blockquote>
<ul>
<li>资源定位：使用统一资源定位符URL</li>
<li>传输协议：使用超文本传输协议HTTP</li>
<li>资源显示：使用超文本标记语言HTML</li>
<li>其他：资源搜索问题：使用搜索引擎</li>
</ul>
</blockquote>
<p>URL格式：URL访问方式://主机:端口/路径</p>
<p>HTTP：</p>
<blockquote>
<ul>
<li>HTTP是面相事务的客户/服务器协议</li>
<li>HTTP 1.0协议是无状态的，HTTP协议本身也是无状态的</li>
<li>HTTP1.1使用持续连接的流水线技术</li>
</ul>
</blockquote>
<p>HTTP报文结构：请求报文、响应报文、状态码…</p>
<p>万维网高速缓存（代理服务器）：</p>
<blockquote>
<ul>
<li>高速缓存将最近的一些请求和响应暂存在本地磁盘中</li>
<li>高速缓存可以减少访问因特网服务器端时延</li>
</ul>
</blockquote>
<p>动态万维网：动态文档，文档内容是在浏览器访问万维网服务器时才由应用程序动态创建（非静态页面）；活动文档，将工作转移给浏览器</p>
<h2 id="6-6-BOOTP和DHCP"><a href="#6-6-BOOTP和DHCP" class="headerlink" title="6.6 BOOTP和DHCP"></a>6.6 BOOTP和DHCP</h2><p>引导程序协议也称为自举协议，其UDP报文使用全1广播地址作为目的地址，全0地址作为源地址</p>
<p>DHCP将IP地址看成资源进行租用</p>
<h1 id="七、无线局域网"><a href="#七、无线局域网" class="headerlink" title="七、无线局域网"></a>七、无线局域网</h1><h2 id="7-1-结构"><a href="#7-1-结构" class="headerlink" title="7.1 结构"></a>7.1 结构</h2><p>IEEE 802.11</p>
<blockquote>
<ul>
<li>基本服务集BSS</li>
<li>基站AP</li>
<li>扩展服务集ESS</li>
</ul>
</blockquote>
<p>移动自由组网</p>
<h2 id="7-2-物理层"><a href="#7-2-物理层" class="headerlink" title="7.2 物理层"></a>7.2 物理层</h2><p>802.11物理层：</p>
<blockquote>
<ul>
<li>2.4GHz波段</li>
<li>使用调频或直接序列扩频</li>
<li>1M或2M带宽</li>
</ul>
</blockquote>
<p>802.11b使用QPSK，带宽达到11Mbps</p>
<p>802.11a使用5GHz波段，正交频分复用，最高54Mbps</p>
<p>802.11g在b上使用正交频分复用，最高54Mbps</p>
<p>802.11n采用双频工作模式，OFDM和MIMO（并行工作）结合，108Mbps-320Mbps</p>
<h2 id="7-3-MAC层"><a href="#7-3-MAC层" class="headerlink" title="7.3 MAC层"></a>7.3 MAC层</h2><p>CSMA/CD在无线局域网中直接应用会存在问题：</p>
<blockquote>
<ul>
<li>隐蔽站问题</li>
<li>暴露站问题</li>
</ul>
</blockquote>
<p>CSMA/CA（碰撞避免）协议</p>
<blockquote>
<ul>
<li>策略为尽量减少而非杜绝冲突</li>
<li>增加使用确认机制，用停等ARQ实现</li>
</ul>
</blockquote>
<p>两种协调功能：</p>
<blockquote>
<ul>
<li>点协调功能PCF：轮询避免碰撞产生</li>
<li>分布协调功能DCF：争用信道</li>
</ul>
</blockquote>
<p>虚拟载波监听：发送站将占用时间提前通知其他站，防止隐蔽站问题，同时大大减少碰撞机会</p>
<p>信道预约技术：发送数据之前对信道进行预约</p>
<blockquote>
<ul>
<li>请求发送RTS</li>
<li>允许发送CTS</li>
</ul>
</blockquote>
<h2 id="7-4-无线个人区域网WPAN"><a href="#7-4-无线个人区域网WPAN" class="headerlink" title="7.4 无线个人区域网WPAN"></a>7.4 无线个人区域网WPAN</h2><p>802.15：通信范围10m左右</p>
<blockquote>
<ul>
<li>802.15.1蓝牙</li>
<li>802.15.4低速WPAN、成本低功耗非常低</li>
<li>802.15.3高速WPAN、使用瞬间高速脉冲，带宽100M-400M</li>
</ul>
</blockquote>
<h2 id="7-5-无线城域网WMAN和蜂窝移动网络"><a href="#7-5-无线城域网WMAN和蜂窝移动网络" class="headerlink" title="7.5 无线城域网WMAN和蜂窝移动网络"></a>7.5 无线城域网WMAN和蜂窝移动网络</h2><p>802.16</p>
<p>802.20</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象分析与设计</title>
    <url>/2020/06/21/object-oriented0/</url>
    <content><![CDATA[<p>课程定义:</p>
<blockquote>
<ul>
<li>面向对象分析与设计是一种思维方式</li>
<li>面向对象分析与设计是一种思考如何用面向对象方法去思考的课程</li>
</ul>
</blockquote>
<p>关于思维方式: 思维方式有无数种,而本课程要学习面向对象思维方式;并利用它去思考实际问题</p>
<p>前导知识:</p>
<blockquote>
<ul>
<li>UML统一建模语言</li>
<li>面向对象的编程语言</li>
<li>设计模式: 用于解决实际问题的一些框架</li>
<li>分析系统</li>
</ul>
</blockquote>
<p>思考的问题:</p>
<blockquote>
<ul>
<li>为何要设计,什么是好的设计,什么是面向对象设计,它有何优势,如何去设计</li>
</ul>
</blockquote>
<p>要细致分析问题: 先有问题后有解决方案</p>
<a id="more"></a>

<h1 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1 面向对象"></a>1 面向对象</h1><h2 id="1-1-面向对象思想的起源"><a href="#1-1-面向对象思想的起源" class="headerlink" title="1.1 面向对象思想的起源"></a>1.1 面向对象思想的起源</h2><ul>
<li>Alan.Kay: 所有对事物的认识都始源于我们不愿盲目地接受(相信)这个世界<blockquote>
<ul>
<li>Smalltalk: 第一个面向对象编程语言,1971年<br>在Smalltalk中,相互独立的个体通过发送讯息彼此交流; 每一条讯息都包含了数据,发送者地址,接收者地址,以及有关接收者如何对数据实施操作的指令</li>
</ul>
</blockquote>
</li>
</ul>
<p>将数据和过程捆绑到一起发送为面向对象设计打下了基础</p>
<p>生物学启发:</p>
<blockquote>
<ul>
<li>每个细胞都有一些共同的基本行为</li>
<li>每个细胞都能独立运作,它们之间能通过化学信号进行通信</li>
<li>细胞会分化</li>
</ul>
</blockquote>
<p>Alan Kay的思考:</p>
<blockquote>
<ul>
<li>关注消息机制和模块间的松耦合和交互,而非模块内部的对象组成</li>
<li>好的系统应设计好模块之间如何通讯,而不是模块应具有什么样的内部属性和行为方法</li>
</ul>
</blockquote>
<p>面向对象举例:打车去机场</p>
<blockquote>
<ul>
<li>面向对象: 去机场</li>
<li>面向过程: 直走,左拐,过桥,靠边…</li>
</ul>
</blockquote>
<h2 id="1-2-面向对象基本概念"><a href="#1-2-面向对象基本概念" class="headerlink" title="1.2 面向对象基本概念"></a>1.2 面向对象基本概念</h2><ul>
<li>类</li>
<li>对象</li>
</ul>
<p>在面向对象思维中:</p>
<blockquote>
<ul>
<li>每一样东西都是对象</li>
<li>一个程序就是一大群对象,通过消息要求对方做点事情</li>
<li>每个对象都有自己的内存空间,里面存放了许多其他对象</li>
<li>每个对象都是一个类的实例</li>
<li>某一类型的所有对象都能接受相同的消息</li>
</ul>
</blockquote>
<h2 id="1-3-什么是面向对象的思考方式"><a href="#1-3-什么是面向对象的思考方式" class="headerlink" title="1.3 什么是面向对象的思考方式"></a>1.3 什么是面向对象的思考方式</h2><ul>
<li>软件工程是与人打交道的,是为人提供服务的<blockquote>
<ul>
<li>问题是什么</li>
<li>谁遇到了问题</li>
<li>本质是什么</li>
<li>问题该如何解决</li>
</ul>
<p>将单一的思维模式转换成多重的思维模式</p>
</blockquote>
</li>
</ul>
<p>定义: 在对世界/系统进行观察/建模的时候,将它们看成一系列相互交流 互相影响的对象集合</p>
<blockquote>
<ul>
<li>世界是由相互作用的对象组成的</li>
<li>面向对象描述与构建由对象组成系统</li>
</ul>
</blockquote>
<p>面向对象与面向过程:</p>
<blockquote>
<ul>
<li>面向对象适合解决不确定的事件和创新性的事件</li>
<li>面向过程适合处理已知的事实,重要条件都已知的场景</li>
</ul>
</blockquote>
<h2 id="1-4-面向对象核心特征"><a href="#1-4-面向对象核心特征" class="headerlink" title="1.4 面向对象核心特征"></a>1.4 面向对象核心特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><blockquote>
<ul>
<li>封装隐藏了对象的实现细节</li>
<li>内部状态不能被访问</li>
<li>对象数据只能通过接口进行访问</li>
</ul>
</blockquote>
<p>封装可以</p>
<blockquote>
<ul>
<li>保护隐私和数据安全</li>
<li>隔离复杂度</li>
</ul>
</blockquote>
<p>封装的内容:</p>
<blockquote>
<ul>
<li>内部信息</li>
<li>类的属性</li>
<li>类的方法</li>
</ul>
</blockquote>
<p>封装的可见性</p>
<blockquote>
<ul>
<li>Public</li>
<li>Private</li>
<li>Protected</li>
<li>Package</li>
</ul>
</blockquote>
<p>封装原则:</p>
<blockquote>
<ul>
<li>非必要信息都进行封装</li>
<li>只提供必要的接口</li>
</ul>
</blockquote>
<h3 id="继承Inheritance"><a href="#继承Inheritance" class="headerlink" title="继承Inheritance"></a>继承Inheritance</h3><p>子类继承父类所有的属性和方法,并添加了自己的属性和方法</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>子类对父类的同一个方法有不同的表达方式</p>
<h3 id="聚合Aggregation-组合Composition"><a href="#聚合Aggregation-组合Composition" class="headerlink" title="聚合Aggregation,组合Composition"></a>聚合Aggregation,组合Composition</h3><p>聚合是一种描述整体和部分的关系(包含关系)</p>
<blockquote>
<ul>
<li>继承是一种”is a”关系,聚合是一种”has a”关系(学校与学生)</li>
<li>聚合是传递的</li>
<li>聚合是不对称的</li>
</ul>
</blockquote>
<p>组合是一种特殊的聚合,它强调整体对部分的控制</p>
<blockquote>
<ul>
<li>部分对象只能存在于整体对象之中,整体对象控制着部分对象的生命周期</li>
<li>如果整体消失,那么部分也将不复存在(手掌与手指的关系)</li>
<li>在某些时候,聚合与组合关系不是很明确,此时多用聚合</li>
</ul>
</blockquote>
<h3 id="接口Interface-实现Implementation"><a href="#接口Interface-实现Implementation" class="headerlink" title="接口Interface,实现Implementation"></a>接口Interface,实现Implementation</h3><p>接口用于描述一个类的用户如何与这个类交互</p>
<blockquote>
<ul>
<li>接口只定义功能,不具有功能,不提供实现</li>
</ul>
</blockquote>
<p>接口对于软件系统的意义:</p>
<blockquote>
<ul>
<li>软件系统中有大量互相关联的类互相通信</li>
<li>接口能够使得对某一个类的局部修改不会影响其他类</li>
</ul>
</blockquote>
<p>实现是完成接口所定义的功能的一种操作</p>
<blockquote>
<ul>
<li>如: 电视机是用户,插座是接口,发电厂是实现</li>
</ul>
</blockquote>
<h3 id="抽象Abstraction"><a href="#抽象Abstraction" class="headerlink" title="抽象Abstraction"></a>抽象Abstraction</h3><p>抽象表示一个对象与其他所有对象区别的基本特征</p>
<blockquote>
<ul>
<li>类是具体对象的抽象,父类是对其子类的抽象</li>
<li>继承的强大之处就在于它的抽象和组织技术</li>
</ul>
</blockquote>
<h1 id="2-UML"><a href="#2-UML" class="headerlink" title="2 UML"></a>2 UML</h1><h2 id="2-1-建模工具UML"><a href="#2-1-建模工具UML" class="headerlink" title="2.1 建模工具UML"></a>2.1 建模工具UML</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>建模: 将未知事物与一些类似的已知事物进行比较来理解这些未知事物的过程</p>
<blockquote>
<ul>
<li>重要的研发成果常常产自类比</li>
<li>模型: 建模产生的结果,它是对现实世界的简化,是对事物的一种抽象</li>
<li>在模型中剔除一些与问题无关的事物,简化模型,可以帮助人们更好地了解事物本质,抓住问题的要害</li>
</ul>
</blockquote>
<p>建模的意义:</p>
<blockquote>
<ul>
<li>完整地理解一个复杂系统是困难的,建模可以最系统进行更好地理解</li>
<li>将目标系统可视化</li>
<li>提供详细描述系统的结构和行为的思路</li>
<li>给出指导我们构造系统的一个模板</li>
<li>对我们所做出的决策进行模板化</li>
</ul>
</blockquote>
<p>建模的基本原理</p>
<blockquote>
<ol>
<li>要选择建立什么模型: 同一事物可以用不同的模型来描述,对解决问题的帮助也是不一样的</li>
<li>模型的精度: 同一模型可以在不同的精度级别上表示(纸飞机和飞机模型)</li>
<li>模型与现实的关联性: 好的模型应当是与现实相关联的,可简化但不能掩盖掉任何重要的细节</li>
<li>可选择多个模型来描述同一系统: 单个模型通常是不充分的,对每一个重要的系统最好用一组几乎独立的模型去处理(盲人摸象,三视图)</li>
</ol>
</blockquote>
<h3 id="统一建模语言UML"><a href="#统一建模语言UML" class="headerlink" title="统一建模语言UML"></a>统一建模语言UML</h3><p>UML:Unified Modeling Language</p>
<blockquote>
<ul>
<li>UML是软件分析师,设计师的工具包; 是用于建模的工具</li>
<li>UML由事物,关系,图三个部分构成<br><img src="/2020/06/21/object-oriented0/UML0.jpg" alt="UML"></li>
</ul>
</blockquote>
<p>UML中的常用符号<br><img src="/2020/06/21/object-oriented0/UML1.jpg" alt="UML"></p>
<h2 id="2-2-用例模型"><a href="#2-2-用例模型" class="headerlink" title="2.2 用例模型"></a>2.2 用例模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>用例模型包含系统边界,参与者,用例,用例图,用例描述</p>
<p>用例模型是系统分析的结果,是系统设计的输入,是开发部门与顾客之间的合同,是软件设计部门和软件工程师之间的合同</p>
<p>用例模型是非直接开发人员,了解系统的主要信息来源</p>
<h3 id="参与者"><a href="#参与者" class="headerlink" title="参与者"></a>参与者</h3><p>参与者(执行者)Actor: 是位于系统之外和系统进行交互的一类事物(人,物或其他软件子系统)</p>
<blockquote>
<ul>
<li>通过参与者可以对软件系统与外界发生的交互进行分析和描述</li>
<li>通过参与者可以了解客户希望的软件系统所具有的功能</li>
</ul>
<p>参与者用小人图(参与者为人)或构造型方框图(参与者为系统)表示</p>
</blockquote>
<p>系统参与者的寻找方式:</p>
<blockquote>
<ul>
<li>系统使用者</li>
<li>系统安装,维护者</li>
<li>系统启功,关闭者</li>
<li>系统获取的信息来源,系统提供信息的去向</li>
<li>系统交互中的角色扮演者</li>
<li>其他相关联系统</li>
<li>内/外部定时器(于特定时间发生的事件)</li>
</ul>
<p>对每一类参与者要有简短的描述</p>
</blockquote>
<p>找出系统中所有的参与者,并与其交流,得到他们所希望的系统具有的功能,并进行整合</p>
<h3 id="用例和用例图"><a href="#用例和用例图" class="headerlink" title="用例和用例图"></a>用例和用例图</h3><p>用例(用况)Usecase: 系统为响应参与者引发的事件而执行的一系列能够为其(参与者)产生有价值的结果的处理/动作</p>
<blockquote>
<ul>
<li>这些动作不但应包含正常情况的动作序列,还应包含对非正常状况时的动作描述</li>
</ul>
</blockquote>
<p>用例图是由边界,参与者,用例和关系组成</p>
<p><img src="/2020/06/21/object-oriented0/Usercase0.jpg" alt="Usercase0.jpg"></p>
<p>用例图中的关系:</p>
<blockquote>
<p><img src="/2020/06/21/object-oriented0/Usercase1.jpg" alt="Usercase1.jpg"></p>
<ul>
<li>参与者与用例之间: 关联关系,实线</li>
<li>参与者与参与者之间的关系: 可以为泛化关系,实线+空心箭头</li>
<li>用例之间的关系: 泛化,包含(include)或扩展(extend)关系</li>
</ul>
</blockquote>
<p>用例的寻找:</p>
<blockquote>
<ul>
<li>参与者希望系统提供什么功能</li>
<li>系统是否存储和检索信息</li>
<li>当系统状态改变时是否通知参与者</li>
<li>是否存在影响系统的外部事件,这些事件由哪些参与者通知系统</li>
<li>哪个参与者触发了活动</li>
</ul>
</blockquote>
<p>用例的名称</p>
<blockquote>
<ul>
<li>每个用例都有一个名称</li>
<li>名称不需要太长,可用短小精悍的动名词</li>
</ul>
</blockquote>
<h3 id="用例描述"><a href="#用例描述" class="headerlink" title="用例描述"></a>用例描述</h3><p>用例描述(Usecase Description)是对用例的一种详尽的文字描述<br><img src="/2020/06/21/object-oriented0/UseDes0.jpg" alt="UseDes"></p>
<p>用例描述格式:</p>
<blockquote>
<ul>
<li>总括</li>
<li>参与者列表</li>
<li>先决条件描述</li>
<li>用例执行描述</li>
<li>后置条件描述(用例执行完之后系统应当处于什么状态)</li>
<li>异常描述</li>
</ul>
</blockquote>
<h2 id="2-3-活动图"><a href="#2-3-活动图" class="headerlink" title="2.3 活动图"></a>2.3 活动图</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>活动图描述了在一个过程中,顺序/并行的活动及其之间的关系</p>
<blockquote>
<ul>
<li>其应用于商业过程,工作流(业务过程),复杂算法的建模</li>
<li>从形式上看,活动图是顶点和弧的集合</li>
</ul>
</blockquote>
<h3 id="活动基本元素"><a href="#活动基本元素" class="headerlink" title="活动基本元素"></a>活动基本元素</h3><p><img src="/2020/06/21/object-oriented0/Action0.jpg" alt="Action"></p>
<ul>
<li>活动图的开始,结束,对象</li>
</ul>
<p><img src="/2020/06/21/object-oriented0/Action1.jpg" alt="Action"></p>
<ul>
<li>活动节点: 一个活动是一个过程的非原子的执行单元,活动的执行最终延伸为一些独立动作(Action)的执行</li>
</ul>
<p><img src="/2020/06/21/object-oriented0/Action2.jpg" alt="Action"></p>
<ul>
<li>活动分支: 一个进入流,多个离去流; 每个分支都有唯一的条件; 多个控制路径可以无条件合并</li>
</ul>
<p><img src="/2020/06/21/object-oriented0/Action3.jpg" alt="Action"></p>
<ul>
<li><p>分岔和汇合(同步棒):表示多个动作可同时进行</p>
</li>
<li><p>泳道: 将活动按实际需要分组,每个组完成一些特定的活动,用竖线隔开</p>
<blockquote>
<ul>
<li>每个活动只属于一个组,但同步棒可以跨过泳道</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="2-4-类图"><a href="#2-4-类图" class="headerlink" title="2.4 类图"></a>2.4 类图</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>类图将软件设计中与类相关的元素以图的方式展现出来</p>
<blockquote>
<ul>
<li>类图是一种静态视图,是软件设计强有力的武器</li>
</ul>
</blockquote>
<p>类图能够表示的信息(创建类图需要思考的问题):</p>
<blockquote>
<ul>
<li>有多少个类</li>
<li>每个类需要定义多少个属性</li>
<li>每个类需要多少个方法</li>
<li>类之间的关系</li>
<li>类之间的信息交互及功能的完成</li>
</ul>
</blockquote>
<h3 id="类图中的常用UML元素"><a href="#类图中的常用UML元素" class="headerlink" title="类图中的常用UML元素"></a>类图中的常用UML元素</h3><p><img src="/2020/06/21/object-oriented0/Class0.jpg" alt="Class"></p>
<h3 id="类元素的命名"><a href="#类元素的命名" class="headerlink" title="类元素的命名"></a>类元素的命名</h3><blockquote>
<ul>
<li>类名中每个词的第一个字母通常大写</li>
<li>操作和属性名命名遵循驼峰法则</li>
</ul>
</blockquote>
<h3 id="关联关系的修饰"><a href="#关联关系的修饰" class="headerlink" title="关联关系的修饰"></a>关联关系的修饰</h3><p><img src="/2020/06/21/object-oriented0/Association0.jpg" alt></p>
<p><img src="/2020/06/21/object-oriented0/Association1.jpg" alt></p>
<p><img src="/2020/06/21/object-oriented0/Association2.jpg" alt></p>
<p><img src="/2020/06/21/object-oriented0/Association3.jpg" alt></p>
<h2 id="2-5-顺序图"><a href="#2-5-顺序图" class="headerlink" title="2.5 顺序图"></a>2.5 顺序图</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>顺序图从时间方面反映程序运行时不同对象之间的交互情况</p>
<blockquote>
<ul>
<li>顺序图是一种动态视图,是软件设计强有力的武器</li>
<li>顺序图可以动态验证类模型的可行性</li>
<li>顺序验证的某一功能应当属于某个用例描述的功能中的一部分(顺序图又称用例实现)</li>
<li>顺序图从上到下反映了对象间相互协作的时间顺序</li>
</ul>
</blockquote>
<h3 id="顺序图的元素"><a href="#顺序图的元素" class="headerlink" title="顺序图的元素"></a>顺序图的元素</h3><p>概念:</p>
<blockquote>
<ul>
<li>交互: 对象之间为实现某一功能而实施的协作过程</li>
<li>消息: 对象之间的协作和交流表现为一个对象以某种方式启动另一个对象(一个对象调用另外一个对象的方法)</li>
</ul>
</blockquote>
<p>建模元素:</p>
<blockquote>
<ul>
<li>对象(角色)</li>
<li>参与者</li>
<li>消息</li>
</ul>
<p>顺序图是一种交互图(通信图也是),是用于描述交互的过程</p>
</blockquote>
<h3 id="消息-交互的基本概念"><a href="#消息-交互的基本概念" class="headerlink" title="消息: 交互的基本概念"></a>消息: 交互的基本概念</h3><p>同步消息: 源对象直接发送消息给目标对象并阻塞,待接到目标对象的回应后继续执行</p>
<p>异步消息: 源对象将消息发到目标对象的消息接收队列中,然后继续执行,并定时检查自己的消息接收队列是否接到目标对象的回复</p>
<h3 id="顺序图"><a href="#顺序图" class="headerlink" title="顺序图"></a>顺序图</h3><p><img src="/2020/06/21/object-oriented0/Order0.jpg" alt></p>
<blockquote>
<ul>
<li>纵向是时间线,横向是对象列表</li>
<li>对象生存线用虚线表示</li>
<li>控制焦点用长矩形表示(控制焦点可以嵌套)</li>
<li>方法调用以箭头表示</li>
<li>可以对消息进行消息序号的标注</li>
</ul>
</blockquote>
<p>顺序图的流程控制:<br><img src="/2020/06/21/object-oriented0/Order1.jpg" alt></p>
<blockquote>
<ul>
<li>可选执行(if): opt</li>
<li>条件执行(switch): alt</li>
<li>并行执行: par</li>
<li>循环执行: loop</li>
</ul>
</blockquote>
<h2 id="2-6-通信图"><a href="#2-6-通信图" class="headerlink" title="2.6 通信图"></a>2.6 通信图</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>通信图从对象之间的结构关系反映程序运行时不同对象之间的交互情况</p>
<blockquote>
<ul>
<li>通信图与顺序图本质上是一样的,只是建模角度不同</li>
</ul>
</blockquote>
<h3 id="通信图"><a href="#通信图" class="headerlink" title="通信图"></a>通信图</h3><p>通信图由对象,链接,在链接上传递的消息构成<br><img src="/2020/06/21/object-oriented0/Message0.jpg" alt></p>
<blockquote>
<ul>
<li>对象之间的关联关系用链接线(实线)表示</li>
<li>通过链接线上加标签来显示对象间的交互情况</li>
</ul>
</blockquote>
<h2 id="2-7-状态图"><a href="#2-7-状态图" class="headerlink" title="2.7 状态图"></a>2.7 状态图</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>状态图用于描述单个对象的动态行为</p>
<blockquote>
<ul>
<li>单个对象可以是系统,模块或构件</li>
<li>这个对象应该是系统中的核心,需要进行详细分析</li>
<li>选择对象应作为一个整体考察</li>
</ul>
</blockquote>
<h3 id="状态和状态机"><a href="#状态和状态机" class="headerlink" title="状态和状态机"></a>状态和状态机</h3><p>状态是对象生命周期中的一个条件或状况</p>
<blockquote>
<ul>
<li>在此期间,对象可以响应事件,执行活动等</li>
</ul>
</blockquote>
<p>状态的组成部分:</p>
<blockquote>
<ul>
<li>名称</li>
<li>进入/退出动作</li>
<li>内部迁移(内部迁移不改变整体的状态)</li>
<li>子状态</li>
<li>延迟事件</li>
</ul>
</blockquote>
<p>状态机:</p>
<blockquote>
<ul>
<li>状态机是一种对象行为</li>
<li>状态机反映对象在生命周期中所经历的状态序列以及对每个接收事件的响应情况</li>
</ul>
</blockquote>
<p>状态图用于将状态机可视化,它强调从状态到其他状态的控制流</p>
<h3 id="事件和迁移"><a href="#事件和迁移" class="headerlink" title="事件和迁移"></a>事件和迁移</h3><p>事件是一个在时间和空间上对对象有意义的事情的描述</p>
<blockquote>
<ul>
<li>在状态机中,一个事件能够触发一个状态迁移</li>
</ul>
</blockquote>
<p>UML对以下事件进行建模:</p>
<blockquote>
<ul>
<li>参量变化: 内部事件导致参数的变化</li>
<li>信号(异步)</li>
<li>调用(同步)</li>
<li>时间事件</li>
</ul>
</blockquote>
<p>迁移是指对象在事件发生时状态的转移,由如下几个部分组成</p>
<blockquote>
<ul>
<li>源状态</li>
<li>事件触发器(触发器名称)</li>
<li>触发条件</li>
<li>效应(迁移过程中的动作)</li>
<li>目标状态</li>
</ul>
</blockquote>
<p>一些特殊迁移:</p>
<blockquote>
<ul>
<li>自身迁移: 从状态A迁移到状态A</li>
<li>内部迁移: 在状态A内部进行一些行为</li>
</ul>
</blockquote>
<h3 id="状态图元素"><a href="#状态图元素" class="headerlink" title="状态图元素"></a>状态图元素</h3><p><img src="/2020/06/21/object-oriented0/State0.jpg" alt></p>
<h3 id="状态图建模"><a href="#状态图建模" class="headerlink" title="状态图建模"></a>状态图建模</h3><blockquote>
<ol>
<li>选择对象及视点: 可以是类的实例,也可以是构件或系统</li>
<li>定义对象在生命期内可能存在的状态: 状态要有意义,要有一定的持续时间</li>
<li>定义在每种状态下可以接收的事件以及将要转去的新的状态</li>
</ol>
</blockquote>
<p>注意:</p>
<blockquote>
<ul>
<li>不能有孤立状态存在</li>
<li>除了终结状态,不能有只进不出的状态(黑洞状态)</li>
<li>除了初始状态,不能有只出不进的状态(奇迹状态)</li>
<li>不允许无条件状态转移</li>
</ul>
</blockquote>
<h1 id="3-面向对象分析与设计"><a href="#3-面向对象分析与设计" class="headerlink" title="3 面向对象分析与设计"></a>3 面向对象分析与设计</h1><h2 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h2><h3 id="什么是良好的对象设计"><a href="#什么是良好的对象设计" class="headerlink" title="什么是良好的对象设计"></a>什么是良好的对象设计</h3><p>良好的对象设计是构建高质量软件系统的基本要求:</p>
<blockquote>
<ul>
<li>架构性的内聚</li>
<li>可重用性</li>
<li>可维护性</li>
<li>可扩展性</li>
<li>灵活性</li>
</ul>
</blockquote>
<h3 id="系统设计中的关键问题"><a href="#系统设计中的关键问题" class="headerlink" title="系统设计中的关键问题"></a>系统设计中的关键问题</h3><p>这是面向对象设计课程的要点:</p>
<blockquote>
<ul>
<li>如何为对象类分配职责: 职责驱动的设计,在设计的过程中完成职责分配(使用GRASP原则)</li>
<li>对象之间应当如何协作</li>
<li>什么样的类应当做什么样的事情</li>
<li>如何使用某些经验法则(解决方案)或自创方案来解决问题</li>
</ul>
</blockquote>
<p>软件开发过程模型: 指示软件开发的步骤</p>
<blockquote>
<ul>
<li>瀑布模型</li>
<li>螺旋模型</li>
<li>增量模型</li>
<li>迭代模型(本课程使用)</li>
<li>喷泉模型</li>
<li>敏捷模型</li>
<li>SMF,RUP等</li>
</ul>
</blockquote>
<h3 id="分析-设计-实现-部署"><a href="#分析-设计-实现-部署" class="headerlink" title="分析,设计,实现,部署"></a>分析,设计,实现,部署</h3><blockquote>
<ul>
<li>分析analysis: 对问题和要求进行分析,而不是直接给出解决方案</li>
<li>设计design: 设计一个概念性的,满足需求的解决方案</li>
<li>实现implement: 将方案进行代码层面的解释</li>
<li>部署deployment: 将软件安装在宿主环境中</li>
</ul>
</blockquote>
<p>分析:做正确的事情; 设计:正确地做事情</p>
<h3 id="面向对象分析和设计"><a href="#面向对象分析和设计" class="headerlink" title="面向对象分析和设计"></a>面向对象分析和设计</h3><blockquote>
<ul>
<li>面向对象分析: 发现并描述问题领域里的对象或概念(概念类)</li>
<li>面向对象设计: 定义软件对象以及它们之间如何协作完成功能(设计类)</li>
</ul>
</blockquote>
<p>分析设计过程:</p>
<blockquote>
<ol>
<li>定义用例</li>
<li>定义领域模型(概念模型): 领域模型是面向对象分析的结果,是问题领域的概念类以及真实对象的可视化表示</li>
<li>定义交互图</li>
<li>定义设计类图</li>
</ol>
</blockquote>
<h2 id="3-2-面向对象分析-名称法"><a href="#3-2-面向对象分析-名称法" class="headerlink" title="3.2 面向对象分析:名称法"></a>3.2 面向对象分析:名称法</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>软件工程中,分析是一种奖用户需求转化为系统需求的过程</p>
<p>复杂系统的分析方法:</p>
<blockquote>
<ul>
<li>面向功能分析</li>
<li>面向对象分析</li>
</ul>
<p>通常软件系统中,在抽象层面面向功能分析,划分模块;每个模块内部面向对象分析</p>
</blockquote>
<p>面向对象分析主要步骤:</p>
<blockquote>
<ol>
<li>识别对象</li>
<li>组织对象</li>
<li>定义对象之间的关系</li>
<li>定义对象的操作: 这一步主要在设计阶段完成</li>
<li>定义对象的内部细节</li>
</ol>
<p>这几步是一个不断反复的过程</p>
</blockquote>
<p>面向对象分析的几种方法:</p>
<blockquote>
<ul>
<li>概念模型(名词法)</li>
<li>分析模型</li>
<li>CRC法:类/职责/协作法</li>
</ul>
<p>一个好的分析不应当局限于上述几种方法,需要灵活应用; 目标只有一个,即发现对象和定义对象之间的管线</p>
</blockquote>
<p>概念模型在UML中表示为没有操作的类图</p>
<h3 id="名词法定义概念类"><a href="#名词法定义概念类" class="headerlink" title="名词法定义概念类"></a>名词法定义概念类</h3><p>策略:</p>
<blockquote>
<ul>
<li>重用或修改已有模型</li>
<li>参考行业,公司内部的”概念类列表”(checklist)</li>
<li>在需求描述中寻找名词(短语)</li>
</ul>
</blockquote>
<p>具体方法:</p>
<blockquote>
<ul>
<li>在问题领域的文本描述中,标识出名词(短语),将它们作为候选的概念类或属性</li>
<li>对发现的名称(短语)进行分析,辨别概念是否能合并</li>
<li>定义概念类之间的关系</li>
<li>定义概念类的属性</li>
</ul>
</blockquote>
<p>注意:</p>
<blockquote>
<ul>
<li>不能机械地将名称直接转换成概念类</li>
<li>对自然语言描述的歧义,重复要仔细分析</li>
</ul>
</blockquote>
<h2 id="3-3-分析模型法"><a href="#3-3-分析模型法" class="headerlink" title="3.3 分析模型法"></a>3.3 分析模型法</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>分析模型法用于描述系统规格的说明;从系统的信息,行为,输入输出的方面入手分析问题</p>
<blockquote>
<ul>
<li>一个健壮,稳定的模型必须与实现环境无关</li>
<li>实现环境的任何变化,不会影响到系统的逻辑结构</li>
<li>分析模型能够关注到系统的信息,行为,展示(输入输出)等特性</li>
</ul>
</blockquote>
<h3 id="分析模型的表示符号"><a href="#分析模型的表示符号" class="headerlink" title="分析模型的表示符号"></a>分析模型的表示符号</h3><p><img src="/2020/06/21/object-oriented0/analysis0.jpg" alt>  </p>
<blockquote>
<ul>
<li>实体类: 圆下一切线;主要表示系统内的信息</li>
<li>边界类: 圆外一边界;主要表示系统的展示</li>
<li>控制类: 圆上一箭头;主要表示系统的行为</li>
</ul>
</blockquote>
<h3 id="分析模型类的标识和类间关系识别"><a href="#分析模型类的标识和类间关系识别" class="headerlink" title="分析模型类的标识和类间关系识别"></a>分析模型类的标识和类间关系识别</h3><p>关注三个维度: 系统信息,系统接口(展示),系统行为(控制)</p>
<blockquote>
<ul>
<li>识别系统内部实体对象: 实体类</li>
<li>识别和接口相关的对象: 边界类</li>
<li>识别调度相关的对象: 控制类</li>
</ul>
</blockquote>
<p>类间关系的表示:<br><img src="/2020/06/21/object-oriented0/analysis1.jpg" alt></p>
<h2 id="3-4-面向对象设计-初步"><a href="#3-4-面向对象设计-初步" class="headerlink" title="3.4 面向对象设计(初步)"></a>3.4 面向对象设计(初步)</h2><p>面向对象设计是在概念模型的基础上进行设计</p>
<h3 id="一般原则"><a href="#一般原则" class="headerlink" title="一般原则"></a>一般原则</h3><blockquote>
<ul>
<li>一个面向对象系统是由相互发送消息的对象组成的</li>
<li>一个软件系统的质量如何取决于各对象是否能够各司其职</li>
</ul>
</blockquote>
<h3 id="职责驱动的设计"><a href="#职责驱动的设计" class="headerlink" title="职责驱动的设计"></a>职责驱动的设计</h3><p>职责: 职责是一个对象的行为,而其他对象依赖这种行为</p>
<blockquote>
<ul>
<li>职责是外界对该对象的一种期待</li>
<li>该对象不履行职责将会对其他对象产生(负面)影响</li>
</ul>
</blockquote>
<p>对象职责的分类(老师和同学的关系):</p>
<blockquote>
<ul>
<li>认知职责: <blockquote>
<ul>
<li>该对象的私有信息: 老师的个人信息</li>
<li>该对象和其他对象相关的一些信息: 老师有学生名单</li>
<li>能通过该对象已知信息推导出来的信息</li>
</ul>
</blockquote>
</li>
<li>行为职责<blockquote>
<ul>
<li>该对象自己的行为: 老师讲课</li>
<li>该对象初始化其他的对象行为: 老师让同学回答问题 </li>
<li>该对象控制协调其他对象的行为: 老师让同学们小组合作</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>策略: 考虑每个类的职责</p>
<blockquote>
<ul>
<li>设计时考虑对象做什么或知道什么</li>
<li>设计时考虑一个对象对其他对象承担的义务或合约</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理相关知识</title>
    <url>/2020/06/07/compilers0/</url>
    <content><![CDATA[<p><del>未完结,持续更新</del>完结</p>
<hr>
<p>课程内容:</p>
<ul>
<li>编译器构造的一般原理和基本实现方法</li>
<li>理论知识: 形式语言和自动机理论,语法制导的定义和属性方法,程序分析原理</li>
<li>强调形式描述技术和自动生成技术</li>
<li>强调对编译原理和技术的宏观理解,不把注意力分散到枝节算法,不偏向于任何源语言或目标机器</li>
</ul>
<a id="more"></a>

<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1-1-编译原理概述"><a href="#1-1-编译原理概述" class="headerlink" title="1.1 编译原理概述"></a>1.1 编译原理概述</h2><p>语言处理器: 由编译器,解释器,汇编器,连接器,加载器,调试器及程序概要提取工具等所构成的集成软件开发环境  </p>
<ul>
<li>机器语言和汇编语言: 第一和第二代程序设计语言  </li>
<li>高级语言: 能够自动进行内存管理,类型一致性检查等功能的程序设计语言   </li>
</ul>
<p>翻译器: 能完成一种语言到另一种语言变换的软件</p>
<p>翻译器的不同形式:</p>
<ul>
<li>编译器(c,c++): 从源程序通过编译器得到目标程序,从输入通过目标程序得到输出(效率高,平台相关)</li>
<li>解释器(Python,JavaScript): 从源程序和输入经过解释器直接得到输出 (平台无关)  </li>
<li>区别: 编译器通过翻译来生成目标程序,解释器直接生成源程序指定的运算*</li>
<li>混和编译器(Java,C#): 源程序通过翻译器得到中间程序,中间程序和输入经过虚拟机得到输出(效率稍高,平台无关,但每个平台都要装虚拟机)</li>
</ul>
<p>语言处理系统: 预处理器,编译器,汇编器,连接器\加载器  </p>
<p>主要流程: 源程序-&gt;修改后的源程序-&gt;目标汇编程序-&gt;可重定位的机器代码-(库文件,可重定位目标文件)&gt;可执行目标程序</p>
<h2 id="1-2-编译器基本结构"><a href="#1-2-编译器基本结构" class="headerlink" title="1.2 编译器基本结构"></a>1.2 编译器基本结构</h2><p>编译器: 将源程序编译为目标可执行程序的系统<br>特点: 目标语言比源语言低级</p>
<p>编译器结构:</p>
<ul>
<li>分析部分,前端: 源程序-&gt;中间表示</li>
<li>综合部分,后端: 中间表示-&gt;目标程序</li>
</ul>
<p>前端,只依赖于源语言: 词法分析-&gt;语法分析-&gt;语义分析-&gt;中间代码生成</p>
<ul>
<li>词法分析: 识别词法单元,如变量、数字等</li>
<li>语法分析: 识别语句,得到语法树</li>
<li>语义分析: 识别语义的合理性,得到语义分析结果</li>
<li>中间代码生成: 得到中间表示</li>
</ul>
<p>后端,独立于源语言;和中间语言与目标机器有关: -&gt;代码优化-&gt;代码生成</p>
<ul>
<li>代码优化: 得到中间表示</li>
<li>代码生成: 得到可执行程序</li>
</ul>
<p>同一前端和不同后端组合可以得到同一源语言在不同机器上的编译器<br>不同前端和同一后端组合可以得到同一机器上的几个编译器</p>
<p>总体过程可以如下表示:<br><img src="/2020/06/07/compilers0/proc0.png" alt="progress"><br>编译的几个阶段常用一趟/遍（pass）扫描来实现，一趟/遍扫描 包括读一个输入文件和写一个输出文件。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>逐个扫描构成源程序的字符,把它们组成词法单元(token)流</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">position</span> = rate * <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>词法单元:</p>
<ul>
<li>标识符: position,rate</li>
<li>运算符: *</li>
<li>赋值符: =</li>
<li>数字: 60</li>
</ul>
<p>词法分析结果: *&lt;id,1&gt; &lt;=&gt; &lt;id,2&gt; &lt;*&gt; &lt;60&gt;*  </p>
<p>词法分析也可以叫做线性分析或扫描</p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>把词法单元流依照语言的语法结构按层次分组,来形式化成语法短语</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">position</span> = rate * <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>构建语法树:<br><img src="/2020/06/07/compilers0/ga0.png" alt="grammer analysis"></p>
<p>表达式、语句等程序层次结构通常由递归的规则表示</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>检查程序语义的正确性,保证程序各个部分能有意义地结合在一起,为后面代码生成阶段手机类型信息  </p>
<p>语义分析包括:</p>
<ul>
<li>类型转换</li>
<li>类型检查</li>
<li>语法制导翻译</li>
</ul>
<p>语义分析结果:<br><img src="/2020/06/07/compilers0/ga1.png" alt="grammer analysis"></p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>生成一个位于高级编程语言和机器语言(目标程序)之间的中间代码  </p>
<p>一般有后缀表示,抽象语法树,三地址码表示法:<br><img src="/2020/06/07/compilers0/ga2.png" alt="grammer analysis"><br><em>三地址码表示中只有三个变量</em></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>改进代码,以产生执行较快的机器代码:<br><img src="/2020/06/07/compilers0/ga3.png" alt="grammer analysis"></p>
<h3 id="目标程序生成"><a href="#目标程序生成" class="headerlink" title="目标程序生成"></a>目标程序生成</h3><p>生成可以重定位的机器代码或汇编码:<br><img src="/2020/06/07/compilers0/ga4.png" alt="grammer analysis">  </p>
<ul>
<li>为源程序所用的每个变量选择存储单元，并且把中间代码翻译成等价的机器指令序列。</li>
<li>关键问题是寄存器分配</li>
</ul>
<h3 id="关于符号表管理"><a href="#关于符号表管理" class="headerlink" title="关于符号表管理"></a>关于符号表管理</h3><p>编译器的一项重要工作是记录源程序中使用的标识符，并收集每个标识符的各种属性  </p>
<ul>
<li>这些属性提供标识符的存储分配、类型和作用域信息  </li>
<li>如果是过程标识符，还有参数的个数和类型、参数传递方式和返回值类型  </li>
</ul>
<p>符号表是为每个标识符保存一个记录的数据结构，记录的域是标识符的属性   </p>
<ul>
<li>该数据结构允许我们迅速地找到一个标识符的记录，在此记录中存储和读取数据 </li>
</ul>
<p>管理符号表:</p>
<ul>
<li>词法分析器发现源程序的标识符时，把该标识符填入符号表;但是,词法分析期间不能确定一个标识符的属性</li>
<li>其余的阶段把标识符的信息填入符号表，然后以不同的方式使用这些信息</li>
</ul>
<p><img src="/2020/06/07/compilers0/ga5.png" alt="grammer analysis"></p>
<h3 id="关于出错管理"><a href="#关于出错管理" class="headerlink" title="关于出错管理"></a>关于出错管理</h3><p>每个阶段都可能发现源程序的错误。发现错误后，该阶段必须处理此错误，使得编译可以继续进行，以便进一步发现源程序的其他错误。</p>
<ul>
<li>词法分析：当前被扫描的字符串不能形成语言的词法记号。</li>
<li>语法分析：记号流违反语言的语法规则。</li>
<li>语义分析：编译器试图找出语法正确但对所含的操作来说是无意义的结构，如相加的两个标识符，其一是数组名，另一个是过程名。</li>
</ul>
<h1 id="二、一个简单的语法制导翻译器"><a href="#二、一个简单的语法制导翻译器" class="headerlink" title="二、一个简单的语法制导翻译器"></a>二、一个简单的语法制导翻译器</h1><p>语法制导翻译器:</p>
<ul>
<li>词法分析</li>
<li>语法分析(上下文无关文法)</li>
<li>中间代码生成(语法制导翻译)</li>
</ul>
<p>前端模型如下:<br><img src="/2020/06/07/compilers0/ga5.png" alt="grammer analysis"></p>
<h2 id="2-1-词法分析概述"><a href="#2-1-词法分析概述" class="headerlink" title="2.1 词法分析概述"></a>2.1 词法分析概述</h2><p>源程序–(词法分析器)-&gt;词法单元序列</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>词法分析基本步骤:</p>
<ul>
<li>剔除空白和注释</li>
<li>识别和计算常量</li>
<li>识别关键字和标识符  </li>
</ul>
<p>创建一个符合语法的状态机,并优化,编程实现它</p>
<p>下面代码可以不用细看,后面会细讲  </p>
<h3 id="剔除空白和注释"><a href="#剔除空白和注释" class="headerlink" title="剔除空白和注释"></a>剔除空白和注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; peek = next input character) &#123;    <span class="comment">// peek为预读字符</span></span><br><span class="line">       <span class="keyword">if</span>( peek is a blank or a tab ) <span class="keyword">do</span> nothing;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>( peek is a newline) </span><br><span class="line">              line = line + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剔除空行和空白,直到扫描到下一个有效词法单元</p>
<h3 id="识别和计算常量"><a href="#识别和计算常量" class="headerlink" title="识别和计算常量"></a>识别和计算常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( peek holds a digit) &#123;</span><br><span class="line">       v = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">               v = v * <span class="number">10</span> + integer value of digit peek;</span><br><span class="line">               peek = next  input  character</span><br><span class="line">        &#125;<span class="keyword">while</span> ( peek holds a digit);</span><br><span class="line">        <span class="keyword">return</span> token (num, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="识别关键字和标识符"><a href="#识别关键字和标识符" class="headerlink" title="识别关键字和标识符"></a>识别关键字和标识符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( peek 存放了一个字母) &#123;</span><br><span class="line">     将字母或数位读入一个缓冲区b;</span><br><span class="line">      s = b 中的字符形成的字符串;</span><br><span class="line">      w = words.get(s) 返回的词法单元；</span><br><span class="line">      <span class="keyword">if</span> ( w 不是 <span class="keyword">null</span>) <span class="keyword">return</span> w;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">             将键-值对(s, &lt;id, s&gt;)加入到words;</span><br><span class="line">              <span class="keyword">return</span> 词法单元&lt;id, s&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Token <span class="title">scan</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       跳过空白符；</span><br><span class="line">       处理数字；</span><br><span class="line">       处理保留字和标识符；</span><br><span class="line">       <span class="comment">/*如果运行到这里，就将预读字符peek作为一个词法单元*/</span></span><br><span class="line">       Token t = <span class="keyword">new</span> Token (peek);</span><br><span class="line">        peek = 空白符 <span class="comment">/*按照预读的规则进行初始化,参见龙书p48*/</span>；</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="词法分析建立的类"><a href="#词法分析建立的类" class="headerlink" title="词法分析建立的类"></a>词法分析建立的类</h3><p>各个对象关系如下:<br><img src="/2020/06/07/compilers0/proc1.png" alt="relatives"></p>
<h2 id="2-2-语法分析概述"><a href="#2-2-语法分析概述" class="headerlink" title="2.2 语法分析概述"></a>2.2 语法分析概述</h2><p>语法分析是决定如何使用一个文法生成一个终结符号串的过程</p>
<p>举例如下:<br><img src="/2020/06/07/compilers0/proc3.png" alt="analysis">  </p>
<p>步骤:</p>
<ul>
<li>根据语法构建文法</li>
<li>根据文法构建预测分析表(LL文法,LR文法)</li>
</ul>
<h3 id="上下文无关文法-CFG"><a href="#上下文无关文法-CFG" class="headerlink" title="上下文无关文法 CFG"></a>上下文无关文法 CFG</h3><p>上下文无关文法(Context Free Grammar)由一个四元组G构成<br><img src="/2020/06/07/compilers0/gra0.png" alt="grammer"></p>
<p>在这里，有<br><img src="/2020/06/07/compilers0/gra1.png" alt="grammer"></p>
<p>例如，由+，-号分隔的数位序列可以由如下语法表示  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终结符号集合 &#123;0,1,2,3,4,5,6,7,8,9,+,-&#125; (叶子节点)</span></span><br><span class="line"><span class="comment">// 非终结符号集合 &#123;list,digit&#125;</span></span><br><span class="line"><span class="comment">// 产生式集合:&#123;</span></span><br><span class="line">    list-&gt;list+digit</span><br><span class="line">    list-&gt;list-digit</span><br><span class="line">    list-&gt;digit</span><br><span class="line">    digit-&gt;<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始符号 list</span></span><br></pre></td></tr></table></figure>
<h3 id="预测分析表"><a href="#预测分析表" class="headerlink" title="预测分析表"></a>预测分析表</h3><p>NaN</p>
<h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树用图形的方式展现从文法的开始符号推出相应符号串的过程  </p>
<p>从定义上看,给定一个上下文无关文法,该文法的一棵语法分析树(parse tree)是具有如下性质的树:</p>
<ol>
<li>根节点的标号为文法的开始符号</li>
<li>每个叶子节点的标号为一个终结符号或空串(e)</li>
<li>每个内部节点的标号为一个非终结符号</li>
<li>如果非终结符号A是某个内部节点的标号,并且它的子节点的标号从左到右分别为X1,X2…Xn,那么必然存在产生式A-&gt;X1,X2…Xn, 其中X1…Xn既可以是终结符号也可以是非终结符号</li>
</ol>
<p>例如:<br><img src="/2020/06/07/compilers0/tree0.png" alt="tree"></p>
<h3 id="左递归问题的消除"><a href="#左递归问题的消除" class="headerlink" title="左递归问题的消除"></a>左递归问题的消除</h3><p>原始公式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A -&gt; A x | y</span><br></pre></td></tr></table></figure>
<p>可以这样理解: 这种公式在考虑FIRST(A)时会遇到无穷递归的问题(实际上不是)</p>
<p>改进公式:将左递归化为循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A -&gt; y R</span><br><span class="line">R -&gt; x R | e(空白符)</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="/2020/06/07/compilers0/recu0.png" alt="recursive"></p>
<h2 id="2-3-语法制导翻译"><a href="#2-3-语法制导翻译" class="headerlink" title="2.3 语法制导翻译"></a>2.3 语法制导翻译</h2><p>语法制导翻译的两种方式:</p>
<ul>
<li>语法制导定义</li>
<li>语法制导翻译方案</li>
</ul>
<h3 id="语法制导定义"><a href="#语法制导定义" class="headerlink" title="语法制导定义"></a>语法制导定义</h3><ul>
<li>每一个产生式和一组语义规则相关联</li>
<li>每个文法符号(非终结符)和一个属性集合相关联</li>
</ul>
<p>此时,产生式和语义规则是分离的,如下:<br><img src="/2020/06/07/compilers0/trans0.png" alt="trans"><br>语法制导定义类似于一种属性文法</p>
<h3 id="语法制导翻译方案"><a href="#语法制导翻译方案" class="headerlink" title="语法制导翻译方案"></a>语法制导翻译方案</h3><ul>
<li>将程序片段附加到一个文法的各个产生式上的表示</li>
<li>被嵌入到产生式体中的程序片段成为语义动作,语义动作用花括号括起来</li>
</ul>
<p>此时,语义是嵌入到产生式中的,如下:<br><img src="/2020/06/07/compilers0/trans1.png" alt="trans"></p>
<h1 id="三、词法分析"><a href="#三、词法分析" class="headerlink" title="三、词法分析"></a>三、词法分析</h1><p><img src="/2020/06/07/compilers0/lex0.png" alt="lex"></p>
<ul>
<li>词法记号：由记号名和属性值构成的二元组，属性值不是必须项，记号名是语法分析的输入符号。(这个模式的名字)</li>
<li>模式：一个记号的模式描述属于该记号的词法单元的形式。和一个给定模式匹配的字（字符串）的集合成为该模式的语言。(一个词法单元可能具有的形式)</li>
<li>词法单元：是源程序中匹配一个记号模式的字符序列，由词法分析器识别为该记号的一个实例。(一个具体的词法单元)</li>
</ul>
<p>常见的词法分析生成器:lex,flex,jlex,ply等  </p>
<h2 id="3-1-串和语言的定义"><a href="#3-1-串和语言的定义" class="headerlink" title="3.1 串和语言的定义"></a>3.1 串和语言的定义</h2><ul>
<li>字母表：符号的有限集合</li>
<li>串：符号的有穷序列,空串为$\epsilon$</li>
<li>语言：字母表上的一个串集,可以只包含空串或是空集</li>
<li>句子：属于语言的串</li>
</ul>
<p>串的运算:<br><img src="/2020/06/07/compilers0/lex1.png" alt="lex"></p>
<h2 id="3-2-正则表达式"><a href="#3-2-正则表达式" class="headerlink" title="3.2 正则表达式"></a>3.2 正则表达式</h2><h3 id="正则表达式的递归定义"><a href="#正则表达式的递归定义" class="headerlink" title="正则表达式的递归定义"></a>正则表达式的递归定义</h3><p><img src="/2020/06/07/compilers0/re0.png" alt="re"></p>
<h3 id="正则表达式的一些公理"><a href="#正则表达式的一些公理" class="headerlink" title="正则表达式的一些公理"></a>正则表达式的一些公理</h3><p><img src="/2020/06/07/compilers0/re1.png" alt="re"></p>
<h3 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h3><p><img src="/2020/06/07/compilers0/re2.png" alt="re"></p>
<h3 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h3><p>为了方便书写,对一些常用的正则表达式做如下定义<br><img src="/2020/06/07/compilers0/re3.png" alt="re"><br><img src="/2020/06/07/compilers0/re4.png" alt="re">  </p>
<p>一些数量方面的运算符也做了扩展<br><img src="/2020/06/07/compilers0/re5.png" alt="re"><br><img src="/2020/06/07/compilers0/re6.png" alt="re"></p>
<h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p>状态转换图描述词法分析器被语法分析器调用时，词法分析器为返回下一个记号所做的动作</p>
<p>绘制状态转换图是构造词法分析器的第一步</p>
<ul>
<li>圆圈表示状态，开始状态由一条没有出发节点、标号为“开始”的边指明</li>
<li>双层圆圈表示接受状态，表示已识别一个记号</li>
<li>有向边表示从一个状态到另一状态</li>
<li>每条边的标号包含一个或多个符号，若离开状态s的某边上标号为other，则它表示离开s的其他边所指示的字符以外的任意字符</li>
<li>*表示输入指针必须回退的转态</li>
</ul>
<p><img src="/2020/06/07/compilers0/status0.png" alt="status"></p>
<h2 id="3-3-有限状态自动机"><a href="#3-3-有限状态自动机" class="headerlink" title="3.3 有限状态自动机"></a>3.3 有限状态自动机</h2><h3 id="不确定的有限状态自动机NFA"><a href="#不确定的有限状态自动机NFA" class="headerlink" title="不确定的有限状态自动机NFA"></a>不确定的有限状态自动机NFA</h3><ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times (\Sigma \cup \lbrace \epsilon \rbrace) \to \rho(Q)$上的映射,$\rho(Q)$表示Q的幂集</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是接受状态集合  <blockquote>
<p>此时,这个自动机在确定的状态接收到了一个确定的符号后,其下一个状态时不确定的</p>
</blockquote>
</li>
</ul>
<h3 id="确定的有限状态自动机DFA"><a href="#确定的有限状态自动机DFA" class="headerlink" title="确定的有限状态自动机DFA"></a>确定的有限状态自动机DFA</h3><ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times \Sigma \to Q$上的映射,是状态转移函数</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是接受状态集合<blockquote>
<ul>
<li>一个符号标记离开同一状态只有一条边</li>
<li>任何状态下都没有ε转换</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="3-4-基于MYT算法从正则表达式到NFA"><a href="#3-4-基于MYT算法从正则表达式到NFA" class="headerlink" title="3.4 基于MYT算法从正则表达式到NFA"></a>3.4 基于MYT算法从正则表达式到NFA</h2><p>正则表达式-(MYT算法)&gt;NFA-(子集构造算法)&gt;DFA-(hopcorft最小化算法)&gt;词法分析器代码</p>
<h3 id="MYT算法"><a href="#MYT算法" class="headerlink" title="MYT算法"></a>MYT算法</h3><p>基本思路: 对正则表达式的结构做归纳  </p>
<ul>
<li>一些基本元素如下构造<br><img src="/2020/06/07/compilers0/construct0.png" alt="cons"><br><img src="/2020/06/07/compilers0/construct1.png" alt="cons"><br><img src="/2020/06/07/compilers0/construct2.png" alt="cons"><br><img src="/2020/06/07/compilers0/construct3.png" alt="cons">  </li>
</ul>
<p>正则表达式的分解和构造:<br><img src="/2020/06/07/compilers0/construct4.png" alt="cons"></p>
<h3 id="从NFA到DFA的转换-子集构造算法"><a href="#从NFA到DFA的转换-子集构造算法" class="headerlink" title="从NFA到DFA的转换(子集构造算法)"></a>从NFA到DFA的转换(子集构造算法)</h3><ul>
<li>找出字母表</li>
<li>分析转换过程(注意$\epsilon$状态可以进行多次输入/滑行),得到DFA<blockquote>
<ol>
<li>以初始状态为中心,将它接受$\epsilon$所能滑行到的状态和这个状态设为一个新状态</li>
<li>扫描字母表,将新状态接受相同字母所能到达的所有状态设合并为一个状态</li>
<li>以2.中所得到的状态为中心执行操作1.,直到没有新状态产生  </li>
</ol>
</blockquote>
</li>
</ul>
<p>一些概念:<br><img src="/2020/06/07/compilers0/construct5.png" alt="cons">  </p>
<p>子集构造算法不一定得到最简的DFA</p>
<h3 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h3><p>目标: 使得DFA的状态最少</p>
<ul>
<li>找出字母表</li>
<li>分析DFA转换过程,得到最简DFA</li>
<li>主要思想:对状态进行最小划分</li>
<li>化简条件:化简前DFA的函数应是全函数(对每一个状态s和输入a都有对应输出状态)<blockquote>
<ol start="0">
<li>如果DFA不是全函数,需要引入非终结的死状态E<blockquote>
<ul>
<li>所有未定义的输出状态全部转到死状态E</li>
<li>死状态接受E的所有输入都转换到本身</li>
</ul>
</blockquote>
</li>
<li>构造状态集合的初始划分$\Pi$={接收状态,非接收状态}</li>
<li>对$\Pi$中每个子集G,对G进行如下划分:<blockquote>
<p>把G划分为若干子集，G的两个状态s和t在同一子集中，当且仅当对任意输入符号a，s和t的a转换都到π的同一子集中</p>
</blockquote>
</li>
<li>重复2.直到$\Pi$不再改变</li>
<li>去除死状态,得到最简的状态集合:<blockquote>
<ul>
<li>删除死状态和所有和这个状态连接的边,所有边都改成无定义</li>
<li>从开始状态不可达到的状态也删除</li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="3-5-直接从正则表达式到DFA"><a href="#3-5-直接从正则表达式到DFA" class="headerlink" title="3.5 直接从正则表达式到DFA"></a>3.5 直接从正则表达式到DFA</h2><p>NaN</p>
<h1 id="四、语法分析"><a href="#四、语法分析" class="headerlink" title="四、语法分析"></a>四、语法分析</h1><p>语法分析器读取词法分析器提供的记号流，检查它是否能由源语言的文法产生，输出分析树的某种表示。</p>
<p><img src="/2020/06/07/compilers0/token0.png" alt="token"></p>
<p>语法分析器类型:</p>
<ul>
<li>通用语法分析（Cocke-Younger-Kasami算法，Earley算法）:效率低</li>
<li>自顶向下语法分析: 从语法分析树的根节点开始向叶子节点构造语法分析树</li>
<li>自底向上语法分析: 从叶子结点开始，逐渐向根节点方向构造语法分析树</li>
</ul>
<h2 id="4-1-上下文无关文法CFG"><a href="#4-1-上下文无关文法CFG" class="headerlink" title="4.1 上下文无关文法CFG"></a>4.1 上下文无关文法CFG</h2><p>正则文法属于一种上下文无关文法,但它不能描述诸如括号匹配或嵌套结构这样的语言</p>
<p>上下文无关文法优点:</p>
<blockquote>
<ul>
<li>文法给出了精确,易于理解的语法说明</li>
<li>文法可以自动产生高效的分析器</li>
<li>它可以给语言定义出层次结构</li>
<li>以文法为基础的语言的实现便于语言的修改</li>
</ul>
</blockquote>
<p>缺点:</p>
<blockquote>
<ul>
<li>文法只能描述编程语言的大部分语法，不能描述语言中上下文有关的语法特征</li>
</ul>
</blockquote>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>上下文无关文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: $ A \to \alpha $; 其中$A \in V, \alpha \in (V\cup T)^*$ <em>(0型文法是$A \in (V\cup T)^*$)</em> </p>
</blockquote>
</li>
</ul>
<p>上下文无关文法是一个产生式文法</p>
<p>约定:</p>
<ul>
<li>终结符号一般用小写字母abc,标点符号,运算符,数字,黑体单词表示</li>
<li>非终结符一般用大写字母ABC(起始符一般为S),小写斜体单词表示</li>
<li>XYZ可以表示文法符号(终结符或非终结符)</li>
<li>$uvw$等表示终结符号(可以为空)串</li>
<li>$\alpha \beta \gamma$等表示(可以为空)的文法符号串</li>
<li>一般一组产生式中第一个产生式的头就是开始符号</li>
</ul>
<h3 id="文法的推导-派生"><a href="#文法的推导-派生" class="headerlink" title="文法的推导(派生)"></a>文法的推导(派生)</h3><p>直接推导:</p>
<ul>
<li>给定文法$G=&lt;V,T,S,P&gt;$,设$x,y \in (V \cup T)^*$. 称<strong>$y$是$x$的直接推导($x\Rightarrow y$)</strong>,当且仅当:  <blockquote>
<p>$\exists u,v \in (V \cup T)^* $ 且 $ \exists$ ‘a-&gt;b’ $\in P$ 使得 $x = uav,y = ubv$ (即把x中的a改写成b后得到y)  </p>
</blockquote>
</li>
</ul>
<p>推导:</p>
<ul>
<li>给定文法$G=&lt;V,T,S,P&gt;$,设$x_1,x_2,…,x_n \in (V \cup T)^*, n \ge 1 且 x_1\Rightarrow x_2 \Rightarrow … \Rightarrow x_n $, 则称<strong>$x_n$是由$x_1$(经过$n-1$步)推导出来的($x_1 \dot \Rightarrow x_n$)</strong>  <blockquote>
<p>注意,对$V \cup T$上的所有字符串$\omega$有$\omega \dot \Rightarrow \omega$. 可见$\dot \Rightarrow$是$\Rightarrow$的自反传递闭包 </p>
<ul>
<li>推导具有自反性和传递性</li>
</ul>
</blockquote>
</li>
</ul>
<p>句型:</p>
<ul>
<li>从文法的开始符号推到含有非终结符的符号串$\alpha$,则$\alpha$是句型</li>
</ul>
<p>生成语言:  </p>
<ul>
<li>设$G=&lt;V,T,S,P&gt;$是一个文法,$L(G)$是文法G<strong>生成的语言</strong>,则$L(G)$满足<br>$$ L(G) = \lbrace \omega \in T^* | S \dot \Rightarrow \omega \rbrace $$   <blockquote>
<p>根据定义,$L(G)$中的字符串满足如下两个条件:</p>
<ol>
<li>字符串由终结符构成</li>
<li>字符串可以由起始符派生出来</li>
</ol>
</blockquote>
</li>
</ul>
<p>文法的等价</p>
<ul>
<li>如果$L(G_1) = L(G_2)$,则称文法$G_1$和$G_2$<strong>等价</strong></li>
</ul>
<p>语法分析器中推导的类型: </p>
<ul>
<li>最左推导: 每次直接推导均替换句型中最左边的非终结符</li>
<li>最右推导: 每次直接推导均替换句型中最右边的非终结符</li>
</ul>
<h3 id="语法分析树-1"><a href="#语法分析树-1" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树是推导的图形表示,过滤掉了推导过程中对非终结符应用产生式的顺序</p>
<ul>
<li>语法分析树中每一个非叶节点表示一次直接推导</li>
<li>每个语法树对应唯一的最左推导或最右推导</li>
</ul>
<p><img src="/2020/06/07/compilers0/tree0.jpg" alt="tree"><br>性质:</p>
<ul>
<li>根节点是开始符号</li>
<li>叶节点是终结符或空</li>
</ul>
<h3 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h3><p>一个文法中,若存在某个句子不止一棵语法分析树(这个句子存在不止一种最左/最右推导),则这个文法是二义的</p>
<ul>
<li>原因: 在产生句子的过程中某些直接推导有多于一种的选择</li>
<li>对策: 对文法规定符号的优先级和符号的结合性</li>
<li>注意: 这种二义性的产生与采用的推导方式无关; 即,无二义性的句子无论采用何种推导方式都只会产生一棵语法分析树</li>
</ul>
<h3 id="正则文法和上下文无关文法"><a href="#正则文法和上下文无关文法" class="headerlink" title="正则文法和上下文无关文法"></a>正则文法和上下文无关文法</h3><p>正则文法属于上下文无关文法</p>
<p>正则文法的CFG表示:</p>
<blockquote>
<ol>
<li>构造正则式的NFA</li>
<li>若0为初态,则$A_0$为开始符号</li>
<li>对于状态i接受a到状态j,构造产生式$A_i \to a A_j$,若a为空串则构造$A_i \to A_j$</li>
<li>若i是接受状态,则构造产生式$A_i \to \epsilon$</li>
</ol>
</blockquote>
<p>正则式直接构造的词法分析器比构造语法分析器效率高</p>
<h2 id="4-2-文法设计"><a href="#4-2-文法设计" class="headerlink" title="4.2 文法设计"></a>4.2 文法设计</h2><h3 id="语法错误的处理"><a href="#语法错误的处理" class="headerlink" title="语法错误的处理"></a>语法错误的处理</h3><p>语法错误: </p>
<blockquote>
<ul>
<li>语法不完整</li>
<li>括号不匹配</li>
<li>其他语法错误</li>
</ul>
</blockquote>
<p>语法分析方法可以高效检测出语法错误, 以尽量小的处理开销来发现正确的错误并对它进行恢复</p>
<p>恢复策略:</p>
<blockquote>
<ul>
<li>恐慌模式恢复: 一旦发现错误就不断丢弃输入中的符号, 一次丢弃一个符号,直到找到能够匹配的元素为止</li>
<li>短语层次的恢复: 发现错误时在余下的输入上进行局部纠正</li>
<li>错误产生式: 通过预测可能遇到的错误,在当前文法中添加特殊的产生式</li>
<li>全局纠正: 在处理一个错误的输入串时通过最少的改动将其转化为语法正确的串</li>
</ul>
</blockquote>
<h3 id="消除二义性"><a href="#消除二义性" class="headerlink" title="消除二义性"></a>消除二义性</h3><p>给定一些规则来定义运算符之间的相对优先关系和结合性,这里以+-*/为例</p>
<ol>
<li>根据运算符优先级的个数来构建多个层次的表达式非终结符, 如expr和term,其中term表达式的优先级比expr高</li>
<li>构造表达式基本单位非终结符,如factor,它可以推导出(非)终结符id和外加括号的内层表达式</li>
<li>从表达式基本单位开始从低优先级到高优先级构造表达式(这样低优先级靠近叶节点,优先计算)</li>
<li>左结合运算符的产生式中,同级别的产生式在运算符左边,低一级的产生式在运算符右边; 反之亦然<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造文法如下:</span></span><br><span class="line">factor -&gt; id | (expr)</span><br><span class="line">expr -&gt; expr + term</span><br><span class="line">      | expr - term</span><br><span class="line">      | term</span><br><span class="line">term -&gt; term * factor</span><br><span class="line">      | term / factor</span><br><span class="line">      | factor</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><p>左递归文法中有这样一个非终结符A,对于某个串a,存在推导$A \dot \to A a$</p>
<ul>
<li>由$A \to A a$产生式引起的左递归称为直接左递归</li>
<li>左递归在自顶向下语法分析中不能被处理,需要消除</li>
</ul>
<p>策略:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始公式</span></span><br><span class="line">A -&gt; A x | y</span><br><span class="line"><span class="comment">// 消除左递归</span></span><br><span class="line">A -&gt; x R</span><br><span class="line">R -&gt; y R | e(空白符)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述策略只能消除直接左递归</p>
</blockquote>
<p>非直接推导引起的左递归需要进行非终结符代入来转换成一个直接左递归的表达式来消除</p>
<h3 id="提取左公因子"><a href="#提取左公因子" class="headerlink" title="提取左公因子"></a>提取左公因子</h3><p>提取左公因子是一种文法变换,用于产生适合于自顶向下分析的文法,它可以将对产生式的选择推后</p>
<p>提取方式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取前</span></span><br><span class="line">A -&gt; ab | ac | ad ... | x</span><br><span class="line"><span class="comment">// 提取后</span></span><br><span class="line">A -&gt; aA<span class="string">' | x</span></span><br><span class="line"><span class="string">A'</span>-&gt; b | c | d ...</span><br></pre></td></tr></table></figure>

<h2 id="4-3-自顶向下语法分析"><a href="#4-3-自顶向下语法分析" class="headerlink" title="4.3 自顶向下语法分析"></a>4.3 自顶向下语法分析</h2><p>对于输入串,从文法开始符号自上而下,从左到右为输入串建立语法分析树,寻求输入串的最左推导过程</p>
<ul>
<li>自顶向下语法分析不能处理左递归情况</li>
<li>自顶向下语法分析不能处理复杂的回溯技术</li>
</ul>
<h3 id="递归下降的语法分析"><a href="#递归下降的语法分析" class="headerlink" title="递归下降的语法分析"></a>递归下降的语法分析</h3><p>为一个非终结符选择产生式时,预测分析能够根据当前输入符号决定这个选择</p>
<ul>
<li>递归下降的预测分析为每一个非终结符写一个分析过程,这个过程本身可能是递归的</li>
</ul>
<p>策略: 考虑当前的输入符号,以语法树中最左边的一个非终结符号为目标选择一个产生式,这个产生式右部第一个符号应和当前符号匹配,若无匹配符号则回溯</p>
<p>递归下降的语法分析需要回溯</p>
<h3 id="FIRST和FOLLOW"><a href="#FIRST和FOLLOW" class="headerlink" title="FIRST和FOLLOW"></a>FIRST和FOLLOW</h3><p>FIRST和FOLLOW两个集合可以帮助我们在自顶向下语法分析中根据下一个输入符号来选择相应的产生式</p>
<ul>
<li>FIRST(a): 对于任意文法符号串a, FIRST(a)表示可从a推导得到的串的首符号集合<blockquote>
<p>计算FIRST(a)方法:</p>
<ul>
<li>若a是一个终结符号,则FIRST(a)=a</li>
<li>若a是非终结符号,考虑每个a的产生式,将产生式右边第一个符号a’的FIRST集合加入FIRST(a)中</li>
<li>若a是一个文法符号串xyz…,则从i=x开始依次将FIRST(i)加入FIRST(a)中,直到FIRST(i)中不存在空串e</li>
</ul>
</blockquote>
</li>
<li>FOLLOW(A): 对于非终结符号A,FOLLOW(A)表示某些句型中紧跟在A右边的终结符号的集合<blockquote>
<p>计算一个文法中所有非终结符号的FOLLOW集合方法:</p>
<ul>
<li>考虑起始符号S,定义一个输入的结束标记$,将它加入FOLLOW(S)中</li>
<li>考虑每个产生式$A\to \alpha B \beta$,将FIRST($\beta$)中除了空串e之外的其他所有符号加入到FOLLOW(B)中</li>
<li>考虑产生式$A\to \alpha B$或$A\to \alpha B \beta$且FIRST($\beta$)中含有空串e,则将FOLLOW(A)加入FOLLOW(B)中</li>
<li>反复应用上述规则,直到所有FOLLOW集合都不再变化</li>
</ul>
<p>注意,FOLLOW集合中只有$,没有空串e</p>
</blockquote>
</li>
</ul>
<h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><p>LL(1)文法意思是能够从左向右扫描输入,每一步向前看一个输入符号,产生最左推导的文法</p>
<p>定义:一个消除所有左递归并提取所有左公因子后的文法G是LL(1)的,当且仅当G的 产生式集合中任何两个左部相同的表达式<code>A -&gt; a | b</code>都满足:</p>
<blockquote>
<ul>
<li>FIRST(a)和FIRST(b)没有交集(否则取a或b会形成矛盾)</li>
<li>串a,b最多只有一个能推导出空串</li>
<li>当串b能推出空串e(即e在FIRST(b)中)时,FIRST(a)和FOLLOW(A)没有交集(否则取FIRST(a)和b空且取FOLLOW(A)会形成矛盾)</li>
</ul>
</blockquote>
<h3 id="非递归下降的预测分析"><a href="#非递归下降的预测分析" class="headerlink" title="非递归下降的预测分析"></a>非递归下降的预测分析</h3><p>LL(1)文法可以构造出非递归下降的预测分析器,只需要检查当前输入符号就可以为一个非终结符号选择正确的产生式</p>
<p>预测语法分析表M的构建:</p>
<blockquote>
<ol>
<li>计算各非终结符的FIRST和FOLLOW集合,有了非终结符的FIRST集合很容易就得到一个串a的FIRST集合</li>
<li>以非终结符号为行标,终结符号(输入符号)加上$为列标构建二维表</li>
<li>按如下策略考察每个产生式<code>A -&gt; a</code><ul>
<li>对FIRST(a)中的每个终结符i,将<code>A -&gt; a</code>加入到<code>M[A,i]</code>中</li>
<li>若空串e在FIRST(a)中,则再对FOLLOW(A)中的每个终结符i,将<code>A -&gt; a</code>加入到<code>M[A,i]</code>中</li>
</ul>
</li>
<li>M中没有定义的单元格都表示error </li>
</ol>
<p><img src="/2020/06/07/compilers0/guess0.jpg" alt="guess"><br>对于每个LL(1)文法,分析表中每个单元格中都应唯一指明一个产生式或error,否则这个文法是左递归或二义性的,也可能是不与任何LL(1)文法等价的文法  </p>
</blockquote>
<p>预测分析器的转换图构建:</p>
<blockquote>
<ol>
<li>创建一个初始状态和一个结束(返回)状态</li>
<li>对于每个产生式<code>A -&gt; ab...c</code>,创建一个从初始状态到结束状态的路径,路径上各边分别标注<code>a,b,...c</code></li>
<li>若<code>A -&gt; e</code>,则在该路径上标空串e</li>
</ol>
<p>注意: </p>
<ul>
<li>文法的转换图需要消除左递归和提取左公因子</li>
<li>每一个非终结符都有一个转换图</li>
<li>每条边上的标注可以是终结符也可以是非终结符,终结符转换表示接受了下一个输入的词法单元并转换状态,非终结符A转换表示对A的过程进行了一次调用  </li>
</ul>
<p><img src="/2020/06/07/compilers0/guess1.jpg" alt="guess"></p>
</blockquote>
<p>表驱动的预测语法分析:</p>
<blockquote>
<p>输入: 一个串w,文法G和预测分析表M<br>输出: 一个w的最左推导或一个错误指示</p>
<ol>
<li>构建一个含有已匹配,栈,输入,动作四个列的表</li>
<li>初始化: 无已匹配字符,栈顶中压入开始符号和结束符$,输入为w和结束符$</li>
<li>执行下列while动作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ip为输入符号串的最左端符号</span></span><br><span class="line"><span class="comment">// X为栈顶符号</span></span><br><span class="line"><span class="keyword">while</span>(X != $)&#123;</span><br><span class="line">   <span class="keyword">if</span>(X == ip) ip得到匹配,弹出栈顶符号,ip指向下一个输入符号;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(X是一个终结符号) 执行错误处理;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(M[X,a]为空或是一个报错条目) 执行错误处理;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(M[X,a]为产生式A-&gt;b)&#123;</span><br><span class="line">       输出产生式A-&gt;b</span><br><span class="line">       弹出栈顶符号</span><br><span class="line">       将b中各符号倒序压入栈中(确保b中最左端元素在栈顶)</span><br><span class="line">   &#125;</span><br><span class="line">   X = 栈顶符号;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>预测分析器示意图:<br><img src="/2020/06/07/compilers0/guess2.jpg" alt="guess"></p>
</blockquote>
<h3 id="预测分析的错误恢复"><a href="#预测分析的错误恢复" class="headerlink" title="预测分析的错误恢复"></a>预测分析的错误恢复</h3><p>错误原因: </p>
<blockquote>
<ul>
<li>栈顶的终结符和输入最左端的终结符不匹配</li>
<li>M[A,a]不合法</li>
</ul>
</blockquote>
<p>定义:</p>
<blockquote>
<ul>
<li>同步集合: 一些界限符,如”{,},;”,它们在程序中应当是清晰无二义的; 同步集合是人为规定的</li>
</ul>
</blockquote>
<p>恐慌模式恢复规则:</p>
<blockquote>
<ul>
<li>把FOLLOW(A)的所有终结符放入非终结符A的同步记号集合中</li>
<li>把FIRST(A)的终结符加入A的同步记号集合</li>
<li>如果终结符在栈顶而不能匹配,弹出此终结符</li>
<li>将高层构造的开始符号加入到低层构造的同步集合中去</li>
<li>如果非终结符可以产生空串,若出错时栈顶是一些特定的非终结符,则可以使用推出空串的产生式</li>
</ul>
</blockquote>
<h2 id="4-4-自底向上语法分析"><a href="#4-4-自底向上语法分析" class="headerlink" title="4.4 自底向上语法分析"></a>4.4 自底向上语法分析</h2><p>一个自底向上语法分析过程对应于为一个输入串构造语法分析树的过程，它从叶子节点开始，逐步向上到达根节点。即把输入串归约成文法的开始符号。</p>
<p>示意图:<br><img src="/2020/06/07/compilers0/reduction0.jpg" alt="reduction"></p>
<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>对子串的归约操作: 一个子串和某个产生式的右部匹配，则用该产生式的左部符号代替这个子串。</p>
<p>每次将左部的符号进行归约,实际上是最右推导的一个反向操作</p>
<h3 id="句柄剪枝"><a href="#句柄剪枝" class="headerlink" title="句柄剪枝"></a>句柄剪枝</h3><p>句柄: 句型中的句柄是该句型中的一个字串,它和某个产生式的右部匹配</p>
<blockquote>
<ul>
<li>注意,和某个产生式体匹配的最左字串不一定是句柄</li>
<li>该句柄字串的右边只含有终结符</li>
<li>如果文法二义,那么句柄可能不唯一</li>
</ul>
</blockquote>
<p>句柄剪枝: 通过不断替换左部的句柄,不断得到最右句型,重构出一个最右推导</p>
<h3 id="移入-归约语法分析技术"><a href="#移入-归约语法分析技术" class="headerlink" title="移入-归约语法分析技术"></a>移入-归约语法分析技术</h3><p>移入-归约语法分析使用栈来保存文法符号，并用一个输入缓冲区来存放将要进行语法分析的其余符号。</p>
<p>移入-归约技术的四种动作:</p>
<blockquote>
<ul>
<li>移入: 将输入中的下一个符号移入栈</li>
<li>归约: 栈中出现了一个句柄,其右端在栈顶,分析器确定了句柄左端在栈中的位置,并决定用某非终结符号替代这个句柄</li>
<li>接受: 宣布语法分析过程成功完成</li>
<li>出错: 发现语法错误,进行错误处理</li>
</ul>
</blockquote>
<p>一个例子:<br><img src="/2020/06/07/compilers0/reduction1.jpg" alt="reduction"></p>
<h3 id="移入-归约语法的冲突"><a href="#移入-归约语法的冲突" class="headerlink" title="移入-归约语法的冲突"></a>移入-归约语法的冲突</h3><p>一些文法在使用移入-归约语法分析技术时会遇到问题:</p>
<blockquote>
<ul>
<li>移入/归约冲突: 无法判断下一次操作时移入还是归约</li>
<li>归约/归约冲突: 无法在多个归约种进行选择</li>
</ul>
</blockquote>
<h2 id="4-5-LR语法分析技术"><a href="#4-5-LR语法分析技术" class="headerlink" title="4.5 LR语法分析技术"></a>4.5 LR语法分析技术</h2><p>LR(k)语法分析技术: 对输入进行从左到右的扫描,每次做决定时向前看k个输入符号,反向构造出一个最右推导序列</p>
<blockquote>
<p>一般情况下,k=0或1,k=1时省略括号</p>
</blockquote>
<p>LR(k)文法: 一个文法是LR(k)文法,当我们在一个最右句型中看到某个产生式右部时,再向前看k个输入符号就可以确定是否使用这个产生式进行归约</p>
<p>LR语法分析器优势:</p>
<blockquote>
<ul>
<li>对几乎所有上下文无关文法都适用</li>
<li>能使用LL语法分析器构造的一定能被LR语法分析器构造,反之不然</li>
</ul>
</blockquote>
<h3 id="LR-0-自动机"><a href="#LR-0-自动机" class="headerlink" title="LR(0)自动机"></a>LR(0)自动机</h3><p>LR(0)文法: 不存在移进-归约冲突和归约-归约冲突的文法</p>
<p>项: 一个文法G的一个LR(0)项是G中的产生式加上一个位于它右部的一个点组成,如:<code>A -&gt; a.bc</code></p>
<blockquote>
<ul>
<li>加点的目的是为了表示分析过程中的状态</li>
<li>点之前的内容经推导所形成的串已经在栈中出现,我们希望接下来出现的是点之后能推导出的串</li>
<li>若点在表达式最右边出现,则表示产生式体(右部)已经全部出现在栈中,可以进行归约了</li>
<li>对于产生式<code>A -&gt; 空串e</code>,只有一个项<code>A -&gt; .</code>与之对应<br>LR(0)语法分析器通过维护一些状态,通过不同状态表明格局在语法分析过程中所处的位置,从而在多个可能的移入-归约选择中做出决定,而这些状态就是一些项的集合</li>
</ul>
</blockquote>
<p>项集可以用整数对集合表示,中间每个项都可以表示成整数对&lt;产生式编号,点的位置&gt;</p>
<p>LR(0)自动机: 根据文法LR(0)项目构造识别可行前缀的DFA</p>
<blockquote>
<p>此时,文法的所有LR(0)项构成一组规范LR(0)项集,这些规范项集对应LR(0)自动机的状态</p>
</blockquote>
<p>增广文法: G是一个以S为开始符号的文法,则G的增广文法就是在G中加上新的开始符号<code>S&#39; -&gt; S</code>而得到的文法</p>
<blockquote>
<p>目的: 告诉语法分析器停止语法分析的时机, 即当其需要使用<code>S&#39; -&gt; S</code>进行归约时,输入符号串被接受</p>
</blockquote>
<p>LR(0)项集I的闭包CLOSURE(I)的算法:</p>
<blockquote>
<ol>
<li>将I中各个项加入CLOSURE(I)中</li>
<li>若<code>A -&gt; a.Bc</code>在CLOSURE(I)中,<code>B -&gt; y</code>是一个产生式,则将项<code>B -&gt; .y</code>加入CLOSURE(I)中(原来就有则不用加)</li>
<li>重复规则2.,直到没有新项能够加入CLOSURE(I)中为止</li>
</ol>
<p>可见,在2.中加入CLOSURE(I)的项中的点都在最左端,我们认为点在最左端的项都为非内核项(除了<code>S&#39; -&gt; S</code>),其他(包括<code>S&#39; -&gt; S</code>)都是内核项,因为一个项集中的非内核项可由其内核项通过闭包运算产生</p>
</blockquote>
<p>GOTO(I,X)函数的定义:</p>
<blockquote>
<ul>
<li>I是一个项集(状态)</li>
<li>X是一个文法符号</li>
<li>GOTO(I,X)是一个项集,它是I中所有形如<code>A -&gt; a.Xb</code>(X紧靠点的右边)的项对应的项<code>A -&gt; aX.b</code>的集合的闭包</li>
<li>若X是空串e,则结果为I中所有形如<code>A -&gt; a.Xb</code>的项对应的项<code>X -&gt; .y</code>的集合的闭包</li>
</ul>
<p>该函数定义了一个LR(0)的转换,是状态I在接受了输入符号X后向下一个状态转换的过程; 在应用中,我们可以对GOTO函数进行限制, 将输入X限制为非终结符号, 将其处理终结符号输入的部分转到ACTION函数</p>
</blockquote>
<p>ACTION(I,a)函数的定义:</p>
<blockquote>
<ul>
<li>I是一个项集(状态)</li>
<li>a是一个终结符号或输入结束标记$</li>
<li>ACTION(I,a)的结果是下列四种形式之一:<ol>
<li>移入j: 将输入符号a移入符号栈中,并将状态j压入状态栈中(用状态j代表a)</li>
<li>归约<code>A -&gt; b</code>: 将符号栈顶端的<code>b</code>归约(替代)为产生式头<code>A</code></li>
<li>接受: 语法分析器接受输入并完成语法分析过程</li>
<li>报错: 语法分析器发现了一个错误并执行某个恢复程序</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="构造S-imple-LR语法分析表"><a href="#构造S-imple-LR语法分析表" class="headerlink" title="构造S(imple)LR语法分析表"></a>构造S(imple)LR语法分析表</h3><p>SLR文法: 存在移进-归约冲突,但这种冲入能用FOLLOW集合解决的文法</p>
<p>输入增广文法G’,构造简单LR语法分析技术的状态集合,并获得广义GOTO函数</p>
<blockquote>
<ol>
<li>定义项集族为C(状态集合)</li>
<li>求出<code>S&#39; -&gt; .S</code>的闭包,将其加入C中</li>
<li>对于C中的每个项集I,扫描每个文法符号X,若GOTO(I,X)非空且不在C中,将GOTO(I,X)作为一个新的状态加入C中</li>
<li>重复3.,直到没有新的状态加入C中 </li>
</ol>
</blockquote>
<p>ACTION函数在状态I接收到终结符x时的动作如下:</p>
<blockquote>
<ol>
<li>若<code>A -&gt; a.xb</code>在I中且能通过GOTO函数转到下一个状态I’,则移入I’</li>
<li>若<code>A -&gt; a.</code>在I中,且x在FOLLOW(A)中(确保规约后能继续推导),则ACTION为归约<code>A -&gt; a</code>(此时A不为S’,且前缀a必定出现在栈中,如何归约见下文)</li>
<li>若<code>S&#39; -&gt; S.</code>在I中且x为$,则ACTION为接受</li>
<li>不符合上面任一动作的都定义为出错</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>上述构造中,状态I可以用数字i代替</li>
<li>SLR(1)文法通过’x在FOLLOW(A)中’来解决移进-归约冲突, 如果使用的是LR(0)文法构造分析表则不需这句话</li>
</ul>
</blockquote>
<p>例子:<br><img src="/2020/06/07/compilers0/SLR0.jpg" alt="SLR"><br><img src="/2020/06/07/compilers0/SLR1.jpg" alt="SLR"></p>
<p>有些非二义性文法在构造SLR分析器时会产生移入/归约等冲突,这是因为这种SLR构造方法不够强大</p>
<h3 id="SLR语法分析算法"><a href="#SLR语法分析算法" class="headerlink" title="SLR语法分析算法"></a>SLR语法分析算法</h3><p><img src="/2020/06/07/compilers0/LR0.jpg" alt="LR"></p>
<p>分析过程:</p>
<blockquote>
<ol>
<li>构建一个含有栈,符号,输入,动作四个列的表</li>
<li>执行下列while动作<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = w$的第一个符号;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">   s = 栈顶状态;</span><br><span class="line">   <span class="keyword">if</span>(ACTION[I,x] == 移入状态t)&#123;</span><br><span class="line">       将t压入栈中;</span><br><span class="line">       a = 下一个符号;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(ACTION[I,x] == 归约 A -&gt; a)&#123;</span><br><span class="line">       从栈中弹出|a|个符号;</span><br><span class="line">       t = 栈顶状态;</span><br><span class="line">       将GOTO(t,A)状态压入栈中; (状态转移)</span><br><span class="line">       输出产生式A -&gt; a;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(ACTION[I,x] == 接受) <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">else</span> 调用错误恢复程序;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p><img src="/2020/06/07/compilers0/SLR2.jpg" alt="SLR"></p>
<h3 id="可行前缀"><a href="#可行前缀" class="headerlink" title="可行前缀"></a>可行前缀</h3><p>一个可行前缀是一个最右句型的前缀,并且它没有越过该最右句型的最左句柄的右端(其他前缀出现在栈中之前就会被归约掉)</p>
<p>LR语法分析中,栈中的符号总是形成一个可行前缀,LR语法分析的本质就是通过构建一个识别可行前缀的DFA(实际上是一个DFA和栈形成的PDA )</p>
<h2 id="4-6-更强大的LR语法分析器"><a href="#4-6-更强大的LR语法分析器" class="headerlink" title="4.6 更强大的LR语法分析器"></a>4.6 更强大的LR语法分析器</h2><p>SLR语法分析的问题: 用FOLLOW集合来判断归约条件会产生一些无效的归约</p>
<p>根源: SLR（1）语法分析表基于LR（0）项，没有考虑到下一个可能的输入符号</p>
<h3 id="规范LR-1-项"><a href="#规范LR-1-项" class="headerlink" title="规范LR(1)项"></a>规范LR(1)项</h3><p>LR(1)项: 形如<code>[A -&gt; a.b, x]</code>的项</p>
<blockquote>
<ul>
<li>A -&gt; a.b: 一个产生式</li>
<li>x: 一个终结符号或$, 是长度为(1)的向前看符号</li>
</ul>
<p>这个向前看符号x仅在<code>b=空串e</code>时,即需要进行归约时产生作用; 此时,仅当下一个符号为x时,才会按照<code>A -&gt; a.</code>进行归约</p>
<p>此时,x总在A的FOLLOW集合中 </p>
</blockquote>
<p>LR(1)项集I的闭包CLOSURE(I)的算法:</p>
<blockquote>
<ol>
<li>将I中各个项加入CLOSURE(I)中</li>
<li>若<code>[A -&gt; a.Bc, x]</code>在CLOSURE(I)中,<code>B -&gt; y</code>是一个产生式,则对于FIRST(Bc)中的每个终结符号x,将项<code>[B -&gt; .y, x]</code>加入CLOSURE(I)中(原来就有则不用加)</li>
<li>重复规则2.,直到没有新项能够加入CLOSURE(I)中为止</li>
</ol>
</blockquote>
<p>此时GOTO(I,x)定义修改如下:</p>
<blockquote>
<ul>
<li>I为LR(1)项集族</li>
<li>GOTO(I,x)也为LR(1)项集族</li>
</ul>
</blockquote>
<h3 id="规范LR-1-语法分析表"><a href="#规范LR-1-语法分析表" class="headerlink" title="规范LR(1)语法分析表"></a>规范LR(1)语法分析表</h3><p>LR(1)项集族的构造(C和GOTO):</p>
<blockquote>
<ol>
<li>定义项集族为C(状态集合)</li>
<li>求出<code>[S&#39; -&gt; .S, $]</code>的闭包,将其加入C中</li>
<li>对于C中的每个项集I,扫描每个文法符号X,若GOTO(I,X)非空且不在C中,将GOTO(I,X)作为一个新的状态加入C中</li>
<li>重复3.,直到没有新的状态加入C中</li>
</ol>
</blockquote>
<p>ACTION函数在状态I接收到终结符x时的动作如下:</p>
<blockquote>
<ol>
<li>若<code>[A -&gt; a.xb, c]</code>在I中且能通过GOTO函数转到下一个状态I’,则移入I’</li>
<li>若<code>[A -&gt; a., x]</code>在I中,则ACTION为归约<code>A -&gt; a</code>(此时A不为S’)</li>
<li>若<code>[S&#39; -&gt; S., $]</code>在I中且x为$,则ACTION为接受</li>
<li>不符合上面任一动作的都定义为出错</li>
</ol>
</blockquote>
<p>若ACTION函数中不包含多重定义的条目,那么此文法称为LR(1)文法</p>
<p>例子:<br><img src="/2020/06/07/compilers0/LR1.jpg" alt="LR1"></p>
<p>对于一个SLR(1)文法,规范LR(1)构造出的状态比SLR(1)构造出的状态多</p>
<h3 id="LALR-1-语法分析"><a href="#LALR-1-语法分析" class="headerlink" title="LALR(1)语法分析"></a>LALR(1)语法分析</h3><p>LALR(1)文法: 文法的LR(1)项集族中合并同心集不产生新的归约-归约冲突(移进-归约冲突本身不可能产生)的文法</p>
<p>同心集: 相同核心的集合,即两个LR(1)项集中各自的每一项的第一分量集合相同(即LR(0)部分相同)</p>
<p>通过LR(1)项集族构造LALR(1)语法分析表:</p>
<blockquote>
<ol>
<li>构造语法的LR(1)项集族</li>
<li>计算每个项集的核心,将具有相同项集的核心合并,对应状态也合并</li>
<li>对应GOTO函数也进行合并</li>
<li>构造ACTION函数,构造方法同规范LR(1)中的ACTION函数构造方法,若存在一个多重定义的条目,则此文法不是LALR(1)文法,不适合用LALR(1)语法分析器进行分析</li>
</ol>
</blockquote>
<p>例子:<br><img src="/2020/06/07/compilers0/LALR0.jpg" alt="LALR"></p>
<h3 id="高效构造LALR-1-语法分析表"><a href="#高效构造LALR-1-语法分析表" class="headerlink" title="高效构造LALR(1)语法分析表"></a>高效构造LALR(1)语法分析表</h3><p>LALR(1)的高效构造使用LR(0)项集和LR(1)的CLOSURE计算方法获得项的向前看符号</p>
<blockquote>
<ol>
<li>构造出该文法的LR(0)项集,结果仅以核心项表示</li>
<li>初始化一个以项集,项,向前看符号构成的表格</li>
<li>对于每个LR(0)项集中的核心K,应用下列算法来发现向前看符号的传播和自发生成<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(K中的每个项 A -&gt; a.b)&#123;</span><br><span class="line">   J = [A -&gt; a.b, #]的闭包, #为一个不在当前文法中的符号;</span><br><span class="line">   if( [B -&gt; y.Xc, a]在J中且a不为#)</span><br><span class="line">       该项集I的GOTO(I,X)中的项B -&gt; yX.c的向前看符号a是自发生成的;</span><br><span class="line">       <span class="comment">//将a加入相应项集中项的向前看符号中</span></span><br><span class="line">   if( [B -&gt; y.Xc, #]在J中)</span><br><span class="line">       某向前看符号从当前项 A -&gt; a.b 传播到了GOTO(I,X)中的项B -&gt; y.Xc上;</span><br><span class="line">       <span class="comment">//将当前项的向前看符号加入被传播的项的向前看符号中</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>通过3.中所有自发生成的向前看符号给项来赋初值,并赋<code>S -&gt; .S</code>的向前看符号为$,</li>
<li>反复执行3., 直到没有新的向前看符号被传播为止</li>
</ol>
</blockquote>
<p>例子:<br><img src="/2020/06/07/compilers0/LALR1.jpg" alt="LALR"></p>
<h2 id="4-7-使用二义文法"><a href="#4-7-使用二义文法" class="headerlink" title="4.7 使用二义文法"></a>4.7 使用二义文法</h2><p>二义文法对语言的说明和实现非常有用,二义文法比任何等价的非二义文法提供的说明都要更简短自然</p>
<p>二义文法可由利用优先级和结合规则来解决冲突</p>
<p>LR语法分析中的错误恢复:</p>
<blockquote>
<ul>
<li>错误检测: LR语法分析器在访问动作表是若遇到到出错表项,就检查出错误,访问转移表时不会发现错误</li>
<li>LR语法分析器只要发现已扫描的输入出现一个不正确的后继就会 立即报告错误</li>
<li>其中,规范LR在遇到错误时不会进行任何无效归约,而SLR和LALR可能会进行错误的归约,但不会把出错点的输入字符移进栈中</li>
</ul>
</blockquote>
<h1 id="五、语法制导翻译"><a href="#五、语法制导翻译" class="headerlink" title="五、语法制导翻译"></a>五、语法制导翻译</h1><p>语法制导翻译使用上下文无关文法来引导对语言的翻译,用于类型检查和中间代码生成</p>
<h2 id="5-1-属性文法"><a href="#5-1-属性文法" class="headerlink" title="5.1 属性文法"></a>5.1 属性文法</h2><p>属性文法通过把属性附加到代表语法结构的文法符号上，将语义信息和程序设计语言的语法结构联系起来，属性的值是用与文法产生式相联系的语义规则来计算的 </p>
<p>通用翻译过程: 输入字符串 -&gt; 语法分析树 -&gt; 依赖图 -&gt; 语义规则计算顺序</p>
<blockquote>
<ol>
<li>对输入符号进行语法分析,构建语法分析树</li>
<li>遍历语法分析树,得到描述节点属性间依赖关系的依赖图</li>
<li>由依赖图得到语义规则的计算顺序</li>
<li>得到翻译结果</li>
</ol>
</blockquote>
<p>这种属性和语义规则的标记有以下两种方法:</p>
<blockquote>
<ul>
<li>语法制导定义: 更加易读</li>
<li>语法制导翻译方案: 更加高效,易于实现</li>
</ul>
</blockquote>
<h2 id="5-2-语法制导定义SDD"><a href="#5-2-语法制导定义SDD" class="headerlink" title="5.2 语法制导定义SDD"></a>5.2 语法制导定义SDD</h2><p>语法制导定义是由CFG+属性+规则/语义动作构成的</p>
<blockquote>
<ul>
<li>属性: 描述文法符号的性质</li>
<li>规则/语义动作: 描述产生式的性质</li>
</ul>
</blockquote>
<p>语法制导定义的构造需要根据实际情况来</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性是文法符号的属性: </p>
<blockquote>
<ul>
<li>每个文法符号都有一个相关的属性集，属性可以代表任何对象： 字符串、数字、类型、内存单元或其他对</li>
<li>与这些属性相关的信息，即属性值可以在语法分析过程中计算和 传递。属性加工的过程即语义的处理过程</li>
</ul>
</blockquote>
<p>综合属性: 语法分析树结点N上的非终结符A的综合属性是由N上的产生式所关联的语义规则定义的 </p>
<blockquote>
<ul>
<li>这个产生式的头一定是非终结符A</li>
<li>结点N上的综合属性只能通过其子节点或其本身的属性值来定义</li>
<li>其综合属性可由继承属性定义</li>
<li>终结符号只有综合属性,它由词法分析器定义,不是计算得到的</li>
</ul>
<p>综合属性是自下而上综合得到的</p>
</blockquote>
<p>继承属性: 语法分析树结点N上的非终结符B的继承属性是由N的父结点上的产生式所关联的语义规则定义的</p>
<blockquote>
<ul>
<li>这个产生式的体中一定包含非终结符B</li>
<li>结点N上的继承属性只能通过其父节点、其本身及其兄弟结点上的属性值来定义</li>
<li>N上的继承属性不能通过N的子节点上的属性值定义</li>
</ul>
<p>继承属性是自上而下继承得到的</p>
</blockquote>
<p>注意: 总可以用综合属性来改写语法制导定义，但使用带有继承属性的语法制导定义更为自然</p>
<p>文法开始符号（对应函数/过程）的所有继承属性作为属性计算前的初始值</p>
<h3 id="语义规则"><a href="#语义规则" class="headerlink" title="语义规则"></a>语义规则</h3><p>每个文法产生式<code>A -&gt; a</code>有一组形式为<code>b = f(c, d, e, ...)</code>的语义规则,其中b,c,d,e…是该产生式文法符号的属性,f是语义规则的函数</p>
<p>属性b的性质: </p>
<blockquote>
<ul>
<li>综合属性: b是A的属性,c,d,e…是产生式右部文法符号的属性或者A的其他属性</li>
<li>继承属性: b是产生式体中某文法符号x的属性; 表明该语义向下定义了某子节点的属性</li>
</ul>
</blockquote>
<h3 id="S属性SDD-一个只包含综合属性的SDD"><a href="#S属性SDD-一个只包含综合属性的SDD" class="headerlink" title="S属性SDD: 一个只包含综合属性的SDD"></a>S属性SDD: 一个只包含综合属性的SDD</h3><p>特点:</p>
<blockquote>
<ul>
<li>每个产生式的语义规则都根据相应产生式的产生式体中的属性值来计算产生式头部非终结符的一个属性</li>
<li>它可以和LR语法分析器一起自然地实现, 归约时进行属性计算</li>
</ul>
</blockquote>
<p><img src="/2020/06/07/compilers0/SSDD0.jpg" alt="SSDD"></p>
<h3 id="L属性SDD-属性依赖图的边总是从左到右"><a href="#L属性SDD-属性依赖图的边总是从左到右" class="headerlink" title="L属性SDD: 属性依赖图的边总是从左到右"></a>L属性SDD: 属性依赖图的边总是从左到右</h3><p>特点: 每个属性可由是综合属性或继承属性, 表达式体X.a继承属性属于如下情况:</p>
<blockquote>
<ul>
<li>a是和产生式头A关联的继承属性</li>
<li>a是和X左边文法符号的继承属性或综合属性相关连</li>
<li>a和X本身的继承属性或综合属性相关,但组成的依赖图中不存在环</li>
</ul>
</blockquote>
<p>实现方法: 通过遍历语法分析树来完成翻译工作,先语法分析后语法制导翻译; 效率较低 </p>
<h3 id="注释分析树"><a href="#注释分析树" class="headerlink" title="注释分析树"></a>注释分析树</h3><p>一个注释分析树是一个显示了结点各个属性值的语法分析树</p>
<p>S属性SDD语法分析树建立: 计算各节点属性值</p>
<blockquote>
<p>后序遍历语法分析树, 根据语义规则对各个节点属性求值</p>
</blockquote>
<p><img src="/2020/06/07/compilers0/SSDD1.jpg" alt="SSDD"></p>
<h3 id="SDD的求值顺序-属性依赖图"><a href="#SDD的求值顺序-属性依赖图" class="headerlink" title="SDD的求值顺序: 属性依赖图"></a>SDD的求值顺序: 属性依赖图</h3><p>属性依赖图可以确定一个给定的语法分析树中各个属性实例的求值顺序</p>
<blockquote>
<ul>
<li>有向边: 语义规则所蕴含的约束</li>
<li>结点: 某文法符号的某属性</li>
</ul>
</blockquote>
<p>构建依赖图:</p>
<blockquote>
<ul>
<li>为为每个包含过程调用的语义规则<code>b = f(c, d, e, ...)</code>引入一个虚综合属性b</li>
<li>若属性b依赖于属性c等,则从c到b有一条有向边</li>
</ul>
</blockquote>
<p>例:<br><img src="/2020/06/07/compilers0/SSDD2.jpg" alt="SSDD"></p>
<p>属性计算顺序(分析树方法): </p>
<blockquote>
<ol>
<li>构造输入语法分析树</li>
<li>构造属性依赖图</li>
<li>按照属性依赖图对节点进行拓扑排序,选其中一种结果作为属性的计算次序</li>
</ol>
</blockquote>
<h3 id="SDD的应用-抽象语法树的构造"><a href="#SDD的应用-抽象语法树的构造" class="headerlink" title="SDD的应用: 抽象语法树的构造"></a>SDD的应用: 抽象语法树的构造</h3><p>抽象语法树是语法分析树的压缩形式; 此时运算符和关键字不再是叶节点,而是作为内节 点成为分析树中叶节点的父节点</p>
<p>Node结点: 非叶结点</p>
<blockquote>
<p>构造函数: Node(label,child1,child2,…)</p>
<ul>
<li>label: 本身属性(代号)</li>
<li>child1,child2,…:各子节点(对于运算符而言,几元运算符就有几个子节点)</li>
</ul>
</blockquote>
<p>Leaf结点: 叶节点</p>
<blockquote>
<p>构造函数: Leaf(op,val)</p>
<ul>
<li>op: 叶节点本身属性(代号)</li>
<li>val: 叶节点的值</li>
</ul>
</blockquote>
<p>根据语法分析树构造抽象语法树:</p>
<blockquote>
<ul>
<li>原语法分析树的边为点虚线</li>
<li>语法分析树结点和抽象语法树结点的对应关系用虚线表示(非叶结点)</li>
<li>抽象语法树的边为实线</li>
<li>抽象语法树的结点以记录的形式表示,记录的第一个字段是op(终结符名)</li>
</ul>
<p>S属性的SDD的抽象语法树可以在自底向上分析的归约时建立</p>
</blockquote>
<p>一个构造抽象语法树的语法制导定义:<br><img src="/2020/06/07/compilers0/tree1.jpg" alt="tree"><br><img src="/2020/06/07/compilers0/tree2.jpg" alt="tree"></p>
<h2 id="5-3-语法制导翻译方案SDT"><a href="#5-3-语法制导翻译方案SDT" class="headerlink" title="5.3 语法制导翻译方案SDT"></a>5.3 语法制导翻译方案SDT</h2><p>语法制导翻译方案是语法制导定义的一种补充,上述语法制导定义的应用都可以用语法制导翻译方案实现</p>
<p>SDT在文法的各产生式的右部嵌入语义动作(即程序片段):</p>
<blockquote>
<ul>
<li>语义动作可以出现在产生式体中的任何地方</li>
<li>语义动作两边用花括号包裹,若冲突也可用引号</li>
</ul>
</blockquote>
<p>一般用SDT来实现SDD,并用LR技术分析S属性SDD,用LL技术分析L属性SDD</p>
<h3 id="将SDD转化为SDT"><a href="#将SDD转化为SDT" class="headerlink" title="将SDD转化为SDT"></a>将SDD转化为SDT</h3><p>对于产生式<code>A-&gt;B</code>及一些定义属性的语义动作,SDT改写规则如下: </p>
<blockquote>
<ul>
<li>产生式体中某符号b的继承属性计算紧跟在b的左边,有多个属性则按照求值顺序先后排列(先定义属性,再出现符号)</li>
<li>产生式头A的综合属性计算放在产生式尾部(最右端)</li>
</ul>
<p>动作的执行: 当一个动作左边的所有符号都被处理后,该动作立刻执行</p>
</blockquote>
<p>对于S属性的SDD,其对应SDT中的语义动作都在产生式结尾,此SDT为后缀SDT</p>
<h3 id="S属性的自下而上计算"><a href="#S属性的自下而上计算" class="headerlink" title="S属性的自下而上计算"></a>S属性的自下而上计算</h3><p>此即后缀SDT语法分析栈的实现</p>
<p>扩展LR分析器,使其能实现S属性语法制导翻译:</p>
<blockquote>
<ol>
<li>在LR分析器的栈中增加一列来保存文法符号的综合属性值</li>
<li>按照下列策略计算各符号的属性值<br><img src="/2020/06/07/compilers0/stack0.jpg" alt="stack"></li>
</ol>
</blockquote>
<p>一个栈操作代码的语法制导定义<br><img src="/2020/06/07/compilers0/stack1.jpg" alt="stack"></p>
<h3 id="L属性的自上而下计算"><a href="#L属性的自上而下计算" class="headerlink" title="L属性的自上而下计算"></a>L属性的自上而下计算</h3><p>L属性SDD需要用自顶向下的方式进行语法分析</p>
<p>从SDT中消除左递归:</p>
<blockquote>
<p>在一个含有语义动作的后缀SDT文法中消除左递归,会导致出现继承属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;这里只有一个属性的符号不显示属性名</span><br><span class="line">&#x2F;&#x2F;变换前</span><br><span class="line">A -&gt; A&#39;a &#123;A&#x3D;f(A&#39;,a)&#125;</span><br><span class="line">A -&gt; b  &#123;A&#x3D;g(b)&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;变换后</span><br><span class="line">A -&gt; b &#123;R.i&#x3D;g(b)&#125; R &#123;A &#x3D; R.s&#125;</span><br><span class="line">R -&gt; a &#123;R&#39;.i&#x3D;f(R.i,a)&#125; R&#39; &#123;R.s&#x3D;R&#39;.s&#125;</span><br><span class="line">R -&gt; e &#123;R.s&#x3D;R.i&#125; </span><br></pre></td></tr></table></figure>
<ul>
<li>该文法用于匹配baaa…字符串</li>
<li>原文法中,自上而下计算时,每出现一次a递归调用一次f(),直到遇到b时执行g()并逐层返回,递归计算f(f(…f(g</li>
<li>变换后,R.i用于顺序计算gfff…,R.s用于递归带回最后的R.i值并赋给A</li>
</ul>
</blockquote>
<p>扩展预测分析器,使其能实现L属性语法制导翻译(预测翻译器):</p>
<blockquote>
<ul>
<li>为每个非终结符A构造一个函数,参数为A的继承属性,返回值为A的综合属性,当前的输入字符a作为可访问的全局变量</li>
<li>该函数主体为switch(a),每个case代表通过当前输入字符选定了一个产生式,并进行相应处理</li>
<li>该处理过程中包含以下两点:<ul>
<li>对于有综合属性x的记号X,则保存在X.x中,并匹配记号X</li>
<li>对于非终结符B,相应计算c = B(b1,b2,…,bk),则b1,b2,…,bk对应B的继承属性, c对应B的综合属性</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<p>博文创建时间:  2020-02-24 16:32:03</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>computer-composition1</title>
    <url>/2020/06/01/computer-composition1/</url>
    <content><![CDATA[<h2 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h2><ul>
<li>ENIAC:1946年</li>
<li>冯诺依曼结构特点,结构图</li>
<li>计算机发展阶段</li>
<li>计算机语言: 机器-&gt;汇编-&gt;高级</li>
<li>计算机多级层次结构</li>
</ul>
<a id="more"></a>

<h2 id="二、计算机中常用的组合逻辑电路"><a href="#二、计算机中常用的组合逻辑电路" class="headerlink" title="二、计算机中常用的组合逻辑电路"></a>二、计算机中常用的组合逻辑电路</h2><ul>
<li>加法器,算术逻辑单元</li>
<li>了解译码器</li>
<li>锁存器,边沿D触发器</li>
<li>寄存器,移位寄存器</li>
<li>了解计数器</li>
<li>阵列逻辑电路概念</li>
</ul>
<h2 id="三、运算方法和运算部件-重点"><a href="#三、运算方法和运算部件-重点" class="headerlink" title="三、运算方法和运算部件(重点)"></a>三、运算方法和运算部件(重点)</h2><ul>
<li>数制转换</li>
<li>十进制数按位编码</li>
<li>机器数原码,反码,补码,移码</li>
<li>加减运算溢出处理(双符号法)</li>
<li>定点数,浮点数,浮点数构成</li>
<li>浮点数规格化,浮点数IEEE745标准</li>
<li>二进制乘法运算,定点原码一位乘</li>
<li>定点补码一位乘(布斯乘法)</li>
<li>定点除法运算:恢复余数法,加减交替法</li>
<li>浮点数加减运算五个过程</li>
<li>定点运算部件: 三个寄存器</li>
<li>数据校验码: 奇偶校验,了解海明码和CRC码</li>
</ul>
<h2 id="四、主存储器"><a href="#四、主存储器" class="headerlink" title="四、主存储器"></a>四、主存储器</h2><ul>
<li>主存储器核心地位,指标,基本操作</li>
<li>读写存储器发展,特点(动态和静态存储器),动态存储器的刷新</li>
<li>存储器组成和控制(重点)<blockquote>
<ul>
<li>位扩展和字扩展</li>
<li>刷新逻辑</li>
</ul>
</blockquote>
</li>
<li>了解多体交叉存储器</li>
</ul>
<h2 id="五、指令系统"><a href="#五、指令系统" class="headerlink" title="五、指令系统"></a>五、指令系统</h2><ul>
<li>指令系统概念,指令格式</li>
<li>指令扩展</li>
<li>寻址方式(重点)</li>
<li>指令类型: 算术逻辑运算指令,堆栈操作指令</li>
<li>了解两种指令系统</li>
</ul>
<p>分析指令类型:</p>
<blockquote>
<ul>
<li>指出指令字长,是几地址指令</li>
<li>操作码字长,可以表示多少条指令</li>
<li>各数据地址码寻址方式,寻址大小,能表示的寄存器个数</li>
<li>指令类型(RS指令,RR指令)</li>
</ul>
</blockquote>
<p>设计指令格式:</p>
<blockquote>
<ul>
<li>按照计算机字长,指令条数,寻址方式选择,寻址大小来分配位数</li>
</ul>
</blockquote>
<h2 id="六、中央处理器"><a href="#六、中央处理器" class="headerlink" title="六、中央处理器"></a>六、中央处理器</h2><ul>
<li><p>控制器组成,各种寄存器名字意思</p>
</li>
<li><p>两种程序控制方法</p>
</li>
<li><p>指令执行过程(加法)</p>
</li>
<li><p>微程序控制: 微操作,微指令,微程序概念和联系</p>
</li>
<li><p>微指令格式</p>
</li>
<li><p>流水线相关操作,了解一下产生的问题</p>
</li>
</ul>
<h2 id="七、存储系统"><a href="#七、存储系统" class="headerlink" title="七、存储系统"></a>七、存储系统</h2><ul>
<li><p>存储器的结构层次</p>
</li>
<li><p>cache各种知识</p>
</li>
</ul>
<h2 id="十、输入输出系统"><a href="#十、输入输出系统" class="headerlink" title="十、输入输出系统"></a>十、输入输出系统</h2><ul>
<li>IO控制方式</li>
<li>中断的知识</li>
</ul>
]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>sql使用</title>
    <url>/2020/05/24/mysql0/</url>
    <content><![CDATA[<p>mysql的使用大全可以参考<a href="http://c.biancheng.net/mysql/" target="_blank" rel="noopener">http://c.biancheng.net/mysql/</a></p>
<p>本文主要根据笔记<a href="http://georgechen.top/2020/02/27/data-base0/" target="_blank" rel="noopener">http://georgechen.top/2020/02/27/data-base0/</a>精简整理,保留常用语句用法</p>
<a id="more"></a>

<h2 id="1-入手"><a href="#1-入手" class="headerlink" title="1. 入手"></a>1. 入手</h2><h3 id="建立用户账户及更改权限"><a href="#建立用户账户及更改权限" class="headerlink" title="建立用户账户及更改权限"></a>建立用户账户及更改权限</h3><p><code>GRANT ALL ON DataBaseA.* TO &#39;root&#39;@&#39;localhost&#39;;</code></p>
<h3 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h3><p><code>&gt;cmd mysql -h hostname|hostlP -p port -u username -p DatabaseName -e &quot;SQL语句&quot;</code></p>
<h3 id="创建数据库及表"><a href="#创建数据库及表" class="headerlink" title="创建数据库及表"></a>创建数据库及表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database school;</span><br><span class="line"></span><br><span class="line">mysql&gt; use school;</span><br></pre></td></tr></table></figure>

<p>mysql数据存储位置:</p>
<ul>
<li>这个位置文件的路径在my.ini中datadir中可以找到  </li>
<li>一般情况下,my.ini在mysql安装目录下(例如C:\ProgramData\MySQL\MySQL Server 8.0)</li>
</ul>
<h2 id="2-数据定义"><a href="#2-数据定义" class="headerlink" title="2. 数据定义"></a>2. 数据定义</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>为某人创建某名的模式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</span><br><span class="line">[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;权限定义子句&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>若没有指定模式名,则模式名隐含为用户名</li>
</ul>
<p>删除某模式:<code>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</code><br>删除选项:</p>
<blockquote>
<ul>
<li>CASADE 级联: 删除模式同时将该模式下的所有数据库对象删除</li>
<li>RESTRICT 限制: 仅当该模式中没有任何下属对象时才能执行, 如果这个模式下有表/视图等定义,则拒绝执行语句</li>
</ul>
</blockquote>
<h3 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h3><h4 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="comment">/* 基本表的名称 */</span> </span><br><span class="line">(&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] <span class="comment">/*组成该表的列*/</span> </span><br><span class="line">[,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] </span><br><span class="line">… </span><br><span class="line">[,&lt;表级完整性约束条件&gt; ] );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>&lt;列级完整性约束条件&gt;: 涉及仅单个属性列的完整性约束条件 </p>
</li>
<li><p>&lt;表级完整性约束条件&gt;: 涉及一个或多个属性列的完整性约束条件 </p>
</li>
<li><p>&lt;表名&gt;:每一个基本表需属于某个模式,可以显式地在表名中给出,也可以在搜索路径中设置 </p>
<blockquote>
<p>设置搜索路径(默认模式):<code>SET search_path TO &lt;模式名&gt;,PUBLIC;</code></p>
</blockquote>
</li>
<li><p>&lt;数据类型&gt;: 有如下数据类型</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">含义</th>
<th align="left">数据类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR(n)</td>
<td align="left">n位定长字符串</td>
<td align="left">CHARACTER(n)</td>
<td align="left">同CHAR(n)</td>
</tr>
<tr>
<td align="left">VRCHAR(n)</td>
<td align="left">最大长度为n的变长字符串</td>
<td align="left">VRCHARACTER(n)</td>
<td align="left">同VRCHAR(n)</td>
</tr>
<tr>
<td align="left">CLOB</td>
<td align="left">字符串大对象</td>
<td align="left">BLOB</td>
<td align="left">二进制大对象</td>
</tr>
<tr>
<td align="left">INT</td>
<td align="left">长整数(4字节)</td>
<td align="left">INTEGER</td>
<td align="left">同INT</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">大整数(8字节)</td>
<td align="left">SMALLINT</td>
<td align="left">短整数(2字节)</td>
</tr>
<tr>
<td align="left">DEC(p,d)</td>
<td align="left">精度为d的p位定点数</td>
<td align="left">DECIMAL(p,d),NUMERIC(p,d)</td>
<td align="left">同DEC(p,d)</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">单精度浮点数</td>
<td align="left">DOUBLE PRECISION</td>
<td align="left">双精度浮点数</td>
</tr>
<tr>
<td align="left">FLOAT(n)</td>
<td align="left">精度为n的浮点数</td>
<td align="left">BOOLEAN</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">格式为YYYY-MM-DD的日期</td>
<td align="left">TIME</td>
<td align="left">格式为HH:MM:SS的时间</td>
</tr>
<tr>
<td align="left">TIMESTAP</td>
<td align="left">时间戳类型</td>
<td align="left">INTERVAL</td>
<td align="left">时间间隔类型</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</span><br><span class="line">[<span class="keyword">ADD</span> &lt;表级完整性约束&gt;] <span class="comment">/*完整性约束只能添加表级完整性约束*/</span></span><br><span class="line">[<span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] &lt;列名&gt; [<span class="keyword">CASCADE</span>| RESTRICT] ]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>&lt;完整性约束名&gt;[ RESTRICT | <span class="keyword">CASCADE</span> ] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> &lt;列名&gt;&lt;数据类型&gt; ] ;</span><br></pre></td></tr></table></figure>
<ul>
<li>ADD COLUMN: 增加列</li>
<li>DROP COLUMN: 删除列<blockquote>
<ul>
<li>级联: 删除该列及引用该列的其他对象</li>
<li>限制: 如果该列被其他对象引用,则拒绝删除</li>
</ul>
</blockquote>
</li>
<li>ALTER COLUMN:修改列,也可以用以下两种方法<blockquote>
<ul>
<li><code>MODIFY &lt;列名&gt; &lt;数据类型&gt;</code>:修改列的数据类型</li>
<li><code>CHANGE &lt;列名&gt; &lt;新列名&gt; &lt;新数据类型&gt;</code>:修改列名</li>
</ul>
</blockquote>
</li>
<li>RENAME TO &lt;新表名&gt;:改个新表名</li>
</ul>
<h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;［RESTRICT| <span class="keyword">CASCADE</span>］;</span><br></pre></td></tr></table></figure>
<ul>
<li>级联:在删除基本表的同时，相关的依赖对象一起删除</li>
<li>限制:如果存在依赖该表的对象(该表被其他表引用),则拒绝删除</li>
</ul>
<h3 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h3><p>建立索引目的: 加快查询速度</p>
<ul>
<li>常见索引:顺序索引,B+树索引,散列索引,位图索引</li>
<li>索引由数据库管理员或建表者建立</li>
<li>索引由关系数据库系统自动完成维护</li>
</ul>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] <span class="keyword">INDEX</span> &lt;索引名&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);</span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;表名&gt;：要建索引的基本表的名字  </li>
<li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔  </li>
<li>&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省 值：ASC  </li>
<li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录  </li>
<li>CLUSTER：表示要建立的索引是聚簇索引</li>
</ul>
<h4 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h4><p><code>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索 引名&gt;;</code></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><code>DROP INDEX &lt;索引名&gt;;</code><br>删除索引时，系统会从数据字典中删去有关该索引的描述</p>
<h3 id="聚簇方法"><a href="#聚簇方法" class="headerlink" title="聚簇方法"></a>聚簇方法</h3><p>聚簇: 通过将属性(组)上具有相同值的元组集中存放在连续的物理块上,提高某个属性(组)的查询速度(减少IO操作)</p>
<blockquote>
<p>上述属性(组)称为聚簇码</p>
</blockquote>
<p>聚簇建立:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CLUSTER &lt;聚簇名&gt; (&lt;聚簇码&gt;) <span class="keyword">SIZE</span> (&lt;大小&gt;);</span><br></pre></td></tr></table></figure>

<h2 id="3-数据完整性约束"><a href="#3-数据完整性约束" class="headerlink" title="3. 数据完整性约束"></a>3. 数据完整性约束</h2><p>数据库的完整性包括以下两个方面:</p>
<ul>
<li>数据的正确性(实体完整性等)</li>
<li>数据的相容性(参照完整性)</li>
</ul>
<p>在2.中定义和修改表时需要用到数据库完整性约束</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><h4 id="实体完整性定义"><a href="#实体完整性定义" class="headerlink" title="实体完整性定义"></a>实体完整性定义</h4><p>关系模型的实体完整性用主码PRIMARY KEY描述</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;列名&gt; ... PRIMARY KEY /* 列级完整性约束 */</span><br><span class="line">PRIMARY KEY(&lt;列名&gt;[,&lt;列名&gt;,...]) /* 表级完整性约束 */</span><br></pre></td></tr></table></figure>
<ul>
<li>列级完整性约束可以定义单属性构成的码</li>
<li>表级完整性约束可以定义单个或多个属性构成的码</li>
</ul>
<p>违约处理:拒绝插入或更新</p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><h4 id="参照完整性定义"><a href="#参照完整性定义" class="headerlink" title="参照完整性定义"></a>参照完整性定义</h4><ul>
<li>定义表中的外码,以及被参照关系的主码<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列级完整性约束 */</span></span><br><span class="line">&lt;外码列名&gt; ... FOREIGN KEY REFERENCES DEPT(&lt;被参考关系主码&gt;) [ON DELETE|UPDATE CASCADE|NO ACTION|SET-NULL]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表级完整性约束 */</span></span><br><span class="line">FOREIGN KEY(&lt;外码列名&gt;) REFERENCES DEPT(&lt;被参考关系主码&gt;) [ON DELETE|UPDATE CASCADE|NO ACTION|SET-NULL]</span><br></pre></td></tr></table></figure></li>
<li>对于参照表的元组插入或外码值修改,违约即拒绝执行</li>
<li>对于被参照表的元组删除或主码值修改,有三种违约处理方式:<blockquote>
<ul>
<li>拒绝执行:不执行语句</li>
<li>级联操作:将参照表中有关联的元组删除或进行外码修改</li>
<li>设置空值:将参照表中有关联的元组外码置为空值,这可能会导致参照表中的元组违反实体完整性约束</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="用户定义完整性约束"><a href="#用户定义完整性约束" class="headerlink" title="用户定义完整性约束"></a>用户定义完整性约束</h3><h4 id="用户完整性约束定义"><a href="#用户完整性约束定义" class="headerlink" title="用户完整性约束定义"></a>用户完整性约束定义</h4><p>列级完整性约束定义(属性约束条件)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;列名&gt; ... [UNIQUE] [NOT NULL] [CHECK(expr)]</span><br></pre></td></tr></table></figure>
<ul>
<li>NOT NULL:列值非空</li>
<li>UNIQUE:列值唯一(相当于主码)</li>
<li>CHECK(expr):列值满足某表达式</li>
</ul>
<p>表级完整性约束定义(元组约束条件):用于设置不同属性之间的取值的相互约束条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHECK(expr)</span><br></pre></td></tr></table></figure>

<p>违约处理:拒绝执行</p>
<h3 id="完整性约束命名字句"><a href="#完整性约束命名字句" class="headerlink" title="完整性约束命名字句"></a>完整性约束命名字句</h3><h4 id="完整性约束命名子句定义"><a href="#完整性约束命名子句定义" class="headerlink" title="完整性约束命名子句定义"></a>完整性约束命名子句定义</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">CONSTANT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</span><br></pre></td></tr></table></figure>
<p>该子句可以作为列级完整性约束或表级完整性约束使用</p>
<h4 id="完整性约束子句的删除和添加"><a href="#完整性约束子句的删除和添加" class="headerlink" title="完整性约束子句的删除和添加"></a>完整性约束子句的删除和添加</h4><p>用ALTER TABLE对约束条件进行删除和添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTANT</span> &lt;完整性约束条件名&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTANT</span> &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现完整性约束子句的修改时,需要先删除约束,再添加约束,如上所示</li>
</ul>
<h3 id="域中的完整性限制"><a href="#域中的完整性限制" class="headerlink" title="域中的完整性限制"></a>域中的完整性限制</h3><p>对于多个具有联系的表,表中的一些属性可能具有相同的域,可以通过建立域的完整性约束来使不同表中的相同的属性域也相同</p>
<h4 id="域完整性约束定义"><a href="#域完整性约束定义" class="headerlink" title="域完整性约束定义"></a>域完整性约束定义</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义完整性约束 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DOMAIN</span> &lt;完整性约束条件名&gt; &lt;被约束列的值类型&gt; &lt;完整性约束子句&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改完整性约束中的限制条件 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DOMAIN</span> &lt;完整性约束条件名&gt; &lt;完整性约束修改子句&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>完整性约束修改子句包括完整性约束子句的删除和添加,需要指定完整性约束条件名</li>
</ul>
<h4 id="域完整性约束使用"><a href="#域完整性约束使用" class="headerlink" title="域完整性约束使用"></a>域完整性约束使用</h4><p>定义好域的完整性约束后,可以直接使用完整性约束条件名来作为同类型的属性的完整性约束条件</p>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>SQL中更一般的约束可以用断言来指定</p>
<p>断言创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ASSERTION</span> &lt;断言名&gt; &lt;<span class="keyword">CHECK</span>子句&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>CHECK子句和WHERE子句的表达类似</li>
</ul>
<p>断言删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">ASSERTION</span> &lt;断言名&gt;</span><br></pre></td></tr></table></figure>

<p>违约处理:拒绝执行</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程, 任何用户对表的增删改操作均由服务器自动激活相应的触发器</p>
<h4 id="定义触发器"><a href="#定义触发器" class="headerlink" title="定义触发器"></a>定义触发器</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt;</span><br><span class="line">&#123;<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>&#125; &lt;触发事件&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">REFERENCING</span> </span><br><span class="line">    <span class="keyword">NEW</span>|<span class="keyword">OLD</span> <span class="keyword">ROW</span> <span class="keyword">AS</span> &lt;变量&gt;,</span><br><span class="line">    <span class="keyword">NEW</span>|<span class="keyword">OLD</span> <span class="keyword">ROW</span> <span class="keyword">AS</span> &lt;变量&gt;,...]</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123;<span class="keyword">ROW</span>|<span class="keyword">STATEMENT</span>&#125;</span><br><span class="line">[<span class="keyword">WHEN</span> &lt;触发条件&gt;] &lt;触发动作体&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>触发器只能由表的拥有者创建</li>
<li>触发器只能定义在基本表上</li>
<li>&lt;触发器名&gt;可以包含或不包含模式名,同一模式下触发器名必须是唯一的</li>
<li>&lt;触发事件&gt;可以是对&lt;表名&gt;的INSERT,DELETE或UPDATE [OF &lt;触发列,…&gt;],触发器可在上述操作之后或者之前执行</li>
<li>RECEFRENCING子句用于指出所引用的变量,在后面的行级触发器中可以用到</li>
<li>FOR EACH子句可以定义触发器的类型:行级触发器或语句级触发器<blockquote>
<ul>
<li>行级触发器在对每一个元组进行相应的更改时激活(会多次激活触发器)</li>
<li>语句级触发器在语句执行时进行激活(以所更改的行为对象一次性进行操作)</li>
</ul>
</blockquote>
</li>
<li>定义WHEN后,只有触发器在激活后满足&lt;触发条件&gt;,触发动作体才会执行</li>
<li>&lt;触发动作体&gt;可以是一个匿名的SQL过程块,也可以是对已创建存储过程的调用;<blockquote>
<ul>
<li>行级触发器中用户可以在触发动作体中使用NEW和OLD引用实践之后的新之和事件之前的旧值</li>
<li>如果触发器动作体执行失败,则激活触发器的事件会被拒绝执行</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="触发器的激活"><a href="#触发器的激活" class="headerlink" title="触发器的激活"></a>触发器的激活</h4><p>一个表上可以定义多个触发器,遵循如下顺序执行</p>
<ul>
<li>执行表上的BEFORE触发器</li>
<li>执行SQL语句</li>
<li>执行表上的AFTER触发器<blockquote>
<p>有多个BEFORE或AFTER触发器时,一般上时间上先定义的触发器先执行</p>
</blockquote>
</li>
</ul>
<h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有具有相应权限的用户才能删除相应的触发器</li>
</ul>
<h2 id="4-数据查询"><a href="#4-数据查询" class="headerlink" title="4. 数据查询"></a>4. 数据查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>语句格式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;] …</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]…|(<span class="keyword">SELECT</span> 语句)</span><br><span class="line">[<span class="keyword">AS</span>]&lt;别名&gt;</span><br><span class="line">[ <span class="keyword">WHERE</span> &lt;条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt; [ <span class="keyword">HAVING</span> &lt;条件表达式&gt; ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [ <span class="keyword">ASC</span>|<span class="keyword">DESC</span> ] ]</span><br></pre></td></tr></table></figure>
<ul>
<li>SELECT:指定要显示的结果属性列,*表示所有列<blockquote>
<ul>
<li>目标列值可以为常量,即使它不在查询对象中</li>
<li>LOWER(&lt;目标列&gt;)可以使目标列值小写输出</li>
<li>目标列值可以用聚集函数表示</li>
<li>可以用别名<code>&lt;目标列表达式&gt; &lt;目标列别名&gt;</code>改变查询结果的列标题</li>
<li>ALL表示不去除重复的行(默认),DISTINCT表示去重</li>
</ul>
</blockquote>
</li>
<li>FROM:指定查询对象</li>
<li>WHERE:查询条件<blockquote>
<p>常用查询条件:</p>
<ul>
<li>基本比较运算符</li>
<li>确定范围: [NOT] BETWEEN .. AND ..</li>
<li>确定集合: [NOT] IN &lt;值表&gt; ; &lt;值表&gt;=(值1,值2,…)</li>
<li>字符匹配: [NOT] LIKE &lt;匹配字符串&gt; [ESCAPE &lt;换码字符&gt;]  <blockquote>
<p>匹配串中’%’表示任意长度通配,’_’表示单字符通配,’&#39;可以将通配符转义(需要ESCAPE’&#39;来表明转义字符)</p>
</blockquote>
</li>
<li>空值:IS [NOT] NULL;其中IS不能用’=’代替</li>
<li>连接运算符:NOT AND OR,优先级从高到低</li>
</ul>
</blockquote>
</li>
<li>GROUP BY:对查询结果按指定列的值分组,列值相等的元素归到一组;通常会在每组中使用聚集函数<blockquote>
<p>常用聚集函数:</p>
<ul>
<li>COUNT([ALL|DISTINCT] &lt;列名&gt;): 列值计数</li>
<li>SUM([ALL|DISTINCT] &lt;列名&gt;): 对数值型的列求总和</li>
<li>AVG([ALL|DISTINCT] &lt;列名&gt;): 对数值型的列求均值</li>
<li>MAX|MIN([ALL|DISTINCT] &lt;列名&gt;): 求列的最大|最小值  </li>
</ul>
<p>没有GROUP BY语句时,聚集函数将作用于整个查询结果,使用分组后函数将分别作用于每个组</p>
</blockquote>
</li>
<li>HAVING:在分组时选择指定条件的组,可以使用聚集函数,不能用WHERE替代</li>
<li>ORDER BY:对查询结果按指定值升序或降序排序,支持以不同优先级设置多个排序标准</li>
</ul>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>SQL中的“连接”是用“连接条件”来表达的。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;表名&gt;.&lt;列名&gt;,...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;,&lt;表<span class="number">2</span>&gt;,...</span><br><span class="line"><span class="keyword">WHERE</span> [&lt;表名<span class="number">1</span>&gt;.]&lt;列名<span class="number">1</span>&gt;  &lt;比较运算符&gt;  [&lt;表名<span class="number">2</span>&gt;.]&lt;列名<span class="number">2</span>&gt;</span><br><span class="line">      <span class="keyword">AND</span> &lt;其他条件&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>WHERE子句中除了连接条件,还可以有选择条件,同时完成选择和连接查询</li>
<li>对于表的自身连接,可以给同一个表取不同的别名来区分,来实现一些复杂的连接条件</li>
<li>左右外连接:<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">LEFT</span>|<span class="keyword">RIGHT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; </span><br><span class="line"><span class="keyword">ON</span> &lt;连接条件&gt;; </span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>FROM中也可以有多个表,进行多表连接</li>
</ul>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>一个SELECT-FROM-WHERE语句称为一个查询块,将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
<h4 id="IN子查询"><a href="#IN子查询" class="headerlink" title="IN子查询"></a>IN子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> &lt;列名(值)&gt; <span class="keyword">IN</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line">        ...</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h4 id="ANY-ALL子查询"><a href="#ANY-ALL子查询" class="headerlink" title="ANY/ALL子查询"></a>ANY/ALL子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> &lt;列名&gt; &lt;比较运算符&gt; <span class="keyword">ANY</span>/<span class="keyword">ALL</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line">        ...</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>当确定内层子查询返回结果是单个值时,可以省略ANY/ALL</li>
<li>ANY/ALL的对象为某个查询结果,表示其中任意一个值或者全部值<blockquote>
<p>有时ANY/ALL谓词表达式可以用子查询中的聚集函数代替,如<code>&lt; ANY (SELECT &lt;列名&gt;)</code>可以用<code>&lt; (SELECT MIN(&lt;列名&gt;))</code>实现</p>
</blockquote>
</li>
</ul>
<h4 id="EXISTS子查询"><a href="#EXISTS子查询" class="headerlink" title="EXISTS子查询"></a>EXISTS子查询</h4><p>EXISTS是相关子查询,它依次取外层查询中表内的各元组,根据它与内层查询相关的属性值处理内层查询,若WHERE子句返回值为真,则取此元组放入结果表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">NOT</span>] <span class="keyword">EXISTS</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> &lt;表<span class="number">2</span>&gt;,...</span><br><span class="line">        <span class="keyword">WHERE</span> &lt;表<span class="number">1</span>&gt;...&lt;表<span class="number">2</span>&gt;...;</span><br><span class="line">    );</span><br><span class="line"><span class="comment">/* 表示查询结果中的每条记录都满足/不满足EXISTS子句 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>EXIST的对象也是某个查询结果，若查询结果非空则返回真<blockquote>
<ul>
<li>由EXISTS引出的子查询中一般都是SELECT *</li>
<li>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换</li>
<li>SQL中的存在,任意,蕴含等谓词都需要用EXISTS手动实现</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h4><p>除法运算需要用EXIST子句实现</p>
<p>原理:</p>
<ol>
<li>计算C(X)=A(X,Y)/B(Y,Z)</li>
<li>根据上式,需要找出所有的c[X],使得对于所有的b[Y],都存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]</li>
<li>SQL中没有全称量词,需要对上式进行转换:找出所有的c[X],使得不存在b[Y],不存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]</li>
<li>对于 ‘不存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]’, 还可以使用集合差运算转化成 ‘全体a[X,Y] - 使得a[X]=c[X],a[Y]=b[Y]的a[X,Y]’</li>
</ol>
<p>3的实现代码如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> X </span><br><span class="line"><span class="keyword">FROM</span> A [<span class="keyword">AS</span>] R <span class="comment">/* 换名防止后面混淆 */</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * </span><br><span class="line">    <span class="keyword">FROM</span> B</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> A</span><br><span class="line">        <span class="keyword">WHERE</span> &lt;X=R.X&gt;</span><br><span class="line">          <span class="keyword">AND</span> &lt;Y=B.Y&gt;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>4的实现代码如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> X </span><br><span class="line"><span class="keyword">FROM</span> A [<span class="keyword">AS</span>] R <span class="comment">/* 换名防止后面混淆 */</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    (<span class="keyword">SELECT</span> *</span><br><span class="line">     <span class="keyword">FROM</span> A</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">EXCEPT</span> <span class="comment">/* 集合做差 */</span></span><br><span class="line">    (<span class="keyword">SELECT</span> X,Y </span><br><span class="line">     <span class="keyword">FROM</span> A,B</span><br><span class="line">     <span class="keyword">WHERE</span> &lt;A.X=R.X&gt;</span><br><span class="line">       <span class="keyword">AND</span> &lt;A.Y=B.Y&gt;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="蕴含逻辑"><a href="#蕴含逻辑" class="headerlink" title="蕴含逻辑"></a>蕴含逻辑</h4><p>蕴含逻辑也需要用EXISTS子句实现</p>
<ol>
<li>给定逻辑:对于任意的a,都有B-&gt;C</li>
<li>化简逻辑:不存在a,使得B或非C</li>
<li>用NOT EXISTS实现上述语句;注意,非C也可以用NOT EXISTS实现</li>
</ol>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>集合查询可以对两个查询结果进行集合运算</p>
<ul>
<li>UNION:并</li>
<li>INTERSECT:交</li>
<li>EXCEPT:差<br>注意:参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同 </li>
</ul>
<h2 id="5-数据更新"><a href="#5-数据更新" class="headerlink" title="5. 数据更新"></a>5. 数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>可以直接插入元组或者插入子查询结果(多个元组)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;[属性列,...]</span><br><span class="line"><span class="keyword">VALUES</span> (属性值,);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;[属性列,...]</span><br><span class="line">&lt;子查询&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有出现的属性列赋空值  </li>
<li>没有定义属性列时默认为原表所有属性</li>
<li>VALUES可以由子查询表示</li>
<li>子查询结果或元组值需要与上面定义的属性列相匹配(子查询结果列的个数和列的类型都要匹配)</li>
<li>除了属性匹配,数据库还会检查所插入元素是否会破坏表的完整性规则</li>
</ul>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">SET</span>  &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>语句将修改指定表中满足WHERE子句条件的元组</li>
<li>SET子句给出&lt;表达式&gt;的值用于取代相应的属性列</li>
<li>注意,如果省略WHERE子句,则会修改表中的所有元组 </li>
<li>执行修改语句时,数据库会检查修改操作是否会破坏表的完整性规则</li>
</ul>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt;</span><br><span class="line">WHERE &lt;条件&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>语句将会删除指定表中满足WHERE子句条件的元组</li>
<li>注意,如果省略WHERE子句,则会删除表中的所有元组</li>
</ul>
<h2 id="6-视图"><a href="#6-视图" class="headerlink" title="6. 视图"></a>6. 视图</h2><h3 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h3><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE  VIEW </span><br><span class="line">    &lt;视图名&gt;  [(&lt;列名&gt;  [,&lt;列名&gt;]…)] </span><br><span class="line">   AS &lt;子查询&gt; </span><br><span class="line">   [WITH  CHECK  OPTION];</span><br></pre></td></tr></table></figure>
<ul>
<li>列名缺省时由子查询中SELECT的列构成<blockquote>
<p>一般出现以下情况,需要指定视图的列名:</p>
<ul>
<li>SELECT的某个列需要聚集函数或列表达式,即出现了一些新的列</li>
<li>多表连接时选出了几个同名列作为视图的字段</li>
<li>需要在视图中为某个列启用新的更合适的名字</li>
</ul>
</blockquote>
</li>
<li>WITH CHECK OPTION 可以保证通过该视图插入的数据符合该视图的定义,即插入成功的数据也会在视图中显示</li>
</ul>
<p>常见视图:</p>
<ul>
<li>行列子集视图:在保留单个基本表主码的情况下,去掉了这个表的某些行和列</li>
<li>基于多个表的视图</li>
<li>基于视图的视图</li>
<li>带表达式的视图:SELECT的某个列为表达式</li>
<li>分组视图:SELECT的某个列为聚集函数</li>
</ul>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><code>DROP  VIEW  &lt;视图名&gt;[CASCADE];</code></p>
<ul>
<li>该语句从数据字典中删除指定的视图定义</li>
<li>如果该视图上还导出了其他视图，需要使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除,否则会拒绝删除</li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</li>
</ul>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>视图查询与上述基本表的查询相同</p>
<p>原理:视图消解法</p>
<ul>
<li>对于数据库系统而言,先得将视图查询转换为对基本表的查询,再进行对基本表的查询</li>
<li>转换时需要进行有效性检查和语句修正</li>
</ul>
<h3 id="更新视图-数据"><a href="#更新视图-数据" class="headerlink" title="更新视图(数据)"></a>更新视图(数据)</h3><p>视图的插入,删除,修改操作与基本表相同</p>
<ul>
<li>一些视图是不可更新的,因为 对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新,如带聚集函数的视图<blockquote>
<p>一般而言,行列子集视图是可以进行更新的  </p>
<p>DB2对视图更新的限制:</p>
<ul>
<li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li>
<li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT 和UPDATE操作，但允许执行DELETE操作。  </li>
<li>若视图的字段来自集函数，则此视图不允许更新。</li>
<li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li>
<li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li>
<li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="7-自主存取控制"><a href="#7-自主存取控制" class="headerlink" title="7. 自主存取控制"></a>7. 自主存取控制</h2><p>通过SQL的GRANT语句和REVOKE语句实现自主存取控制</p>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><h4 id="权限的授予"><a href="#权限的授予" class="headerlink" title="权限的授予"></a>权限的授予</h4><p>给某用户授予对某对象的某操作权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">TO</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>权限有SELECT，INSERT，UPDATE，DELETE，REFERENCES几种; ALL PRIVILEGES表示所有操作权限<blockquote>
<p>至于CREATE,ALTER等权限,是数据库管理员在创建用户时授予的</p>
</blockquote>
</li>
<li>指定了ON的对象,表名这是一种实体权限的授予,而不是系统权限(对任意对象的操作)的授予</li>
<li>TO用户可以时一个或多个具体用户,也可以是全体用户PUBLIC</li>
<li>WITH GRANT OPTION表示授予的权限可以再由该用户向下转授<blockquote>
<p>注意:权限不能循环授予,这样会导致回收权限时遇到无穷递归</p>
</blockquote>
</li>
<li>GRANT语句的发出者可以是数据库管理员,数据库对象创建者或者拥有该权限的用户</li>
</ul>
<h4 id="权限的回收"><a href="#权限的回收" class="headerlink" title="权限的回收"></a>权限的回收</h4><p>收回本授权者对某用户的某对象某操作权限的授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[<span class="keyword">CASCADE</span> | RESTRICT];</span><br></pre></td></tr></table></figure>
<ul>
<li>级联回收: 将用户和他传播的权限全部回收</li>
<li>受限回收: 若用户传播过该权限并没有收回,则拒绝执行回收操作</li>
<li>权限的回收可由管理员或授权者来执行</li>
<li>回收只回收本用户直接或间接对目标用户授予的权限,若该用户还从其他地方获得了相同的权限,则他们仍具有此权限</li>
</ul>
<h3 id="用户-用户的创建"><a href="#用户-用户的创建" class="headerlink" title="用户:用户的创建"></a>用户:用户的创建</h3><p>CREATE USER不是SQL标准,不同数据库对用户创建的实现不一样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">USER</span>  &lt;username&gt;</span><br><span class="line">[<span class="keyword">WITH</span>][DBA|<span class="keyword">RESOURCE</span>|<span class="keyword">CONNECT</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>DBA:可以创建用户,模式,表以及登录数据库执行增删改查等操作</li>
<li>RESOURCE:只能创建表并登录数据库执行增删改查等操作</li>
<li>CONNECT: 能登陆数据库进行增删改查等操作,但必须获得相应权限</li>
</ul>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>角色是权限的集合,能够通过为一组具有相同权限的用户创建一个角色来简化授权的过程</p>
<h4 id="角色的创建"><a href="#角色的创建" class="headerlink" title="角色的创建"></a>角色的创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> &lt;角色名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="给角色添加权限"><a href="#给角色添加权限" class="headerlink" title="给角色添加权限"></a>给角色添加权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">TO</span> &lt;角色&gt;[,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure>

<h4 id="回收角色的某权限"><a href="#回收角色的某权限" class="headerlink" title="回收角色的某权限"></a>回收角色的某权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;角色&gt;[,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure>
<ul>
<li>用户可以回收角色的权限，从而修改角色拥有的权限</li>
<li>(不知道对不对)之前通过此角色授予出去的权限也会因为这个操作而被回收</li>
<li>这个REVOKE的发起者是角色的创建者或者拥有该角色ADMIN OPTION的用户</li>
</ul>
<h4 id="把角色授予给某用户或角色"><a href="#把角色授予给某用户或角色" class="headerlink" title="把角色授予给某用户或角色"></a>把角色授予给某用户或角色</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>  &lt;角色<span class="number">1</span>&gt;[,&lt;角色<span class="number">2</span>&gt;]...</span><br><span class="line"><span class="keyword">TO</span>  &lt;角色<span class="number">3</span>&gt;[,&lt;用户<span class="number">1</span>&gt;]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>一个角色的权限是直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限 </li>
<li>把角色授给目标用户后,该用户获得这个角色的所有权限</li>
<li>WITH ADMIN OPTION表示目标角色或用户还可以把这种角色权限授予其他的角色或用户,也有权力更改这个角色的权限</li>
<li>这个GRANT的发起者是角色的创建者或者拥有该角色ADMIN OPTION的用户</li>
</ul>
<h4 id="通过角色收回赋予出去的权限"><a href="#通过角色收回赋予出去的权限" class="headerlink" title="通过角色收回赋予出去的权限"></a>通过角色收回赋予出去的权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;角色<span class="number">1</span>&gt;[,&lt;角色<span class="number">2</span>&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;角色<span class="number">3</span>&gt;[,&lt;用户<span class="number">1</span>&gt;]...</span><br></pre></td></tr></table></figure>
<ul>
<li>目标用户或角色失去了原角色赋予给他的权限</li>
</ul>
<h2 id="8-过程化SQL"><a href="#8-过程化SQL" class="headerlink" title="8 过程化SQL"></a>8 过程化SQL</h2><p>目标: 扩展SQL语言本身的能力,加入过程控制的功能</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>定义语句:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">    &lt;变量名&gt; &lt;数据类型&gt; [[<span class="keyword">NOT</span> <span class="literal">NULL</span>] [:=] &lt;初值表达式&gt;];</span><br><span class="line">    &lt;常量名&gt; &lt;数据类型&gt; CONSTANT := &lt;常量表达式&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义的变量,常量生命周期为整个块</li>
<li>常量定义后在作用域中不能再赋值</li>
</ul>
<p>执行语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">    [<span class="keyword">SET</span>] &lt;变量名&gt; := &lt;表达式&gt;;</span><br><span class="line">    </span><br><span class="line">    IF &lt;条件&gt; THEN</span><br><span class="line">        &lt;语句&gt;;</span><br><span class="line">    [ELSE &lt;语句&gt;;]</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    [WHILE &lt;条件&gt;]|    </span><br><span class="line">    [FOR &lt;count&gt; IN [REVERSE] &lt;值1&gt;...&lt;值n&gt;]</span><br><span class="line">    LOOP</span><br><span class="line">        &lt;语句&gt; [EXIT|BREAK|LEAVE];</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    </span><br><span class="line">EXCEPTION</span><br></pre></td></tr></table></figure>

<h3 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h3><p>存储过程: 由过程化SQL书写的一段语句经编译和优化后命名并存储在数据库服务器中待使用时调用的过程</p>
<p>过程化SQL块类型:</p>
<blockquote>
<ul>
<li>命名块: 编译后保存在数据库中供反复高效调用,过程和函数是命名块</li>
<li>匿名块: 每次执行都要编译的块,不能被存储和调用</li>
</ul>
</blockquote>
<h4 id="存储过程的用户接口"><a href="#存储过程的用户接口" class="headerlink" title="存储过程的用户接口"></a>存储过程的用户接口</h4><p>创建存储:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt; ([&lt;参数<span class="number">1</span>&gt;,&lt;参数<span class="number">2</span>&gt;,...]) <span class="keyword">AS</span> &lt;过程化<span class="keyword">SQL</span>块&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表: 调用时给出的参数值,需要指定值的数据类型; 参数可定义为输入参数(默认),输出参数和输入/输出参数</li>
<li>过程块: 一个包括声明部分和可执行语句部分的块,过程块中可以调用其他存储过程</li>
</ul>
<p>执行存储过程:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span>|PREFORM <span class="keyword">PROCEDURE</span> &lt;过程名&gt; (&lt;参数列表&gt;);</span><br></pre></td></tr></table></figure>

<p>修改存储过程:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新过程名&gt;;</span><br></pre></td></tr></table></figure>

<p>删除存储过程:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数和存储过程都是持久性的存储过程,但函数必须执行返回值的类型</p>
<p>函数定义:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> &lt;函数名&gt; ([&lt;参数列表&gt;])</span><br><span class="line"><span class="keyword">RETURNS</span> &lt;返回值类型&gt; <span class="keyword">AS</span> &lt;过程化<span class="keyword">SQL</span>块&gt;;</span><br></pre></td></tr></table></figure>

<p>函数执行:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span>|<span class="keyword">SELECT</span> &lt;函数名&gt; ([&lt;参数列表&gt;]);</span><br></pre></td></tr></table></figure>

<p>修改函数:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> &lt;过程名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新过程名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> &lt;过程名&gt; COMPILE; //重新编译</span><br></pre></td></tr></table></figure>

<hr>
<p>博文创建时间: 2020-04-11 15:18:05</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理与设计(高级篇)</title>
    <url>/2020/05/24/data-base1/</url>
    <content><![CDATA[<p>未完结,持续更新</p>
<hr>
<p>任课教师: 赵朋朋<a href="http://web.suda.edu.cn/ppzhao/" target="_blank" rel="noopener">http://web.suda.edu.cn/ppzhao/</a></p>
<p>网课资源: 慕课中国人民大学数据库系统概论<a href="https://www.icourse163.org/learn/RUC-1001655006" target="_blank" rel="noopener">https://www.icourse163.org/learn/RUC-1001655006</a></p>
<p>参考教材: 高等教育出版社《数据库系统概论(第5版)》</p>
<p>课程主要讲述关系型数据库的原理, 不着重于具体数据库的使用</p>
<p>在高级篇中,从管理系统的角度来介绍DBMS系统,用使用和应用的角度来讲解数据库设计的方法</p>
<p>数据库原理与设计(基础篇)见<a href="http://georgechen.top/2020/02/27/data-base0/" target="_blank" rel="noopener">http://georgechen.top/2020/02/27/data-base0/</a></p>
<a id="more"></a>

<h1 id="六、关系数据理论"><a href="#六、关系数据理论" class="headerlink" title="六、关系数据理论"></a>六、关系数据理论</h1><h2 id="6-1-关系数据理论的提出"><a href="#6-1-关系数据理论的提出" class="headerlink" title="6.1 关系数据理论的提出"></a>6.1 关系数据理论的提出</h2><p>需要解决的问题:怎么根据具体问题构造出一个合适的数据模式;即,什么是一个好的数据库逻辑设计</p>
<p>好的关系模式不会因为数据冗余而发生:</p>
<blockquote>
<ul>
<li>存储空间浪费</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常<br>因此,好的关系模式数据冗余应尽可能少(但较少的冗余度可能会降低增删改查时的效率)</li>
</ul>
</blockquote>
<p>问题的根源:数据依赖</p>
<h3 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h3><p>数据库中,数据依赖是完整性约束的一种表现形式,是数据库模式设计的关键</p>
<ul>
<li>限定属性的取值范围</li>
<li>定义属性间的相互关联(一般以相等关系体现)</li>
</ul>
<p>现实生活中,数据依赖是</p>
<blockquote>
<ul>
<li>现实世界属性间相互联系的抽象</li>
<li>数据内在的性质</li>
<li>语义的体现</li>
</ul>
</blockquote>
<p>数据依赖的类型</p>
<blockquote>
<ul>
<li>函数依赖FD</li>
<li>多值依赖MVD</li>
<li>连接依赖</li>
<li>…</li>
</ul>
</blockquote>
<p>不适合的数据依赖会造成插入、删除、更新异常和数据冗余问题</p>
<h3 id="关系模式的简化表示"><a href="#关系模式的简化表示" class="headerlink" title="关系模式的简化表示"></a>关系模式的简化表示</h3><p>$R&lt;U,F&gt;$是一个简化表示的关系模式</p>
<blockquote>
<ul>
<li>$U$:关系的属性集合</li>
<li>$F$: 属性间数据依赖的关系集合<br>当且仅当$U$上的一个关系r满足$F$时,r为关系模式$R$的一个关系</li>
</ul>
</blockquote>
<h2 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集.若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等;则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。X称为这个函数依赖的决定属性组，也称为决定因素(Determinant)。</p>
<blockquote>
<ul>
<li>Y依赖于X:X相等则Y相等</li>
<li>X确定了那么Y也确定了</li>
</ul>
</blockquote>
<p>注意: </p>
<blockquote>
<ul>
<li>函数依赖是语义范畴的概念,只能根据数据的语义来确定函数依赖,而不能根据数据的具体形式来反推可能的函数依赖</li>
<li>函数依赖确定后,所有的关系实例都要满足该约束条件<br>当然,数据库设计者可以对现实世界做强制的规定来使得某两个属性产生函数依赖;如:不允许有学生重名,则学生的其他信息可以依赖于学生姓名</li>
</ul>
</blockquote>
<h4 id="平凡函数依赖和非平凡函数依赖"><a href="#平凡函数依赖和非平凡函数依赖" class="headerlink" title="平凡函数依赖和非平凡函数依赖"></a>平凡函数依赖和非平凡函数依赖</h4><ul>
<li>$X\to Y,Y\subseteq X,X\to Y$为非平凡函数依赖</li>
<li>$X\to Y,Y\not \subseteq X,X\to Y$为平凡函数依赖</li>
</ul>
<p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明， 我们总是讨论非平凡 函数依赖。</p>
<h4 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h4><ul>
<li>$X\to Y$,且对于任意的$X’ \subsetneq X,X \not \to Y$,则$X\to Y$为完全函数依赖,记作$X$-F-&gt;$Y$(Full)</li>
<li>非完全函数依赖记作$X$-P-&gt;$Y$(Part)<blockquote>
<p>注意,X是一个属性的集合</p>
</blockquote>
</li>
</ul>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><ul>
<li>$X\to Y,Y \to Z 且 Y \not \subseteq X,Y \not \to X$时,称Z传递函数依赖于X,X传递(函数)确定Z,记作$X$-传递-&gt;$Z$<blockquote>
<p>注意,若$Y\to X$,则$Z$直接依赖于$X$</p>
</blockquote>
</li>
</ul>
<h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖*"></a>多值依赖*</h3><p>函数依赖中X确定一个单值Y,但有时给定X的值x,它能确定多个Y的值;在插入x时,需要插入多条(x,y)元组才能符合这种依赖关系,而且这种依赖关系是隐式的,十分不方便.</p>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote>
<ul>
<li>候选码: $R&lt;U,F&gt;$中,$K \subset U,K$-F-&gt;$U$,则K为R的一个(候选)码</li>
<li>超码: 上述情况下$K$-P-&gt;$U$</li>
<li>主码: 若R有多个候选码,则选定其中一个作为主码</li>
<li>全码: 整个属性组都是码,称为全码(候选码为整个属性组)<br>候选码长度是超码长度的一个极小值,即候选码的任意一个真子集都不是候选码</li>
</ul>
</blockquote>
<h4 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h4><ul>
<li>任意一个候选码中的任意一个属性都为主属性</li>
<li>不包含在任何码中的属性为非主属性(非码属性)</li>
</ul>
<h4 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h4><ul>
<li>$R&lt;U,F&gt;$中属性(组)$X$不是$R$的(候选)码,但$X$是另外一个关系模式的码,则称$X$是$R$的外部码</li>
</ul>
<p>主码与外码一起提供了表示关系间联系的手段</p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式是符合某一种级别的关系模式的集合</p>
<p>关系数据库中的关系必须满足一定的要求,满足不同程度要求的为不同范式</p>
<p>范式种类(级别由低到高):</p>
<ul>
<li>第一范式1NF: 关系模式的最低要求</li>
<li>第二范式2NF: 消除非主属性对码的部分函数依赖</li>
<li>第三范式3NF: 消除非主属性对码的传递函数依赖</li>
<li>修正的第三范式BCNF: 消除主属性对码的部分和传递函数依赖</li>
<li>第四范式4NF: 消除非平凡且非函数依赖的多值依赖</li>
<li>第五范式5NF: 消除非候选码所蕴含的连接依赖<blockquote>
<ul>
<li>低级别的范式一定包含高级别的范式</li>
<li>某一关系模式R为第n范式,记为$R \in nNF$</li>
</ul>
</blockquote>
</li>
</ul>
<p>一个低一级范式的关系模式,通过模式分解可以转化成若干个高一级范式的关系模式的集合,这种过程叫做规范化</p>
<p>关系数据库的规范化理论是数据库逻辑设计的工具</p>
<h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>如果一个关系模式$R$的所有属性都是不可分的基本数据项,则$R\in 1NF$</p>
<blockquote>
<ul>
<li>即,不能表中嵌表</li>
<li>所有的关系数据库模式都满足第一范式,第一范式是对关系模式的最起码的要求;不满足第一范式的数据库模式不能称为关系数据模式</li>
</ul>
</blockquote>
<p>然而,满足第一范式的关系模式不一定是一个好的关系模式</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>若关系模式$R \in 1NF$,且每一个非主属性都完全依赖于$R$的码,则$R \in 2NF$</p>
<ul>
<li>即,$R$中码的任何一部分都不能单独决定一些属性,这些属性必须由整个码来确定<blockquote>
<p>能够单独决定一些属性的码需要被独立成另外的关系</p>
</blockquote>
</li>
<li>不符合第二范式的关系模式会产生问题<blockquote>
<ul>
<li>插入异常: 数据库不能插入一些只包含部分合理信息的元组(码的其他部分也得被确定下来)</li>
<li>删除异常: 数据库有时不能将元组的部分信息合理删除(这些信息可能包含码的部分)</li>
<li>数据冗余</li>
<li>修改复杂: 修改元组部分信息时,表中其他元组的部分信息也得被修改(数据冗余造成的)<br>根本原因: 一些属性部分依赖于码</li>
</ul>
</blockquote>
</li>
<li>解决上述问题的方法: 投影分解法,消除部分依赖,使得关系符合第二范式</li>
</ul>
<p>但是,第二范式并不能完全消除关系模式中异常情况和修改复杂、数据冗余情况,因为有传递函数依赖的存在</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>若关系模式$R \in 1NF$,且不存在这样的码$X$、属性<strong>组</strong>$Y$以及非主属性$Z(Z\not \subset Y)$,使得$X\to Y,Y \to Z,Y \not \to X$成立($Z$不传递依赖于X),则$R \in 3NF$</p>
<ul>
<li>传递函数依赖的存在使得一些信息被”隐式”地存储在表中,需要将它们独立成另外的关系</li>
</ul>
<p>性质:</p>
<blockquote>
<ul>
<li>第三范式关系中的每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码</li>
<li>若R属于第三范式,那么R必定属于第二范式</li>
<li>采用投影分解法能将一个第二范式关系分解成多个第三范式关系</li>
</ul>
</blockquote>
<p>然而,第三范式还是不能完全消除关系模式中的各种异常情况和数据冗余,因为主属性之间也会存在依赖</p>
<h4 id="修正的第三范式-BCNF"><a href="#修正的第三范式-BCNF" class="headerlink" title="修正的第三范式(BCNF)"></a>修正的第三范式(BCNF)</h4><p>若关系模式$R \in 1NF$,且对$R$中每个函数依赖$X\to Y 且 Y\not \in X时$,X必含有码,则$R \in BCNF$</p>
<p>性质:</p>
<blockquote>
<ul>
<li>所有非主属性对每一个码都是完全函数依赖</li>
<li>所有主属性对每一个不包含它的码都是完全函数依赖</li>
<li>没有任何属性完全函数依赖于一些非码属性(不存在传递函数依赖)</li>
<li>符合BCNF的范式一定符合3NF,反之不然<br>BCNF在函数依赖范畴内已经实现了模式的彻底分解,达到了最高的规范化程度,消除了操作异常的诸多问题</li>
</ul>
</blockquote>
<h2 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a>6.3 数据依赖的公理系统</h2><p>数据依赖的公理系统式模式分解算法的理论基础</p>
<p>Armstrong公理系统式函数依赖的一个有效而完备的公理系统</p>
<h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><p>Armstrong公理系统是一套推理规则,用于回答某个函数依赖是否被某组函数依赖F蕴含</p>
<blockquote>
<ul>
<li>有效性: 由F出发根据Armstrong公理推导出的每一个函数依赖一定在$F^+$中</li>
<li>完备性: $F^+$中的每一个函数依赖必定可以由Armstrong公理推导出来</li>
</ul>
</blockquote>
<h3 id="逻辑蕴涵的定义"><a href="#逻辑蕴涵的定义" class="headerlink" title="逻辑蕴涵的定义"></a>逻辑蕴涵的定义</h3><p>对于满足一组函数依赖F的关系模式$R(U,F)$,对符合它的任意关系r,若都有函数依赖$X\to Y$成立,则称F(逻辑)蕴涵$X\to Y$</p>
<h3 id="几个导出的推理规则"><a href="#几个导出的推理规则" class="headerlink" title="几个导出的推理规则"></a>几个导出的推理规则</h3><p>设U为属性集总体, F是U上的一组函数依赖, 对关系$R&lt;U,F&gt;$ 来说, 有以下的推理规则: </p>
<blockquote>
<ul>
<li>自反律: 若$Y \subseteq X \subseteq U$,则F蕴含$X\to Y$</li>
<li>增广律: 若F蕴含$X\to Y$且$Z\subseteq U$,则F蕴含$XZ\to YZ$</li>
<li>传递律: 若F蕴含$X\to Y和Y\to Z$,则F蕴含$X\to Z$</li>
</ul>
</blockquote>
<p>上述三个推理规则可以进一步得到以下几个推理规则:</p>
<blockquote>
<ul>
<li>合并规则: 由$X\to Y,X\to Z$,可以得到$X\to YZ$</li>
<li>伪传递规则: 由$X\to Y,YW\to Z$,可以得到$XW\to Z$</li>
<li>分解规则: 由$X\to Y,Z \subseteq Y$,可以得到$X\to Z$</li>
</ul>
</blockquote>
<p>根据合并规则和分解规则可以得到下述重要引理:</p>
<blockquote>
<ul>
<li>$X\to A_1A_2…A_n$成立的充要条件是$X\to A_i(i=1,2,…n)$</li>
</ul>
</blockquote>
<h3 id="函数依赖闭包"><a href="#函数依赖闭包" class="headerlink" title="函数依赖闭包"></a>函数依赖闭包</h3><h4 id="定义和一些引理"><a href="#定义和一些引理" class="headerlink" title="定义和一些引理"></a>定义和一些引理</h4><ul>
<li>在关系模式$R&lt;U,F&gt;$中被F所蕴含的函数依赖的全体称为F的闭包,记作$F^+$</li>
<li>设F为属性集U上的一组函数依赖,$X\subseteq U$,$X_{F^+} = \lbrace A | X\to A能由F根据Armstrong公理导出 \rbrace$,称为属性集X关于函数依赖集F的闭包<blockquote>
<ul>
<li>$X_{F^+}$表示属性组X能根据F推导出的所有属性</li>
<li>$F^+$不容易直接求出,在考虑某函数依赖是否在$F^+$中时,需要转化成对$X_{F^+}$的判定</li>
</ul>
</blockquote>
</li>
</ul>
<p>关于闭包的引理</p>
<ul>
<li>F为属性集U上的一组函数依赖,X Y为U上的两个属性组;$X\to Y$能由F根据Armstrong公理导出的充要条件是$Y\subseteq X_{F^+}$<blockquote>
<ul>
<li>判断$X\to Y$是否在$F^+$中,只需判断Y是否是$X_{F^+}$的子集</li>
<li>若$X_{F^+}=U$,则X为R的候选码</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="求-X-F-的算法"><a href="#求-X-F-的算法" class="headerlink" title="求$X_{F^+}$的算法"></a>求$X_{F^+}$的算法</h4><p>遵循如下迭代算法求取$X_{F^+}$:</p>
<ol>
<li>令$X_{add} = \emptyset$</li>
<li>扫描F,将能根据X或部分X推导出的元素加入$X_{add}$</li>
<li>$X = X \cup X_{add}$</li>
<li>若X并没有改变,则得到结果$X_{F^+}$,否则转1.</li>
</ol>
<h3 id="函数依赖集的一些性质"><a href="#函数依赖集的一些性质" class="headerlink" title="函数依赖集的一些性质"></a>函数依赖集的一些性质</h3><h4 id="函数依赖集的等价"><a href="#函数依赖集的等价" class="headerlink" title="函数依赖集的等价"></a>函数依赖集的等价</h4><p>两个函数依赖集$F$和$G$,若$F^+=G^+$,则$F$与$G$等价(F覆盖G,F是G的覆盖或反之)</p>
<ul>
<li>函数依赖集的等价是指它们的闭包等价</li>
</ul>
<h4 id="最小-极小-依赖集"><a href="#最小-极小-依赖集" class="headerlink" title="最小(极小)依赖集"></a>最小(极小)依赖集</h4><p>满足下列条件的依赖集F称为一个最小依赖集</p>
<blockquote>
<ul>
<li>F中任意一个函数依赖的右边只含有一个属性</li>
<li>F中的每个函数依赖的左边均为最小属性集<ul>
<li>若存在一个函数依赖$X\to A$,使得去掉这条依赖中X的部分属性,得到的函数依赖集F’与F等价,则原F不是最小依赖集</li>
</ul>
</li>
<li>F中的每个函数依赖均不能由F中其他的函数依赖导出</li>
</ul>
</blockquote>
<h4 id="求最小依赖集的算法"><a href="#求最小依赖集的算法" class="headerlink" title="求最小依赖集的算法"></a>求最小依赖集的算法</h4><ol>
<li>扫描F中的函数依赖,将所有依赖项的右边拆分成单属性</li>
<li>扫描每个函数依赖的左边,去除左边冗余的属性</li>
<li>去掉F中冗余的函数依赖关系</li>
</ol>
<ul>
<li>F的最小依赖集不是唯一的</li>
</ul>
<h2 id="6-4-模式的分解"><a href="#6-4-模式的分解" class="headerlink" title="6.4 模式的分解"></a>6.4 模式的分解</h2><p>关系模式的规范化是通过模式分解来实现的</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>投影:</p>
<ul>
<li>$F_i = \lbrace X\to Y | X\to Y \in F^+ , XY \subseteq U_i \rbrace$ 称为$F$在$U_i$上的投影</li>
</ul>
<p>关系模式的分解:</p>
<ul>
<li>$R&lt;U,F&gt;$的一个分解为$\rho = \lbrace R_1&lt;U_1,F_1&gt;,…,R_n&lt;U_n,F_n&gt;\rbrace$,其中$U = U_1\cup … U_n$, 且不存在$U_i\subseteq U_j$</li>
</ul>
<p>模式分解主要涉及到投影和自然连接两个运算</p>
<h3 id="模式分解的三个目标"><a href="#模式分解的三个目标" class="headerlink" title="模式分解的三个目标"></a>模式分解的三个目标</h3><p>一个模式有多种分解方法,符合一些要求的分解方法才有意义</p>
<blockquote>
<ul>
<li>无损连接分解: 将分解后的多个模式进行自然连接,结果应和原模式一样</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>保持函数依赖: 分解前F的最小依赖集中的每个函数依赖都应该被投影到分解后的某个关系模式中去<ul>
<li>即:$F^+ = (F_1\cup … \cup F_n)^+$</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>达到更高级范式: 分解得到的每个关系模式应该相比于分解前的关系模式达到更高级别的范式</li>
</ul>
</blockquote>
<h3 id="模式分解算法"><a href="#模式分解算法" class="headerlink" title="模式分解算法"></a>模式分解算法</h3><h4 id="达到BCNF并保持无损连接的算法"><a href="#达到BCNF并保持无损连接的算法" class="headerlink" title="达到BCNF并保持无损连接的算法"></a>达到BCNF并保持无损连接的算法</h4><ol>
<li>令$\rho = \lbrace R&lt;U,F&gt; \rbrace$</li>
<li>检查$\rho$中各关系模式是否属于BCNF,若是则返回结果</li>
<li>发现有$R_i&lt;U_i,F_i&gt;$不是BCNF,即有$X\to A$在$F_i^+$中且X不包含$R_i$的码,则将$X\to A$单独从$R_i$中分出来,指定X为新模式的码,将新模式加入$\rho$中(原$R_i$中不再有$X\to A$),转2.</li>
</ol>
<blockquote>
<p>这种分解方法能达到BCNF,但不一定保持原有的函数依赖</p>
</blockquote>
<h4 id="达到3NF并保持函数依赖的算法"><a href="#达到3NF并保持函数依赖的算法" class="headerlink" title="达到3NF并保持函数依赖的算法"></a>达到3NF并保持函数依赖的算法</h4><ol>
<li>求出$F$的最小覆盖$F_m$</li>
<li>找出不在$F_m$中出现的属性,将它们从U中分离出来构成一个新的关系模式(这个关系模式的码是全码)</li>
<li>若有$X\to A \in F_m$ ，且XA=U，则$\rho$={R}，算法终止</li>
<li>对FC按具有相同左部的原则进行分组（设为k组），每一组函数依赖所涉及的属性全体为Ui，令$F_i$为$F_m$在$U_i$上的投影，则$\rho$ = {R1&lt;U1 ,F1&gt; ,… , Rk&lt;Uk , Fk&gt;}是R&lt;U , F&gt;的一个保持函数依赖的分解，并且每个Ri&lt;Ui , Fi&gt; $\in$ 3NF</li>
</ol>
<blockquote>
<p>这种分解算法可能有损</p>
</blockquote>
<h4 id="达到3NF并保持无损分解和函数依赖的算法"><a href="#达到3NF并保持无损分解和函数依赖的算法" class="headerlink" title="达到3NF并保持无损分解和函数依赖的算法"></a>达到3NF并保持无损分解和函数依赖的算法</h4><p>在上一个算法后继续进行操作</p>
<ol start="5">
<li>考虑R的码X,若X在某个$U_i$中,则无需进行操作,否则需要将{&lt;X,$F_X$&gt;}加入到$\rho$中</li>
</ol>
<blockquote>
<p>这种分解算法不一定能达到BCNF</p>
</blockquote>
<h1 id="七、数据库设计"><a href="#七、数据库设计" class="headerlink" title="七、数据库设计"></a>七、数据库设计</h1><h2 id="7-1-数据库设计概述"><a href="#7-1-数据库设计概述" class="headerlink" title="7.1 数据库设计概述"></a>7.1 数据库设计概述</h2><ul>
<li>广义上,数据库设计是设计整个数据库应用系统</li>
<li>狭义上,数据库设计就是设计数据库本身</li>
</ul>
<p>特点:</p>
<blockquote>
<ul>
<li>数据库设计是三分技术,七分管理,十二分基础数据</li>
<li>数据库设计是结构(数据)设计和行为(处理)设计的结合</li>
</ul>
</blockquote>
<p>数据库设计方法:</p>
<blockquote>
<ul>
<li>手工设计法</li>
<li>规范设计法:如新奥尔良法</li>
<li>基于ER模型的设计方法</li>
<li>3NF设计方法</li>
<li>ODL方法</li>
<li>UML方法</li>
</ul>
</blockquote>
<p>数据库设计工具: SYSBASE等</p>
<p>数据库设计基本步骤:</p>
<ol>
<li>需求分析: 了解和分析用户需求</li>
<li>概念结构设计: 综合,归纳,抽象用户需求,形成概念模型(ER图 )<blockquote>
<p>需求分析和概念结构设计独立于任何DBMS系统</p>
</blockquote>
</li>
<li>逻辑结构设计: 将概念模型转化成数据模型,并进行数据模型优化</li>
<li>物理结构设计: 为数据模型选取一个物理结构(存储结构和存取方法设计),并评价设计,预测性能;不满意需要重新进行逻辑设计<blockquote>
<p>逻辑结构设计和物理结构设计与选用数据库系统相关</p>
</blockquote>
</li>
<li>数据库实施: 进行物理实现和实验性运行;不满意需要返回物理结构或逻辑结构设计</li>
<li>数据库运行和维护</li>
</ol>
<p>设计一个完善的数据库应用系统是上述6个阶段的不断反复</p>
<h2 id="7-2-需求分析"><a href="#7-2-需求分析" class="headerlink" title="7.2 需求分析"></a>7.2 需求分析</h2><p>需求分析是分析用户的需求,是设计数据库的起点</p>
<p>任务: 通过了解原系统的工作情况,调查应用的环境,明确用户的需求,从而确定新系统的功能</p>
<ul>
<li>调查重点是数据和处理两方面</li>
</ul>
<p>方法:</p>
<ol>
<li>调查组织机构总体情况</li>
<li>熟悉业务活动<blockquote>
<p>上述两点需要数据库设计人员和用户进行对接</p>
</blockquote>
</li>
<li>明确用户的需求</li>
<li>确定系统的边界: 设计数据字典,设计用户需求规格说明书</li>
<li>概念设计等…</li>
</ol>
<p>数据字典:</p>
<ul>
<li>数据字典是对数据库中数据的描述,为元数据;它是一种数据的数据</li>
<li>数据字典在需求分析阶段建立,在数据库设计过程总不断修改充实完善; 是详细数据收集和分析获得的主要结果<blockquote>
<p>数据字典内容</p>
<ul>
<li>数据项: 数据最小组成单位; 有含义说明,取值范围和函数依赖等描述</li>
<li>数据结构: 由若干个数据项或数据结构组成</li>
<li>数据流: 由数据结构,数据流来源,数据流去向等组成; 描述数据结构在系统内部传输的路径</li>
<li>数据存储: 是数据结构停留或保存的地方,也是数据流的来源和去向之一</li>
<li>处理过程: 是从输入数据流到输出数据流的转换; 具体逻辑一般用判定表或判定树表示</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="7-3-概念结构设计"><a href="#7-3-概念结构设计" class="headerlink" title="7.3 概念结构设计"></a>7.3 概念结构设计</h2><p>概念结构设计: 将需求分析得到的用户需求抽象为信息结构(概念模型)的过程</p>
<p>概念模型是现实世界的一种抽象</p>
<h3 id="E-R模型"><a href="#E-R模型" class="headerlink" title="E-R模型"></a>E-R模型</h3><p>实体-联系模型称为E-R模型,它用E-R图来描述现实世界的概念模型</p>
<p>实体之间的联系:</p>
<ul>
<li><p>一对一联系: 对于两个实体集中的每一个实体,它至多只与对方实体集中的一个实体有联系,则称两个实体集具有一对一联系,记为1:1</p>
<blockquote>
<p>当然,这并不要求每一个实体都得和另一个实体有联系</p>
</blockquote>
</li>
<li><p>一对多联系: 对于实体集A中的每一个实体,实体集B中有多个实体与之联系,反之实体集B中的实体最多只能和A中的一个实体有联系,则称实体集A与实体集B有一对多联系,记为1:n</p>
</li>
<li><p>多对多联系: 于实体集A中的每一个实体,实体集B中有多个实体与之联系,反之亦然, 则称实体集A与实体集B有多对多联系,记为m:n</p>
<blockquote>
<p>多个实体围绕一个动作也可以形成一对一等联系,单个实体内部也可以形成联系</p>
</blockquote>
</li>
<li><p>联系的度: 把参与联系的实体的数据称为联系的度,N个实体之间的联系的度为N,称为N元联系</p>
</li>
</ul>
<p>E-R模型表示:</p>
<blockquote>
<ul>
<li>实体型: 用矩形表示,矩形内写明实体名; 如学生</li>
<li>属性: 用椭圆形表示,由无向边和实体型连接</li>
<li>联系: 用菱形表示,框内标注联系名,用无向边与有关实体联系起来,同时在边上标明联系的类型(n:m); 联系也可以有自己的属性,由无向边连接</li>
</ul>
</blockquote>
<h3 id="扩展的E-R模型"><a href="#扩展的E-R模型" class="headerlink" title="扩展的E-R模型"></a>扩展的E-R模型</h3><p>扩展的E-R模型用于丰富基本E-R模型的表达能力</p>
<h4 id="ISA联系"><a href="#ISA联系" class="headerlink" title="ISA联系"></a>ISA联系</h4><ul>
<li>ISA联系用三角形表示,表明某些实体是某个实体的子类型</li>
<li>子类继承了父类的所有属性,同时也可以有自己的属性</li>
</ul>
<p>分类属性:</p>
<blockquote>
<ul>
<li>分类属性是父实体型的一个属性</li>
<li>分类属性的值把夫实体型中的实体分派到子实体型中</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/ISA.jpg" alt="isa"></p>
<p>约束:</p>
<blockquote>
<ul>
<li>不相交约束: 表明父类某个实体最多只能属于一个子类实体集; 此时三角形中需要有一个叉号</li>
<li>完备性约束: 表明父类中的某个实体必须是某一个子类中的实体,又称完全特化; 此时父类到子类之间的线用双线表示</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/ISA1.jpg" alt="isa"></p>
<h4 id="基数约束"><a href="#基数约束" class="headerlink" title="基数约束"></a>基数约束</h4><ul>
<li>技术约束用于表明一个实体可以在联系中出现的次数上下限</li>
<li>这是一个一对一,一对多,多对多联系的细化</li>
<li>约束用一个数对min..max表示,标注在联系和实体之间,max为’*‘时表示无穷大</li>
</ul>
<p><img src="/2020/05/24/data-base1/restrain0.jpg" alt="res"></p>
<p>约束类型:</p>
<blockquote>
<ul>
<li>强制参与约束: min=1,表明被施加约束的实体型中的每个实体都要参与联系</li>
<li>非强制参与约束: min=0,表明被施加约束的实体型中的实体可以出现在联系中,也可以不出现在联系中</li>
</ul>
</blockquote>
<h4 id="PART-OF联系"><a href="#PART-OF联系" class="headerlink" title="PART-OF联系"></a>PART-OF联系</h4><ul>
<li>PART-OF联系用于描述某个实体型是另外一个实体型的一部分</li>
</ul>
<p>PART-OF联系的分类:</p>
<blockquote>
<ul>
<li>非独占联系: 整体实体如果被破坏,部分实体仍可以独立存在</li>
<li>独占联系: 整体实体如果被破坏,则部分实体不能存在</li>
<li>非独占联系可以用用非强制参与的一对多联系表示(0..1)</li>
<li>独占联系需要用弱实体类型和识别联系表示</li>
</ul>
</blockquote>
<p>弱实体类型和识别联系:</p>
<blockquote>
<ul>
<li>弱实体类型表明该实体型的存在依赖于其他实体型的存在(否则为强实体型); 弱实体型用双矩形表示</li>
<li>独占联系用双菱形表示</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/PO0.jpg" alt="partof"></p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><ul>
<li>UML为统一建模语言,是对象管理组织的一个标准</li>
<li>UML中的类大致对应E-R图中的实体</li>
</ul>
<p>用UML的类图表示E-R图:</p>
<blockquote>
<ul>
<li>实体型: 用类表示; 矩形框上部记录实体名,下部列出属性名</li>
<li>实体的码: 在类图中的属性后面加上’PK’表示码</li>
<li>联系: 用类图之间的关联来表示</li>
<li>基数约束: 和E-R图中的基数约束表示类似</li>
<li>UML中的子类和E-R图中的ISA联系一致</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/UML0.jpg" alt="UML"></p>
<h3 id="概念结构设计方法"><a href="#概念结构设计方法" class="headerlink" title="概念结构设计方法"></a>概念结构设计方法</h3><h4 id="实体与属性的划分原则"><a href="#实体与属性的划分原则" class="headerlink" title="实体与属性的划分原则"></a>实体与属性的划分原则</h4><p>实体和属性的划分方法:</p>
<blockquote>
<ul>
<li>对需求分析阶段收集到的数据进行分类,组织</li>
<li>确定实体,实体的属性,实体之间的联系类型</li>
</ul>
</blockquote>
<p>原则:</p>
<blockquote>
<ul>
<li>现实世界的事物能以属性对待的,尽量以属性对待,这可以简化E-R图的处理</li>
<li>作为属性,不能再具有需要描述的性质; 即它必须是不可分的数据项,不能包含其他属性</li>
<li>属性不能与其他实体具有联系; 联系应当是实体之间的联系</li>
</ul>
</blockquote>
<h4 id="分E-R图的设计"><a href="#分E-R图的设计" class="headerlink" title="分E-R图的设计"></a>分E-R图的设计</h4><ul>
<li>先设计分E-R图的草图: 先写出框架</li>
<li>对E-R图进行详细的设计和调整: 填入一些细节,加入一些具体的联系,填入如联系名等</li>
</ul>
<h4 id="E-R图的集成"><a href="#E-R图的集成" class="headerlink" title="E-R图的集成"></a>E-R图的集成</h4><p>合并: 解决各E-R图之间的冲突,将分E-R图合并,生成初步的E-R图</p>
<ul>
<li>属性冲突: 属性值的类型,取值范围,取值单位冲突</li>
<li>命名冲突: 同名异义,异名同义<blockquote>
<ul>
<li>命名冲突在在实体,联系,属性中都可能发生</li>
<li>命名冲突需要根据具体情况解决</li>
</ul>
</blockquote>
</li>
<li>结构冲突：<blockquote>
<ul>
<li>同一对象在不同应用中有不同的抽象,需要统一(全是实体或全是属性)</li>
<li>同一实体在不同子系统的E-R图中的属性个数和次序不同; 需要取各系统属性的并集,再适当调整次序</li>
<li>实体间的联系在不同E-R图中有不同的类型; 需要根据语义进行调整</li>
</ul>
</blockquote>
</li>
</ul>
<p>消除不必要的冗余,设计基本E-R图:</p>
<ul>
<li>冗余的数据: 可由基本数据导出的数据</li>
<li>冗余的联系: 可由其他联系导出的联系</li>
<li>消除冗余的方法: 分析法,规范化理论法<blockquote>
<p>规范化理论: </p>
<ol>
<li>确定分E-R图之间的数据依赖,可以通过联系的类型来确定函数依赖集F</li>
<li>求F的最小覆盖G,求差集D=F-G</li>
<li>注意考察D中的函数依赖,确定是否为冗余依赖,若是则将其去除<br>注意: 冗余的联系一定在D中,反之不然;当实体之间存在多种联系时,需要将其在形式上加以区分</li>
</ol>
</blockquote>
</li>
</ul>
<p>一个例子:<br><img src="/2020/05/24/data-base1/example0.jpg" alt="example"></p>
<h2 id="7-4-逻辑结构设计"><a href="#7-4-逻辑结构设计" class="headerlink" title="7.4 逻辑结构设计"></a>7.4 逻辑结构设计</h2><p>任务: 将概念结构的E-R图转换为DBMS产品支持的逻辑结构</p>
<ul>
<li>就目前关系数据库而言,其逻辑结构为一组关系模式的集合<br><img src="/2020/05/24/data-base1/logic.jpg" alt="logic"><h3 id="E-R图向关系模型的转换"><a href="#E-R图向关系模型的转换" class="headerlink" title="E-R图向关系模型的转换"></a>E-R图向关系模型的转换</h3></li>
<li>实体型的转换: 一个实体型转换为一个关系模式<blockquote>
<ul>
<li>属性: 实体的各属性</li>
<li>码: 实体的码</li>
</ul>
</blockquote>
</li>
<li>实体型间的一对一联系:<blockquote>
<p>转换为独立的关系模式</p>
<ul>
<li>属性: 与该联系相连的各实体的码以及联系本身的属性</li>
<li>码: 每个实体的码都是该关系模式的候选码<br>将上述关系模式合并到相连的任意一个关系模式中(更倾向)</li>
<li>属性: 原关系模式属性加上上述属性</li>
<li>码: 上述的码</li>
</ul>
</blockquote>
</li>
<li>实体间的一对多联系:<blockquote>
<p>转换为一个独立的关系模式</p>
<ul>
<li>属性: 与该联系相连的各实体的码以及联系本身的属性</li>
<li>码: n端的实体的码(即多端的实体的码)<br>与n端的关系模式合并(更倾向)</li>
<li>属性: n端关系模式属性加上上述属性</li>
<li>码: n端实体的码</li>
</ul>
</blockquote>
</li>
<li>实体间的多对多联系:转换成一个独立的关系模式<blockquote>
<ul>
<li>属性: 各实体的码以及联系本身的属性</li>
<li>码: 各实体的码的组合</li>
</ul>
</blockquote>
</li>
<li>三个或以上实体间的一个多元联系: 转换成一个独立的关系模式</li>
<li>可以合并具有相同码的关系模式(减少关系个数)<blockquote>
<ul>
<li>将其中一个关系模式的全部属性加入另一个关系模式中</li>
<li>去掉同义的属性,并适当调整属性的次序</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="数据模型的优化"><a href="#数据模型的优化" class="headerlink" title="数据模型的优化"></a>数据模型的优化</h3><p>数据库逻辑设计结果不是唯一的,需要运用规范化理论进行修改和调整</p>
<blockquote>
<ul>
<li>确定数据依赖</li>
<li>对各个关系模式之间的数据依赖进行极小化处理,消除冗余</li>
<li>确定各关系模式属于的范式</li>
<li>按要求对各关系模式进行合并或分解<br>注意:</li>
<li>规范化通常的代价是更多的连接运算</li>
<li>非BCNF的关系模式只会存在更新异常,不会存在查询异常,若实际应用中只是查询为主,则高范式对关系模式没有实际影响</li>
</ul>
</blockquote>
<h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><p>考虑局部应用的特殊需求和用户体验,可由视图机制来定义用户子模式</p>
<ul>
<li>使用更符合用户习惯的别名</li>
<li>针对不同级别的用户定义不同的视图,提高系统的安全性</li>
<li>简化用户对系统的使用</li>
</ul>
<h2 id="7-5-物理结构设计"><a href="#7-5-物理结构设计" class="headerlink" title="7.5 物理结构设计"></a>7.5 物理结构设计</h2><p>物理设计: 为逻辑数据模型选取一个最适合应用要求的物理结构,包括物理设备上的存储结构和存取方法</p>
<p><img src="/2020/05/24/data-base1/phys0.jpg" alt="phys"></p>
<h3 id="物理设计的内容和方法"><a href="#物理设计的内容和方法" class="headerlink" title="物理设计的内容和方法"></a>物理设计的内容和方法</h3><p>内容:</p>
<blockquote>
<ul>
<li>为关系模式选择存取方法(建立存取路径)</li>
<li>为关系,索引,日志,备份等数据库文件选择物理存储结构</li>
</ul>
</blockquote>
<p>设计原则:</p>
<blockquote>
<ul>
<li>充分了解应用环境: 分析运行的事物,选择设计所需参数</li>
<li>充分了解RDBMS内部特征: 了解系统提供的存取方法和存储结构,如索引等<br>物理数据库设计参数<ul>
<li>数据库查询事务: 查询所涉及的关系,属性等</li>
<li>数据更新事务: 被更新的关系,所设计的属性等</li>
<li>每个事务在各关系上运行的频率和性能要求</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="关系模式存取方法选择"><a href="#关系模式存取方法选择" class="headerlink" title="关系模式存取方法选择"></a>关系模式存取方法选择</h3><h4 id="索引方法"><a href="#索引方法" class="headerlink" title="索引方法"></a>索引方法</h4><p>建立索引可以提高存取效率,索引存取方法的选择需要根据应用要求确定</p>
<blockquote>
<ul>
<li>对哪些属性列建立索引</li>
<li>对哪些索引要设计唯一索引,组合索引</li>
<li>选择合适的索引方法</li>
</ul>
</blockquote>
<p>创建索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">USING</span> &lt;索引方法&gt;] (列<span class="number">1</span> [,列<span class="number">2</span>,...]);</span><br></pre></td></tr></table></figure>
<ul>
<li>RDBMS提供的索引方法: B-tree(缺省),hash,R-tree,Bitmap等</li>
</ul>
<p>在某属性(组)上选择索引存取方法的一般规则:</p>
<blockquote>
<ul>
<li>某属性(组)经常在查询条件中</li>
<li>一个属性(组)常作为聚集函数(最值)的参数</li>
<li>一个属性(组)常在连接操作的条件中出现</li>
</ul>
</blockquote>
<p>索引建立会带来维护,查找,存储索引的开销</p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树特点:</p>
<blockquote>
<ul>
<li>多分平衡树,存取效率高</li>
<li>能随机查找也能顺序查找</li>
<li>增删改操作中能通过算法保持树平衡  </li>
</ul>
</blockquote>
<p>B+树结构如下:<br><img src="/2020/05/24/data-base1/B0.jpg" alt="B"></p>
<blockquote>
<ul>
<li>随机查找: 与每一层进行一次比较,若在叶节点中找到码值相等的记录,则根据指针取出相应记录<ul>
<li>若B+树完全存储在文件中,则进行一次比较消耗一次IO操作;若找到相等的节点,最后取记录也消耗一次IO操作</li>
</ul>
</li>
<li>范围查找: 先找到起始记录(码值最小的记录),然后沿着叶节点链向后查找,直到码值超出范围</li>
</ul>
</blockquote>
<h4 id="hash存取方法"><a href="#hash存取方法" class="headerlink" title="hash存取方法"></a>hash存取方法</h4><p>hash通过散列函数将key与record一一对应起来</p>
<p>hash存取方法适用下列情况:</p>
<blockquote>
<ul>
<li>一个关系属性主要出现在等值连接条件或等值比较选择条件中</li>
<li>该关系大小可预知,且不变</li>
<li>该关系大小动态改变,但所选用DBMS提供了动态hash存取方法</li>
</ul>
</blockquote>
<h4 id="聚簇方法"><a href="#聚簇方法" class="headerlink" title="聚簇方法"></a>聚簇方法</h4><p>聚簇: 通过将属性(组)上具有相同值的元组集中存放在连续的物理块上,提高某个属性(组)的查询速度(减少IO操作)</p>
<blockquote>
<p>上述属性(组)称为聚簇码</p>
</blockquote>
<p>聚簇建立:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> CLUSTER &lt;聚簇名&gt; (&lt;聚簇码&gt;) <span class="keyword">SIZE</span> (&lt;大小&gt;);</span><br></pre></td></tr></table></figure>

<p>适用范围:</p>
<blockquote>
<ul>
<li>对单个关系进行独立聚簇,也适用多个关系组合聚簇</li>
<li>SQL语句中包含有与聚簇码有关的排序,聚集,集合交并操作时,使用聚簇可以省去或减少对结果集的排序操作</li>
<li>很少对基表进行增删操作</li>
<li>很少对其中的变长列进行修改操作</li>
</ul>
</blockquote>
<p>局限性:</p>
<blockquote>
<ul>
<li>一个基本表上最多只能建立一个聚簇索引</li>
<li>聚簇只能提高某些特定应用的性能</li>
<li>建立与维护聚簇开销相当大<ul>
<li>聚簇建立会导致关系中元组的物理存储位置移动,使关系上原有的索引失效,需要重建索引</li>
<li>当一个元组聚簇码改变时,它的存储位置也要相应改变</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="确定数据的存储结构"><a href="#确定数据的存储结构" class="headerlink" title="确定数据的存储结构"></a>确定数据的存储结构</h4><p>基本原则:</p>
<blockquote>
<ul>
<li>易变部分和稳定部分分开存放</li>
<li>经常存取的部分和存取频率较低的部分分开存放</li>
<li>将日志和数据库对象分开存放</li>
</ul>
</blockquote>
<h4 id="评价物理结构"><a href="#评价物理结构" class="headerlink" title="评价物理结构"></a>评价物理结构</h4><p>物理设计可以有多种方案,需要从中选择一个较优的方案进行实现</p>
<p>方法:</p>
<blockquote>
<ul>
<li>定量估算各种方案<ul>
<li>存储空间,存取时间,维护代价等</li>
</ul>
</li>
<li>对估算结构进行权衡比较,选择出一个较优的合理的物理结构</li>
<li>返回用户,征求意见,修改设计</li>
</ul>
</blockquote>
<h2 id="7-6-数据库的实施和维护"><a href="#7-6-数据库的实施和维护" class="headerlink" title="7.6 数据库的实施和维护"></a>7.6 数据库的实施和维护</h2><p>示意图:<br><img src="/2020/05/24/data-base1/act0.jpg" alt></p>
<h3 id="数据的载入和应用程序的调试"><a href="#数据的载入和应用程序的调试" class="headerlink" title="数据的载入和应用程序的调试"></a>数据的载入和应用程序的调试</h3><ul>
<li>定义数据库结构: 用DDL语言创建基本表,视图,索引等(产生目标模式,生成数据字典)</li>
<li>数据装载: 数据抽取,数据转换,数据载入(ETL)<blockquote>
<p>数据装载相当费时费力,可以使用DBMS提供的ETL工具辅助完成</p>
</blockquote>
</li>
<li>编制调试应用程序: 数据库设计和数据库应用程序设计是并行的,在数据库实施阶段应当进行编制与调试数据库的应用程序<blockquote>
<p>此时可以使用一些模拟数据</p>
</blockquote>
<h3 id="数据库试运行"><a href="#数据库试运行" class="headerlink" title="数据库试运行"></a>数据库试运行</h3></li>
</ul>
<p>在调试完成后,让一小部分数据入库,对数据库系统进行综合的调试; 这里可以包括功能测试和性能测试</p>
<ul>
<li>数据库性能指标的测量: 需要测量实际运行的性能指标,若不符合设计目标,需要返回物理设计阶段调整物理结构,甚至返回逻辑设计阶段调整逻辑结构</li>
<li>数据的分期入库: 先输入小批量数据供先期联合调试; 待试运行基本合格后再输入大批量数据; 逐步增加数据量来逐步完成运行评价</li>
<li>数据库的转储和恢复: 做好数据库的转储和恢复工作,尽量减少对数据库的破坏</li>
</ul>
<h3 id="数据库的运行和维护"><a href="#数据库的运行和维护" class="headerlink" title="数据库的运行和维护"></a>数据库的运行和维护</h3><p>数据库的运行和维护主要由数据库管理员完成</p>
<ul>
<li>数据库的转储和恢复<blockquote>
<ul>
<li>针对不同的应用要求制定不同的转储计划,定期对数据库和日志文件进行备份</li>
<li>一旦发生介质故障,需要利用数据库备份及日志文件备份尽快将数据库恢复到某种一致性的状态</li>
</ul>
</blockquote>
</li>
<li>数据库安全性,完整性控制<blockquote>
<ul>
<li>初始定义: 数据库管理员根据用户实际需求授予不同的操作权限</li>
<li>修改定义: 应用环境发生变化时,数据库管理员需要根据实际情况修改原有的安全控制和完整性约束条件</li>
</ul>
</blockquote>
</li>
<li>数据库性能的监督,分析和改进<blockquote>
<ul>
<li>利用监测工具获取系统运行过程中的性能参数值</li>
<li>分析数据判断系统的运行状态是否最佳</li>
<li>适时通过调整某些参数来改进数据库的性能</li>
</ul>
</blockquote>
</li>
<li>数据库的重组织与重构造: 记录的增删改查会影响数据库的物理存储,降低数据库存储空间利用率,使得数据库性能下降<blockquote>
<ul>
<li>重组织: 按原设计要求重新安排存储位置,回收垃圾,减少指针链(这不会破坏数据库的逻辑结构和物理结构)</li>
<li>重构造: 增加新的应用或实体,修改某些已有应用; 根据新环境调整数据库的模式和内模式<br>注意,重构造数据库的程度是有限的, 当应用需求变化太大或者软硬件发展太快导致重构数据库代价太大时,需要重新设计数据库应用系统了,原有数据库应用系统的生命周期已经结束</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="八、数据库编程"><a href="#八、数据库编程" class="headerlink" title="八、数据库编程"></a>八、数据库编程</h1><p>问题: 一些要求无法使用SQL语言表达</p>
<p>突破SQL语言局限性的解决方案:</p>
<blockquote>
<ul>
<li>利用高级语言的表达能力: 嵌入式SQL</li>
<li>扩展SQL语言: 过程化SQL</li>
<li>在一个更大的视野上将数据库看成是一类数据源: ODBC编程接口</li>
</ul>
</blockquote>
<h2 id="8-1-嵌入式SQL"><a href="#8-1-嵌入式SQL" class="headerlink" title="8.1 嵌入式SQL"></a>8.1 嵌入式SQL</h2><h3 id="C语言中的SQL基本语法"><a href="#C语言中的SQL基本语法" class="headerlink" title="C语言中的SQL基本语法"></a>C语言中的SQL基本语法</h3><p>基本格式: <code>EXEC SQL &lt;语句块;&gt;</code></p>
<p>主语言程序编译过程:</p>
<blockquote>
<ol>
<li>编写含嵌入式SQL语句的主语言程序</li>
<li>预编译程序(预编译器由SQL厂商提供),将嵌入式SQL变为函数调用(形式上消除SQL)</li>
<li>正常编译主语言程序</li>
</ol>
</blockquote>
<p>主语言访问数据库的基本步骤</p>
<blockquote>
<ol>
<li>打开数据库</li>
<li>定义必要的主变量和数据通信区</li>
<li>用SQL访问数据库,并对返回结果进行处理</li>
<li>关闭数据库</li>
</ol>
</blockquote>
<h4 id="建立数据库连接"><a href="#建立数据库连接" class="headerlink" title="建立数据库连接"></a>建立数据库连接</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">EXEC SQL CONNECT TO &lt;服务器名&gt; [AS &lt;连接名&gt;] [USER &lt;用户名&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器名是要连接的数据库服务器的名字,可以是<blockquote>
<ul>
<li>服务器标识串,如<code>&lt;dbname&gt;@&lt;hostname&gt;:&lt;port&gt;</code></li>
<li>包含服务器标识的SQL串常量</li>
<li>DEFAULT</li>
</ul>
</blockquote>
</li>
<li>整个程序内只有一个连接时可以不指定连接名</li>
<li>可以通过<code>EXEC SQL CONNECTION &lt;连接名&gt;|DEFAULT</code>来修改当前的连接</li>
</ul>
<h4 id="定义主变量与数据通讯区"><a href="#定义主变量与数据通讯区" class="headerlink" title="定义主变量与数据通讯区"></a>定义主变量与数据通讯区</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>; <span class="comment">/*主变量说明开始*/</span> </span><br><span class="line">    &lt;变量类型&gt; &lt;变量名&gt;;</span><br><span class="line">    &lt;类型&gt; &lt;名&gt;;...</span><br><span class="line">EXEC SQL <span class="keyword">END</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>; <span class="comment">/*主变量说明结束*/</span></span><br><span class="line">long SQLCODE;</span><br><span class="line">EXEC SQL INCLUDE SQLCA; <span class="comment">/*定义SQL通信区*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这些数据的定义一般在函数外定义<ul>
<li>后面SQL查询所INTO的变量需要在主变量说明中定义</li>
</ul>
</li>
</ul>
<h4 id="执行相关SQL语句"><a href="#执行相关SQL语句" class="headerlink" title="执行相关SQL语句"></a>执行相关SQL语句</h4><p>所有SQL语句都可以通过执行,包括数据的定义控制更新查询</p>
<p>查询:  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">SELECT</span> &lt;属性<span class="number">1</span>&gt; [,&lt;属性<span class="number">2</span>&gt;,...]</span><br><span class="line">    <span class="keyword">INTO</span>:&lt;主变量<span class="number">1</span>&gt; [,:&lt;主变量<span class="number">2</span>&gt;,...]</span><br><span class="line">    <span class="keyword">FROM</span> ...</span><br><span class="line">    <span class="keyword">WHERE</span> ...</span><br><span class="line">    ...;</span><br></pre></td></tr></table></figure>
<ul>
<li>INTO子句用于保存查询结果</li>
<li>前面带”:”标识的变量为主变量,即主语言的变量<blockquote>
<ul>
<li>INTO,WHERE,HAVING中都可以使用主变量</li>
<li>返回的记录中某些列的值可能为NULL</li>
<li>主变量只能存储一条记录,若返回多条记录则程序出错</li>
</ul>
</blockquote>
</li>
</ul>
<p>增删改:</p>
<blockquote>
<ul>
<li>增删改中的SET和WHERE子句中可以使用主变量</li>
<li>使用SET时,需要在主程序中将相应的值赋给主变量</li>
</ul>
</blockquote>
<h4 id="关闭数据库连接"><a href="#关闭数据库连接" class="headerlink" title="关闭数据库连接"></a>关闭数据库连接</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">EXEC SQL DISCONNECT &lt;连接名&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h3><p>高级语言是一种过程性语言(执行命令),而SQL语言是描述性语言(描述集合)</p>
<p>通信机制:</p>
<blockquote>
<ul>
<li>状态信息传递: 利用SQL通信区,向主语言传递SQL语句的执行状态信息,使主语言能够控制程序流程</li>
<li>参数传递: 利用主变量,让主语言向SQL语句提供参数</li>
<li>结果传递: 使用主变量和游标,将SQL语句查询结果返回给主语言</li>
</ul>
</blockquote>
<h4 id="SQL通信区SQLCA"><a href="#SQL通信区SQLCA" class="headerlink" title="SQL通信区SQLCA"></a>SQL通信区SQLCA</h4><p>用途:</p>
<ul>
<li>在执行完SQL语句后,DBMS将系统的当前工作状态和运行环境送到通信区返回给应用程序,应用程序根据这些信息决定接下来的动作</li>
</ul>
<p>SQLCA是一个数据结构(SQL Communication Area)</p>
<p>使用方法:</p>
<blockquote>
<ul>
<li>定义: <code>EXEC SQL INCLUDE SQLCA</code></li>
<li>使用: SQL的返回代码会存储在SQLCODE中,SQLCODE为SUCCESS则表示语句成功,否则出错</li>
</ul>
</blockquote>
<h4 id="主变量"><a href="#主变量" class="headerlink" title="主变量"></a>主变量</h4><p>主变量是在SQL语句中使用的主语言程序变量</p>
<blockquote>
<ul>
<li>输入主变量: 由应用程序赋值,SQL语句引用</li>
<li>输出主变量: 由SQL语句对其赋值或设置状态信息, 返回给应用程序</li>
<li>指示变量: 整型变量,可以带在主变量后面; 用于指示输入或输出主变量的值是否为空值<br>例1: <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">SELECT</span> Sno,Cno,Grade</span><br><span class="line">   <span class="keyword">INTO</span> :Hsno,:Hcno,:Hgrade:Gradeid  <span class="comment">/*指示变量Gradeid*/</span></span><br><span class="line">   <span class="keyword">FROM</span>  SC</span><br><span class="line">   <span class="keyword">WHERE</span> Sno=:givensno <span class="keyword">AND</span> Cno=:givencno </span><br></pre></td></tr></table></figure>
若Gradeid&lt;0,不论Hgrade为何值,Hgrade都为空  </li>
</ul>
<p>例2:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">gradeid=-1</span><br><span class="line"> EXEC SQL <span class="keyword">INSERT</span> </span><br><span class="line"> <span class="keyword">INTO</span> SC(Sno,Cno,Grade)                 <span class="keyword">VALUES</span>(:stdno,:couno,:gr:gradeid); </span><br></pre></td></tr></table></figure>
<p>此时Grade插入的是空值</p>
</blockquote>
<p>使用主变量和指示变量需要事先声明</p>
<blockquote>
<ul>
<li>声明之后的主变量可以在主程序中或SQL中任何一个可以使用表达式的地方使用</li>
<li>SQL中的主变量之前要加上’:’以示区别</li>
<li>指示变量必须紧跟主变量之后使用,也需要加上’:’区别</li>
<li>SQL之外的主变量正常使用即可</li>
</ul>
</blockquote>
<h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><ul>
<li>INTO主变量的方式只能得到一条查询结果</li>
<li>游标是数据库系统为用户开设的数据缓冲区,用于存放SQL语句的执行结果,可以是多条查询结果(集合)</li>
<li>每个游标区有一个名字,可以看成该缓冲区的指针</li>
<li>可以用SQL语句逐一从游标中获取记录赋给主变量</li>
</ul>
<p>何时使用游标:</p>
<blockquote>
<ul>
<li>查询结果为多条SELECT语句</li>
<li>CURRENT形式的UPDATE和DELETE语句</li>
</ul>
</blockquote>
<p>游标声明:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> &lt;游标名&gt; <span class="keyword">CURSOR</span></span><br><span class="line">    <span class="keyword">FOR</span> &lt;<span class="keyword">SELECT</span>语句&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>该语句是一条说明性语句并不执行SELECT语句,只是申请一个数据空间来存放未来的执行结果</li>
</ul>
<p>打开游标:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">EXEC SQL OPEN &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时游标中定义的SELECT语句被执行,查询结果被放到缓冲区中</li>
<li>此时游标处于活动状态,指针指向查询结果的第一条记录</li>
</ul>
<p>推进游标:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">EXEC SQL FETCH &lt;游标名&gt;</span><br><span class="line">    INTO &lt;主变量1&gt;[, &lt;主变量2&gt;, ...];</span><br></pre></td></tr></table></figure>
<ul>
<li>每执行一次该语句,指针将指向的记录赋给主变量,并将指针后移一位</li>
</ul>
<p>关闭游标:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">EXEC SQL CLOSE &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭游标,释放缓冲区以及占用的其他资源</li>
<li>游标被关闭后,就不再和原来的结果集相联系; 但可以再次打开游标,重新生成并连接结果集</li>
</ul>
<p>CURRENT形式的UPDATE和DELETE语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span></span><br><span class="line">    &lt;删改语句&gt;</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> &lt;游标名&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时游标应事先打开</li>
<li>删除或修改的是游标指针目前指向的记录</li>
<li>一般使用方法: 先用游标SELECT出所有满足条件的记录; 再推进游标,找到想要修改或删除的记录; 最后使用CURRENT语句删改该记录<blockquote>
<p>注意: 当游标SELECT语句中带有UNION或ORDER BY等子句,删改操作无法转换成对基本表的删改,此时无法使用CURRENT形式的删改语句</p>
</blockquote>
</li>
</ul>
<h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>有些SQL语句无法在编译阶段就确定下来,需要在程序执行时才能确定,称为动态嵌入式SQL</p>
<blockquote>
<ul>
<li>它允许程序在运行过程中临时”组装”出SQL语句</li>
<li>支持动态组装SQL语句和动态参数两种形式</li>
</ul>
</blockquote>
<h4 id="SQL语句主变量"><a href="#SQL语句主变量" class="headerlink" title="SQL语句主变量"></a>SQL语句主变量</h4><p>语句主变量定义:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>;</span><br><span class="line">    const char *stmt="&lt;SQL语句字符串&gt;";</span><br><span class="line">EXEC SQL <span class="keyword">END</span> <span class="keyword">DECLARE</span> <span class="keyword">SECTION</span>;</span><br></pre></td></tr></table></figure>

<p>执行动态SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">EXECUTE</span> <span class="keyword">IMMEDIATE</span> :stmt; <span class="comment">/*stmt为字符串常量指针名*/</span></span><br></pre></td></tr></table></figure>

<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><p>动态参数是上面SQL语句主变量中的可变元素,使用参数符号’?’标识; 其输入是在程序执行过程中完成绑定</p>
<p>声明SQL语句主变量例:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">const char *stmt = "INSERT INTO table VALUES(?);";</span><br></pre></td></tr></table></figure>

<p>准备SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">PREPARE</span> &lt;语句名&gt; <span class="keyword">FROM</span> &lt;<span class="keyword">SQL</span>语句主变量(:stmt)&gt;;</span><br></pre></td></tr></table></figure>

<p>执行SQL语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">EXECUTE</span> &lt;语句名&gt;</span><br><span class="line">    [<span class="keyword">INTO</span> &lt;主变量表&gt;]</span><br><span class="line">    [<span class="keyword">USING</span> &lt;主变量或常量&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>此时用INTO和USING后面的内容来与前面的(?)相绑定</li>
</ul>
<h2 id="8-2-过程化SQL"><a href="#8-2-过程化SQL" class="headerlink" title="8.2 过程化SQL"></a>8.2 过程化SQL</h2><p>目标: 扩展SQL语言本身的能力,加入过程控制的功能</p>
<ul>
<li>过程化SQL尽量减少系统之间的通讯和协同,使得这些功能能被数据库本身完成</li>
</ul>
<p>过程化SQL又称PL/SQL,是对SQL的扩展</p>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>PL/SQL中</p>
<blockquote>
<ul>
<li>基本结构是块</li>
<li>增加了变量常量的定义,变量的赋值和流程控制语句</li>
</ul>
</blockquote>
<p>定义语句:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">    &lt;变量名&gt; &lt;数据类型&gt; [[<span class="keyword">NOT</span> <span class="literal">NULL</span>] [:=] &lt;初值表达式&gt;];</span><br><span class="line">    &lt;常量名&gt; &lt;数据类型&gt; CONSTANT := &lt;常量表达式&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义的变量,常量生命周期为整个块</li>
<li>常量定义后在作用域中不能再赋值</li>
</ul>
<p>执行语句:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">    [<span class="keyword">SET</span>] &lt;变量名&gt; := &lt;表达式&gt;;</span><br><span class="line">    </span><br><span class="line">    IF &lt;条件&gt; THEN</span><br><span class="line">        &lt;语句&gt;;</span><br><span class="line">    [ELSE &lt;语句&gt;;]</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    </span><br><span class="line">    [WHILE &lt;条件&gt;]|    </span><br><span class="line">    [FOR &lt;count&gt; IN [REVERSE] &lt;值1&gt;...&lt;值n&gt;]</span><br><span class="line">    LOOP</span><br><span class="line">        &lt;语句&gt; [EXIT|BREAK|LEAVE];</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    </span><br><span class="line">EXCEPTION</span><br></pre></td></tr></table></figure>

<h3 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h3><p>存储过程: 由过程化SQL书写的一段语句经编译和优化后命名并存储在数据库服务器中待使用时调用的过程</p>
<blockquote>
<p>优点</p>
<ul>
<li>运行效率高</li>
<li>降低客户机和服务器之间的通讯量</li>
<li>方便实施企业规划</li>
</ul>
</blockquote>
<p>过程化SQL块类型:</p>
<blockquote>
<ul>
<li>命名块: 编译后保存在数据库中供反复高效调用,过程和函数是命名块</li>
<li>匿名块: 每次执行都要编译的块,不能被存储和调用</li>
</ul>
</blockquote>
<h4 id="存储过程的用户接口"><a href="#存储过程的用户接口" class="headerlink" title="存储过程的用户接口"></a>存储过程的用户接口</h4><p>创建存储:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt; ([&lt;参数<span class="number">1</span>&gt;,&lt;参数<span class="number">2</span>&gt;,...]) <span class="keyword">AS</span> &lt;过程化<span class="keyword">SQL</span>块&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数列表: 调用时给出的参数值,需要指定值的数据类型; 参数可定义为输入参数(默认),输出参数和输入/输出参数</li>
<li>过程块: 一个包括声明部分和可执行语句部分的块,过程块中可以调用其他存储过程</li>
</ul>
<p>执行存储过程:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span>|PREFORM <span class="keyword">PROCEDURE</span> &lt;过程名&gt; (&lt;参数列表&gt;);</span><br></pre></td></tr></table></figure>

<p>修改存储过程:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新过程名&gt;;</span><br></pre></td></tr></table></figure>

<p>删除存储过程:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> &lt;过程名&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数和存储过程都是持久性的存储过程,但函数必须执行返回值的类型</p>
<p>函数定义:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> &lt;函数名&gt; ([&lt;参数列表&gt;])</span><br><span class="line"><span class="keyword">RETURNS</span> &lt;返回值类型&gt; <span class="keyword">AS</span> &lt;过程化<span class="keyword">SQL</span>块&gt;;</span><br></pre></td></tr></table></figure>

<p>函数执行:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span>|<span class="keyword">SELECT</span> &lt;函数名&gt; ([&lt;参数列表&gt;]);</span><br></pre></td></tr></table></figure>

<p>修改函数:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> &lt;过程名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新过程名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">FUNCTION</span> &lt;过程名&gt; COMPILE; //重新编译</span><br></pre></td></tr></table></figure>

<h2 id="8-3-ODBC编程"><a href="#8-3-ODBC编程" class="headerlink" title="8.3 ODBC编程"></a>8.3 ODBC编程</h2><p>DOBC提供了一组访问数据库的应用程序编程接口,为不同应用程序对不同数据库的访问提供了同一的接口</p>
<p>ODBC约束力:</p>
<blockquote>
<ul>
<li>规范应用开发</li>
<li>规范关系数据库管理系统应用接口</li>
</ul>
</blockquote>
<h3 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h3><p>ODBC体系接口:</p>
<blockquote>
<ul>
<li>用户应用程序</li>
<li>ODBC驱动程序管理器</li>
<li>数据库驱动程序</li>
<li>数据源</li>
</ul>
</blockquote>
<ul>
<li>ODBC应用程序:<blockquote>
<ul>
<li>请求连接数据库</li>
<li>断开与数据源的连接</li>
<li>操作数据库以及获取数据库的执行状态</li>
</ul>
</blockquote>
</li>
<li>驱动程序管理器: 用于管理各种驱动程序</li>
<li>数据库驱动程序: 由厂商提供<blockquote>
<p>类型:</p>
<ul>
<li>单束驱动程序: 数据源和应用程序在同一台</li>
<li>多束驱动程序: 支持网络环境下的数据访问</li>
</ul>
</blockquote>
</li>
<li>　数据源: 最终用户需要访问的数据,包含了数据库位置和数据库类型等信息,是一种数据连接的抽象<blockquote>
<p>数据源对最终用户是透明的</p>
</blockquote>
</li>
</ul>
<p>ODBC优点:</p>
<blockquote>
<ul>
<li>应用程序移植性好</li>
<li>能在同一个应用中同时访问不同的数据库</li>
</ul>
</blockquote>
<h3 id="ODBC-API基础"><a href="#ODBC-API基础" class="headerlink" title="ODBC API基础"></a>ODBC API基础</h3><h4 id="函数概述"><a href="#函数概述" class="headerlink" title="函数概述"></a>函数概述</h4><ul>
<li>环境句柄: 管理多个连接句柄,访问不同数据源</li>
<li>连接句柄: 连接某一个数据源(同一个RDBMS下每个数据库可以创建一个数据源)</li>
<li>语句句柄: 执行SQL语句</li>
</ul>
<p>函数接口(ODBC3.0):</p>
<blockquote>
<ul>
<li>分配和释放环境,连接,语句句柄</li>
<li>连接函数: SQLDriverconnect等</li>
<li>与信息相关的函数: SQLGetinfo,SQLGetFunction等</li>
<li>事务处理函数: SQLEndTran</li>
<li>执行相关函数:SQLExecdirect,SQLExecute等</li>
<li>编目函数(数据字典相关)</li>
</ul>
</blockquote>
<h4 id="句柄及其属性"><a href="#句柄及其属性" class="headerlink" title="句柄及其属性"></a>句柄及其属性</h4><ul>
<li>句柄是一个32位整数值,是一个指向程序的指针</li>
<li>每一个ODBC应用程序需要建立一个ODBC环境,分配一个环境句柄,存储数据的全局性背景</li>
<li>一个环境句柄可以建立多个连接句柄,每个连接句柄实现与一个数据源之间的连接</li>
</ul>
<blockquote>
<p>ODBC应用程序-1:1-环境句柄-1:n-连接句柄</p>
<p>连接句柄下可接一个数据源句柄和多个语句或描述符句柄</p>
</blockquote>
<h4 id="ODBC标准数据类型"><a href="#ODBC标准数据类型" class="headerlink" title="ODBC标准数据类型"></a>ODBC标准数据类型</h4><ul>
<li>SQL数据类型: 用于数据源</li>
<li>C数据类型: 用于应用程序的C代码</li>
</ul>
<p>相应数据映射关系参照<a href="https://msdn.microsoft.com/en-us/library/ms714556(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/ms714556(v=vs.85).aspx</a></p>
<p>SQLBindcol用于从SQL结果集列中返回结果到应用程序变量; SQLBindparameter用于从应用程序中传变量到语句参数</p>
<h4 id="ODBC工作流程"><a href="#ODBC工作流程" class="headerlink" title="ODBC工作流程"></a>ODBC工作流程</h4><ol>
<li>配置数据源</li>
<li>初始化环境</li>
<li>连接数据源</li>
<li>分配语句句柄</li>
<li>执行SQL语句</li>
<li>(产生结果集)处理结果集</li>
<li>结束</li>
</ol>
<p>配置数据源:</p>
<blockquote>
<p>在ODBC数据源管理器中添加数据源</p>
</blockquote>
<p>初始化环境:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLHENV henv; &#x2F;&#x2F;声明环境句柄变量</span><br><span class="line">SQLAllocHandle(SQL_HANDLE_ENV,SQL_NULL_HANDLE,&amp;henv); &#x2F;&#x2F;创建环境句柄变量</span><br><span class="line">SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0); &#x2F;&#x2F;初始化环境句柄变量</span><br></pre></td></tr></table></figure>

<p>建立连接:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLHDBC hdbc; &#x2F;&#x2F;声明连接句柄变量</span><br><span class="line">SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc); &#x2F;&#x2F;创建连接句柄变量</span><br><span class="line">SQLConnect(hdbc, &lt;数据源名称&gt;,SQL_NTS, &lt;用户名字符串&gt;,SQL_NTS,&lt;密码字符串&gt;,SQL_NTS); &#x2F;&#x2F;初始化连接句柄变量,连接创建的数据源</span><br></pre></td></tr></table></figure>

<p>分配语句句柄:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLHSTMT hstmt; &#x2F;&#x2F;声明语句句柄变量</span><br><span class="line">SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp; hstmt); &#x2F;&#x2F;创建语句句柄变量</span><br><span class="line">SQLSetStmtAttr(hstmt,SQL_ATTR_ROW_BIND_TYPE,(S QLPOINTER)SQL_BIND_BY_COLUMN,SQL_IS_INTEGER ); &#x2F;&#x2F;初始化,设置语句句柄属性</span><br></pre></td></tr></table></figure>

<p>执行SQL语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLExecDirect(hstmt,&lt;SQL语句字符串&gt;,SQL_NTS); &#x2F;&#x2F;直接执行</span><br><span class="line"></span><br><span class="line">SQLPrepare(hstmt,&lt;SQL语句字符串&gt;, SQL_NTS);</span><br><span class="line">SQLPrepare(hstmt,&lt;SQL语句字符串2&gt;, SQL_NTS);</span><br><span class="line">SQLExecute(hstmt); &#x2F;&#x2F;批量执行</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SQLPrepar中的语句字符串可以带”?”参数,需要通过SQLBindParameter动态绑定</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def SQLRETURN SQLBindparameter(</span><br><span class="line">    &lt;SQL语句句柄&gt;,</span><br><span class="line">    &lt;变量参数位置(从1开始计数)&gt;,</span><br><span class="line">    &lt;指明输入&#x2F;输出标志&gt;, &#x2F;&#x2F;SQL_PARAM_INPUT|SQL_PARAM_OUTPUT|SQL_PARAM_INPUT_OUTPUT</span><br><span class="line">    &lt;用于和参数绑定的C语言的数据类型&gt;,</span><br><span class="line">    &lt;SQL数据类型&gt;,</span><br><span class="line">    &lt;接受数据的宽度(普通变量为0即可)&gt;,</span><br><span class="line">    &lt;SQL类型为NUMERIC或DECIMAL时指明小数点进度(否则为0)&gt;,</span><br><span class="line">    &lt;参数指针指向缓冲区的字节数大小(普通变量为0)&gt;,</span><br><span class="line">    &lt;输入数据字节数大小(普通变量为0)&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;例如:</span><br><span class="line"></span><br><span class="line">SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_CHAR,SQL_CHAR, SNO_LEN, 0, sSno, 0, &amp;SQL_NTS);</span><br></pre></td></tr></table></figure>

<p>结果集处理(如果产生结果集):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;例: </span><br><span class="line">&#x2F;&#x2F;将查询结果绑定到应用程序缓冲区</span><br><span class="line">SQLBindCol(hstmt, 1, SQL_C_CHAR,sSno,SNO_LEN, &amp;SQLINTEGER); </span><br><span class="line">SQLBindCol(hstmt, 2, SQL_C_CHAR, sName, NAME_LEN, &amp;SQLINTEGER); </span><br><span class="line">SQLBindCol(hstmt, 3, SQL_C_CHAR, sSex, SSEX_LEN, &amp;SQLINTEGER); </span><br><span class="line">SQLBindCol(hstmt, 4, SQL_C_LONG, &amp;sAge, 0, &amp;SQLINTEGER); </span><br><span class="line">SQLBindCol(hstmt, 5, SQL_C_CHAR, sDepart, DEPART_LEN, &amp;SQLINTEGER);</span><br><span class="line">&#x2F;&#x2F;移动游标获取结果集中的每一行数据</span><br><span class="line">while ((ret&#x3D;SQLFetch(hstmt)) !&#x3D;SQL_NO_DATA_FOUND)   </span><br><span class="line">    process(sSno, sName, sSex, sAge, sDepart);</span><br></pre></td></tr></table></figure>

<p>终止处理: 释放语句句柄,释放数据库连接,断开数据库服务器,释放ODBC环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQLFreeHandle(SQL_HANDLE_STMT, hstmt); </span><br><span class="line">SQLDisconnect(hdbc); </span><br><span class="line">SQLFreeHandle(SQL_HANDLE_DBC, hdbc); </span><br><span class="line">SQLFreeHandle(SQL_HANDLE_ENV, henv); </span><br><span class="line">SQLFreeHandle(SQL_HANDLE_ENV,serverhenv);</span><br></pre></td></tr></table></figure>

<h1 id="九、关系查询处理"><a href="#九、关系查询处理" class="headerlink" title="九、关系查询处理"></a>九、关系查询处理</h1><h2 id="9-1-SQL语句的处理过程"><a href="#9-1-SQL语句的处理过程" class="headerlink" title="9.1 SQL语句的处理过程"></a>9.1 SQL语句的处理过程</h2><p>处理步骤:<br><img src="/2020/05/24/data-base1/query0.jpg" alt="query"></p>
<h3 id="查询分析"><a href="#查询分析" class="headerlink" title="查询分析"></a>查询分析</h3><p>任务: 对查询语句进行扫描,词法分析和语法分析</p>
<ul>
<li>词法分析: 从查询语句中识别出正确的语言符号</li>
<li>语法分析: 进行语法检查</li>
</ul>
<h3 id="查询检查"><a href="#查询检查" class="headerlink" title="查询检查"></a>查询检查</h3><ul>
<li>有效性检查: 根据数据字典检查语句中的数据库对象是否存在和有效</li>
<li>视图转换: 用视图消解法将对视图的操作转换成对基本表的操作</li>
<li>安全性检查: 根据数据字典对用户权限进行检查</li>
<li>完整性初步检查: 根据数据字典对完整性约束进行检查  </li>
</ul>
<p>检查通过后,SQL语句会被转换成内部表示,一般为语法分析树</p>
<h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>任务: 选择一个高效执行的查询处理策略</p>
<p>分类:</p>
<blockquote>
<ul>
<li>代数/逻辑优化: 针对关系代数表达式进行优化</li>
<li>物理优化: 对存取路径和底层操作算法进行选择优化</li>
</ul>
</blockquote>
<p>查询优化的依据:</p>
<blockquote>
<ul>
<li>基于规则</li>
<li>基于代价</li>
<li>基于语义</li>
</ul>
</blockquote>
<h3 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h3><p>任务: 根据优化器得到的执行策略生成查询指向计划</p>
<p>两种执行方法: 自顶向下; 自底向上</p>
<h2 id="9-2-关系算子的实现"><a href="#9-2-关系算子的实现" class="headerlink" title="9.2 关系算子的实现"></a>9.2 关系算子的实现</h2><h3 id="选择操作的实现"><a href="#选择操作的实现" class="headerlink" title="选择操作的实现"></a>选择操作的实现</h3><h4 id="全表扫描法"><a href="#全表扫描法" class="headerlink" title="全表扫描法"></a>全表扫描法</h4><p>对查询的基本表顺序扫描,逐一检查每个元组是否满足选择条件,将符合条件的元组输出</p>
<ul>
<li>适合小表,不适合大表</li>
</ul>
<h4 id="索引扫描法"><a href="#索引扫描法" class="headerlink" title="索引扫描法"></a>索引扫描法</h4><p>通过索引先找出满足条件的元组主码或指针,通过指针直接在查询的基本表中找到元组</p>
<ul>
<li>适合选择条件中的属性上有索引(B+树索引或Hash索引)</li>
</ul>
<h3 id="连接操作的实现"><a href="#连接操作的实现" class="headerlink" title="连接操作的实现"></a>连接操作的实现</h3><h4 id="嵌套循环法"><a href="#嵌套循环法" class="headerlink" title="嵌套循环法"></a>嵌套循环法</h4><p>对外层循环的每一个元组,检查内层循环中的每一个元组是否和前面的元组满足连接条件,满足则输出</p>
<h4 id="排序-合并算法"><a href="#排序-合并算法" class="headerlink" title="排序-合并算法"></a>排序-合并算法</h4><p>先对两表中的连接属性进行排序,取外层循环中的一个元组,将内层循环中第一个和它连接属性相同的元组a进行连接,当遇到一个不能连接的元组时就放弃,取下一个元组,从刚才的a继续往下连接</p>
<ul>
<li>此时连接应为等值连接</li>
</ul>
<h4 id="索引连接算法"><a href="#索引连接算法" class="headerlink" title="索引连接算法"></a>索引连接算法</h4><p>在内层表中对连接属性建立索引,在外层表中,通过索引找到对应的内层表元组进行连接</p>
<ul>
<li>此时连接应为等值连接</li>
</ul>
<h4 id="Hash-Join算法"><a href="#Hash-Join算法" class="headerlink" title="Hash Join算法"></a>Hash Join算法</h4><p>将连接属性作为hash码,将两表中的元组散列到hash表中;(划分阶段)对包含较少元组的表进行一遍处理,将它的元组散列到哈士表的桶中;(试探阶段)对另一个表也按同一个hash函数进行散列,将结果与桶中匹配的元组连接起来</p>
<ul>
<li>前提: 两个表中较小的表在划分阶段时可以完全放入内存的hash桶中</li>
</ul>
<h1 id="十、数据库恢复技术"><a href="#十、数据库恢复技术" class="headerlink" title="十、数据库恢复技术"></a>十、数据库恢复技术</h1><h2 id="10-1-事务"><a href="#10-1-事务" class="headerlink" title="10.1 事务"></a>10.1 事务</h2><p>事务时用户定义的一个数据库操作序列,这组操作是一个不可分割的操作单位; 这些操作要么全做,要么全不做</p>
<blockquote>
<ul>
<li>一个程序中可以包含多个事务</li>
<li>一个事务可以是一条或者多条SQL语句</li>
</ul>
</blockquote>
<p>事务时恢复和并发控制的基本单位</p>
<h3 id="事务定义"><a href="#事务定义" class="headerlink" title="事务定义"></a>事务定义</h3><p>显式定义:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACRION</span><br><span class="line">    <span class="keyword">SQL</span> &lt;语句<span class="number">1</span>&gt;</span><br><span class="line">    <span class="keyword">SQL</span> &lt;语句<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">COMMIT</span>|<span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure>
<ul>
<li>COMMIT: 提交, 事务正常结束,提交事务的所有操作</li>
<li>ROLLBACK: 主动回滚, 事务异常终止,撤销所有操作,数据库回滚到事务开始的状态</li>
</ul>
<p>隐式定义: 当用户没有显式定义事务时,DBMS按缺省规定自动划分事务</p>
<h3 id="事务的性质"><a href="#事务的性质" class="headerlink" title="事务的性质"></a>事务的性质</h3><p>ACID性质:</p>
<ul>
<li>原子性: 事务是数据库的逻辑工作单位</li>
<li>一致性: 事务执行的结构必须使数据库从一个一致性状态变为另一个一致性状态 (银行转账)<blockquote>
<ul>
<li>一致性状态: 数据库中只包含成功事务的提交结果</li>
<li>不一致状态: 一些未完成事务对数据库所做的修改有一部分被写入物理数据库, 此时数据库处于一种不正确的状态  </li>
</ul>
</blockquote>
</li>
<li>隔离性: 一个事务的执行不能被其他事务干扰 (两个人抢同一张票)<blockquote>
<ul>
<li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li>
<li>并发执行的各个事务之间不能相互干扰</li>
</ul>
</blockquote>
</li>
<li>持续性: 提交的事务对数据库的修改应该是永久性的<blockquote>
<ul>
<li>接下来的其他操作或故障不应该对该事务的执行结果有任何影响</li>
</ul>
</blockquote>
</li>
</ul>
<p>保证事务ACID特性是事务处理的任务</p>
<p>破坏事务ACID特性的因素:</p>
<blockquote>
<ul>
<li>多个事务并行运行,不同事物的操作交叉执行</li>
<li>事务在运行过程中被强行终止<br>数据库管理系统必须保证多个事务交叉运行不影响事务的隔离性; 必须保证被强行终止的事务对数据库和其他事务没有任何影响</li>
</ul>
</blockquote>
<h2 id="10-2-数据库恢复技术"><a href="#10-2-数据库恢复技术" class="headerlink" title="10.2 数据库恢复技术"></a>10.2 数据库恢复技术</h2><p>故障是不可避免的,会影响数据库中数据的正确性,破坏数据库</p>
<p>对策: DBMS必须具有把数据库从错误状态恢复到某一已知的正确状态的功能</p>
<p>恢复子系统是DBMS的一个重要组成部分,恢复技术是衡量系统优劣性的重要指标</p>
<h2 id="10-3-故障的种类"><a href="#10-3-故障的种类" class="headerlink" title="10.3 故障的种类"></a>10.3 故障的种类</h2><h3 id="事务内部的故障"><a href="#事务内部的故障" class="headerlink" title="事务内部的故障"></a>事务内部的故障</h3><ul>
<li>可预期的: 该故障可以通过事务程序本身发现<blockquote>
<p>可预期的故障一般可以通过添加ROLLBACK处理</p>
</blockquote>
</li>
<li>非预期的: 不能由事务程序处理,一般事务故障指的是非预期故障<blockquote>
<ul>
<li>运算溢出</li>
<li>并发事务发生死锁而被选中撤销该事务</li>
<li>违反某些完整性限制而被终止</li>
</ul>
</blockquote>
</li>
</ul>
<p>事务故障意味着事务没有被commit或者被显式的rollback,数据库可能处于不正常的状态</p>
<p>事务故障的恢复: 事务撤销(UNDO)</p>
<blockquote>
<ul>
<li>UNDO表示强行回滚该事务</li>
<li>撤销事务已经做出的任何对数据库的修改,使得该事务像根本没有启动一样</li>
</ul>
</blockquote>
<h3 id="系统故障"><a href="#系统故障" class="headerlink" title="系统故障"></a>系统故障</h3><p>系统故障指造成系统停止运转的任何事件(需要重启系统)</p>
<blockquote>
<ul>
<li>特定类型的硬件错误</li>
<li>操作系统故障</li>
<li>DBMS代码错误</li>
<li>系统断电</li>
</ul>
</blockquote>
<p>系统故障的影响:</p>
<blockquote>
<ul>
<li>系统的正常运行被突然破坏</li>
<li>所有正在运行的事务被异常终止</li>
<li>内存中数据库缓冲区的信息全部丢失</li>
<li>不破坏数据库</li>
</ul>
</blockquote>
<p>然而此时一些尚未完成的结果可能已经送入物理数据库,使得数据库可能处于不正常的状态</p>
<blockquote>
<p>恢复策略: 系统重启后,恢复程序让所有非正常终止的事务回滚,强行撤销所有未完成的事务</p>
</blockquote>
<p>此时有些已完成的事务可能还留在缓冲区没被写回物理磁盘上</p>
<blockquote>
<p>恢复策略: 撤销所有未完成的事务后,重做所有已提交的事务</p>
</blockquote>
<h3 id="介质故障"><a href="#介质故障" class="headerlink" title="介质故障"></a>介质故障</h3><p>介质故障又称硬故障,指外存故障</p>
<ul>
<li>介质故障破坏部分或整个数据库,并影响正在存取这部分数据 的所有事务</li>
<li>介质故障发生的可能性较低,但破坏性很大</li>
</ul>
<p>恢复策略: 重装数据库备份文件</p>
<h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><p>计算机病毒是一种人为的破坏,可以繁殖和传播,造成对计算机系统的危害</p>
<p>数据库一旦被破坏仍要用恢复技术把数据库加以恢复 </p>
<h3 id="恢复的要点"><a href="#恢复的要点" class="headerlink" title="恢复的要点"></a>恢复的要点</h3><p>恢复操作的基本原理: 冗余</p>
<p>恢复的实现技术是复杂的,代码占数据库全部代码的10%以上</p>
<h2 id="10-4-恢复的实现技术"><a href="#10-4-恢复的实现技术" class="headerlink" title="10.4 恢复的实现技术"></a>10.4 恢复的实现技术</h2><h3 id="数据转储"><a href="#数据转储" class="headerlink" title="数据转储"></a>数据转储</h3><p>转储: 数据库管理员定期地将整个数据库复制到磁带,磁盘或其他存储介质上保存起来的过程</p>
<p>备用的数据文本称为后备副本backup或后援副本</p>
<blockquote>
<ul>
<li>被破坏后,数据库可以将后备副本重新装入</li>
<li>后备副本只能将数据库恢复到转储时的状态,后续还需要运行自转储后的所有更新事务</li>
</ul>
</blockquote>
<h4 id="静态转储"><a href="#静态转储" class="headerlink" title="静态转储"></a>静态转储</h4><blockquote>
<ul>
<li>在系统中无运行事务时进行转储操作</li>
<li>转储开始时数据库处于一致性状态</li>
<li>转储期间不允许对数据库进行任何存取,修改活动</li>
</ul>
</blockquote>
<p>优点: 简单,恢复速度较快</p>
<p>缺点: 降低了数据库的可用性</p>
<h4 id="动态转储"><a href="#动态转储" class="headerlink" title="动态转储"></a>动态转储</h4><blockquote>
<ul>
<li>转储操作与用户事务并发进行</li>
<li>转储期间允许对数据库进行存取或修改</li>
<li>动态转储得到的是数据库的一个中间状态,非一致性状态</li>
</ul>
</blockquote>
<p>优点: 不用等待正在允许的用户事务结束; 不会影响新事务的运行</p>
<p>缺点: 不能保证副本中的数据有效</p>
<p>动态转储的故障恢复:</p>
<blockquote>
<ul>
<li>动态转储时: 建立日志文件,对动态转储期间各事务对数据库的修改活动登记</li>
<li>后备副本加上日志文件可以把数据库恢复到某一时刻的正确状态</li>
</ul>
</blockquote>
<h4 id="海量转储"><a href="#海量转储" class="headerlink" title="海量转储"></a>海量转储</h4><p>每次转储全部数据库</p>
<p>特点: 恢复更方便</p>
<h4 id="增量转储"><a href="#增量转储" class="headerlink" title="增量转储"></a>增量转储</h4><p>只转储上次转储后更新过的数据</p>
<p>特点: 适合庞大而且事务处理十分繁杂的数据库</p>
<h3 id="登记日志文件"><a href="#登记日志文件" class="headerlink" title="登记日志文件"></a>登记日志文件</h3><p>日志文件是用来记录事务对数据库的更新操作的文件</p>
<p>两种格式: 以记录为单位的日志和以数据块为单位的日志文件</p>
<h4 id="以记录为单位的日志文件"><a href="#以记录为单位的日志文件" class="headerlink" title="以记录为单位的日志文件"></a>以记录为单位的日志文件</h4><p>一个日志记录应包含(T表示事务标志):</p>
<blockquote>
<ul>
<li>各个事务的开始标记(T1 BEGIN TRANSACTION)</li>
<li>各事务的结束标记(T1 COMMIT/T2 ROLLBACK)</li>
<li>各事务的所有更新操作(包含事务标志,操作类型,操作对象,旧值和新值)</li>
</ul>
</blockquote>
<h4 id="以数据块为单位的日志文件"><a href="#以数据块为单位的日志文件" class="headerlink" title="以数据块为单位的日志文件"></a>以数据块为单位的日志文件</h4><p>包含内容:</p>
<blockquote>
<ul>
<li>事务标志</li>
<li>被更新的数据块</li>
</ul>
</blockquote>
<h4 id="日志文件作用"><a href="#日志文件作用" class="headerlink" title="日志文件作用"></a>日志文件作用</h4><p>用途:</p>
<blockquote>
<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
</blockquote>
<p>静态转储中也可以建立日志文件,利用日志文件重做已完成的事务并撤销未完成的事务; 而不用重新运行事务程序</p>
<p>日志文件登记原则:</p>
<blockquote>
<ul>
<li>等级的次序严格按照并发事务执行的时间次序</li>
<li>必须先写日志文件后写数据库(先记录修改操作后执行i修改)</li>
</ul>
</blockquote>
<h2 id="10-5-恢复策略"><a href="#10-5-恢复策略" class="headerlink" title="10.5 恢复策略"></a>10.5 恢复策略</h2><p>以记录为单位的日志文件格式为例</p>
<h3 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h3><p>事务故障: 事务在运行至正常终止点前被终止</p>
<p>策略: 由恢复子系统利用日志文件撤销该事务对数据库进行的修改</p>
<blockquote>
<p>此恢复过程不需要用户干预</p>
</blockquote>
<p>步骤:</p>
<blockquote>
<ol>
<li>反向扫描日志文件,查找该事务的更新操作</li>
<li>对该事务的更新操作执行逆操作,将更新前的值写入数据库</li>
<li>重复2.直到扫描到该事务的开始标记,事务故障恢复完成</li>
</ol>
</blockquote>
<h3 id="系统故障的恢复"><a href="#系统故障的恢复" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h3><p>系统故障对数据库的影响:</p>
<blockquote>
<ul>
<li>未完成事务的更新操作已经写入数据库</li>
<li>已完成事务的更新操作还留在缓冲区中未写入数据库</li>
</ul>
</blockquote>
<p>策略: 撤销故障发生时未完成的事务,重做已完成的事务</p>
<blockquote>
<p>此恢复过程不需要用户干预</p>
</blockquote>
<p>步骤:</p>
<blockquote>
<ol>
<li>正向扫描日志文件,生成已提交事务(有COMMIT记录)的重做队列和未完成事务(无COMMIT和ROLLBACK记录)的撤销队列</li>
<li>对撤销队列中的事务进行撤销操作,即反向扫描队列对更新操作执行逆操作</li>
<li>对重做队列中的事务进行重做操作,即正向扫描队列,将记录中更新后的值重新写入数据库</li>
</ol>
</blockquote>
<h3 id="介质故障的恢复"><a href="#介质故障的恢复" class="headerlink" title="介质故障的恢复"></a>介质故障的恢复</h3><p>策略: 重新装载数据库,重做已完成的数据库</p>
<p>步骤:</p>
<blockquote>
<ol>
<li>装入最新的后备副本(装入转储时刻的日志文件副本),使得数据库恢复到最近一次转储时的一致性状态</li>
<li>装入转储结束时刻的日志文件副本,重做到故障发生之前所有已完成的事务</li>
</ol>
</blockquote>
<p>这需要数据库管理员介入,装载数据库副本和各日志文件副本,执行系统提供的恢复命令; 但具体的恢复操作仍由DBMS完成</p>
<h2 id="10-6-具有检查点的恢复技术"><a href="#10-6-具有检查点的恢复技术" class="headerlink" title="10.6 具有检查点的恢复技术"></a>10.6 具有检查点的恢复技术</h2><p>用于更好地解决系统故障</p>
<h3 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h3><ul>
<li>系统故障恢复时,扫描整个日志文件将耗费大量时间</li>
<li>重做事务时,会浪费大量时间</li>
</ul>
<p>具有检查点的恢复技术:</p>
<blockquote>
<ul>
<li>在日志文件中增加检查点记录(checkpoint)</li>
<li>增加重新开始文件</li>
<li>恢复子系统在登录日志文件期间动态地维护日志</li>
</ul>
</blockquote>
<p>使用检查点技术之后,恢复数据库时只需要从最近的检查点开始扫描日志并重做事务即可</p>
<h3 id="检查点技术"><a href="#检查点技术" class="headerlink" title="检查点技术"></a>检查点技术</h3><ul>
<li>检查点记录的内容<blockquote>
<ul>
<li>建立检查点时刻所有正在执行的事务清单</li>
<li>这些事务最近一个日志记录的地址<br>这样,可以保证检查点之前的所有事务已经被提交并写入数据库,恢复时不需重做这些事务</li>
</ul>
</blockquote>
</li>
<li>重新开始文件的内容<blockquote>
<p>记录各个检查点记录在日志文件中的地址</p>
</blockquote>
</li>
<li>动态维护日志文件的方法: 周期性建立检查点,保存数据库的状态<blockquote>
<ol>
<li>将当前缓冲区内的日志记录写入到磁盘的日志文件上</li>
<li>在日志文件中写入一个检查点记录</li>
<li>将当前缓冲区内的所有数据记录写入四篇的数据库中</li>
<li>把检查点记录在日志文件中的地址写入一个重新开始文件</li>
</ol>
</blockquote>
</li>
</ul>
<p>检查点的建立可以是定期或不定期的</p>
<h3 id="检查点的恢复策略"><a href="#检查点的恢复策略" class="headerlink" title="检查点的恢复策略"></a>检查点的恢复策略</h3><p>事务的T执行策略:</p>
<blockquote>
<ul>
<li>无需操作: T在检查点之前完成</li>
<li>重做: T在系统故障前完成,但在检查点建立时并未完成</li>
<li>撤销: T在系统故障时未完成</li>
</ul>
</blockquote>
<p>恢复步骤:</p>
<blockquote>
<ol>
<li>通过重新开始文件找到最后一个检查点记录</li>
<li>通过该检查点记录得到当前执行的事务清单ACTIVATE-LIST,并将它们全部放入撤销队列</li>
<li>从检查点开始正向扫描日志文件,遇到事务开始则先将其放入撤销队列,遇到事务结束则将其从撤销队列移入重做队列,直到日志结束</li>
<li>对重做队列中的每个事务执行重做操作,对撤销队列中的每个事务执行撤销操作</li>
</ol>
</blockquote>
<h2 id="10-7-数据库镜像"><a href="#10-7-数据库镜像" class="headerlink" title="10.7 数据库镜像"></a>10.7 数据库镜像</h2><p>用于更好地解决介质故障</p>
<p>问题: 介质故障恢复比较费时,DBA需要周期性地转储数据库</p>
<p>解决策略: 数据库镜像(Mirror)</p>
<p>数据库镜像:</p>
<blockquote>
<ul>
<li>DBMS自动把整个数据库或其中的关键数据复制到另一个磁盘上</li>
<li>DBMS自动保证镜像数据与主数据的一致性; DBMS自动将更新后的数据复制到镜像上</li>
</ul>
</blockquote>
<p>用途:</p>
<blockquote>
<ul>
<li>出现介质故障时可由镜像磁盘继续提供数据库服务,并对故障磁盘进行数据恢复,不需要关闭系统或重装数据库副本</li>
<li>未出现故障时可由用于提高并发操作的效率</li>
</ul>
</blockquote>
<p>问题: 频繁地复制数据会降低DBMS的运行效率,实际使用中往往只会对关键数据和日志文件进行镜像</p>
<h1 id="十一、并发控制"><a href="#十一、并发控制" class="headerlink" title="十一、并发控制"></a>十一、并发控制</h1><h2 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h2><p>数据库是多用户数据库系统,在同一时刻并发运行的事务数可达数百上千个</p>
<ul>
<li><p>多事务串行执行不能充分利用系统资源，发挥数据库共 享资源的特点</p>
</li>
<li><p>交叉并发:  事务的并行执行是这些并行事务的并行操作轮流交叉运行,这可以提高系统效率,但并不是真正的并行运行</p>
</li>
<li><p>同时并发: 多处理机系统中每个处理机可以运行一个事务,实现多个事务真正并行运行; 这是效率最高的并发方式,但复杂并受制于硬件环境</p>
</li>
</ul>
<p>本章讨论的数据库系统并发控制技术是以单处理机系统为基础的 </p>
<h3 id="并发带来的问题"><a href="#并发带来的问题" class="headerlink" title="并发带来的问题"></a>并发带来的问题</h3><blockquote>
<ul>
<li>多个事务同时存取同一时间</li>
<li>这会导致存取和存储不正确的数据,破坏事务隔离性和数据库一致性</li>
</ul>
</blockquote>
<p>数据库管理系统必须提供并发控制机制<br>并发控制机制是衡量一个数据库管理系统性能的重要标志之一 </p>
<p>并发操作带来的数据不一致性:</p>
<blockquote>
<ul>
<li>丢失修改: 当前修改被其他事务覆盖</li>
<li>不可重复读: 读取数据后该数据被其他事务修改(删除,插入:幻影现象)</li>
<li>读”脏”数据: 之前读取的(错误)数据被撤销</li>
</ul>
</blockquote>
<p>对数据库的应用有时允许某些不一致性，可以降低对一致 性的要求以减少系统开销 </p>
<h3 id="并发控制主要技术"><a href="#并发控制主要技术" class="headerlink" title="并发控制主要技术"></a>并发控制主要技术</h3><blockquote>
<ul>
<li>封锁</li>
<li>时间戳</li>
<li>乐观控制法</li>
<li>多版本并发控制</li>
</ul>
</blockquote>
<h2 id="11-2-封锁"><a href="#11-2-封锁" class="headerlink" title="11.2 封锁"></a>11.2 封锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>封锁: 事务T对某个数据对象操作之前,先向系统发出请求对其加锁,使该事务对此数据对象有了一定的控制; 在该锁被释放之前,其他事务不能更新此数据对象</p>
<blockquote>
<p>封锁是实现并发控制的一个重要的技术</p>
</blockquote>
<p>类型:</p>
<blockquote>
<ul>
<li>排他锁(X锁)</li>
<li>共享锁(S锁)</li>
</ul>
</blockquote>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><ul>
<li><p>该事务可以读取和修改被加锁对象</p>
</li>
<li><p>直到该事务释放锁之前,其他任何事物都不能再对该对象加任何类型的锁</p>
</li>
</ul>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><ul>
<li><p>该事务只能读取被加锁对象</p>
</li>
<li><p>其他事务只能再对该对象加共享锁而不能加排他锁,保证其他事务也能读取该对象</p>
</li>
</ul>
<h3 id="锁的相容矩阵"><a href="#锁的相容矩阵" class="headerlink" title="锁的相容矩阵"></a>锁的相容矩阵</h3><table>
<thead>
<tr>
<th align="center">T1\T2</th>
<th align="center">X</th>
<th align="center">S</th>
<th align="center">-</th>
</tr>
</thead>
<tbody><tr>
<td align="center">X</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
</tbody></table>
<h2 id="11-3-封锁协议"><a href="#11-3-封锁协议" class="headerlink" title="11.3 封锁协议"></a>11.3 封锁协议</h2><p>封锁协议: 运用锁对数据对象加锁时的一些规则</p>
<blockquote>
<ul>
<li>何时申请X锁或S锁</li>
<li>持锁时间</li>
<li>何时释放</li>
</ul>
</blockquote>
<p>不同封锁协议可以在不同程度上保证并发操作的正确调度</p>
<h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><blockquote>
<ul>
<li>事务T在修改R数据前必须先对其加X锁,直到事务结束(提交或回滚)才释放</li>
</ul>
</blockquote>
<blockquote>
<p>该协议可以防止修改丢失,保证T是可恢复的</p>
</blockquote>
<p>一级封锁协议无法保证读脏数据</p>
<h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><blockquote>
<ul>
<li>事务T在修改R数据前必须先对其加X锁,直到事务结束(提交或回滚)才释放</li>
<li>事务T在读取R数据之前必须先对其加S锁,读完之后即可释放S锁<br>该协议可以防止丢失修改和读脏数据</li>
</ul>
</blockquote>
<p>二级封锁协议不能保证可重复读</p>
<h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><blockquote>
<ul>
<li>事务T在修改R数据前必须先对其加X锁,直到事务结束(提交或回滚)才释放</li>
<li>事务T在读取R数据之前必须先对其加S锁,直到事务结束才释放<br>三级封锁协议可防止丢失修改、读脏数据和不可重复读</li>
</ul>
</blockquote>
<h2 id="11-4-活锁和死锁"><a href="#11-4-活锁和死锁" class="headerlink" title="11.4 活锁和死锁"></a>11.4 活锁和死锁</h2><p>封锁技术带来的问题: 活锁和死锁</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>系统先行批准后请求的(一批)事务对数据加锁,导致前面的事务无法获得封锁而一直处于等待状态</p>
<p>解决策略: 采用先来先服务策略</p>
<blockquote>
<ul>
<li>当多个事务请求封锁同一数据对象时</li>
<li>按请求封锁的先后次序对这些事务进行排队</li>
<li>该数据对象上的锁一旦被释放,首先批准队列中第一个事务获得该锁</li>
</ul>
</blockquote>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>两个或多个事务都已封锁一些数据对象未释放时,又请求访问被对方锁住的数据对象,导致这些事务同时进入无限等待的状态</p>
<p>解决策略:</p>
<ol>
<li>预防死锁: 代价较高<blockquote>
<p>一次封锁法: </p>
<ul>
<li>每个事务必须一次将所有要使用的数据全部加锁,否则不能执行</li>
<li>这样过早加锁,降低系统并发度; 且实际情况下难以精确缺点封锁对象</li>
</ul>
<p>顺序封锁法:</p>
<ul>
<li>预先对数据对象规定一个封锁顺序,所有事物都按这个顺序实行封锁</li>
<li>数据库中的对象多且动态变化,维护这样一个顺序成本很高; 实际情况下封锁请求可以随着事物的执行动态缺点,实现难度大</li>
</ul>
</blockquote>
</li>
<li>诊断和解除死锁:<blockquote>
<p>超时法:</p>
<ul>
<li>如果一个事物等待时间超过了规定的时限,就认为发生了死锁</li>
<li>实现简单,但有可能误判死锁,且需要等待长时间才能发现死锁<br>等待图法:</li>
<li>若T2请求数据时发现它被T1锁住,则称T2等待T1,由节点T2画一条有向边指向T1</li>
<li>并发控制子系统周期性地生成事务等待图,若发现整个有向图中出现了回路,则表示系统中出现了死锁</li>
<li>解除死锁: 选择一个处理死锁代价最小的事务,将其撤销,释放其持有的锁</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="11-5-并发调度的可串行性"><a href="#11-5-并发调度的可串行性" class="headerlink" title="11.5 并发调度的可串行性"></a>11.5 并发调度的可串行性</h2><p>DBMS对并发事务的不同的调度可能会产生不同的结果</p>
<blockquote>
<ul>
<li>串行调度是正确的</li>
<li>执行结果等价于串行调度也的调度是正确的,称为可串行化调度</li>
</ul>
</blockquote>
<h3 id="可串行化调度"><a href="#可串行化调度" class="headerlink" title="可串行化调度"></a>可串行化调度</h3><p>多个事务并发执行是正确的,当且仅当其执行结果与按某一次序串行执行这些植物时的结果相同</p>
<blockquote>
<ul>
<li>可串行性时并发事务正确调度的准则</li>
<li>一个给定的并发调度,当且仅当它是可串行化的,才认为是正确的调度</li>
</ul>
</blockquote>
<p>如何判断一个调度是可串行化调度是个问题</p>
<h3 id="冲突可串行化的调度"><a href="#冲突可串行化的调度" class="headerlink" title="冲突可串行化的调度"></a>冲突可串行化的调度</h3><p>冲突可串行化比可串行化更严格,它是可串行化的充分条件</p>
<p>冲突操作: 不同事务对同一数据的读写操作和写写操作; 即两个操作涉及同一个数据库元素,且至少有一个为写操作</p>
<p>定义: 不能交换的动作</p>
<blockquote>
<ul>
<li>同一事务的两个操作</li>
<li>不同事务的冲突操作</li>
</ul>
</blockquote>
<p>冲突可串行化的调度: 一个调度S在保证冲突操作次序不变的情况下,通过交换<strong>两个</strong>事务的不冲突操作的次序得到了一个串行调度S’,则S为冲突可串行化的调度</p>
<h2 id="11-6-两段锁协议"><a href="#11-6-两段锁协议" class="headerlink" title="11.6 两段锁协议"></a>11.6 两段锁协议</h2><p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性,从而保证调度的正确性</p>
<p>两段锁协议: 所有事物必须分两个阶段对数据项加锁和解锁</p>
<blockquote>
<ul>
<li>扩展阶段: 在对任何数据进行读写操作之前,事务首先要获得对该数据的封锁; 此时事务不能释放任何锁</li>
<li>收缩阶段: 在释放一个封锁之后,事务不在申请和获得任何其他的封锁; 此时事务可以释放锁,但不能再获得任何锁</li>
</ul>
</blockquote>
<p>若一组并发事务都遵守两段锁协议,则这些事务的任何并发调度策略都是可串行化的; 事务遵守两段锁协议是可串行化的充分条件</p>
<p>注意: </p>
<blockquote>
<ul>
<li>两段锁协议遵守三级封锁协议,反之不然</li>
<li>一次封锁法遵守两段锁协议,但两者不同,两段锁协议不能防止事务死锁</li>
</ul>
</blockquote>
<h2 id="11-7-封锁的粒度"><a href="#11-7-封锁的粒度" class="headerlink" title="11.7 封锁的粒度"></a>11.7 封锁的粒度</h2><p>封锁的对象可以是逻辑单元(属性组等)也可以是物理单元(数据页等),封锁对象的大小称为封锁粒度</p>
<p>封锁粒度越大,系统开销越小,但并发度也越小; 反之亦然</p>
<p>多粒度封锁: 在一个系统中同时支持多种封锁粒度供不同的事务选择 </p>
<h3 id="多粒度封锁"><a href="#多粒度封锁" class="headerlink" title="多粒度封锁"></a>多粒度封锁</h3><p>多粒度树:</p>
<blockquote>
<ul>
<li>以树形结构来表示多级封锁粒度</li>
<li>根结点是整个数据库,表示最大的数据粒度</li>
<li>叶节点表示最小的数据粒度<br><img src="/2020/05/24/data-base1/tree0.jpg" alt="tree"></li>
</ul>
</blockquote>
<p>多粒度封锁协议允许多粒度树种每个节点被独立加锁</p>
<blockquote>
<ul>
<li>对一个节点加锁意味着这个节点下的所有子节点也被加以同样的锁</li>
<li>显式封锁: 直接加到数据对象上的锁</li>
<li>隐式封锁: 该数据对象由于其上级节点被加锁而使得它本身也被加锁</li>
<li>从效果上看,显式封锁和隐式封锁是一样的</li>
</ul>
</blockquote>
<p>锁的冲突检查: 对某个数据对象加锁时,系统要检查</p>
<blockquote>
<ul>
<li>该数据对象上有无显式封锁与之冲突</li>
<li>该对象所有上级节点,有无上级节点的显式封锁造成的该对象的隐式封锁与之冲突</li>
<li>该对象所有下级节点,有无下级节点的显示封锁与该对象封锁对其造成的隐式封锁冲突</li>
</ul>
</blockquote>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>意向锁的引入能提高对某个数据对象加锁时系统的检查效率</p>
<blockquote>
<ul>
<li>如果一个节点被加意向锁,说明该节点的某个下层节点正在被加锁</li>
<li>对任一节点加基本锁,必须先对它的上层节点加意向锁</li>
</ul>
</blockquote>
<p>类型:</p>
<blockquote>
<ul>
<li>意向共享(IS)锁</li>
<li>意向排他(IX)锁</li>
<li>共享意向排他锁(SIX)锁</li>
</ul>
<p>其中,SIX锁表示某一个事务要访问某一数据节点,并且更新它的后代节点; 该节点的上层节点被加IS和IX锁; 该节点被先加S锁后加IX锁(合在一起就是SIX锁); 该节点的某个后代节点被加X锁</p>
</blockquote>
<p>数据锁的相容矩阵:<br><img src="/2020/05/24/data-base1/matrix0.jpg" alt="matrix"></p>
<p>锁的强度:  </p>
<blockquote>
<ul>
<li>锁的强度是指它对其他锁的排斥程度</li>
<li>一个事务再申请封锁时,以强锁代替弱锁是安全的,反之不然</li>
</ul>
</blockquote>
<p><img src="/2020/05/24/data-base1/lock0.jpg" alt="lock"></p>
<p>具有意向锁的多粒度封锁方法:</p>
<blockquote>
<ul>
<li>申请封锁时应按照自上而下的次序进行</li>
<li>释放封锁时应按照自下而上的次序进行</li>
</ul>
</blockquote>
<p>优点:</p>
<blockquote>
<ul>
<li>提高了系统的并发度</li>
<li>减少了加锁和解锁的开销</li>
<li>实际应用广泛</li>
</ul>
</blockquote>
<hr>
<p>简明的数据库使用笔记可参考<a href="http://georgechen.top/2020/04/11/mysql0/" target="_blank" rel="noopener">http://georgechen.top/2020/04/11/mysql0/</a></p>
<p>博文创建时间: 2020-04-16 14:06:44</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理与设计(基础篇)</title>
    <url>/2020/05/24/data-base0/</url>
    <content><![CDATA[<p><del>未完结,持续更新</del> 完结</p>
<hr>
<p>任课教师: 赵朋朋<a href="http://web.suda.edu.cn/ppzhao/" target="_blank" rel="noopener">http://web.suda.edu.cn/ppzhao/</a></p>
<p>网课资源: 慕课中国人民大学数据库系统概论<a href="https://www.icourse163.org/course/RUC-488001" target="_blank" rel="noopener">https://www.icourse163.org/course/RUC-488001</a></p>
<p>参考教材: 高等教育出版社《数据库系统概论(第5版)》</p>
<p>课程主要讲述关系型数据库的原理, 不着重于具体数据库的使用</p>
<p>简明的数据库使用笔记可参考<a href="http://georgechen.top/2020/04/11/mysql0/" target="_blank" rel="noopener">http://georgechen.top/2020/04/11/mysql0/</a></p>
<p>后续见数据库原理与设计(高级篇)<a href="http://georgechen.top/2020/04/16/data-base1/" target="_blank" rel="noopener">http://georgechen.top/2020/04/16/data-base1/</a></p>
<a id="more"></a>

<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a>1.1 数据库系统概述</h2><h3 id="数据库中的基本概念"><a href="#数据库中的基本概念" class="headerlink" title="数据库中的基本概念"></a>数据库中的基本概念</h3><ul>
<li>数据(data): 是数据库中存储的基本对象; 是描述事物的符号记录,包括数字、文字等不同种类 </li>
</ul>
<blockquote>
<p>数据是有语义的:相同的数据形式可能有不同的含义,数据与语义是不可分的<br>数据是有结构的:记录是计算机存储数据的一种格式或方法</p>
</blockquote>
<ul>
<li>数据库(database): 是长期存储在计算机内,有组织,可共享的大量数据的集合</li>
</ul>
<blockquote>
<p>数据库能够收集并抽取应用的数据将其保存,用后续处理<br>数据库的基本特征:  </p>
<ol>
<li>数据按一定的数据模型组织,描述和存储</li>
<li>可为各种用户共享,冗余度较小,易扩展</li>
<li>数据独立性较高</li>
</ol>
</blockquote>
<ul>
<li>数据库管理系统(DBMS): 是位于用户应用与操作系统之间的一层数据管理软件,是一个大型复杂的软件系统</li>
</ul>
<blockquote>
<p>用途: 能科学地组织和存储数据,高效的获取和维护数据<br>功能: </p>
<ol>
<li>数据定义功能:提供数据定义语言,定义数据库中的数据对象</li>
<li>数据组织存储和管理功能</li>
<li>数据操纵功能:提供数据操纵语言,实现对数据库增删改查</li>
<li>数据库的事务和并发管理和运行管理功能:保证数据安全完整,故障恢复</li>
<li>数据库建立和维护功能:提供实用程序和工具</li>
<li>其它功能:通信,数据转换等</li>
</ol>
</blockquote>
<ul>
<li>数据库系统(DBS): 在计算机系统中引入数据库后的系统构成, 也可简称为数据库</li>
</ul>
<blockquote>
<p>数据库系统构成: 数据库, 数据库管理系统(及其应用开发工具), 应用程序, 数据库管理员(DBA)</p>
</blockquote>
<h3 id="数据库管理技术"><a href="#数据库管理技术" class="headerlink" title="数据库管理技术"></a>数据库管理技术</h3><p>数据管理: 对数据进行分类,组织,编码,存储,检索和维护<br>数据管理是数据处理和数据分析的中心问题</p>
<p>发展: 人工管理-&gt;文件系统管理-&gt;数据库系统管理<br><img src="/2020/05/24/data-base0/diff0.png" alt="diff"></p>
<blockquote>
<ul>
<li>人工管理阶段, 应用程序和数据集是一一对应的</li>
<li>文件系统阶段, 存取方法是共享的, 但应用程序和数据集是一一对应的</li>
<li>数据库系统阶段, 多个应用程序通过同一个数据库管理系统对同一个数据库进行操作</li>
</ul>
</blockquote>
<h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><ul>
<li>数据结构化</li>
<li>数据的共享性高,冗余度低且易扩充</li>
<li>数据独立性高:有物理独立性和逻辑独立性</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ul>
<h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2  数据模型"></a>1.2  数据模型</h2><p>数据模型是对现实世界数据特征的抽象,是对现实世界的模拟</p>
<p>数据模型应满足三方面要求</p>
<blockquote>
<ul>
<li>能比较真实地模拟现实世界</li>
<li>容易为人所理解</li>
<li>便于在计算机上实现  </li>
</ul>
</blockquote>
<p>数据模型是数据库系统的核心和基础 </p>
<h3 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h3><p>数据模型分为两类(两个不同层次):  </p>
<ul>
<li>概念模型，也称信息模型 : 它是按用户的观点来对数据和信息建模，用于数据库设计  </li>
<li>逻辑模型和物理模型 <blockquote>
<ul>
<li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等</li>
<li>逻辑模型是按计算机系统的观点对数据建模，用于DBMS实现</li>
<li>物理模型是对数据最底层的抽象, 是描述数据在系统内（磁盘上）的表示方式和存取方法</li>
</ul>
</blockquote>
</li>
</ul>
<p>现实世界中客观对象的抽象过程:<br><img src="/2020/05/24/data-base0/proc0.png" alt="proc"></p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ul>
<li>概念模型用于信息世界的建模 </li>
<li>是现实世界到机器世界的一个中间层次</li>
<li>是数据库设计的有力工具</li>
<li>数据库设计人员和用户之间进行交流的语言 </li>
</ul>
<p>概念模型的特点:  </p>
<blockquote>
<ul>
<li>较强的语义表达能力</li>
<li>简单、清晰、易于用户理解 </li>
</ul>
</blockquote>
<p>信息世界中的基本概念: </p>
<blockquote>
<ul>
<li>实体（Entity）: 客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。</li>
<li>属性（Attribute）: 实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。</li>
<li>码（Key）: 唯一标识实体的属性集称为码。</li>
<li>实体型（Entity Type）: 用实体名及其属性名集合来抽象和刻画同类实体称为实体型(对象)</li>
<li>实体集（Entity Set）: 同一类型实体的集合称为实体集 </li>
<li>联系（Relationship）: 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。<ul>
<li>实体内部的联系: 是指组成实体的各属性之间的联系 </li>
<li>实体之间的联系: 通常是指不同实体集之间的联系, 实体之间的联系有一对一（1:1）、一对多（1:n）和多对多（m:n）等多种类型 </li>
</ul>
</li>
</ul>
</blockquote>
<p>实体-联系方法（Entity-Relationship Approach）是概念模型的一种表示方法:</p>
<blockquote>
<ul>
<li>用E-R图来描述现实世界的概念模型 </li>
<li>E-R方法也称为E-R模型<br><img src="/2020/05/24/data-base0/rela0.png" alt="relation">  </li>
</ul>
</blockquote>
<p>(具体方法在数据库设计中会讲到)</p>
<h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><p>数据模型是严格定义的一组概念的集合</p>
<ul>
<li>它精确地描述了系统的静态特性、动态特性和完整性约束条件 (Integrity Constraints)。</li>
</ul>
<p>数据模型由三部分组成</p>
<blockquote>
<ul>
<li>数据结构–描述系统的静态特性 </li>
<li>数据操作–描述系统的动态特性 </li>
<li>完整性约束条件</li>
</ul>
</blockquote>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>数据结构是刻画数据模型性质的重要方面  </p>
<blockquote>
<ul>
<li>一般用数据结构的类型来命名数据模型,如: 层次结构-层次模型、网状结构–网状模型、关系结构—关系模型 </li>
</ul>
</blockquote>
</li>
<li><p>数据结构是用来描述数据库的组成对象–对象的类型、内容、性质</p>
</li>
<li><p>数据结构可以用来描述对象之间的联系 </p>
</li>
</ul>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>数据操作是对数据库中各种对象的实例允许执行的操作的集合，包括操作的类型及有关的操作规则</p>
<p>操作的类型: 增删改查</p>
<p>数据操作语言: </p>
<blockquote>
<ul>
<li>数据操作语言需要定义数据操作的确切含义、符号、优先级别</li>
<li>数据操作语言需要实现查询语言(Query Language)和更新语言(Insert、Delete、Update) </li>
</ul>
</blockquote>
<h4 id="数据完整性约束条件"><a href="#数据完整性约束条件" class="headerlink" title="数据完整性约束条件"></a>数据完整性约束条件</h4><p>数据完整性约束条件是一组完整性规则的集合</p>
<blockquote>
<ul>
<li>完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则</li>
<li>完整性规则可以限定符合数据模型的数据库状态以及状态的变化，以保证数 据的正确、有效和相容。</li>
</ul>
</blockquote>
<p>数据模型对完整性约束条件的定义:</p>
<blockquote>
<ul>
<li>反映和规定必须遵守的基本的通用的完整性约束条件</li>
<li>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</li>
</ul>
</blockquote>
<h3 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h3><ul>
<li>格式化模型: 层次模型,网状模型 </li>
<li>关系模型</li>
<li>对象模型: 面向对象数据模型,对象关系数据模型</li>
<li>半结构化数据模型:XML,HTML</li>
<li>非结构化数据模型,图模型,…</li>
</ul>
<h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>层次模型用树形结构来表示各类实体以及实体间的联系</p>
<p>表示方法：</p>
<blockquote>
<ul>
<li>实体型：用纪录类描述，每个节点表示一个记录类型</li>
<li>属性：用字段描述，每个记录类型可包含若干个字段</li>
<li>联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系</li>
</ul>
</blockquote>
<p>特点:</p>
<blockquote>
<ul>
<li>结点的双亲是唯一的</li>
<li>只能直接处理一对多的实体联系</li>
<li>任何记录值只有按其路径查看</li>
<li>没有一个子女记录值能够脱离双亲记录值而独立存在 </li>
</ul>
</blockquote>
<p>优缺点:</p>
<blockquote>
<ul>
<li>(优点)层次模型的数据结构比较简单清晰</li>
<li>查询效率高，性能优于关系模型，不低于网状模型</li>
<li>层次数据模型提供了良好的完整性支持</li>
<li>(缺点)结点之间的多对多联系表示不自然</li>
<li>对插入和删除操作的限制多，应用程序的编写比较复杂</li>
<li>查询子女结点必须通过双亲结点</li>
<li>层次数据库的命令（语言）趋于程序化  </li>
</ul>
</blockquote>
<h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><p>网状数据库系统采用网状结构来表示各类实体以及实体间的联系(有向图)</p>
<p>网状模型表示方法和层次模型相同</p>
<p>特点:</p>
<blockquote>
<ul>
<li>允许多个结点没有双亲结点</li>
<li>允许一个结点有多个双亲结点</li>
<li>允许两个结点之间有多种联系</li>
<li>要为每个联系命名并指出与该联系有关的双亲记录和子女记录 </li>
</ul>
</blockquote>
<p>优缺点:</p>
<blockquote>
<ul>
<li>(优点)能够更为直接地描述现实世界，如一个结点可以有多个双亲</li>
<li>具有良好的性能，存取效率较高</li>
<li>(缺点)结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握</li>
<li>DDL、DML语言复杂，用户不容易使用</li>
<li>记录之间联系是通过存取路径实现的，应用程序必须选择存取路径，加重了程序员的负担</li>
</ul>
</blockquote>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表,如下<br><img src="/2020/05/24/data-base0/table0.png" alt="relation">  </p>
<p>其中:</p>
<blockquote>
<ul>
<li>关系: 一个关系对应通常来说的一张表</li>
<li>元组: 表中的一行即为一个元组</li>
<li>属性: 表中的一列即为一个属性, 每一个属性都会有一个属性名</li>
<li>主码(key): 也称码键, 是可以唯一确定一个元组的属性组</li>
<li>域(domain): 是一组具有相同数据类型的值的集合, 是属性的取值范围</li>
<li>分量: 元组中的一个属性值</li>
<li>关系模式: 对关系的描述</li>
</ul>
</blockquote>
<p>注意: 关系模型中的关系必须是规范化的, 关系中的每一个分量必须是不可分的数据项, 即不允许表中套表(这个表应该是个纯粹的二维数组)</p>
<p>优点:</p>
<blockquote>
<ul>
<li>建立在严格的数学概念的基础上</li>
<li>概念单一<ul>
<li>实体和各类联系都用关系来表示 </li>
<li>对数据的检索结果也是关系 </li>
</ul>
</li>
<li>关系模型的存取路径对用户透明(用户感受不到路径)<ul>
<li>具有更高的数据独立性，更好的安全保密性 </li>
<li>简化了程序员的工作和数据库开发建立的工作 </li>
</ul>
</li>
</ul>
</blockquote>
<p>缺点:</p>
<blockquote>
<ul>
<li>存取路径对用户透明，查询效率往往不如格式化数据模型</li>
<li>为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度</li>
</ul>
</blockquote>
<h2 id="1-3-数据库系统的结构"><a href="#1-3-数据库系统的结构" class="headerlink" title="1.3 数据库系统的结构"></a>1.3 数据库系统的结构</h2><p>从数据库应用开发人员角度看：</p>
<blockquote>
<ul>
<li>数据库系统采用三级模式结构，是数据库系统内部的系统结构</li>
</ul>
</blockquote>
<p>从数据库最终用户角度看，数据库系统的结构有：</p>
<blockquote>
<ul>
<li>单用户结构</li>
<li>主从式结构</li>
<li>分布式结构</li>
<li>客户-服务器</li>
<li>浏览器-应用服务器／数据库服务器等</li>
</ul>
</blockquote>
<h3 id="关于模式的一些概念"><a href="#关于模式的一些概念" class="headerlink" title="关于模式的一些概念"></a>关于模式的一些概念</h3><p>模式:</p>
<blockquote>
<ul>
<li>是对数据库逻辑结构和特征的描述</li>
<li>是型的描述,不涉及具体值</li>
<li>模式是相对稳定的</li>
</ul>
</blockquote>
<p>实例</p>
<blockquote>
<ul>
<li>数据库某一时刻的状态: 模式的一个具体值</li>
<li>同一个模式可以有很多实例</li>
<li>实例随数据库中的数据的更新而变动</li>
</ul>
</blockquote>
<h3 id="三级模式结构"><a href="#三级模式结构" class="headerlink" title="三级模式结构"></a>三级模式结构</h3><p><img src="/2020/05/24/data-base0/pattern0.png" alt="pattern"></p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>模式(逻辑模式)</p>
<blockquote>
<ul>
<li>是数据库中全体数据的逻辑结构和特征描述 </li>
<li>是所有用户的公共数据视图<br>一般,某个应用的数据库有一个模式  </li>
</ul>
</blockquote>
<p>模式是数据库系统模式结构的中心:</p>
<blockquote>
<ul>
<li>与数据的物理存储细节和硬件环境无关</li>
<li>与具体的应用程序、开发工具及高级程序设计语言无关 </li>
</ul>
</blockquote>
<p>定义模式</p>
<blockquote>
<ul>
<li>DDL定义数据的逻辑结构，以某种数据模型为基础</li>
<li>数据记录由哪些数据项构成，数据项的名字、类型、取值范围等</li>
<li>定义数据之间的联系</li>
<li>定义与数据有关的安全性、完整性要求</li>
</ul>
</blockquote>
<h4 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h4><p>外模式（也称子模式或用户模式）</p>
<blockquote>
<ul>
<li>数据库用户使用的局部数据的逻辑结构和特征的描述</li>
<li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 </li>
</ul>
</blockquote>
<p>外模式与模式的关系</p>
<blockquote>
<ul>
<li>外模式通常是模式的子集、一个模式可以有多个外模式</li>
<li>反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li>
<li>对模式中某一数据，在不同的外模式中 结构、类型、长度、保密级别等都可以不同 </li>
</ul>
</blockquote>
<p>外模式与应用的关系</p>
<blockquote>
<ul>
<li>一个外模式可以为 多个应用系统所使用，一个应用程序只能使用一个外模式 </li>
</ul>
</blockquote>
<p>外模式的用途</p>
<blockquote>
<ul>
<li>每个用户只能看见和访问所对应的外模式中的数据，简化用户视图</li>
<li>保证数据库安全性的一个有力措施</li>
</ul>
</blockquote>
<h4 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h4><p>内模式（也称存储模式）</p>
<blockquote>
<ul>
<li>是数据物理结构和存储方式的描述</li>
<li>是数据在数据库内部的表示方式<ul>
<li>记录的存储方式 （例如，顺序存储，堆存储，Cluste按hash方法存储等）</li>
<li>索引的组织方式（B+树，Bitmap，Hash）</li>
<li>数据是否压缩存储</li>
<li>数据是否加密</li>
<li>数据存储记录结构的规定—如定长/变长，记录是否可以跨页存放等 </li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>一个数据库只有一个内模式</li>
</ul>
<h3 id="二级映像"><a href="#二级映像" class="headerlink" title="二级映像"></a>二级映像</h3><p>三级模式实际上是对数据的三个抽象级别</p>
<p>数据库管理系统内部提供了二级映像</p>
<blockquote>
<ul>
<li>外模式/模式映像</li>
<li>模式/内模式映像</li>
</ul>
</blockquote>
<h4 id="外模式-模式映像"><a href="#外模式-模式映像" class="headerlink" title="外模式/模式映像"></a>外模式/模式映像</h4><p>对每一个外模式,有一个外模式/模式映像</p>
<blockquote>
<ul>
<li>它定义了外模式与模式之间的对应关系</li>
<li>映像定义通常包含在各外模式的描述中</li>
</ul>
</blockquote>
<p>这种映像可以保证数据(和程序)的逻辑独立性</p>
<blockquote>
<ul>
<li>当模式改变时，数据库管理员对外模式／模式映像作相应改变，使外模式保持不变</li>
<li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据 与程序的逻辑独立性，简称数据的逻辑独立性 </li>
</ul>
</blockquote>
<h4 id="模式-内模式映像"><a href="#模式-内模式映像" class="headerlink" title="模式/内模式映像"></a>模式/内模式映像</h4><p>模式/内模式映像定义了全局数据逻辑结构与存储结构之间的对应关系(如，说明某个逻辑记录对应何种存储结构)</p>
<p>数据库中模式/内模式映像是唯一的,该映像定义通常包含在模式的描述中</p>
<p>这种映像能保证数据的物理独立性</p>
<blockquote>
<ul>
<li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员 修改模式／内模式映象，使模式保持不变。</li>
<li>模式不变，则应用程序不变。保证了数据与程序的物理独立性，简称数据的 物理独立性。</li>
</ul>
</blockquote>
<h4 id="二级映像的功能与数据独立性"><a href="#二级映像的功能与数据独立性" class="headerlink" title="二级映像的功能与数据独立性"></a>二级映像的功能与数据独立性</h4><ul>
<li><p>保证了应用程序的稳定性</p>
<blockquote>
<ul>
<li>除非应用需求本身发生变化，否则应用程序一般不需要修改。</li>
</ul>
</blockquote>
</li>
<li><p>从程序为中心——发展为 以数据为中心</p>
<blockquote>
<ul>
<li>具有了数据与程序之间的独立性，使得数据的定义和描述可以从应用 程序中分离出去</li>
</ul>
</blockquote>
</li>
<li><p>数据的存取由数据库管理系统管理</p>
<blockquote>
<ul>
<li>简化了应用程序的编制</li>
<li>大大减少了应用程序的维护和修改  </li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="1-4-数据库系统的组成"><a href="#1-4-数据库系统的组成" class="headerlink" title="1.4 数据库系统的组成"></a>1.4 数据库系统的组成</h2><ul>
<li>数据库</li>
<li>数据库管理系统（及其开发工具）</li>
<li>应用程序</li>
<li>数据库管理员 </li>
</ul>
<h3 id="硬件平台及数据库"><a href="#硬件平台及数据库" class="headerlink" title="硬件平台及数据库"></a>硬件平台及数据库</h3><p>数据库对硬件资源的要求:</p>
<blockquote>
<ul>
<li>足够大的内存</li>
<li>足够大的磁盘(阵列)等外部设备</li>
<li>较高的通讯能力</li>
</ul>
</blockquote>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul>
<li>数据库管理系统</li>
<li>支持数据库管理系统运行的操作系统</li>
<li>与数据库接口的高级语言及其编译系统</li>
<li>以数据库管理系统为核心的应用开发工具</li>
<li>为特定应用环境开发的数据库应用系统</li>
</ul>
<h3 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h3><p>不同的人员涉及不同的数据抽象级别，具有不同的数据视图:</p>
<blockquote>
<ul>
<li>用户:应用程序客户端</li>
<li>应用程序员:外模式</li>
<li>数据库管理员,系统分析员:数据库,内模式,模式,外模式</li>
</ul>
</blockquote>
<h1 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h1><h2 id="2-1-关系模型"><a href="#2-1-关系模型" class="headerlink" title="2.1 关系模型"></a>2.1 关系模型</h2><h3 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><p>关系数据结构是单一的数据结构-关系</p>
<p>关系数据结构示意图如下:<br><img src="/2020/05/24/data-base0/relation0.png" alt="rela"></p>
<h4 id="域和笛卡尔积空间"><a href="#域和笛卡尔积空间" class="headerlink" title="域和笛卡尔积空间"></a>域和笛卡尔积空间</h4><ul>
<li><p>域:域是一组具有相同数据类型的值的集合,是属性的取值范围</p>
</li>
<li><p>域的笛卡尔积空间是一组域的笛卡尔积,是属性值组合的集合</p>
</li>
<li><p>笛卡尔积的基数是参与笛卡尔积中元素的个数</p>
</li>
<li><p>笛卡尔积可以表示为一张二维表,行对应集合中的每个元素,列对应每个属性的域</p>
</li>
</ul>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>关系是在笛卡尔积上的子集  </p>
<p>关系中的元素可以用元组表示,在二维表中由一行表示</p>
<ul>
<li>属性: 关系中不同列称为属性,每个属性有一个名字; n目关系有n个属性</li>
<li>码: 码是能唯一标识一个元组的属性(组)<blockquote>
<ul>
<li>候选码:关系中能唯一地标识一个元组的最小属性组，则称该属性组为候选码 </li>
<li>全码:关系模式的所有属性都是这个关系模式的候选码时,这个属性组称为全码（All-key）</li>
<li>主码:若一个关系有多个候选码，则选定其中一个为主码（Primary key）</li>
<li>主属性:候选码的诸属性称为主属性（Prime attribute）不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）  </li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>关系模式是对关系的描述<br>关系模式主要有元组集合的结构和完整性约束条件两方面构成</p>
<p>关系模式可以由一个五元组R(U,D,DOM,F)表示,其中:</p>
<blockquote>
<ul>
<li>R:关系名</li>
<li>U:属性名集合</li>
<li>D:各属性的域的集合</li>
<li>DOM:属性向域的映像集合(映射关系,指明哪个属性的域是哪个)</li>
<li>F:属性间数据依赖的关系集合</li>
</ul>
</blockquote>
<h3 id="关系完整性约束"><a href="#关系完整性约束" class="headerlink" title="关系完整性约束"></a>关系完整性约束</h3><ul>
<li><p>实体完整性和参照完整性: 关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持</p>
</li>
<li><p>用户定义的完整性: 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 </p>
</li>
</ul>
<p>关系完整性约束能够使得一些不符合条件的元组不能进入数据库</p>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><ul>
<li>关系的主属性不能取空值(码不能为空)</li>
</ul>
<p>说明: </p>
<blockquote>
<ul>
<li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li>
<li>现实世界中的实体是可区分的，即它们具有某种唯一性标识。</li>
<li>关系模型中以主码作为唯一性标识。</li>
<li>主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性</li>
</ul>
</blockquote>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><ul>
<li>关系中的某些属性的取值需要参考另外一个关系中的相关数据</li>
</ul>
<p>在关系模型中实体及实体间的联系都是用关系来描述的,自然存在着关系与关系间的引用,而这种引用应当是有意义的 </p>
<p>若关系R中的属性F的取值需要参考关系S中的主码K,则:</p>
<blockquote>
<ul>
<li>F为R的外码/外键,此时F不能是R的码</li>
<li>R为参照关系</li>
<li>S为被参照关系或目标关系</li>
<li>外码F只能为空或者是关系S中某个存在的元组的K属性(有意义)</li>
<li>R和S可以是同一个关系</li>
</ul>
</blockquote>
<h4 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h4><p>其他一些用户定义的完整性规则,可以是列级完整性约束也可以是表级完整性约束</p>
<h2 id="2-2-关系代数"><a href="#2-2-关系代数" class="headerlink" title="2.2 关系代数"></a>2.2 关系代数</h2><p>关系数据库语言分类：</p>
<blockquote>
<ul>
<li>关系代数语言: 用对关系的运算来表达查询要求</li>
<li>关系演算语言：用谓词来表达查询要求</li>
<li>具有关系代数和关系演算双重特点的语言(SQL)</li>
</ul>
</blockquote>
<p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询,其以集合运算为数学基础</p>
<blockquote>
<ul>
<li>关系代数运算对象是关系</li>
<li>关系代数运算结果是关系</li>
<li>关系代数运算符分为集合运算符和专门关系的运算符</li>
</ul>
</blockquote>
<h3 id="传统集合操作"><a href="#传统集合操作" class="headerlink" title="传统集合操作"></a>传统集合操作</h3><p>一些记号的定义:</p>
<blockquote>
<ul>
<li>$R(A_1,A_2,…,A_n)$表示n目的关系模式,$A_i$表示属性</li>
<li>$R$为符合上述关系模式的一个关系</li>
<li>$t\in R$是R中的一个元组</li>
<li>$t[A_i]$表示元组$t$中属性$A_i$的值</li>
<li>$A=\lbrace A_i,A_j,…,A_k \rbrace$表示属性列或属性组</li>
<li>$t[A]$可以表示$t$在上述属性组中诸分量的集合</li>
<li>$\overline A$表示$A$在全体属性中的补集</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>$\widehat {t_rt_s}$表示关系R和关系S中两个元组的连接</li>
<li>$Z_x$是象集,表示R中属性组$X$上值为$x$的所有元组在属性组$Z$上分量的集合,称为$x$在$R$中的象集</li>
</ul>
</blockquote>
<h4 id="关系的并"><a href="#关系的并" class="headerlink" title="关系的并"></a>关系的并</h4><p>关系的并就是集合的并,运算要求如下:</p>
<blockquote>
<ul>
<li>关系R和S目数相同,相应的属性属于同一个域</li>
<li>R并S仍为n目关系,R$\cup$S是R和S上所有元组的集合</li>
<li>并完之后要去重</li>
</ul>
</blockquote>
<h4 id="关系的差"><a href="#关系的差" class="headerlink" title="关系的差"></a>关系的差</h4><p>关系的差就是集合的差,运算要求如下:</p>
<blockquote>
<ul>
<li>关系R和S目数相同,相应的属性属于同一个域</li>
<li>R并S仍为n目关系,R-S是属于R而不属于S的所有元组的集合</li>
</ul>
</blockquote>
<h4 id="关系的交"><a href="#关系的交" class="headerlink" title="关系的交"></a>关系的交</h4><p>要求同上,运算结果是在R和S中都存在的元组的集合</p>
<h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>关系的笛卡尔积中,$R\times S = \lbrace \widehat {t_rt_s} | t_r \in R \land t_s \in S \rbrace$</p>
<blockquote>
<ul>
<li>行:运算后为$n_R+n_S$目关系</li>
<li>列:运算后有$k_R*k_S$个元组</li>
</ul>
</blockquote>
<h3 id="关系特有操作"><a href="#关系特有操作" class="headerlink" title="关系特有操作"></a>关系特有操作</h3><h4 id="选择-sigma"><a href="#选择-sigma" class="headerlink" title="选择$\sigma$"></a>选择$\sigma$</h4><ul>
<li>选择运算又称为限制</li>
<li>是在关系R中选择符合条件的元组组成集合</li>
<li>条件是一个取值为真或假的逻辑表达式</li>
</ul>
<h4 id="投影-pi"><a href="#投影-pi" class="headerlink" title="投影$\pi$"></a>投影$\pi$</h4><ul>
<li>从关系R中选择出若干属性列组成新的关系</li>
<li>投影后形成的新的关系目数会减少</li>
<li>需要去重</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接是从两个关系的笛卡尔积中选择属性满足一定条件A$\theta$B的元组组成的关系</p>
<p>此时,参与连接的两个关系有一些度数相等且可以进行比较的属性组A和B</p>
<ul>
<li><p>等值连接: 两个元组能连接的条件是对应属性组的值相等,即$\theta$为’=’</p>
</li>
<li><p>自然连接: 一种特殊的等值连接,两个进行比较的属性组必须相同,且运算结束后这些重复的属性组将会被去掉,这是一种对行和列都进行操作的运算</p>
</li>
<li><p>两个关系R和S在做自然连接时，被舍弃的元组称为悬浮元组</p>
</li>
<li><p>外连接: 将悬浮元组也保留在结果关系中,附加的属性置为空</p>
<blockquote>
<ul>
<li>左外连接:只保留左边关系R中的悬浮元组,悬浮元组中多出来的S分量全置为空</li>
<li>右外连接:只保留右边关系S中的悬浮元组,多出来的R分量全置为空</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h4><ul>
<li>给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组;Y一般为R和S中都有的属性组</li>
<li>R/S的结果是R上的一个投影P(X)的子集</li>
<li>R/S中的元组在X上分量值x的象集Yx包含S在Y上投影的集合<blockquote>
<ul>
<li>如果R是选课记录,S是全体课程,R/S就表示选了所有课程的学生</li>
</ul>
</blockquote>
</li>
<li>属性组Z没有参与到R/S的运算中</li>
</ul>
<h2 id="2-3-关系演算"><a href="#2-3-关系演算" class="headerlink" title="2.3 关系演算"></a>2.3 关系演算</h2><p>关系演算是以谓词演算为数学基础</p>
<p>按谓词变元不同,可分为元组关系演算(ALPHA语言)和域关系演算(QBE语言)</p>
<h3 id="元组关系演算ALPHA"><a href="#元组关系演算ALPHA" class="headerlink" title="元组关系演算ALPHA"></a>元组关系演算ALPHA</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p><code>GET [(定额)] &lt;工作空间&gt; (&lt;操作对象&gt;) [:条件] [DOWN|UP 排序方式]</code></p>
<blockquote>
<ul>
<li>以相应排序方式返回符合条件的操作对象</li>
<li>如果有定额则只返回前n个结果</li>
</ul>
</blockquote>
<h4 id="用元组变量进行检索"><a href="#用元组变量进行检索" class="headerlink" title="用元组变量进行检索"></a>用元组变量进行检索</h4><p>元组变量是可以在某一关系上任意取值的变量</p>
<blockquote>
<ul>
<li>可以用元组变量来代替较长的关系名</li>
<li>如果条件中使用量词,其后只能接元组变量</li>
</ul>
</blockquote>
<p>元组关系演算是以元组变量作为谓词变元的基本对象的关系演算</p>
<p>定义方式:<code>RANGE &lt;关系名&gt; &lt;变量名&gt;</code></p>
<h4 id="用存在量词的检索"><a href="#用存在量词的检索" class="headerlink" title="用存在量词的检索"></a>用存在量词的检索</h4><ul>
<li>使用量词时先得定义在关系上的元组变量</li>
</ul>
<p>条件语句格式: $\exists$ &lt;元组变量&gt; (&lt;关于元组变量和目标元组的表达式&gt;)</p>
<p>对于需要判断的目标元组,只要存在一个元组变量的取值使得后面的表达式成立,这个目标元组就能够被选择</p>
<h4 id="用全称量词检索"><a href="#用全称量词检索" class="headerlink" title="用全称量词检索"></a>用全称量词检索</h4><ul>
<li>使用量词时先得定义在关系上的元组变量</li>
</ul>
<p>条件语句格式: $\forall$ &lt;元组变量&gt; (&lt;关于元组变量和目标元组的表达式&gt;)</p>
<p>对于需要判断的目标元组,无论元组变量取什么值后面的表达式都成立,则这个目标元组能够被选择</p>
<h4 id="用蕴含的检索"><a href="#用蕴含的检索" class="headerlink" title="用蕴含的检索"></a>用蕴含的检索</h4><p>在上述表达式中,可以使用蕴含条件</p>
<p>表达式格式:A$\to$B</p>
<p>当A成立时B一定成立,表达式为真</p>
<h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><p>常用聚集函数(内部函数):</p>
<blockquote>
<ul>
<li>COUNT: 对元组计数(计数时会自动排除重复值)</li>
<li>TOTAL: 求值的总和</li>
<li>MAX: 求最大值</li>
<li>MIN: 求最小值</li>
<li>AVG: 求平均值</li>
</ul>
</blockquote>
<h3 id="域关系演算QBE"><a href="#域关系演算QBE" class="headerlink" title="域关系演算QBE"></a>域关系演算QBE</h3><p>域关系演算是以元组变量的分量即域变量作为谓词变元的基本对象的关系演算</p>
<h1 id="三、关系数据库标准语言SQL"><a href="#三、关系数据库标准语言SQL" class="headerlink" title="三、关系数据库标准语言SQL"></a>三、关系数据库标准语言SQL</h1><p>SQL: 结构化查询语言,Structured Query Language</p>
<p>目前,没有一个数据库系统能够支持SQL标准的所有概念和特性</p>
<h2 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h2><p>SQL（Structured Query Language）结构化查询语言是关系数据库的标准语言</p>
<h3 id="SQL特点"><a href="#SQL特点" class="headerlink" title="SQL特点"></a>SQL特点</h3><p>综合统一: </p>
<blockquote>
<ul>
<li>集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。 </li>
<li>可以独立完成数据库生命周期中的全部活动  </li>
</ul>
</blockquote>
<p>高度非过程化:</p>
<blockquote>
<ul>
<li>非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径。</li>
<li>SQL只要提出“做什么”，无须了解存取路径。</li>
<li>存取路径的选择以及SQL的操作过程由系统自动完成。</li>
</ul>
</blockquote>
<p>面向集合的操作方式: </p>
<blockquote>
<ul>
<li>非关系数据模型采用面向记录的操作方式，操作对象是一条记录</li>
<li>SQL采用集合操作方式</li>
<li>操作对象、查找结果可以是元组的集合</li>
<li>一次插入、删除、更新操作的对象可以是元组的集合</li>
</ul>
</blockquote>
<p>以同一种语法结构提供多种使用方式: </p>
<blockquote>
<ul>
<li>SQL是独立的语言,能够独立地用于联机交互的使用方式</li>
<li>SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用</li>
</ul>
</blockquote>
<p>语言简洁，易学易用: </p>
<blockquote>
<ul>
<li>SQL功能极强，完成核心功能只用了9个动词。</li>
<li>数据定义:CREATE,DROP,ALTER</li>
<li>数据操纵:INSERT,UPDATE,DELETE</li>
<li>数据查询:SELECT</li>
<li>权限控制:GRANT,REVOKE</li>
</ul>
</blockquote>
<h3 id="SQL基本概念"><a href="#SQL基本概念" class="headerlink" title="SQL基本概念"></a>SQL基本概念</h3><p>数据库三级模式在SQL数据库中的体现:<br><img src="/2020/05/24/data-base0/sql0.png" alt="sql"></p>
<ul>
<li><p>基本表(模式)</p>
<blockquote>
<ul>
<li>本身独立存在的表</li>
<li>SQL中一个关系就对应一个基本表</li>
<li>一个（或多个）基本表对应一个存储文件</li>
<li>一个表可以带若干索引</li>
</ul>
</blockquote>
</li>
<li><p>存储文件(内模式)</p>
<blockquote>
<ul>
<li>存储文件以逻辑结构的方式组成了关系数据库的内模式</li>
<li>而物理存储结构对用户是隐蔽的(透明)</li>
</ul>
</blockquote>
</li>
<li><p>视图(外模式)</p>
<blockquote>
<ul>
<li>视图是由一个或几个基本表导出的表,是一个虚表</li>
<li>视图不存储数据,数据库中只存放视图的定义</li>
<li>视图上可以再定义视图</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="3-2-数据定义"><a href="#3-2-数据定义" class="headerlink" title="3.2 数据定义"></a>3.2 数据定义</h2><p>数据定义是定义各种数据库的对象</p>
<blockquote>
<p>数据定义包括模式(SCHEMA)定义,表(TABLE)定义,视图(VIEW)定义,索引(INDEX)定义  </p>
<ul>
<li>这里的模式通常指基本表的结构</li>
<li>一个数据库中可以建立多个模式</li>
<li>一个模式下可以建立多个表,视图,索引等数据库对象</li>
</ul>
</blockquote>
<p>上述对象的定义存储在数据库系统的数据字典中</p>
<ul>
<li>数据字典: 数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有对象的定义等一些信息<blockquote>
<ul>
<li>除了模式,表,视图,索引的定义(包括完整性约束)外, 数据字典还会存储各类用户对数据库的操作权限和统计信息等</li>
<li>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>为某人创建某名的模式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</span><br><span class="line">[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;权限定义子句&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>若没有指定模式名,则模式名隐含为用户名</li>
</ul>
<p>删除某模式:<code>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</code><br>删除选项:</p>
<blockquote>
<ul>
<li>CASADE 级联: 删除模式同时将该模式下的所有数据库对象删除</li>
<li>RESTRICT 限制: 仅当该模式中没有任何下属对象时才能执行, 如果这个模式下有表/视图等定义,则拒绝执行语句</li>
</ul>
</blockquote>
<h3 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h3><h4 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="comment">/* 基本表的名称 */</span> </span><br><span class="line">(&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] <span class="comment">/*组成该表的列*/</span> </span><br><span class="line">[,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] </span><br><span class="line">… </span><br><span class="line">[,&lt;表级完整性约束条件&gt; ] );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>&lt;列级完整性约束条件&gt;: 涉及仅单个属性列的完整性约束条件 </p>
</li>
<li><p>&lt;表级完整性约束条件&gt;: 涉及一个或多个属性列的完整性约束条件 </p>
</li>
<li><p>&lt;表名&gt;:每一个基本表需属于某个模式,可以显式地在表名中给出,也可以在搜索路径中设置 </p>
<blockquote>
<p>设置搜索路径(默认模式):<code>SET search_path TO &lt;模式名&gt;,PUBLIC;</code></p>
</blockquote>
</li>
<li><p>&lt;数据类型&gt;: 有如下数据类型</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">含义</th>
<th align="left">数据类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR(n)</td>
<td align="left">n位定长字符串</td>
<td align="left">CHARACTER(n)</td>
<td align="left">同CHAR(n)</td>
</tr>
<tr>
<td align="left">VRCHAR(n)</td>
<td align="left">最大长度为n的变长字符串</td>
<td align="left">VRCHARACTER(n)</td>
<td align="left">同VRCHAR(n)</td>
</tr>
<tr>
<td align="left">CLOB</td>
<td align="left">字符串大对象</td>
<td align="left">BLOB</td>
<td align="left">二进制大对象</td>
</tr>
<tr>
<td align="left">INT</td>
<td align="left">长整数(4字节)</td>
<td align="left">INTEGER</td>
<td align="left">同INT</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">大整数(8字节)</td>
<td align="left">SMALLINT</td>
<td align="left">短整数(2字节)</td>
</tr>
<tr>
<td align="left">DEC(p,d)</td>
<td align="left">精度为d的p位定点数</td>
<td align="left">DECIMAL(p,d),NUMERIC(p,d)</td>
<td align="left">同DEC(p,d)</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">单精度浮点数</td>
<td align="left">DOUBLE PRECISION</td>
<td align="left">双精度浮点数</td>
</tr>
<tr>
<td align="left">FLOAT(n)</td>
<td align="left">精度为n的浮点数</td>
<td align="left">BOOLEAN</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">格式为YYYY-MM-DD的日期</td>
<td align="left">TIME</td>
<td align="left">格式为HH:MM:SS的时间</td>
</tr>
<tr>
<td align="left">TIMESTAP</td>
<td align="left">时间戳类型</td>
<td align="left">INTERVAL</td>
<td align="left">时间间隔类型</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</span><br><span class="line">[<span class="keyword">ADD</span> &lt;表级完整性约束&gt;] <span class="comment">/*完整性约束只能添加表级完整性约束*/</span></span><br><span class="line">[<span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] &lt;列名&gt; [<span class="keyword">CASCADE</span>| RESTRICT] ]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>&lt;完整性约束名&gt;[ RESTRICT | <span class="keyword">CASCADE</span> ] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> &lt;列名&gt;&lt;数据类型&gt; ] ;</span><br></pre></td></tr></table></figure>
<ul>
<li>ADD COLUMN: 增加列</li>
<li>DROP COLUMN: 删除列<blockquote>
<ul>
<li>级联: 删除该列及引用该列的其他对象</li>
<li>限制: 如果该列被其他对象引用,则拒绝删除</li>
</ul>
</blockquote>
</li>
<li>ALTER COLUMN:修改列,也可以用以下两种方法<blockquote>
<ul>
<li><code>MODIFY &lt;列名&gt; &lt;数据类型&gt;</code>:修改列的数据类型</li>
<li><code>CHANGE &lt;列名&gt; &lt;新列名&gt; &lt;新数据类型&gt;</code>:修改列名</li>
</ul>
</blockquote>
</li>
<li>RENAME TO &lt;新表名&gt;:改个新表名</li>
</ul>
<h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;［RESTRICT| <span class="keyword">CASCADE</span>］;</span><br></pre></td></tr></table></figure>
<ul>
<li>级联:在删除基本表的同时，相关的依赖对象一起删除</li>
<li>限制:如果存在依赖该表的对象(该表被其他表引用),则拒绝删除</li>
</ul>
<h3 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h3><p>建立索引目的: 加快查询速度</p>
<ul>
<li>常见索引:顺序索引,B+树索引,散列索引,位图索引</li>
<li>索引由数据库管理员或建表者建立</li>
<li>索引由关系数据库系统自动完成维护</li>
</ul>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] <span class="keyword">INDEX</span> &lt;索引名&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);</span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;表名&gt;：要建索引的基本表的名字  </li>
<li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔  </li>
<li>&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省 值：ASC  </li>
<li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录  </li>
<li>CLUSTER：表示要建立的索引是聚簇索引</li>
</ul>
<h4 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h4><p><code>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索 引名&gt;;</code></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><code>DROP INDEX &lt;索引名&gt;;</code><br>删除索引时，系统会从数据字典中删去有关该索引的描述</p>
<h2 id="3-3-数据查询"><a href="#3-3-数据查询" class="headerlink" title="3.3 数据查询"></a>3.3 数据查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>语句格式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;] …</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]…|(<span class="keyword">SELECT</span> 语句)</span><br><span class="line">[<span class="keyword">AS</span>]&lt;别名&gt;</span><br><span class="line">[ <span class="keyword">WHERE</span> &lt;条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt; [ <span class="keyword">HAVING</span> &lt;条件表达式&gt; ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [ <span class="keyword">ASC</span>|<span class="keyword">DESC</span> ] ]</span><br></pre></td></tr></table></figure>
<ul>
<li>SELECT:指定要显示的结果属性列,*表示所有列<blockquote>
<ul>
<li>目标列值可以为常量,即使它不在查询对象中</li>
<li>LOWER(&lt;目标列&gt;)可以使目标列值小写输出</li>
<li>目标列值可以用聚集函数表示</li>
<li>可以用别名<code>&lt;目标列表达式&gt; &lt;目标列别名&gt;</code>改变查询结果的列标题</li>
<li>ALL表示不去除重复的行(默认),DISTINCT表示去重</li>
</ul>
</blockquote>
</li>
<li>FROM:指定查询对象</li>
<li>WHERE:查询条件<blockquote>
<p>常用查询条件:</p>
<ul>
<li>基本比较运算符</li>
<li>确定范围: [NOT] BETWEEN .. AND ..</li>
<li>确定集合: [NOT] IN &lt;值表&gt; ; &lt;值表&gt;=(值1,值2,…)</li>
<li>字符匹配: [NOT] LIKE &lt;匹配字符串&gt; [ESCAPE &lt;换码字符&gt;]  <blockquote>
<p>匹配串中’%’表示任意长度通配,’_’表示单字符通配,’&#39;可以将通配符转义(需要ESCAPE’&#39;来表明转义字符)</p>
</blockquote>
</li>
<li>空值:IS [NOT] NULL;其中IS不能用’=’代替</li>
<li>连接运算符:NOT AND OR,优先级从高到低</li>
</ul>
</blockquote>
</li>
<li>GROUP BY:对查询结果按指定列的值分组,列值相等的元素归到一组;通常会在每组中使用聚集函数<blockquote>
<p>常用聚集函数:</p>
<ul>
<li>COUNT([ALL|DISTINCT] &lt;列名&gt;): 列值计数</li>
<li>SUM([ALL|DISTINCT] &lt;列名&gt;): 对数值型的列求总和</li>
<li>AVG([ALL|DISTINCT] &lt;列名&gt;): 对数值型的列求均值</li>
<li>MAX|MIN([ALL|DISTINCT] &lt;列名&gt;): 求列的最大|最小值  </li>
</ul>
<p>没有GROUP BY语句时,聚集函数将作用于整个查询结果,使用分组后函数将分别作用于每个组</p>
</blockquote>
</li>
<li>HAVING:在分组时选择指定条件的组,可以使用聚集函数,不能用WHERE替代</li>
<li>ORDER BY:对查询结果按指定值升序或降序排序,支持以不同优先级设置多个排序标准</li>
</ul>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>不像关系代数中“连接”是用一个特殊符号来表达的，在SQL中“连接”是用“连接条件”来表达的。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;表名&gt;.&lt;列名&gt;,...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;,&lt;表<span class="number">2</span>&gt;,...</span><br><span class="line"><span class="keyword">WHERE</span> [&lt;表名<span class="number">1</span>&gt;.]&lt;列名<span class="number">1</span>&gt;  &lt;比较运算符&gt;  [&lt;表名<span class="number">2</span>&gt;.]&lt;列名<span class="number">2</span>&gt;</span><br><span class="line">      <span class="keyword">AND</span> &lt;其他条件&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>WHERE子句中除了连接条件,还可以有选择条件,同时完成选择和连接查询</li>
<li>对于表的自身连接,可以给同一个表取不同的别名来区分,来实现一些复杂的连接条件</li>
<li>左右外连接:<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">LEFT</span>|<span class="keyword">RIGHT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; </span><br><span class="line"><span class="keyword">ON</span> &lt;连接条件&gt;; </span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>FROM中也可以有多个表,进行多表连接</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>循环嵌套法:</p>
<blockquote>
<p>每从表1中取出一个元组,扫描一遍表2,将表2中符合条件的元组与前面的元组拼接起来,重复直到表1中的元组都处理完毕</p>
</blockquote>
<p>排序合并法:(常用于等值连接)</p>
<blockquote>
<p>按连接属性对表1和2进行排序,然后设置两个指针分别从两个表头开始从前向后扫;如果扫描的两个指针可以连接,则拼接后两个指针同时向后移,否在值较小的指针向后移动(归并算法);重复直到某个指针走到了表尾</p>
</blockquote>
<p>索引连接:</p>
<blockquote>
<p>对表2按连接字段建立索引,对于表1中的每个元组,按索引结果进行连接(循环嵌套法的一个变种)</p>
</blockquote>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个SELECT-FROM-WHERE语句称为一个查询块,将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
<ul>
<li>上层的查询块称为外层查询或父查询</li>
<li>下层查询块称为内层查询或子查询</li>
<li>SQL语言允许多层嵌套查询</li>
<li>子查询不能使用ORDER BY子句</li>
</ul>
<p>嵌套查询类型:</p>
<ul>
<li><p>不相关子查询:子查询的查询条件不依赖于父查询,如IN,ANY/ALL子查询 </p>
<blockquote>
<p>原理:由里向外逐层处理</p>
</blockquote>
</li>
<li><p>相关子查询:子查询的查询条件依赖于父查询,如EXISTS子查询</p>
<blockquote>
<p>原理:依次取外层查询中表内的各元组,根据它与内层查询相关的属性值处理内层查询,若WHERE子句返回值为真,则取此元组放入结果表中</p>
</blockquote>
</li>
</ul>
<h4 id="IN子查询"><a href="#IN子查询" class="headerlink" title="IN子查询"></a>IN子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> &lt;列名(值)&gt; <span class="keyword">IN</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line">        ...</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h4 id="ANY-ALL子查询"><a href="#ANY-ALL子查询" class="headerlink" title="ANY/ALL子查询"></a>ANY/ALL子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> &lt;列名&gt; &lt;比较运算符&gt; <span class="keyword">ANY</span>/<span class="keyword">ALL</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line">        ...</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>当确定内层子查询返回结果是单个值时,可以省略ANY/ALL</li>
<li>ANY/ALL的对象为某个查询结果,表示其中任意一个值或者全部值<blockquote>
<p>有时ANY/ALL谓词表达式可以用子查询中的聚集函数代替,如<code>&lt;ANY (SELECT &lt;列名&gt;)</code>可以用<code>&lt; (SELECT MIN(&lt;列名&gt;))</code>实现</p>
</blockquote>
</li>
</ul>
<h4 id="EXISTS子查询"><a href="#EXISTS子查询" class="headerlink" title="EXISTS子查询"></a>EXISTS子查询</h4><p>EXISTS是相关子查询,它依次取外层查询中表内的各元组,根据它与内层查询相关的属性值处理内层查询,若WHERE子句返回值为真,则取此元组放入结果表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">NOT</span>] <span class="keyword">EXISTS</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> &lt;表<span class="number">2</span>&gt;,...</span><br><span class="line">        <span class="keyword">WHERE</span> &lt;表<span class="number">1</span>&gt;...&lt;表<span class="number">2</span>&gt;...;</span><br><span class="line">    );</span><br><span class="line"><span class="comment">/* 表示查询结果中的每条记录都满足/不满足EXISTS子句 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>EXIST的对象也是某个查询结果，若查询结果非空则返回真<blockquote>
<ul>
<li>由EXISTS引出的子查询中一般都是SELECT *</li>
<li>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换</li>
<li>SQL中的存在,任意,蕴含等谓词都需要用EXISTS手动实现</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h4><p>除法运算需要用EXIST子句实现</p>
<p>原理:</p>
<ol>
<li>计算C(X)=A(X,Y)/B(Y,Z)</li>
<li>根据上式,需要找出所有的c[X],使得对于所有的b[Y],都存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]</li>
<li>SQL中没有全称量词,需要对上式进行转换:找出所有的c[X],使得不存在b[Y],不存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]</li>
<li>对于 ‘不存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]’, 还可以使用集合差运算转化成 ‘全体a[X,Y] - 使得a[X]=c[X],a[Y]=b[Y]的a[X,Y]’</li>
</ol>
<p>3的实现代码如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> X </span><br><span class="line"><span class="keyword">FROM</span> A [<span class="keyword">AS</span>] R <span class="comment">/* 换名防止后面混淆 */</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * </span><br><span class="line">    <span class="keyword">FROM</span> B</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> A</span><br><span class="line">        <span class="keyword">WHERE</span> &lt;X=R.X&gt;</span><br><span class="line">          <span class="keyword">AND</span> &lt;Y=B.Y&gt;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>4的实现代码如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> X </span><br><span class="line"><span class="keyword">FROM</span> A [<span class="keyword">AS</span>] R <span class="comment">/* 换名防止后面混淆 */</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    (<span class="keyword">SELECT</span> *</span><br><span class="line">     <span class="keyword">FROM</span> A</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">EXCEPT</span> <span class="comment">/* 集合做差 */</span></span><br><span class="line">    (<span class="keyword">SELECT</span> X,Y </span><br><span class="line">     <span class="keyword">FROM</span> A,B</span><br><span class="line">     <span class="keyword">WHERE</span> &lt;A.X=R.X&gt;</span><br><span class="line">       <span class="keyword">AND</span> &lt;A.Y=B.Y&gt;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="蕴含逻辑"><a href="#蕴含逻辑" class="headerlink" title="蕴含逻辑"></a>蕴含逻辑</h4><p>蕴含逻辑也需要用EXISTS子句实现</p>
<ol>
<li>给定逻辑:对于任意的a,都有B-&gt;C</li>
<li>化简逻辑:不存在a,使得B或非C</li>
<li>用NOT EXISTS实现上述语句;注意,非C也可以用NOT EXISTS实现</li>
</ol>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>集合查询可以对两个查询结果进行集合运算</p>
<ul>
<li>UNION:并</li>
<li>INTERSECT:交</li>
<li>EXCEPT:差<br>注意:参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同 </li>
</ul>
<h2 id="3-4-数据更新"><a href="#3-4-数据更新" class="headerlink" title="3.4 数据更新"></a>3.4 数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>可以直接插入元组或者插入子查询结果(多个元组)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;[属性列,...]</span><br><span class="line"><span class="keyword">VALUES</span> (属性值,);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;[属性列,...]</span><br><span class="line">&lt;子查询&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有出现的属性列赋空值  </li>
<li>没有定义属性列时默认为原表所有属性</li>
<li>VALUES可以由子查询表示</li>
<li>子查询结果或元组值需要与上面定义的属性列相匹配(子查询结果列的个数和列的类型都要匹配)</li>
<li>除了属性匹配,数据库还会检查所插入元素是否会破坏表的完整性规则</li>
</ul>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">SET</span>  &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>语句将修改指定表中满足WHERE子句条件的元组</li>
<li>SET子句给出&lt;表达式&gt;的值用于取代相应的属性列</li>
<li>注意,如果省略WHERE子句,则会修改表中的所有元组 </li>
<li>执行修改语句时,数据库会检查修改操作是否会破坏表的完整性规则</li>
</ul>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt;</span><br><span class="line">WHERE &lt;条件&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>语句将会删除指定表中满足WHERE子句条件的元组</li>
<li>注意,如果省略WHERE子句,则会删除表中的所有元组</li>
</ul>
<h2 id="3-5-空值处理"><a href="#3-5-空值处理" class="headerlink" title="3.5 空值处理"></a>3.5 空值处理</h2><p>空值一般可以表示不存在(无意义)的值,未知值,不便于显示的值</p>
<p>空值一般用NULL表示,在关系运算中,需要对它进行特殊处理</p>
<ul>
<li>IS [NOT] NULL用来判断值是否为空</li>
<li>空值与其他值进行算术运算的结果为空值</li>
<li>空值与其他值(包括另一个空值)进行比较运算的结果为UNKNOWN</li>
<li>UNKNOWN将传统的二值（TRUE，FALSE）逻辑扩展成了三值逻辑</li>
<li>一般情况下UNKNOWN会被当成FALSE看待</li>
</ul>
<h2 id="3-6-视图"><a href="#3-6-视图" class="headerlink" title="3.6 视图"></a>3.6 视图</h2><ul>
<li>视图是一种虚拟的表,是从基本表中导出的表</li>
<li>视图只有定义,不存放数据</li>
<li>基本表中的数据发生变化，从视图中查询出的数据也随之改变</li>
</ul>
<h3 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h3><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE  VIEW </span><br><span class="line">    &lt;视图名&gt;  [(&lt;列名&gt;  [,&lt;列名&gt;]…)] </span><br><span class="line">   AS &lt;子查询&gt; </span><br><span class="line">   [WITH  CHECK  OPTION];</span><br></pre></td></tr></table></figure>
<ul>
<li>列名缺省时由子查询中SELECT的列构成<blockquote>
<p>一般出现以下情况,需要指定视图的列名:</p>
<ul>
<li>SELECT的某个列需要聚集函数或列表达式,即出现了一些新的列</li>
<li>多表连接时选出了几个同名列作为视图的字段</li>
<li>需要在视图中为某个列启用新的更合适的名字</li>
</ul>
</blockquote>
</li>
<li>WITH CHECK OPTION 可以保证通过该视图插入的数据符合该视图的定义,即插入成功的数据也会在视图中显示</li>
</ul>
<p>常见视图:</p>
<ul>
<li>行列子集视图:在保留单个基本表主码的情况下,去掉了这个表的某些行和列</li>
<li>基于多个表的视图</li>
<li>基于视图的视图</li>
<li>带表达式的视图:SELECT的某个列为表达式</li>
<li>分组视图:SELECT的某个列为聚集函数</li>
</ul>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><code>DROP  VIEW  &lt;视图名&gt;[CASCADE];</code></p>
<ul>
<li>该语句从数据字典中删除指定的视图定义</li>
<li>如果该视图上还导出了其他视图，需要使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除,否则会拒绝删除</li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</li>
</ul>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>视图查询与上述基本表的查询相同</p>
<p>原理:视图消解法</p>
<ul>
<li>对于数据库系统而言,先得将视图查询转换为对基本表的查询,再进行对基本表的查询</li>
<li>转换时需要进行有效性检查和语句修正</li>
</ul>
<h3 id="更新视图-数据"><a href="#更新视图-数据" class="headerlink" title="更新视图(数据)"></a>更新视图(数据)</h3><p>视图的插入,删除,修改操作与基本表相同</p>
<ul>
<li>一些视图是不可更新的,因为 对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新,如带聚集函数的视图<blockquote>
<p>一般而言,行列子集视图是可以进行更新的  </p>
<p>DB2对视图更新的限制:</p>
<ul>
<li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li>
<li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT 和UPDATE操作，但允许执行DELETE操作。  </li>
<li>若视图的字段来自集函数，则此视图不允许更新。</li>
<li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li>
<li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li>
<li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h3><ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当的利用视图可以更清晰的表达查询</li>
</ul>
<h1 id="四、数据库安全性"><a href="#四、数据库安全性" class="headerlink" title="四、数据库安全性"></a>四、数据库安全性</h1><p>数据库的一大特点就是数据可以共享,而这必然带来安全性问题,这种数据的共享不能是无条件的共享</p>
<ul>
<li>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏</li>
<li>系统的安全保护措施是否有效是数据库系统主要的性能指标之一</li>
</ul>
<h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="数据库不安全因素"><a href="#数据库不安全因素" class="headerlink" title="数据库不安全因素"></a>数据库不安全因素</h3><p>不安全的因素和主要对策</p>
<ul>
<li>非授权用户对数据库的恶意存取和破坏:用户身份鉴别,存取控制和视图技术</li>
<li>数据库中重要或敏感数据被泄露:强制存取控制,数据存储加密和传输加密</li>
<li>安全环境的脆弱性:建立可信计算机系统的标准</li>
</ul>
<h3 id="安全标准简介"><a href="#安全标准简介" class="headerlink" title="安全标准简介"></a>安全标准简介</h3><ul>
<li>TCSEC标准-&gt;CC标准</li>
</ul>
<p>TCSEC/TDI标准从四个方面来考虑程序的安全性: 安全策略,责任,保证和文档</p>
<p>TCSEC/TDI安全级别划分(由低到高):  </p>
<ul>
<li>D 最小保护: 一切不符合更高安全等级的系统,例如DOS</li>
<li>C1 自主安全保护: 能够实现对用户和数据的分离，进行自主存取控制（ DAC），保护或限制用户权限的传播; 现有商业系统稍作改进即可满足 </li>
<li>C2 受控的存取保护: 提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离; 如Windows2000</li>
<li>B1 标记安全保护: 对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制; 是安全或可信的产品</li>
<li>B2 结构化保护: 建立形式化的安全策略模型并对系统内的所有主体和 客体实施DAC和MAC </li>
<li>B3 安全域: 该级的TCB必须满足访问监控器的要求，审计跟踪能 力更强，并提供系统恢复过程 </li>
<li>A1 验证设计: 验证设计，即提供B3级保护的同时给出系统的形式化 设计说明和验证以确信各安全保护真正实现。</li>
</ul>
<p>CC评估保证级(EAL)划分:</p>
<ul>
<li>EAL1:功能测试（functionally tested）</li>
<li>EAL2:结构测试（structurally tested）,相当于C1</li>
<li>EAL3:系统地测试和检查（methodically tested and checked）,相当于C2 </li>
<li>EAL4:系统地设计、测试和复查（methodically designed， tested， and reviewed）,相当于B1 </li>
<li>EAL5:半形式化设计和测试（semiformally designed and tested）,相当于B2 </li>
<li>EAL6:半形式化验证的设计和测试（semiformally verified design and tested）,相当于B3 </li>
<li>EAL7:形式化验证的设计和测试（formally verified design and tested）,相当于A1 </li>
</ul>
<h2 id="4-2-数据库安全性控制"><a href="#4-2-数据库安全性控制" class="headerlink" title="4.2 数据库安全性控制"></a>4.2 数据库安全性控制</h2><p>计算机系统中,安全措施是一级一级层层设置的:<br>用户标识和鉴别(用户)&lt;-&gt;数据库安全保护(DBMS)&lt;-&gt;操作系统安全保护(OS)&lt;-&gt;数据密码存储(DB)</p>
<p>数据库安全控制常用方法</p>
<ul>
<li>用户身份鉴别</li>
<li>存取控制</li>
<li>视图</li>
<li>审计</li>
<li>数据加密</li>
</ul>
<p><img src="/2020/05/24/data-base0/sec0.png" alt="security"></p>
<h3 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h3><p>用户身份鉴别是系统提供的最外层安全保护措施</p>
<ul>
<li>用户标识：由用户名和用户标识号组成（用户标识号在系统整个生命周期内唯一） </li>
<li>身份鉴别方法:静态口令识别,动态口令识别,智能卡识别,生物特征鉴别</li>
</ul>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><ul>
<li>定义用户对数据对象的操作权限,并将权限登记到数据字典中,称为安全规则或授权规则</li>
<li>对每个用户发出的存取数据库的请求,DBMS都会查找数据字典进行合法权限检查</li>
</ul>
<p>用户权限定义和合法权检查机制一起组成了DBMS的存取控制子系统 </p>
<h3 id="自主存取控制DAC"><a href="#自主存取控制DAC" class="headerlink" title="自主存取控制DAC"></a>自主存取控制DAC</h3><h4 id="自主存取控制方法概述"><a href="#自主存取控制方法概述" class="headerlink" title="自主存取控制方法概述"></a>自主存取控制方法概述</h4><ul>
<li>用户对不同的数据对象有不同的存取权限</li>
<li>不同的用户对同一对象也有不同的权限</li>
<li>用户还可将其拥有的存取权限转授给其他用户</li>
</ul>
<p>通过SQL的GRANT语句和REVOKE语句实现</p>
<h4 id="权限的授予"><a href="#权限的授予" class="headerlink" title="权限的授予"></a>权限的授予</h4><p>给某用户授予对某对象的某操作权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">TO</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>权限有SELECT，INSERT，UPDATE，DELETE，REFERENCES几种; ALL PRIVILEGES表示所有操作权限<blockquote>
<p>至于CREATE,ALTER等权限,是数据库管理员在创建用户时授予的</p>
</blockquote>
</li>
<li>指定了ON的对象,表名这是一种实体权限的授予,而不是系统权限(对任意对象的操作)的授予</li>
<li>TO用户可以时一个或多个具体用户,也可以是全体用户PUBLIC</li>
<li>WITH GRANT OPTION表示授予的权限可以再由该用户向下转授<blockquote>
<p>注意:权限不能循环授予,这样会导致回收权限时遇到无穷递归</p>
</blockquote>
</li>
<li>GRANT语句的发出者可以是数据库管理员,数据库对象创建者或者拥有该权限的用户</li>
</ul>
<h4 id="权限的回收"><a href="#权限的回收" class="headerlink" title="权限的回收"></a>权限的回收</h4><p>收回本授权者对某用户的某对象某操作权限的授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[<span class="keyword">CASCADE</span> | RESTRICT];</span><br></pre></td></tr></table></figure>
<ul>
<li>级联回收: 将用户和他传播的权限全部回收</li>
<li>受限回收: 若用户传播过该权限并没有收回,则拒绝执行回收操作</li>
<li>权限的回收可由管理员或授权者来执行</li>
<li>回收只回收本用户直接或间接对目标用户授予的权限,若该用户还从其他地方获得了相同的权限,则他们仍具有此权限</li>
</ul>
<h4 id="用户的创建"><a href="#用户的创建" class="headerlink" title="用户的创建"></a>用户的创建</h4><p>CREATE USER不是SQL标准,不同数据库对用户创建的实现不一样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">USER</span>  &lt;username&gt;</span><br><span class="line">[<span class="keyword">WITH</span>][DBA|<span class="keyword">RESOURCE</span>|<span class="keyword">CONNECT</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>DBA:可以创建用户,模式,表以及登录数据库执行增删改查等操作</li>
<li>RESOURCE:只能创建表并登录数据库执行增删改查等操作</li>
<li>CONNECT: 能登陆数据库进行增删改查等操作,但必须获得相应权限</li>
</ul>
<h3 id="数据库中的角色"><a href="#数据库中的角色" class="headerlink" title="数据库中的角色"></a>数据库中的角色</h3><p>角色是权限的集合,能够通过为一组具有相同权限的用户创建一个角色来简化授权的过程</p>
<h4 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> &lt;角色名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="给角色添加权限"><a href="#给角色添加权限" class="headerlink" title="给角色添加权限"></a>给角色添加权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">TO</span> &lt;角色&gt;[,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure>

<h4 id="回收角色的某权限"><a href="#回收角色的某权限" class="headerlink" title="回收角色的某权限"></a>回收角色的某权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;角色&gt;[,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure>
<ul>
<li>用户可以回收角色的权限，从而修改角色拥有的权限</li>
<li>(不知道对不对)之前通过此角色授予出去的权限也会因为这个操作而被回收</li>
<li>这个REVOKE的发起者是角色的创建者或者拥有该角色ADMIN OPTION的用户</li>
</ul>
<h4 id="把角色授予给某用户或角色"><a href="#把角色授予给某用户或角色" class="headerlink" title="把角色授予给某用户或角色"></a>把角色授予给某用户或角色</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>  &lt;角色<span class="number">1</span>&gt;[,&lt;角色<span class="number">2</span>&gt;]...</span><br><span class="line"><span class="keyword">TO</span>  &lt;角色<span class="number">3</span>&gt;[,&lt;用户<span class="number">1</span>&gt;]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>一个角色的权限是直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限 </li>
<li>把角色授给目标用户后,该用户获得这个角色的所有权限</li>
<li>WITH ADMIN OPTION表示目标角色或用户还可以把这种角色权限授予其他的角色或用户,也有权力更改这个角色的权限</li>
<li>这个GRANT的发起者是角色的创建者或者拥有该角色ADMIN OPTION的用户</li>
</ul>
<h4 id="通过角色收回赋予出去的权限"><a href="#通过角色收回赋予出去的权限" class="headerlink" title="通过角色收回赋予出去的权限"></a>通过角色收回赋予出去的权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;角色<span class="number">1</span>&gt;[,&lt;角色<span class="number">2</span>&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;角色<span class="number">3</span>&gt;[,&lt;用户<span class="number">1</span>&gt;]...</span><br></pre></td></tr></table></figure>
<ul>
<li>目标用户或角色失去了原角色赋予给他的权限</li>
</ul>
<h3 id="强制存取控制MAC"><a href="#强制存取控制MAC" class="headerlink" title="强制存取控制MAC"></a>强制存取控制MAC</h3><p>自主存取控制可能存在数据的“无意泄露”,因为自主存取控制仅仅通过对数据的存取权限来进行安全控制,而数据本身并无安全性标记 </p>
<ul>
<li>强制存取控制（MAC）保证更高程度的安全性,用户不能直接感知或进行控制</li>
<li>强制存取控制适用于对数据有严格而固定密级分类的部门 </li>
</ul>
<h4 id="强制存取控制方法概述"><a href="#强制存取控制方法概述" class="headerlink" title="强制存取控制方法概述"></a>强制存取控制方法概述</h4><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为两大类:</p>
<ul>
<li>主体:系统中的活动实体,即用户</li>
<li>客体:系统中受主体操纵的被动实体,如文件、基本表、索引、视图等</li>
</ul>
<p>DBMS对每个主体和客体的实例指派了一个敏感度标记(从高到低):</p>
<ul>
<li>绝密: Top Secret, TS</li>
<li>机密: Secret, S</li>
<li>可信: Confidential, C</li>
<li>公开: Public, P</li>
</ul>
<blockquote>
<ul>
<li>对主体的敏感度标记称为许可证(Clearance Level)</li>
<li>对客体的敏感度标记称为密级(Classification Leve)</li>
</ul>
</blockquote>
<h4 id="强制存取控制读写规则"><a href="#强制存取控制读写规则" class="headerlink" title="强制存取控制读写规则"></a>强制存取控制读写规则</h4><ul>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体<blockquote>
<ul>
<li>可以防止主体看到一些敏感性较高的数据</li>
</ul>
</blockquote>
</li>
<li>仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体 <blockquote>
<ul>
<li>可以防止主体将高敏感性的数据向下透露(写)给低敏感性数据</li>
<li>主体可以更改密级比它高的数据,但写完之后它自己不能读取到</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="DAC-MAC安全检查"><a href="#DAC-MAC安全检查" class="headerlink" title="DAC+MAC安全检查"></a>DAC+MAC安全检查</h3><p>实现强制存取控制MAC时要首先实现自主存取控制DAC,因为较高安全性级别提 供的安全保护要包含较低级别的所有保护  </p>
<p>自主存取控制与强制存取控制共同构成数据库管理系统的安全机制</p>
<p>检查过程: SQL语法分析、语义检查-&gt;DAC检查-&gt;MAC检查-&gt;继续语义检查</p>
<h2 id="4-3-视图机制"><a href="#4-3-视图机制" class="headerlink" title="4.3 视图机制"></a>4.3 视图机制</h2><p>把要保密的数据对无权存取这些数据的用户通过视图隐藏起来，对数据提供一定程度的安全保护</p>
<p>例如,允许用户对表的部分进行查询的权限,用GRANT语句就无法实现,需要用视图进行操作</p>
<p>视图的相关操作可参见上面的3.6</p>
<h2 id="4-4-审计"><a href="#4-4-审计" class="headerlink" title="4.4 审计"></a>4.4 审计</h2><ul>
<li>用户身份鉴别,自主存取控制,强制存取控制,视图,数据加密是预防性措施</li>
<li>审计是监控措施<br>C2以上安全级别的DBMS必须具有审计功能 </li>
</ul>
<h3 id="审计相关概述"><a href="#审计相关概述" class="headerlink" title="审计相关概述"></a>审计相关概述</h3><p>审计就是启用一个专用的审计日志（Audit Log）,将用户对数据库的所有操作记录在上面   </p>
<p>审计员利用审计日志监控数据库中的各种行为,发现非法存取,发现潜在威胁  </p>
<p>可以被审计的事件:</p>
<ul>
<li>服务器事件: 记录数据库服务器发生的相关事件</li>
<li>系统权限: 记录对系统拥有的结构或模式对象进行的操作</li>
<li>语句事件: 记录SQL(或者其他数据库)语言发生的事件</li>
<li>模式对象事件: 记录对特定模式对象上进行的SELECT或DML操作</li>
</ul>
<p>审计日志管理:</p>
<ul>
<li>基本功能: 提供多种审计查阅方式</li>
<li>在初始化时设定多套审计规则</li>
<li>提供审计分析和报表功能</li>
<li>审计日志文件管理: 包括防止误删、加密、完整性保护、查阅和转储权限的管理</li>
<li>提供查询审计设置及审计记录信息的专门视图</li>
</ul>
<h3 id="审计功能的设置"><a href="#审计功能的设置" class="headerlink" title="审计功能的设置"></a>审计功能的设置</h3><p>由于审计很费时间和空间,可以选择使用或不使用审计功能</p>
<ul>
<li>系统级审计只能由数据库管理员设置,监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作</li>
<li>用户级审计是任何用户可设置的审计,主要是用户针对自己创建的数据库表和视图进行审计</li>
</ul>
<p>审计功能用AUDIT和NOAUDIT设置和取消</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用户级审计定义 */</span></span><br><span class="line">AUDIT &lt;操作名&gt;</span><br><span class="line">ON &lt;表名&gt;; /* 可以对某表结构或数据的修改操作进行审计 */</span><br><span class="line"></span><br><span class="line">NOAUDIT &lt;操作名&gt;</span><br><span class="line">ON &lt;表名&gt;; /* 取消审计 */</span><br></pre></td></tr></table></figure>

<h2 id="4-5-数据加密"><a href="#4-5-数据加密" class="headerlink" title="4.5 数据加密"></a>4.5 数据加密</h2><p>数据加密是一种预防性措施,是防止数据库中数据在存储和传输中失密的有效手段</p>
<p>有存储加密和传输加密两种</p>
<h3 id="存储加密"><a href="#存储加密" class="headerlink" title="存储加密"></a>存储加密</h3><p>透明存储加密:性能较好，安全完备性较高</p>
<ul>
<li>内核级加密保护方式，对用户完全透明</li>
<li>将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密</li>
<li>数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可</li>
</ul>
<p>非透明存储加密:</p>
<ul>
<li>通过多个加密函数实现的加密</li>
</ul>
<h3 id="传输加密"><a href="#传输加密" class="headerlink" title="传输加密"></a>传输加密</h3><p>链路加密:</p>
<ul>
<li>传输信息由报头和报文两部分组成;报头是路由选择信息,报文是要传送的数据信息</li>
<li>报文和报头均加密</li>
</ul>
<p>端到端加密:</p>
<ul>
<li>在发送端加密，接收端解密</li>
<li>只加密报文不加密报头</li>
<li>所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息</li>
</ul>
<p>数据库系统可信传输示意图:<br><img src="/2020/05/24/data-base0/trust0.png" alt="trust"></p>
<h2 id="4-6-其他安全性保护"><a href="#4-6-其他安全性保护" class="headerlink" title="4.6 其他安全性保护"></a>4.6 其他安全性保护</h2><h3 id="推理控制"><a href="#推理控制" class="headerlink" title="推理控制"></a>推理控制</h3><p>强制存取控制不能解决通过公开信息推理出机密信息的问题</p>
<p>常用策略:基于函数依赖的推理控制,基于敏感关联的推理控制</p>
<h3 id="隐蔽信道"><a href="#隐蔽信道" class="headerlink" title="隐蔽信道"></a>隐蔽信道</h3><p>强制存取控制不能解决高安全等级用户利用数据库特性,按事先约定的方式主动向低安全等级用户透露信息的问题</p>
<p>隐蔽信道用于解决类似这种问题:例如,绝密用户向数据库插入了一条绝密数据,而此时一个公开用户向数据库插入相同数据时被拒绝,绝密用户便通过这种隐蔽的方式向公开用户透露了这条信息的存在</p>
<h1 id="五、数据库完整性"><a href="#五、数据库完整性" class="headerlink" title="五、数据库完整性"></a>五、数据库完整性</h1><p>数据库安全性防范的是非法操作,而数据库完整性防范的是非法数据 </p>
<p>数据库的完整性包括以下两个方面:</p>
<ul>
<li>数据的正确性(实体完整性等)</li>
<li>数据的相容性(参照完整性)</li>
</ul>
<p>数据库提供的机制:</p>
<ul>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查机制 </li>
<li>违约处理 </li>
</ul>
<h2 id="5-1-实体完整性"><a href="#5-1-实体完整性" class="headerlink" title="5.1 实体完整性"></a>5.1 实体完整性</h2><p>关系的主属性(码)唯一且不能为空,详细定义见2.1关系完整性约束</p>
<h3 id="实体完整性定义"><a href="#实体完整性定义" class="headerlink" title="实体完整性定义"></a>实体完整性定义</h3><p>关系模型的实体完整性用主码PRIMARY KEY描述</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;列名&gt; ... PRIMARY KEY /* 列级完整性约束 */</span><br><span class="line">PRIMARY KEY(&lt;列名&gt;[,&lt;列名&gt;,...]) /* 表级完整性约束 */</span><br></pre></td></tr></table></figure>
<ul>
<li>列级完整性约束可以定义单属性构成的码</li>
<li>表级完整性约束可以定义单个或多个属性构成的码</li>
</ul>
<h3 id="实体完整性检查和违约处理"><a href="#实体完整性检查和违约处理" class="headerlink" title="实体完整性检查和违约处理"></a>实体完整性检查和违约处理</h3><p>实体完整性检查发生在插入或对主码列进行更新操作时</p>
<p>检查方法:</p>
<ul>
<li>全表扫描(费时)</li>
<li>建立索引搜索(这个一般由RDBMS核心自动完成,可以是B+索引树)</li>
</ul>
<p>违约处理:拒绝插入或更新</p>
<h2 id="5-2-参照完整性"><a href="#5-2-参照完整性" class="headerlink" title="5.2 参照完整性"></a>5.2 参照完整性</h2><p>保证外码取值符合参照完整性约束,详细定义见2.1关系完整性约束</p>
<h3 id="参照完整性定义"><a href="#参照完整性定义" class="headerlink" title="参照完整性定义"></a>参照完整性定义</h3><ul>
<li>定义表中的外码,以及被参照关系的主码<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列级完整性约束 */</span></span><br><span class="line">&lt;外码列名&gt; ... FOREIGN KEY REFERENCES DEPT(&lt;被参考关系主码&gt;) [ON DELETE|UPDATE CASCADE|NO ACTION|SET-NULL]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表级完整性约束 */</span></span><br><span class="line">FOREIGN KEY(&lt;外码列名&gt;) REFERENCES DEPT(&lt;被参考关系主码&gt;) [ON DELETE|UPDATE CASCADE|NO ACTION|SET-NULL]</span><br></pre></td></tr></table></figure></li>
<li>违约选项:见下文违约处理</li>
</ul>
<h3 id="参照完整性检查"><a href="#参照完整性检查" class="headerlink" title="参照完整性检查"></a>参照完整性检查</h3><p>参照完整性检查发生在对被参照表或参照表进行增删改操作时</p>
<h3 id="违约处理"><a href="#违约处理" class="headerlink" title="违约处理"></a>违约处理</h3><p>对于参照表的元组插入或外码值修改,违约即拒绝执行</p>
<p>对于被参照表的元组删除或主码值修改,有三种违约处理方式:</p>
<ul>
<li>拒绝执行:不执行语句</li>
<li>级联操作:将参照表中有关联的元组删除或进行外码修改</li>
<li>设置空值:将参照表中有关联的元组外码置为空值,这可能会导致参照表中的元组违反实体完整性约束</li>
</ul>
<h2 id="5-3-用户定义完整性约束"><a href="#5-3-用户定义完整性约束" class="headerlink" title="5.3 用户定义完整性约束"></a>5.3 用户定义完整性约束</h2><p>针对某一具体应用的数据必须满足的语义要求,需要用户定义完整性约束</p>
<h3 id="用户完整性约束定义"><a href="#用户完整性约束定义" class="headerlink" title="用户完整性约束定义"></a>用户完整性约束定义</h3><p>列级完整性约束定义(属性约束条件)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;列名&gt; ... [UNIQUE] [NOT NULL] [CHECK(expr)]</span><br></pre></td></tr></table></figure>
<ul>
<li>NOT NULL:列值非空</li>
<li>UNIQUE:列值唯一(相当于主码)</li>
<li>CHECK(expr):列值满足某表达式</li>
</ul>
<p>表级完整性约束定义(元组约束条件):用于设置不同属性之间的取值的相互约束条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHECK(expr)</span><br></pre></td></tr></table></figure>

<h3 id="用户定义完整性约束检查和违约处理"><a href="#用户定义完整性约束检查和违约处理" class="headerlink" title="用户定义完整性约束检查和违约处理"></a>用户定义完整性约束检查和违约处理</h3><p>用户定义约束条件检查发生在插入元组或修改属性的值时</p>
<p>违约即拒绝执行</p>
<h2 id="5-4-完整性约束命名字句"><a href="#5-4-完整性约束命名字句" class="headerlink" title="5.4 完整性约束命名字句"></a>5.4 完整性约束命名字句</h2><p>为完整性约束条件起个名字,方便后面对它进行修改和删除,否则无法操作</p>
<h3 id="完整性约束命名子句定义"><a href="#完整性约束命名子句定义" class="headerlink" title="完整性约束命名子句定义"></a>完整性约束命名子句定义</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">CONSTANT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</span><br></pre></td></tr></table></figure>
<p>该子句可以作为列级完整性约束或表级完整性约束使用</p>
<h3 id="完整性约束子句的删除和添加"><a href="#完整性约束子句的删除和添加" class="headerlink" title="完整性约束子句的删除和添加"></a>完整性约束子句的删除和添加</h3><p>用ALTER TABLE对约束条件进行删除和添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTANT</span> &lt;完整性约束条件名&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTANT</span> &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现完整性约束子句的修改时,需要先删除约束,再添加约束,如上所示</li>
</ul>
<h2 id="5-5-域中的完整性限制"><a href="#5-5-域中的完整性限制" class="headerlink" title="5.5 域中的完整性限制"></a>5.5 域中的完整性限制</h2><p>对于多个具有联系的表,表中的一些属性可能具有相同的域,可以通过建立域的完整性约束来使不同表中的相同的属性域也相同</p>
<h3 id="域完整性约束定义"><a href="#域完整性约束定义" class="headerlink" title="域完整性约束定义"></a>域完整性约束定义</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义完整性约束 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DOMAIN</span> &lt;完整性约束条件名&gt; &lt;被约束列的值类型&gt; &lt;完整性约束子句&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改完整性约束中的限制条件 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DOMAIN</span> &lt;完整性约束条件名&gt; &lt;完整性约束修改子句&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>完整性约束修改子句包括完整性约束子句的删除和添加,需要指定完整性约束条件名</li>
</ul>
<h3 id="域完整性约束使用"><a href="#域完整性约束使用" class="headerlink" title="域完整性约束使用"></a>域完整性约束使用</h3><p>定义好域的完整性约束后,可以直接使用完整性约束条件名来作为同类型的属性的完整性约束条件</p>
<h2 id="5-6-断言"><a href="#5-6-断言" class="headerlink" title="5.6 断言"></a>5.6 断言</h2><p>SQL中更一般的约束可以用断言来指定</p>
<ul>
<li>涉及多个表或聚集操作比较复杂的完整性约束</li>
<li>断言创建以后,任何对断言中所涉及的关系的操作都会触发检查</li>
<li>断言不为真则拒绝执行</li>
</ul>
<p>断言创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ASSERTION</span> &lt;断言名&gt; &lt;<span class="keyword">CHECK</span>子句&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>CHECK子句和WHERE子句的表达类似</li>
</ul>
<p>断言删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">ASSERTION</span> &lt;断言名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-7-触发器"><a href="#5-7-触发器" class="headerlink" title="5.7 触发器"></a>5.7 触发器</h2><ul>
<li>触发器是用户定义在关系表上的一类由事件驱动的特殊过程</li>
<li>任何用户对表的增删改操作均由服务器自动激活相应的触发器</li>
<li>触发器可以实施更为复杂的检查和操作(前面的完整性约束检查都是自动触发),具有更精细和更强大的数据控制能力</li>
</ul>
<p>触发器又叫做事件-条件-动作规则</p>
<h3 id="定义触发器"><a href="#定义触发器" class="headerlink" title="定义触发器"></a>定义触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt;</span><br><span class="line">&#123;<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>&#125; &lt;触发事件&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">REFERENCING</span> </span><br><span class="line">    <span class="keyword">NEW</span>|<span class="keyword">OLD</span> <span class="keyword">ROW</span> <span class="keyword">AS</span> &lt;变量&gt;,</span><br><span class="line">    <span class="keyword">NEW</span>|<span class="keyword">OLD</span> <span class="keyword">ROW</span> <span class="keyword">AS</span> &lt;变量&gt;,...]</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123;<span class="keyword">ROW</span>|<span class="keyword">STATEMENT</span>&#125;</span><br><span class="line">[<span class="keyword">WHEN</span> &lt;触发条件&gt;] &lt;触发动作体&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>触发器只能由表的拥有者创建</li>
<li>触发器只能定义在基本表上</li>
<li>&lt;触发器名&gt;可以包含或不包含模式名,同一模式下触发器名必须是唯一的</li>
<li>&lt;触发事件&gt;可以是对&lt;表名&gt;的INSERT,DELETE或UPDATE [OF &lt;触发列,…&gt;],触发器可在上述操作之后或者之前执行</li>
<li>RECEFRENCING子句用于指出所引用的变量,在后面的行级触发器中可以用到</li>
<li>FOR EACH子句可以定义触发器的类型:行级触发器或语句级触发器<blockquote>
<ul>
<li>行级触发器在对每一个元组进行相应的更改时激活(会多次激活触发器)</li>
<li>语句级触发器在语句执行时进行激活(以所更改的行为对象一次性进行操作)</li>
</ul>
</blockquote>
</li>
<li>定义WHEN后,只有触发器在激活后满足&lt;触发条件&gt;,触发动作体才会执行</li>
<li>&lt;触发动作体&gt;可以是一个匿名的SQL过程块,也可以是对已创建存储过程的调用;<blockquote>
<ul>
<li>行级触发器中用户可以在触发动作体中使用NEW和OLD引用实践之后的新之和事件之前的旧值</li>
<li>如果触发器动作体执行失败,则激活触发器的事件会被拒绝执行</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="触发器的激活"><a href="#触发器的激活" class="headerlink" title="触发器的激活"></a>触发器的激活</h3><p>一个表上可以定义多个触发器,遵循如下顺序执行</p>
<ul>
<li>执行表上的BEFORE触发器</li>
<li>执行SQL语句</li>
<li>执行表上的AFTER触发器<blockquote>
<p>有多个BEFORE或AFTER触发器时,一般上时间上先定义的触发器先执行</p>
</blockquote>
</li>
</ul>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有具有相应权限的用户才能删除相应的触发器</li>
</ul>
<hr>
<p>后续见数据库原理与设计(高级篇)<a href="http://georgechen.top/2020/04/16/data-base1/" target="_blank" rel="noopener">http://georgechen.top/2020/04/16/data-base1/</a></p>
<p>博文创建时间: date: 2020-02-27 13:24:32</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下C#对cmd的操作</title>
    <url>/2020/03/10/csharp-command/</url>
    <content><![CDATA[<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"请输入要执行的命令:"</span>);</span><br><span class="line"><span class="keyword">string</span> strInput = Console.ReadLine();</span><br><span class="line">Process p = <span class="keyword">new</span> Process();</span><br><span class="line"><span class="comment">//设置要启动的应用程序</span></span><br><span class="line">p.StartInfo.FileName = <span class="string">"cmd.exe"</span>;</span><br><span class="line"><span class="comment">//是否使用操作系统shell启动</span></span><br><span class="line">p.StartInfo.UseShellExecute = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 接受来自调用程序的输入信息</span></span><br><span class="line">p.StartInfo.RedirectStandardInput = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//输出信息</span></span><br><span class="line">p.StartInfo.RedirectStandardOutput = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 输出错误</span></span><br><span class="line">p.StartInfo.RedirectStandardError = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//不显示程序窗口</span></span><br><span class="line">p.StartInfo.CreateNoWindow = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//启动程序</span></span><br><span class="line">p.Start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向cmd窗口发送输入信息</span></span><br><span class="line">p.StandardInput.WriteLine(strInput);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.StandardInput.WriteLine(<span class="string">"exit"</span>);</span><br><span class="line">p.StandardInput.AutoFlush = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">string</span> strOuput = p.StandardOutput.ReadToEnd();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取输出信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待程序执行完退出进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Console.WriteLine(strOuput);</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>命名管道和进程通讯</title>
    <url>/2020/03/10/FIFO/</url>
    <content><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>参考<a href="https://blog.csdn.net/wh_sjc/article/details/70283843" target="_blank" rel="noopener">https://blog.csdn.net/wh_sjc/article/details/70283843</a><br>IPC（进程间通讯）的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。</p>
<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>“命名管道”是一种简单的进程间通信（IPC）机制，命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信。</p>
<h2 id="python中的命名管道"><a href="#python中的命名管道" class="headerlink" title="python中的命名管道"></a>python中的命名管道</h2><p>参考<a href="https://blog.csdn.net/kongxx/article/details/78037069" target="_blank" rel="noopener">https://blog.csdn.net/kongxx/article/details/78037069</a><br><a href="https://www.programcreek.com/python/example/62752/win32pipe.PIPE_WAIT" target="_blank" rel="noopener">https://www.programcreek.com/python/example/62752/win32pipe.PIPE_WAIT</a><br><a href="https://www.cnblogs.com/achillis/p/10462585.html" target="_blank" rel="noopener">https://www.cnblogs.com/achillis/p/10462585.html</a>  </p>
<p>在 Windows 上的命名管道主要是通过调用 win32 api 的以下方法来实现的</p>
<h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32file</span><br><span class="line"><span class="keyword">import</span> win32pipe</span><br><span class="line"></span><br><span class="line">PIPE_NAME = <span class="string">r'\\.\pipe\test_pipe'</span></span><br><span class="line">PIPE_BUFFER_SIZE = <span class="number">65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    named_pipe = win32pipe.CreateNamedPipe(PIPE_NAME,</span><br><span class="line">                                           win32pipe.PIPE_ACCESS_DUPLEX,</span><br><span class="line">                                           win32pipe.PIPE_TYPE_MESSAGE | win32pipe.PIPE_WAIT | win32pipe.PIPE_READMODE_MESSAGE,</span><br><span class="line">                                           win32pipe.PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">                                           PIPE_BUFFER_SIZE,</span><br><span class="line">                                           PIPE_BUFFER_SIZE, <span class="number">500</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                win32pipe.ConnectNamedPipe(named_pipe, <span class="literal">None</span>)    <span class="comment">#连接管道</span></span><br><span class="line">                data = win32file.ReadFile(named_pipe, PIPE_BUFFER_SIZE, <span class="literal">None</span>)   <span class="comment">#接收消息</span></span><br><span class="line">                win32file.WriteFile(named_pipe, bytes(<span class="string">"OK"</span>, encoding=<span class="string">'utf-8'</span>))  <span class="comment">#发送消息(二进制)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(data) &lt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                print(<span class="string">'receive msg:'</span>, data)</span><br><span class="line">            <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"exception:"</span>, e)  </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            win32pipe.DisconnectNamedPipe(named_pipe)   <span class="comment">#断开连接</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="client客户端"><a href="#client客户端" class="headerlink" title="client客户端"></a>client客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32pipe, win32file</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">PIPE_NAME = <span class="string">r'\\.\pipe\test_pipe'</span></span><br><span class="line"></span><br><span class="line">file_handle = win32file.CreateFile(PIPE_NAME,</span><br><span class="line">                                   win32file.GENERIC_READ | win32file.GENERIC_WRITE,</span><br><span class="line">                                   win32file.FILE_SHARE_WRITE, <span class="literal">None</span>,</span><br><span class="line">                                   win32file.OPEN_EXISTING, <span class="number">0</span>, <span class="literal">None</span>)    <span class="comment"># 连接管道</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">        msg = str(i)</span><br><span class="line">        print(<span class="string">'send msg:'</span>, msg)</span><br><span class="line">        win32file.WriteFile(file_handle, bytes(msg,encoding=<span class="string">'utf-8'</span>))   <span class="comment"># 发送信息</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        data = win32file.ReadFile(file_handle, <span class="number">65535</span>, <span class="literal">None</span>) <span class="comment"># 接收信息(阻塞)</span></span><br><span class="line">        print(data)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        win32file.CloseHandle(file_handle)  <span class="comment"># 关闭连接</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的命名管道"><a href="#C-中的命名管道" class="headerlink" title="C#中的命名管道"></a>C#中的命名管道</h2><h3 id="server端-1"><a href="#server端-1" class="headerlink" title="server端"></a>server端</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">NamedPipeServerStream server = <span class="keyword">new</span> NamedPipeServerStream(<span class="string">"test_pipe"</span>, PipeDirection.InOut, <span class="number">100</span>, PipeTransmissionMode.Byte, PipeOptions.None, <span class="number">65535</span>, <span class="number">65535</span>);</span><br><span class="line">server.WaitForConnection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (server.IsConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = server.Read(res, <span class="number">0</span>, <span class="number">65535</span>); <span class="comment">//接收信息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> s = System.Text.Encoding.UTF8.GetString(res,<span class="number">0</span>,n);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">        n = Encoding.UTF8.GetBytes(s, <span class="number">0</span>, s.Length, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        server.Write(res, <span class="number">0</span>, n);    <span class="comment">//发送信息</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">NamedPipeClientStream client = <span class="keyword">new</span> NamedPipeClientStream(<span class="string">"test_pipe"</span>);</span><br><span class="line">client.Connect();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (client.IsConnected)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = client.Read(res, <span class="number">0</span>, <span class="number">65535</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> s = System.Text.Encoding.UTF8.GetString(res,<span class="number">0</span>,n);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">    n = Encoding.UTF8.GetBytes(s, <span class="number">0</span>, s.Length, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    client.Write(res, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="python和C-交互代码示例"><a href="#python和C-交互代码示例" class="headerlink" title="python和C#交互代码示例"></a>python和C#交互代码示例</h2><p>python端  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32file</span><br><span class="line"><span class="keyword">import</span> win32pipe</span><br><span class="line"></span><br><span class="line">PIPE_NAME = <span class="string">r'\\.\pipe\test_pipe'</span></span><br><span class="line">PIPE_BUFFER_SIZE = <span class="number">65535</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    named_pipe = win32pipe.CreateNamedPipe(PIPE_NAME,</span><br><span class="line">                                           win32pipe.PIPE_ACCESS_DUPLEX,</span><br><span class="line">                                           win32pipe.PIPE_TYPE_MESSAGE | win32pipe.PIPE_WAIT | win32pipe.PIPE_READMODE_MESSAGE,</span><br><span class="line">                                           win32pipe.PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">                                           PIPE_BUFFER_SIZE,</span><br><span class="line">                                           PIPE_BUFFER_SIZE, <span class="number">500</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                win32pipe.ConnectNamedPipe(named_pipe, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">                win32file.WriteFile(named_pipe, bytes(<span class="string">"hello"</span>, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">                data = win32file.ReadFile(named_pipe, PIPE_BUFFER_SIZE, <span class="literal">None</span>)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># data = str.encode()</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(data) &lt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                print(<span class="string">'receive msg:'</span>, data)</span><br><span class="line">            <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"exception:"</span>, e)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            win32pipe.DisconnectNamedPipe(named_pipe)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>C#端</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">   <span class="keyword">byte</span>[] res = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">65535</span>];</span><br><span class="line"></span><br><span class="line">       NamedPipeClientStream client = <span class="keyword">new</span> NamedPipeClientStream(<span class="string">"test_pipe"</span>);</span><br><span class="line">       client.Connect();</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (client.IsConnected)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> n = client.Read(res, <span class="number">0</span>, <span class="number">65535</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">string</span> s = System.Text.Encoding.UTF8.GetString(res,<span class="number">0</span>,n);</span><br><span class="line"></span><br><span class="line">           Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">           n = Encoding.UTF8.GetBytes(s, <span class="number">0</span>, s.Length, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           client.Write(res, <span class="number">0</span>, n);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>python</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>微机原理</title>
    <url>/2020/03/08/micro-computer0/</url>
    <content><![CDATA[<p>罗喜召</p>
<h1 id="一、微型计算机基本结构及信息表示"><a href="#一、微型计算机基本结构及信息表示" class="headerlink" title="一、微型计算机基本结构及信息表示"></a>一、微型计算机基本结构及信息表示</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>微型计算机：处理器为核心</p>
<blockquote>
<ul>
<li>地址总线</li>
<li>数据总线</li>
<li>控制总线</li>
</ul>
</blockquote>
<p>冯诺依曼结构：指令和数据存储器统一编址<br>哈佛结构：指令和数据存储器分开编址</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>专业选修</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>微机原理</tag>
      </tags>
  </entry>
  <entry>
    <title>形式语言和自动机初步</title>
    <url>/2020/03/04/formal-language-and-automata/</url>
    <content><![CDATA[<p>参考离散数学(清华大学出版社,第五版)相关内容  </p>
<p>ps: 编辑公式真费时间$\to$_$\to$</p>
<hr>
<p>自动机是描述计算的数学模型,用来识别语言或计算函数. 形式文法也是一种数学模型,用来产生形式语言. 形式语言和自动机理论密切相关,是计算机科学和技术的重要理论基础.  </p>
<p>本文扼要地介绍形式文法的基本概念,有穷自动机和图灵机以及它们识别的语言类,其他不做分析</p>
<a id="more"></a>

<h2 id="形式语言和形式文法"><a href="#形式语言和形式文法" class="headerlink" title="形式语言和形式文法"></a>形式语言和形式文法</h2><p>形式语言的描述最早在1956年由语言学家乔姆斯基建立</p>
<p>在乔姆斯基的分类中,形式文法一共有如下几类:</p>
<ul>
<li>0型文法: 现证明等价于图灵机(下同)</li>
<li>1型文法: 等价于非确定型线性界限自动机</li>
<li>2型文法: 等价于非确定型下推自动机</li>
<li>3型文法: 等价于有穷自动机</li>
</ul>
<p>形式文法,特别是上下文无关文法(2型文法)和正则文法(3型文法)在程序设计语言和编译理论中起着重要的作用</p>
<h3 id="字符串和形式语言"><a href="#字符串和形式语言" class="headerlink" title="字符串和形式语言"></a>字符串和形式语言</h3><p>抽象而言,语言是按照一定规则排列的符号的集合</p>
<p>定义:</p>
<ul>
<li>字母表$\Sigma$: 一个非空的有穷集合</li>
<li>字符串$\omega$: 由$\Sigma$中的符号组成的有穷序列,如$a_ia_j…a_k$; 特别地,$aaa…a$记作$a^n$</li>
<li>$\vert \omega \vert$: 字符串$\omega$的长度, 空串$\epsilon$长度为0  </li>
</ul>
<ul>
<li>形式语言(语言): $\Sigma^*$的任何子集称作字母表$\Sigma$上的形式语言, 其中,$\Sigma^*$是$\Sigma$上字符串的全体  </li>
</ul>
<blockquote>
<p>$\emptyset, \lbrace \epsilon \rbrace, \Sigma^*$都是$\Sigma$上的语言. 注意,前两者是不同的</p>
</blockquote>
<p>在字符串$\omega$中:</p>
<ul>
<li>前缀: 由$\omega$左端若干个连续符号组成的字符串</li>
<li>后缀: 由$\omega$右端若干个连续符号组成的字符串</li>
<li>字串: 由$\omega$任何部位若干个连续符号组成的字符串</li>
<li>连接运算: $\omega_1\omega_2$表示把$\omega_2$接在$\omega_1$的右边, 显然,它是可结合的</li>
</ul>
<h3 id="形式文法"><a href="#形式文法" class="headerlink" title="形式文法"></a>形式文法</h3><p>语言是由一定规则产生出来的,这种规则就是文法</p>
<p>例如,<code>9+5-2</code>这个字符串可由如下文法规则产生:</p>
<blockquote>
<ol>
<li>表达式-&gt;表达式+数字;  </li>
<li>表达式-&gt;表达式-数字;  </li>
<li>表达式-&gt;数字;</li>
<li>数字-&gt;2;  </li>
<li>数字-&gt;5;  </li>
<li>数字-&gt;9;</li>
</ol>
</blockquote>
<p>定义:</p>
<ul>
<li>产生式: 文法中的每一条规则都叫做产生式</li>
<li>终结符: 不能产生其他字符串的符号, 如上述文法中的2,5,9</li>
<li>非终结符: 文法规则中除了终结符之外的其他符号,如<code>表达式</code>,<code>数字</code>,<code>+</code>,<code>-</code></li>
</ul>
<p><code>9+5-2</code>的推理过程:</p>
<ul>
<li>从<code>表达式</code>开始由2,1,3得到<code>数字+数字+数字</code></li>
<li>由4,5,6可以得到<code>9+5-2</code></li>
</ul>
<p>当然,这组规则不仅仅只能推出<code>9+5-2</code>  </p>
<p>注意: 规则所推出的字符串在语义上不一定正确,但在形式上都是合法的</p>
<h4 id="形式文法的定义"><a href="#形式文法的定义" class="headerlink" title="形式文法的定义"></a>形式文法的定义</h4><p>一个形式文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是一个非空有限集合,集合的元素称作变元或<strong>非终结符</strong></li>
<li>$T$是一个非空有限集合,$V\cap T=\emptyset$,集合中的元素称作<strong>终结符</strong></li>
<li>$S\in V$称作<strong>起始符</strong></li>
<li>$P$是一个非空有穷集合,它的元素称作<strong>产生式</strong>或改写规则<br>&emsp; $P$中元素应有这样的形式: a-&gt;b; 其中a,b$\in (V\cup T)^*$, 且a$\ne \epsilon$</li>
</ul>
<h4 id="派生-生成语言"><a href="#派生-生成语言" class="headerlink" title="派生,生成语言"></a>派生,生成语言</h4><p>直接派生:</p>
<ul>
<li>给定文法$G=&lt;V,T,S,P&gt;$,设$x,y \in (V \cup T)^*$. 称<strong>$y$是$x$的直接派生($x\Rightarrow y$)</strong>,当且仅当:  <blockquote>
<p>$\exists u,v \in (V \cup T)^* $ 且 $ \exists$ ‘a-&gt;b’ $\in P$ 使得 $x = uav,y = ubv$ (即把x中的a改写成b后得到y)  </p>
</blockquote>
</li>
</ul>
<p>派生:</p>
<ul>
<li>给定文法$G=&lt;V,T,S,P&gt;$,设$x_1,x_2,…,x_n \in (V \cup T)^*, n \ge 1 且 x_1\Rightarrow x_2 \Rightarrow … \Rightarrow x_n $, 则称<strong>$x_n$是由$x_1$派生出来的($x_1 \dot \Rightarrow x_n$)</strong>  <blockquote>
<p>注意,对$V \cup T$上的所有字符串$\omega$有$\omega \dot \Rightarrow \omega$. 可见$\dot \Rightarrow$是$\Rightarrow$的自反传递闭包  </p>
</blockquote>
</li>
</ul>
<p>生成语言:  </p>
<ul>
<li>设$G=&lt;V,T,S,P&gt;$是一个文法,$L(G)$是文法G<strong>生成的语言</strong>,则$L(G)$满足<br>$$ L(G) = \lbrace \omega \in T^* | S \dot \Rightarrow \omega \rbrace $$   <blockquote>
<p>根据定义,$L(G)$中的字符串满足如下两个条件:</p>
<ol>
<li>字符串由终结符构成</li>
<li>字符串可以由起始符派生出来</li>
</ol>
</blockquote>
</li>
</ul>
<p>文法的等价</p>
<ul>
<li>如果$L(G_1) = L(G_2)$,则称文法$G_1$和$G_2$<strong>等价</strong></li>
</ul>
<h3 id="形式文法分类"><a href="#形式文法分类" class="headerlink" title="形式文法分类"></a>形式文法分类</h3><h4 id="0型文法-无限制文法"><a href="#0型文法-无限制文法" class="headerlink" title="0型文法: 无限制文法"></a>0型文法: 无限制文法</h4><p>0型文法就是一般形式的文法,在形式文法定义的基础上不附加任何条件  </p>
<p>一个0型文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限</li>
</ul>
<p>0型文法又称作短语结构文法或无限制文法,0型文法生成的语言称作0型语言</p>
<h4 id="1型文法-上下文有关文法"><a href="#1型文法-上下文有关文法" class="headerlink" title="1型文法: 上下文有关文法"></a>1型文法: 上下文有关文法</h4><p>1型文法在0型文法上加了一条限制: 对P中每一个产生式a-&gt;b都有$\vert a \vert \ge \vert b \vert$  </p>
<p>一个1型文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: 对P中任意一个产生式a-&gt;b都有$\vert a \vert \ge \vert b \vert$  </p>
</blockquote>
</li>
</ul>
<p>每一个1型文法都等价于这样一个文法(证明略),它的产生式形如<br>$$ uAv \to u \alpha v $$  </p>
<blockquote>
<p>这里$ A \in V, u,v \in (V \cup T)^* ,\alpha \ne \epsilon$  </p>
</blockquote>
<p>也就是说,在这种文法中,替换变元时必须考虑它的上下文,才能把$A$换成$\alpha$  </p>
<p>因此,1型文法又叫做上下文有关文法,若$L-\lbrace \epsilon \rbrace$可由1型文法生成,则L称作1型语言或上下文有关语言(1型文法本身不能生成$\epsilon$)</p>
<h4 id="2型文法-上下文无关文法"><a href="#2型文法-上下文无关文法" class="headerlink" title="2型文法: 上下文无关文法"></a>2型文法: 上下文无关文法</h4><p>2型文法在1型文法的基础上又做了一些限制(令上文中的$u,v = \epsilon$)</p>
<p>一个2型文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: $ A \to \alpha $; 其中$A \in V, \alpha \in (V\cup T)^*$ <em>(0型文法是$A \in (V\cup T)^*$)</em>  </p>
</blockquote>
</li>
</ul>
<p>此时,在这种文法中,替换变元时不需要考虑它的上下文</p>
<p>因此,2型文法又称作上下文无关文法,2型文法生成的语言称作2型语言或上下文无关语言</p>
<h4 id="3型文法-正则文法"><a href="#3型文法-正则文法" class="headerlink" title="3型文法: 正则文法"></a>3型文法: 正则文法</h4><p>3型文法在2型文法的基础上做了更多的限制,其分为右线性文法和左线性文法</p>
<p>一个<strong>右线性文法</strong>是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: $ A \to \alpha B $或$ A \to \alpha $; 其中$A,B \in V, \alpha \in T^*$ <em>(注意符号所属范围)</em></p>
</blockquote>
</li>
</ul>
<p>一个<strong>左线性文法</strong>是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: $ A \to B \alpha $或$ A \to \alpha $; 其中$A,B \in V, \alpha \in T^*$  </p>
</blockquote>
</li>
</ul>
<p>右线性文法和左线性文法统称做3型文法或正则文法,3型文法生成的语言称作3型语言或正则语言  </p>
<p>可以证明的是,每一个右线性文法都存在与之等价的左线性文法,反之亦然; 即每一个正则语言都可以同时用右线性文法和左线性文法生成</p>
<h4 id="几种形式文法生成的语言类之间的关系"><a href="#几种形式文法生成的语言类之间的关系" class="headerlink" title="几种形式文法生成的语言类之间的关系"></a>几种形式文法生成的语言类之间的关系</h4><p>这几种语言类之间存在着真包含关系</p>
<ul>
<li>正则语言是上下文无关语言</li>
<li>上下文无关语言是上下文有关语言</li>
<li>上下文有关语言是0型语言</li>
</ul>
<p>在编译原理中,词法分析可以用正则文法解决,而语法分析使用上下文无关文法</p>
<p>注: 在正则文法和上下文无关文法中,当同一个符号作为多个产生式的左端时,可以用”或”<code>|</code>来合在一起写</p>
<h2 id="图灵机TM"><a href="#图灵机TM" class="headerlink" title="图灵机TM"></a>图灵机TM</h2><p>图灵机是图灵于1936年提出的一种数学模型, 这个模型很好地描述了计算的过程. 大量事实表明, 任何算法都可以用一个图灵机来描述, 这就是Chruch论题.  </p>
<p>图灵机在可计算性理论中起着重要的作用, 可以证明, 图灵机识别的语言是0型语言</p>
<h3 id="图灵机的基本模型"><a href="#图灵机的基本模型" class="headerlink" title="图灵机的基本模型"></a>图灵机的基本模型</h3><p>设想图灵机由一个控制器和一条无穷长的纸带组成,纸带分成了一个一个的小方格，每个方格有不同的颜色。有一个机器头在纸带上移来移去。机器头有一组内部状态，还有一些固定的程序。在每个时刻，机器头都要从当前纸带上读入一个方格信息，然后结合自己的内部状态查找程序表，根据程序输出信息到纸带方格上，并转换自己的内部状态，然后进行移动, 如下图:<br><img src="/2020/03/04/formal-language-and-automata/TM0.jpg" alt="TM"></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>图灵机是一个有序组$M = &lt;Q, \Sigma, \Gamma, \delta, q_0, B, A&gt;$, 其中</p>
<ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\Gamma$是非空有穷的带字母表且$\Sigma \subset \Gamma$</li>
<li>$\delta$为一个$Q \times \Gamma \to \Gamma \times \lbrace L, R \rbrace \times Q$的映射,是动作函数</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$B \in \Gamma - \Sigma$是空白符</li>
<li>$A \subset Q$是接收状态的集合<blockquote>
<p>对于$\delta$, 给定当前状态$q$和当前位置的符号$s$,它能将当前位置的符号改为$s’$、并且给出扫描头移动方向和次态$q’$; 即$\delta (q,s) = (s’, L/R, q’)$</p>
</blockquote>
</li>
</ul>
<p>显然,对于每一步计算,带上只有穷个方格的内容是非空白符,因此,纸带可以表示为$$Ba_1a_2…a_nB$$即两边都有无穷多个空白符的形式  </p>
<p>给定了图灵机M和纸带,为了描述计算中的每一步,这里又有一些定义:</p>
<ul>
<li><p>格局: 计算中某一步时带上的内容、控制器的状态和读写头扫视的带方格称为M的一个格局</p>
<blockquote>
<p>一般地,一个格局总可以表示成$\alpha_1 q \alpha_2$, 其中$\alpha_1, \alpha_2 \in \Gamma, q \in Q$<br>这表示带上的内容为$\alpha_1 \alpha_2$, 当前状态为$q$, 读写头正在扫视$\alpha_2$的第一个字符(若$\alpha_2$是空串则扫视紧挨在右边的空白符)   </p>
<ul>
<li>$q_0\omega$是M的初始格局,$\omega \in \Sigma^*$是输入字符串  </li>
</ul>
</blockquote>
</li>
<li><p>接受格局: $\sigma = \alpha_1 q \alpha_2$中的$q$是接收状态,即$q \in A$</p>
</li>
<li><p>停机格局: $\sigma$时对应的&amp;\delta (q,s)&amp;没有定义,即图灵机不知道接下来一步要干什么  </p>
</li>
<li><p>$\vdash$: 设$\sigma_1, \sigma_2$是两个格局, 如果从$\sigma_1$经过一步到达$sigma_2$,则记作$\sigma_1\vdash\sigma_2$</p>
</li>
<li><p>$\dot \vdash$: 设$\sigma_1, \sigma_2$是两个格局, 如果从$\sigma_1$经过有限步到达$sigma_2$,则记作$\sigma_1\dot\vdash\sigma_2$  </p>
</li>
<li><p>计算: 一个格局序列$\sigma_1,\sigma_2,…,\sigma_n,…$(可以有穷也可以无穷)中每一个$\sigma_{i+1}$都能由$\sigma_i$一步得到,则称这个序列是一个计算</p>
</li>
</ul>
<h3 id="图灵机接受的语言"><a href="#图灵机接受的语言" class="headerlink" title="图灵机接受的语言"></a>图灵机接受的语言</h3><p>任给一个字符串$\omega$,从初始格局开始,图灵机M在字符串上的计算有如下三种可能:</p>
<ul>
<li>停机在接受状态,此时称图灵机M接受字符串$\omega$</li>
<li>婷机在非接受状态,此时图灵机M不接受或拒绝字符串$\omega$</li>
<li>用不停机,此时也称图灵机M不接受或拒绝字符串$\omega$</li>
</ul>
<p>则图灵机M接受的语言L(M)可定义为:<br>$$L(M) = \lbrace \omega | \omega \in \Sigma^* , M接受\omega \rbrace$$</p>
<h3 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h3><p>状态转移图是一个有向图,每一个节点代表一个状态; 初始状态用一个指向该节点的箭头标明, 终结状态用双圈标明; 边上应注明状态转换时的输入/输出</p>
<p>例如:<br><img src="/2020/03/04/formal-language-and-automata/TM1.png" alt="TM"></p>
<ul>
<li>状态转移图有时候也可以用状态转移表表示</li>
</ul>
<h3 id="用图灵机计算函数"><a href="#用图灵机计算函数" class="headerlink" title="用图灵机计算函数"></a>用图灵机计算函数</h3><p>NaN</p>
<h2 id="线性界限自动机LBA"><a href="#线性界限自动机LBA" class="headerlink" title="线性界限自动机LBA"></a>线性界限自动机LBA</h2><p>线性界限自动机(Linear Bounded Automaton)是有限制的图灵机; 它不使用无限纸带，它的纸带有同输入符号数目成正比的空间  </p>
<p>可以证明,LBA 接受上下文有关语言</p>
<h2 id="下推自动机PDA"><a href="#下推自动机PDA" class="headerlink" title="下推自动机PDA"></a>下推自动机PDA</h2><p>下推自动机(Pushdown Automation)可以看成是一个带有附加下推存储器的有穷自动机,下推存储器是一个堆栈,如下:<br><img src="/2020/03/04/formal-language-and-automata/PDA0.png" alt="PDA"></p>
<p>如果把下推自动机扩展，允许一个有限状态自动机存取两个栈，我们得到一个能力更强的自动机，这个自动机与图灵机等价</p>
<h2 id="有穷自动机FA"><a href="#有穷自动机FA" class="headerlink" title="有穷自动机FA"></a>有穷自动机FA</h2><p>有穷自动机(Finity Automation)是具有离散输入和输出系统的一种数学模型,它有有限个内部状态.随着信号的输入,内部状态不断地转移</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>有穷自动机(FA)是一个有序五元组$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$, 其中</p>
<ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times \Sigma \to Q$上的映射,是状态转移函数</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是终结状态集合</li>
</ul>
<p>为了精确描述有穷自动机在输入字符串上的动作,我们推广状态转移函数为$\hat \delta : Q \times \Sigma^* to Q $如下</p>
<blockquote>
<p>对任意的$q \in Q, \omega \in \Sigma^*, a \in \Sigma$都有:<br>$$\hat \delta (q, \epsilon) = q$$  $$\hat \delta (q, \omega a) = \delta (\hat \delta (q, \omega), a)$$<br>即$\hat \delta (q, \omega)$正好是自动机从状态$q$开始扫描完$\omega$所有符号后所处的状态</p>
</blockquote>
<h3 id="有穷自动机接受的语言"><a href="#有穷自动机接受的语言" class="headerlink" title="有穷自动机接受的语言"></a>有穷自动机接受的语言</h3><p>有穷自动机$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$接受的语言$L(M)$为:<br>$$L(M) = \lbrace \omega | \omega \in \Sigma^* , \hat \delta (q_0, \omega) \in F \rbrace$$</p>
<p>由$\delta$定义可知,对于一个确定的状态$q$和输入$a$,输出的次态是唯一的,所以FA在给定字符串上的动作是确定的; 因此上面讲的有穷自动机又叫确定型有穷自动机(DFA)</p>
<h3 id="非确定型有穷自动机NFA"><a href="#非确定型有穷自动机NFA" class="headerlink" title="非确定型有穷自动机NFA"></a>非确定型有穷自动机NFA</h3><p>若在有穷自动机中,FA在输入字符串上的动作是不确定的,那么这种自动机叫做非确定型有穷自动机</p>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>非确定型有穷自动机是一个有序五元组$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$, 其中</p>
<ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times \Sigma \to \rho(Q)$上的映射,$\rho(Q)$表示Q的幂集</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是终结状态集合<br>这样,$\delta (q, a)$就是一个状态集合,它可以含有一个或多个状态,也可以是空集</li>
</ul>
<p>类似地,我们将$\delta$推广成$\hat \delta : Q \times \Sigma^* to \rho(Q)$:</p>
<blockquote>
<p>对任意的$q \in Q, \omega \in \Sigma^*, a \in \Sigma$都有:<br>$$\hat \delta (q, \epsilon) = \lbrace q \rbrace$$  $$\hat \delta (q, \omega a) =\bigcup_{r \in \hat \delta (q, \omega)} \hat \delta (r, a)$$<br>此时$\hat \delta (q, \omega)$表示的是从状态$q$开始扫描完$\omega$所有符号后所有可能的结束状态的集合</p>
</blockquote>
<h4 id="NFA接受的语言"><a href="#NFA接受的语言" class="headerlink" title="NFA接受的语言"></a>NFA接受的语言</h4><p>非确定型有穷自动机$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$接受的语言$L(M)$为:<br>$$L(M) = \lbrace \omega | \omega \in \Sigma^* , \hat \delta (q_0, \omega) \cap F \ne \emptyset \rbrace$$</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>每一个DFA都可以看成一个特殊的NFA,只要把$\hat \delta (q, \epsilon) = q$看成$\hat \delta (q, \epsilon) = \lbrace q \rbrace$即可  </li>
</ul>
<p>实际上,相比于DFA,非确定性并没有增加NFA的能力,正如下面所述:</p>
<ul>
<li>对每一个非确定型有穷自动机$M$,都存在一个确定型有穷自动机$M’$,使得$L(M) = L(M’)$(证明略)  </li>
</ul>
<p>这种转换方式在此不做介绍</p>
<h3 id="带-epsilon-转移的非确定型有穷自动机"><a href="#带-epsilon-转移的非确定型有穷自动机" class="headerlink" title="带$\epsilon$转移的非确定型有穷自动机"></a>带$\epsilon$转移的非确定型有穷自动机</h3><p>对NFA稍加推广,不仅对$\Sigma$中的每一个符号都可以有状态转移, 而且在不读入任何符号(或者说读入空串$\epsilon$)的情况下,自动机在某些状态下也可以自动转移到另一个状态, 这样的NFA称为带$\epsilon$转移的NFA</p>
<h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>带$\epsilon$转移的非确定型有穷自动机是一个有序五元组$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$, 其中</p>
<ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times (\Sigma \cup \lbrace \epsilon \rbrace) \to \rho(Q)$上的映射,$\rho(Q)$表示Q的幂集</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是终结状态集合</li>
</ul>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul>
<li>NFA可以看成是特殊的带$\epsilon$转移的NFA  </li>
</ul>
<p>实际上,带$\epsilon$转移也没有增加NFA的能力:</p>
<ul>
<li>对每一个带$\epsilon$转移的非确定型有穷自动机$M$,都存在一个非确定型有穷自动机$M’$,使得$L(M) = L(M’)$(证明略)  </li>
</ul>
<p>可见,DFA、NFA、带$\epsilon$转移的NFA这三种自动机模型是等价的</p>
<h3 id="有穷自动机和正则文法的等价性"><a href="#有穷自动机和正则文法的等价性" class="headerlink" title="有穷自动机和正则文法的等价性"></a>有穷自动机和正则文法的等价性</h3><ul>
<li>模拟是证明两个计算模型等价的主要方法; 用模型A模拟模型B,就是用模型A实现模型B的计算  </li>
</ul>
<p>可以证明,有穷自动机识别的语言类型恰好是正则语言:</p>
<ul>
<li>对每一个正则语言L,都存在一个带$\epsilon$转移的非确定型有穷自动机$M$使得$L(M) = L$</li>
<li>对每一个带$\epsilon$转移的非确定型有穷自动机$M$,都存在一个右线性文法$G$和左线性文法$G’$使得$L(G) = L(G’)=L(M)$</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown中的公式编辑</title>
    <url>/2020/03/04/markdown-formula-editor/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h3><p>正文(inline)中的LaTeX公式用<code>$...$</code>定义</p>
<p>例如<code>$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$</code></p>
<p>显示为$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$</p>
<h3 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h3><p>单独显示(display)的LaTeX公式用<code>$$...$$</code>定义，此时公式居中并放大显示  </p>
<p>例如<code>$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$</code>   </p>
<p>显示为$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$ </p>
<a id="more"></a>

<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">显示</th>
<th align="center">命令</th>
<th align="center">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\alpha</td>
<td align="center">$\alpha$</td>
<td align="center">A</td>
<td align="center">$A$</td>
</tr>
<tr>
<td align="center">\beta</td>
<td align="center">$\beta$</td>
<td align="center">B</td>
<td align="center">$B$</td>
</tr>
<tr>
<td align="center">\gamma</td>
<td align="center">$\gamma$</td>
<td align="center">\Gamma</td>
<td align="center">$\Gamma$</td>
</tr>
<tr>
<td align="center">\delta</td>
<td align="center">$\delta$</td>
<td align="center">\Delta</td>
<td align="center">$\Delta$</td>
</tr>
<tr>
<td align="center">\epsilon</td>
<td align="center">$\epsilon$</td>
<td align="center">E</td>
<td align="center">$E$</td>
</tr>
<tr>
<td align="center">\zeta</td>
<td align="center">$\zeta$</td>
<td align="center">Z</td>
<td align="center">$Z$</td>
</tr>
<tr>
<td align="center">\eta</td>
<td align="center">$\eta$</td>
<td align="center">H</td>
<td align="center">$H$</td>
</tr>
<tr>
<td align="center">\theta</td>
<td align="center">$\theta$</td>
<td align="center">\Theta</td>
<td align="center">$\Theta$</td>
</tr>
<tr>
<td align="center">\iota</td>
<td align="center">$\iota$</td>
<td align="center">I</td>
<td align="center">$I$</td>
</tr>
<tr>
<td align="center">\kappa</td>
<td align="center">$\kappa$</td>
<td align="center">K</td>
<td align="center">$K$</td>
</tr>
<tr>
<td align="center">\lambda</td>
<td align="center">$\lambda$</td>
<td align="center">\Lambda</td>
<td align="center">$\Lambda$</td>
</tr>
<tr>
<td align="center">\mu</td>
<td align="center">$\mu$</td>
<td align="center">M</td>
<td align="center">$M$</td>
</tr>
<tr>
<td align="center">\nu</td>
<td align="center">$\nu$</td>
<td align="center">N</td>
<td align="center">$N$</td>
</tr>
<tr>
<td align="center">\xi</td>
<td align="center">$\xi$</td>
<td align="center">\Xi</td>
<td align="center">$\Xi$</td>
</tr>
<tr>
<td align="center">\omicron</td>
<td align="center">$\omicron$</td>
<td align="center">O</td>
<td align="center">$O$</td>
</tr>
<tr>
<td align="center">\pi</td>
<td align="center">$\pi$</td>
<td align="center">\Pi</td>
<td align="center">$\Pi$</td>
</tr>
<tr>
<td align="center">\rho</td>
<td align="center">$\rho$</td>
<td align="center">P</td>
<td align="center">$P$</td>
</tr>
<tr>
<td align="center">\sigma</td>
<td align="center">$\sigma$</td>
<td align="center">\Sigma</td>
<td align="center">$\Sigma$</td>
</tr>
<tr>
<td align="center">\tau</td>
<td align="center">$\tau$</td>
<td align="center">T</td>
<td align="center">$T$</td>
</tr>
<tr>
<td align="center">\upsilon</td>
<td align="center">$\upsilon$</td>
<td align="center">Y</td>
<td align="center">$Y$</td>
</tr>
<tr>
<td align="center">\phi</td>
<td align="center">$\phi$</td>
<td align="center">\Phi</td>
<td align="center">$\Phi$</td>
</tr>
<tr>
<td align="center">\chi</td>
<td align="center">$\chi$</td>
<td align="center">X</td>
<td align="center">$X$</td>
</tr>
<tr>
<td align="center">\psi</td>
<td align="center">$\psi$</td>
<td align="center">\Psi</td>
<td align="center">$\Psi$</td>
</tr>
<tr>
<td align="center">\omega</td>
<td align="center">$\omega$</td>
<td align="center">\Omega</td>
<td align="center">$\Omega$</td>
</tr>
</tbody></table>
<h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>上标和下标分别使用<code>^</code>与<code>_</code>，例如<code>$x_i^2$</code>表示的是$x_i^2$  </p>
<p>默认情况下, 上下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>{..}</code> 包裹起来的内容。如果使用<code>$10^10$</code>表示的是$10^10$;而<code>$10^{10}$</code>才是$10^{10}$。同时,大括号还能消除二义性，如<code>x^5^6</code> 将得到一个错误，必须使用大括号来界定^的结合性，如<code>${x^5}^6$</code>:${x^5}^6$或者<code>$x^{5^6}$</code>:$x^{5^6}$。</p>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>使用原始的<code>( )</code>,<code>[ ]</code> 即可，如<code>$(2+3)[4+4]$</code>:$(2+3)[4+4]$<br>使用\left(或\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\left(\frac{x}{y}\right)$</code>:$\left(\frac{x}{y}\right)$</p>
<p>以下转载<a href="https://www.jianshu.com/p/8b6fc36035c0" target="_blank" rel="noopener">https://www.jianshu.com/p/8b6fc36035c0</a></p>
<!DOCTYPE html>
<html lang="en">
<head>
<title></title>
  <meta name="generator" content="hexo-theme-yilia-plus">
<style>
body, html {
    width: 100%;
    height: 100%;
}
*, ::after, ::before {
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
article, aside, dialog, figcaption, figure, footer, header, hgroup, main, nav, section {
    display: block;
}
._2rhmJa {
    font-weight: 400;
    line-height: 1.8;
    margin-bottom: 20px;
    padding-right: 50px;
}
._3Z3nHf, .ouvJEz {
    background-color: #fff;
    border-radius: 4px;
    margin-bottom: 10px;
}
.ouvJEz {
    padding: 24px;
}
._gp-ck {
    flex-shrink: 0;
    width: 730px;
    margin-bottom: 24px;
    margin-right: 10px;
}
._3VRLsv {
    box-sizing: content-box;
    padding-left: 16px;
    padding-right: 1000px;
    margin-left: auto;
    margin-right: auto;
}
._3VRLsv {
    justify-content: center;
    align-items: flex-start;
    min-height: calc(-66px + 100vh);
}
._3kbg6I {
    background-color: #f9f9f9;
}
body {
    margin: 0;
    color: rgba(0, 0, 0, 0.65);
    font-size: 14px;
    font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","PingFang SC","Hiragino Sans GB","Microsoft YaHei","Helvetica Neue",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
    line-height: 1.5;
    -webkit-font-feature-settings: "tnum","tnum";
    font-feature-settings: "tnum" 1, "tnum" 1;
}
body {
    line-height: 1.4285;
    color: #404040;
    background-color: #fff;
    font-family: -apple-system,BlinkMacSystemFont,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Segoe UI","PingFang SC","Hiragino Sans GB","Microsoft YaHei","Helvetica Neue",Helvetica,Arial,sans-serif;
    font-feature-settings: "tnum" 1;
    font-variant: tabular-nums;
}
html {
    font-family: sans-serif;
    line-height: 1.15;
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
    -ms-overflow-style: scrollbar;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
html {
    --antd-wave-shadow-color: #ec7259;
}
p {
    margin-top: 0px;
    margin-bottom: 1em;
}
._2rhmJa p {
    margin-bottom: 20px;
    word-break: break-word;
}
hr {
    -webkit-box-sizing: content-box;
    box-sizing: content-box;
    height: 0px;
    overflow: visible;
}
._2rhmJa hr {
    margin: 0 0 20px;
    border: 0;
    border-top: 1px solid #eee !important;
}
table {
    border-collapse: collapse;
}
._2rhmJa table {
    width: 100%;
    margin-bottom: 20px;
    border-collapse: collapse;
    border: 1px solid #eee;
    border-left: none;
    word-break: break-word;
}
h1, h2, h3, h4, h5, h6 {
    margin-top: 0px;
    margin-bottom: 0.5em;
    color: rgba(0, 0, 0, 0.85);
    font-weight: 500;
}
b, strong {
    font-weight: bolder;
}
b, h1, h2, h3, h4, h5, h6, strong {
    font-weight: 600;
}
h1, h2, h3, h4, h5, h6 {
    color: #404040;
    text-rendering: optimizelegibility;
}
._2rhmJa h1, ._2rhmJa h2, ._2rhmJa h3, ._2rhmJa h4, ._2rhmJa h5, ._2rhmJa h6 {
    margin-bottom: 16px;
}
._2rhmJa h2 {
    font-size: 24px;
}
dl, ol, ul {
    margin-top: 0px;
    margin-bottom: 1em;
}
ol, ul {
    padding-left: 0px;
    margin: 0;
    list-style: none;
}
ol ol, ol ul, ul ol, ul ul {
    margin-bottom: 0px;
}
._2rhmJa ol, ._2rhmJa ul {
    word-break: break-word;
    margin: 0 0 20px 20px;
}
._2rhmJa ul {
    list-style-type: disc;
}
._2Uzcx_ {
    position: relative;
    overflow: hidden;
}
._2rhmJa h3 {
    font-size: 22px;
}
._2rhmJa ol {
    list-style-type: decimal;
}
._2rhmJa table tr:nth-of-type(2n) {
    background-color: hsla(0, 0%, 70%, 0.15);
}
th {
    text-align: inherit;
}
._2rhmJa table td, ._2rhmJa table th {
    padding: 8px;
    border: 1px solid #eee;
    line-height: 20px;
    vertical-align: middle;
}
a {
    color: #ec7259;
    text-decoration: none;
    background-color: transparent;
    outline: none;
    cursor: pointer;
    -webkit-transition: color .3s;
    transition: color .3s;
    -webkit-text-decoration-skip: objects;
}
[role=button], a, area, button, input:not([type=range]), label, select, summary, textarea {
    -ms-touch-action: manipulation;
    touch-action: manipulation;
}
a {
    color: #0681d0;
}
code, kbd, pre, samp {
    font-size: 1em;
    font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
pre {
    margin-top: 0px;
    margin-bottom: 1em;
    overflow: auto;
}
._2rhmJa code {
    padding: 2px 4px;
    border: none;
    vertical-align: middle;
    white-space: pre-wrap;
}
code[class*=language-], pre[class*=language-] {
    color: #ccc;
    background: none;
    font-family: Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;
    font-size: 1em;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}
pre[class*=language-] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}
:not(pre) > code[class*=language-], pre[class*=language-] {
    background: #2d2d2d;
}
._2rhmJa code, ._2rhmJa pre, ._2rhmJa pre[class*=language-] {
    font-family: Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;
    font-size: 12px;
}
._2rhmJa pre, ._2rhmJa pre[class*=language-] {
    word-wrap: normal;
    word-break: break-all;
    white-space: pre;
    overflow-x: scroll;
    overscroll-behavior-x: contain;
    margin-top: 0px;
    margin-bottom: 20px;
    border-radius: 4px;
    z-index: 0;
    padding: 1em;
    line-height: 1.5;
    color: #ccc;
    background: #2d2d2d;
}
._2rhmJa :not(pre) code {
    color: #c7254e;
    background-color: #f2f2f2;
}
._2rhmJa table th {
    font-weight: bold;
}
._2rhmJa table thead th {
    vertical-align: middle;
    text-align: inherit;
}
img {
    vertical-align: middle;
    border-style: none;
}
._2rhmJa img {
    max-width: 100%;
}
._2rhmJa [mathimg='1'].math-inline {
    display: inline;
    margin: 0 3px;
    vertical-align: middle;
}
._2rhmJa [mathimg='1'].math-block {
    display: block;
    margin: 1em auto;
}
._2rhmJa [mathimg='1'].math-block, ._2rhmJa [mathimg='1'].math-inline {
    max-width: 100%;
}
button, input, optgroup, select, textarea {
    margin: 0;
    color: inherit;
    font-size: inherit;
    font-family: inherit;
    line-height: inherit;
}
button, input {
    overflow: visible;
}
button, select {
    text-transform: none;
}
.VJbwyy {
    position: absolute;
    top: 6px;
    right: 6px;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 32px;
    height: 24px;
    cursor: pointer;
    font-size: 14px;
    padding: 0;
    border: none;
    border-radius: 6px;
    color: #ccc;
    background-color: hsla(0, 0%, 90%, 0.2);
    box-shadow: 0px 2px 0px 0px rgba(0,0,0,0.25);
    opacity: 0;
    visibility: hidden;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    transition: opacity .2s ease-in-out,visibility .2s ease-in-out;
    z-index: 1;
}
[type=reset], [type=submit], button, html [type=button] {
    -webkit-appearance: button;
}
[role=button], button {
    cursor: pointer;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
pre[class*=language-].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}
._2rhmJa pre[class*=language-] code, ._2rhmJa pre code {
    padding: 0;
    background-color: transparent;
    color: inherit;
    white-space: pre;
    vertical-align: unset;
}
pre[class*=language-].line-numbers > code {
    position: relative;
    white-space: inherit;
}
.token.atrule, .token.builtin, .token.important, .token.keyword, .token.selector {
    color: #cc99cd;
}
.token.punctuation {
    color: #ccc;
}
.token.entity, .token.operator, .token.url {
    color: #67cdcc;
}
.token.boolean, .token.function, .token.number {
    color: #f08d49;
}
.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0px;
    font-size: 100%;
    left: -3.8em;
    width: 3em;
    letter-spacing: -1px;
    border-right: 1px solid #999;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
.line-numbers-rows > span {
    pointer-events: none;
    display: block;
    counter-increment: linenumber;
}
.anticon {
    display: inline-block;
    color: inherit;
    font-style: normal;
    line-height: 0;
    text-align: center;
    text-transform: none;
    vertical-align: -0.12em;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
.anticon > * {
    line-height: 1;
}
svg:not(:root) {
    overflow: hidden;
}
.anticon svg {
    display: inline-block;
}
._2rhmJa ol li, ._2rhmJa ul li {
    line-height: 30px;
}
.token.class-name, .token.constant, .token.property, .token.symbol {
    color: #f8c555;
}
.token.attr-value, .token.char, .token.regex, .token.string, .token.variable {
    color: #7ec699;
}
._2rhmJa ol li ol, ._2rhmJa ol li ul, ._2rhmJa ul li ol, ._2rhmJa ul li ul {
    margin-top: 16px;
}
</style>
</head>
<body><div id="__next"><div class="_21bLU4 _3kbg6I"><div class="_3VRLsv" role="main"><div class="_gp-ck"><section class="ouvJEz"><article class="_2rhmJa">
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">Author</th>
<th style="text-align:left">shaniadolphin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">e-mail</td>
<td style="text-align:left"><a href="mailto:349948204@qq.com" target="_blank" rel="nofollow">349948204@qq.com</a></td>
</tr>
<tr>
<td style="text-align:center">github</td>
<td style="text-align:left"><a href="https://github.com/shaniadolphin/" target="_blank" rel="nofollow">https://github.com/shaniadolphin/</a></td>
</tr>
</tbody>
</table>
<h3>大括号</h3>
<p>  由于大括号<code>{}</code> 被用于分组，因此需要使用<code>\{</code>和<code>\}</code>表示大括号，也可以使用<code>\lbrace</code> 和<code>\rbrace</code>来表示。如<code>$\{a\*b\}:a\∗b$</code> 或<code>$\lbrace a\*b\rbrace :a\*b$</code> 表示<img class="math-inline" alt="\{a*b\}:a∗b" src="https://math.jianshu.com/math?formula=%5C%7Ba*b%5C%7D%3Aa%E2%88%97b" mathimg="1">。</p>
<h3>尖括号</h3>
<p>  区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<code>$\langle x \rangle$</code> 表示：<img class="math-inline" alt="\langle x \rangle" src="https://math.jianshu.com/math?formula=%5Clangle%20x%20%5Crangle" mathimg="1">。</p>
<h3>上取整</h3>
<p>  使用<code>\lceil</code> 和 <code>\rceil</code> 表示。 如，<code>$\lceil x \rceil$</code>：<img class="math-inline" alt="\lceil x \rceil" src="https://math.jianshu.com/math?formula=%5Clceil%20x%20%5Crceil" mathimg="1">。</p>
<h3>下取整</h3>
<p>  使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示。如，<code>$\lfloor x \rfloor$</code>：<img class="math-inline" alt="\lfloor x \rfloor" src="https://math.jianshu.com/math?formula=%5Clfloor%20x%20%5Crfloor" mathimg="1">。</p>
<h2><strong>求和与积分</strong></h2>
<h3>求和</h3>
<p>  <code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br>
  <code>$\sum_{r=1}^n$</code>表示：<img class="math-inline" alt="\sum_{r=1}^n" src="https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En" mathimg="1">。<br>
  <code>$$\sum_{r=1}^n$$</code>表示：<img class="math-block" alt="\sum_{r=1}^n" src="https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En" mathimg="1"></p>
<h3>积分</h3>
<p>  <code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\int_{r=1}^\infty$</code>：<img class="math-inline" alt="\int_{r=1}^\infty" src="https://math.jianshu.com/math?formula=%5Cint_%7Br%3D1%7D%5E%5Cinfty" mathimg="1">。<br>
  多重积分同样使用 <strong>int</strong> ，通过 <strong>i</strong> 的数量表示积分导数：<br>
  <code>$\iint$</code> ：<img class="math-inline" alt="\iint" src="https://math.jianshu.com/math?formula=%5Ciint" mathimg="1"><br>
  <code>$\iiint$</code> ：<img class="math-inline" alt="\iiint" src="https://math.jianshu.com/math?formula=%5Ciiint" mathimg="1"><br>
  <code>$\iiiint$</code> ：<img class="math-inline" alt="\iiiint" src="https://math.jianshu.com/math?formula=%5Ciiiint" mathimg="1"></p>
<h3>连乘</h3>
<p>  <code>$\prod {a+b}$</code>，输出：<img class="math-inline" alt="\prod {a+b}" src="https://math.jianshu.com/math?formula=%5Cprod%20%7Ba%2Bb%7D" mathimg="1">。<br>
  <code>$\prod_{i=1}^{K}$</code>，输出：<img class="math-inline" alt="\prod_{i=1}^{K}" src="https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D" mathimg="1">。<br>
  <code>$$\prod_{i=1}^{K}$$</code>，输出：<img class="math-inline" alt="\prod_{i=1}^{K}" src="https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D" mathimg="1">。</p>
<h3>其他</h3>
<p>  与此类似的符号还有，<br>
  <code>$\prod$</code> ：<img class="math-inline" alt="\prod" src="https://math.jianshu.com/math?formula=%5Cprod" mathimg="1"><br>
  <code>$\bigcup$</code> ：<img class="math-inline" alt="\bigcup" src="https://math.jianshu.com/math?formula=%5Cbigcup" mathimg="1"><br>
  <code>$\bigcap$</code> ：<img class="math-inline" alt="\bigcap" src="https://math.jianshu.com/math?formula=%5Cbigcap" mathimg="1"><br>
  <code>$arg\,\max_{c_k}$</code>：<img class="math-inline" alt="arg\,\max_{c_k}" src="https://math.jianshu.com/math?formula=arg%5C%2C%5Cmax_%7Bc_k%7D" mathimg="1"><br>
  <code>$arg\,\min_{c_k}$</code>：<img class="math-inline" alt="arg\,\min_{c_k}" src="https://math.jianshu.com/math?formula=arg%5C%2C%5Cmin_%7Bc_k%7D" mathimg="1"><br>
  <code>$\mathop {argmin}_{c_k}$</code>：<img class="math-inline" alt="\mathop {argmin}_{c_k}" src="https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmin%7D_%7Bc_k%7D" mathimg="1"><br>
  <code>$\mathop {argmax}_{c_k}$</code>：<img class="math-inline" alt="\mathop {argmax}_{c_k}" src="https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmax%7D_%7Bc_k%7D" mathimg="1"><br>
  <code>$\max_{c_k}$</code>：<img class="math-inline" alt="\max_{c_k}" src="https://math.jianshu.com/math?formula=%5Cmax_%7Bc_k%7D" mathimg="1"><br>
  <code>$\min_{c_k}$</code>：<img class="math-inline" alt="\min_{c_k}" src="https://math.jianshu.com/math?formula=%5Cmin_%7Bc_k%7D" mathimg="1"></p>
<h2><strong>分式与根式</strong></h2>
<h3>分式</h3>
<ul>
<li>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a</code> ，<code>b</code> ，结果为<img class="math-inline" alt="\frac ab" src="https://math.jianshu.com/math?formula=%5Cfrac%20ab" mathimg="1">。如果你的分子或分母不是单个字符，请使用<code>{..}</code>来分组，比如<code>$\frac {a+c+1}{b+c+2}$</code>表示<img class="math-inline" alt="\frac {a+c+1}{b+c+2}" src="https://math.jianshu.com/math?formula=%5Cfrac%20%7Ba%2Bc%2B1%7D%7Bb%2Bc%2B2%7D" mathimg="1">。</li>
<li>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>{a+1\over b+1}</code>：<img class="math-inline" alt="{a+1\over b+1}" src="https://math.jianshu.com/math?formula=%7Ba%2B1%5Cover%20b%2B1%7D" mathimg="1">
</li>
</ul>
<h3>连分数</h3>
<p>  书写连分数表达式时，请使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>两者效果对比如下：<br>
  <code>\frac</code> 表示如下：</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby"><span class="token variable">$$x</span><span class="token operator">=</span>a_0 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_1 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_2 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_3 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_4 <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>$$
<span class="line-numbers-rows" aria-hidden="true"><span></span></span></code></pre></div>
<p>  显示如下：<br>
<img class="math-block" alt="x=a_0 + \frac {1^2}{a_1 + \frac {2^2}{a_2 + \frac {3^2}{a_3 + \frac {4^2}{a_4 + ...}}}}" src="https://math.jianshu.com/math?formula=x%3Da_0%20%2B%20%5Cfrac%20%7B1%5E2%7D%7Ba_1%20%2B%20%5Cfrac%20%7B2%5E2%7D%7Ba_2%20%2B%20%5Cfrac%20%7B3%5E2%7D%7Ba_3%20%2B%20%5Cfrac%20%7B4%5E2%7D%7Ba_4%20%2B%20...%7D%7D%7D%7D" mathimg="1"><br>
  <code>\cfrac</code> 表示如下：</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby"><span class="token variable">$$x</span><span class="token operator">=</span>a_0 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_1 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_2 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_3 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_4 <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>$$
<span class="line-numbers-rows" aria-hidden="true"><span></span></span></code></pre></div>
<p>  显示如下：<br>
<img class="math-block" alt="x=a_0 + \cfrac {1^2}{a_1 + \cfrac {2^2}{a_2 + \cfrac {3^2}{a_3 + \cfrac {4^2}{a_4 + ...}}}}" src="https://math.jianshu.com/math?formula=x%3Da_0%20%2B%20%5Ccfrac%20%7B1%5E2%7D%7Ba_1%20%2B%20%5Ccfrac%20%7B2%5E2%7D%7Ba_2%20%2B%20%5Ccfrac%20%7B3%5E2%7D%7Ba_3%20%2B%20%5Ccfrac%20%7B4%5E2%7D%7Ba_4%20%2B%20...%7D%7D%7D%7D" mathimg="1"></p>
<h3>根式</h3>
<p>  根式使用<code>\sqrt</code> 来表示。<br>
  如开4次方：<code>$\sqrt[4]{\frac xy}$</code> ：<img class="math-inline" alt="\sqrt[4]{\frac xy}" src="https://math.jianshu.com/math?formula=%5Csqrt%5B4%5D%7B%5Cfrac%20xy%7D" mathimg="1">。<br>
  开平方：<code>$\sqrt {a+b}$</code>：<img class="math-inline" alt="\sqrt {a+b}" src="https://math.jianshu.com/math?formula=%5Csqrt%20%7Ba%2Bb%7D" mathimg="1">。</p>
<h2><strong>多行表达式</strong></h2>
<h3>分类表达式</h3>
<p>  定义函数的时候经常需要分情况给出表达式，使用<code>\begin{cases}…\end{cases}</code> 。其中：</p>
<ul>
<li>  使用<code>\\</code> 来分类，</li>
<li>  使用<code>&amp;</code> 指示需要对齐的位置，</li>
<li>  使用<code>\</code> +<code>空格</code>表示空格。</li>
</ul>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
f<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
\cfrac n2<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">if</span>\ n\ is\ even\\
<span class="token number">3</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">if</span>\  n\ is\ odd
\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示:<br>
<img class="math-block" alt="f(n) \begin{cases} \cfrac n2, &amp;if\ n\ is\ even\\ 3n + 1, &amp;if\ n\ is\ odd \end{cases}" src="https://math.jianshu.com/math?formula=f(n)%20%5Cbegin%7Bcases%7D%20%5Ccfrac%20n2%2C%20%26if%5C%20n%5C%20is%5C%20even%5C%5C%203n%20%2B%201%2C%20%26if%5C%20n%5C%20is%5C%20odd%20%5Cend%7Bcases%7D" mathimg="1"></p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
<span class="token constant">L</span><span class="token punctuation">(</span><span class="token constant">Y</span><span class="token punctuation">,</span>f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span>
\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> <span class="token operator">=</span> f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  \\
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> $\neq$ f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示:<br>
<img class="math-block" alt="L(Y,f(X)) = \begin{cases} 0, &amp; \text{Y = f(X)} \\ 1, &amp; \text{Y $\neq$ f(X)} \end{cases}" src="https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D" mathimg="1"><br>
  如果想分类之间的垂直间隔变大，可以使用<code>\\[2ex]</code> 代替<code>\\</code> 来分隔不同的情况。(<code>3ex,4ex</code> 也可以用，<code>1ex</code> 相当于原始距离）。如下所示：</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
<span class="token constant">L</span><span class="token punctuation">(</span><span class="token constant">Y</span><span class="token punctuation">,</span>f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span>
\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> <span class="token operator">=</span> f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span> \\<span class="token punctuation">[</span><span class="token number">5</span>ex<span class="token punctuation">]</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> $\neq$ f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="L(Y,f(X)) = \begin{cases} 0, &amp; \text{Y = f(X)} \\[5ex] 1, &amp; \text{Y $\neq$ f(X)} \end{cases}" src="https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D" mathimg="1"></p>
<h3>多行表达式</h3>
<p>  有时候需要将一行公式分多行进行显示。</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>\<span class="token keyword">begin</span><span class="token punctuation">{</span>split<span class="token punctuation">}</span> 
a<span class="token operator">&amp;</span><span class="token operator">=</span>b<span class="token operator">+</span>c<span class="token operator">-</span>d \\ 
<span class="token operator">&amp;</span>\quad <span class="token operator">+</span>e<span class="token operator">-</span>f\\ 
<span class="token operator">&amp;</span><span class="token operator">=</span>g<span class="token operator">+</span>h\\ 
<span class="token operator">&amp;</span> <span class="token operator">=</span>i 
\<span class="token keyword">end</span><span class="token punctuation">{</span>split<span class="token punctuation">}</span>\<span class="token keyword">end</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="\begin{equation}\begin{split} a&amp;=b+c-d \\ &amp;\quad +e-f\\ &amp;=g+h\\ &amp; =i \end{split}\end{equation}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%5Cbegin%7Bsplit%7D%20a%26%3Db%2Bc-d%20%5C%5C%20%26%5Cquad%20%2Be-f%5C%5C%20%26%3Dg%2Bh%5C%5C%20%26%20%3Di%20%5Cend%7Bsplit%7D%5Cend%7Bequation%7D" mathimg="1"><br>
  其中<code>begin{equation}</code> 表示开始方程，<code>end{equation}</code> 表示方程结束；<code>begin{split}</code> 表示开始多行公式，<code>end{split}</code> 表示结束；公式中用<code>\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置。</p>
<h3>方程组</h3>
<p>  使用<code>\begin{array}...\end{array}</code> 与<code>\left \{</code> 与<code>\right.</code> 配合表示方程组:</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\left \<span class="token punctuation">{</span> 
\<span class="token keyword">begin</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span>
a_1x<span class="token operator">+</span>b_1y<span class="token operator">+</span>c_1z<span class="token operator">=</span>d_1 \\ 
a_2x<span class="token operator">+</span>b_2y<span class="token operator">+</span>c_2z<span class="token operator">=</span>d_2 \\ 
a_3x<span class="token operator">+</span>b_3y<span class="token operator">+</span>c_3z<span class="token operator">=</span>d_3
\<span class="token keyword">end</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span>
\right<span class="token punctuation">.</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="\left \{ \begin{array}{c} a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \\ a_3x+b_3y+c_3z=d_3 \end{array} \right." src="https://math.jianshu.com/math?formula=%5Cleft%20%5C%7B%20%5Cbegin%7Barray%7D%7Bc%7D%20a_1x%2Bb_1y%2Bc_1z%3Dd_1%20%5C%5C%20a_2x%2Bb_2y%2Bc_2z%3Dd_2%20%5C%5C%20a_3x%2Bb_3y%2Bc_3z%3Dd_3%20%5Cend%7Barray%7D%20%5Cright." mathimg="1"><br>
  注意：通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code> （<code>.</code>表示空格）都会显示为<code>ab</code> 。可以通过在<code>ab</code> 间加入<code>\</code> ,增加些许间隙，<code>\;</code> 增加较宽的间隙，<code>\quad</code>  与<code>\qquad</code> 会增加更大的间隙。</p>
<h2><strong>特殊函数与符号</strong></h2>
<h3>三角函数</h3>
<p>  <code>\snx$</code> : <img class="math-inline" alt="sinx" src="https://math.jianshu.com/math?formula=sinx" mathimg="1"><br>
  <code>\arctanx</code> : <img class="math-inline" alt="arctanx" src="https://math.jianshu.com/math?formula=arctanx" mathimg="1"></p>
<h3>比较运算符</h3>
<p>  小于(<code>\lt</code> )：<img class="math-inline" alt="\lt" src="https://math.jianshu.com/math?formula=%5Clt" mathimg="1"><br>
  大于(<code>\gt</code> )：<img class="math-inline" alt="\gt" src="https://math.jianshu.com/math?formula=%5Cgt" mathimg="1"><br>
  小于等于(<code>\le</code> )：<img class="math-inline" alt="\le" src="https://math.jianshu.com/math?formula=%5Cle" mathimg="1"><br>
  大于等于(<code>\ge</code> )：<img class="math-inline" alt="\ge" src="https://math.jianshu.com/math?formula=%5Cge" mathimg="1"><br>
  不等于(<code>\ne</code> ) : <img class="math-inline" alt="\ne" src="https://math.jianshu.com/math?formula=%5Cne" mathimg="1"><br>
  可以在这些运算符前面加上<code>\not</code> ，如<code>\not\lt</code> : <img class="math-inline" alt="\not\lt`" src="https://math.jianshu.com/math?formula=%5Cnot%5Clt%60" mathimg="1"></p>
<h3>集合关系与运算</h3>
<p>  并集(<code>\cup</code> ): <img class="math-inline" alt="\cup" src="https://math.jianshu.com/math?formula=%5Ccup" mathimg="1"><br>
  交集(<code>\cap</code> ): <img class="math-inline" alt="\cap" src="https://math.jianshu.com/math?formula=%5Ccap" mathimg="1"><br>
  差集(<code>\setminus</code> ): <img class="math-inline" alt="\setminus" src="https://math.jianshu.com/math?formula=%5Csetminus" mathimg="1"><br>
  子集(<code>\subset</code> ): <img class="math-inline" alt="\subset" src="https://math.jianshu.com/math?formula=%5Csubset" mathimg="1"><br>
  子集(<code>\subseteq</code> ): <img class="math-inline" alt="\subseteq" src="https://math.jianshu.com/math?formula=%5Csubseteq" mathimg="1"><br>
  非子集(<code>\subsetneq</code> ): <img class="math-inline" alt="\subsetneq" src="https://math.jianshu.com/math?formula=%5Csubsetneq" mathimg="1"><br>
  父集(<code>\supset</code> ): <img class="math-inline" alt="\supset" src="https://math.jianshu.com/math?formula=%5Csupset" mathimg="1"><br>
  属于(<code>\in</code> ): <img class="math-inline" alt="\in" src="https://math.jianshu.com/math?formula=%5Cin" mathimg="1"><br>
  不属于(<code>\notin</code> ): <img class="math-inline" alt="\notin" src="https://math.jianshu.com/math?formula=%5Cnotin" mathimg="1"><br>
  空集(<code>\emptyset</code> ): <img class="math-inline" alt="\emptyset" src="https://math.jianshu.com/math?formula=%5Cemptyset" mathimg="1"><br>
  空(<code>\varnothing</code> ): <img class="math-inline" alt="\varnothing" src="https://math.jianshu.com/math?formula=%5Cvarnothing" mathimg="1"></p>
<h3>排列</h3>
<p>  <code>\binom{n+1}{2k}</code> : <img class="math-inline" alt="\binom{n+1}{2k}" src="https://math.jianshu.com/math?formula=%5Cbinom%7Bn%2B1%7D%7B2k%7D" mathimg="1"><br>
  <code>{n+1 \choose 2k}</code> : <img class="math-inline" alt="{n+1 \choose 2k}" src="https://math.jianshu.com/math?formula=%7Bn%2B1%20%5Cchoose%202k%7D" mathimg="1"></p>
<h3>箭头</h3>
<p>  (<code>\to</code> ):<img class="math-inline" alt="\to" src="https://math.jianshu.com/math?formula=%5Cto" mathimg="1"><br>
  (<code>\rightarrow</code> ): <img class="math-inline" alt="\rightarrow" src="https://math.jianshu.com/math?formula=%5Crightarrow" mathimg="1"><br>
  (<code>\leftarrow</code> ): <img class="math-inline" alt="\leftarrow" src="https://math.jianshu.com/math?formula=%5Cleftarrow" mathimg="1"><br>
  (<code>\Rightarrow</code> ): <img class="math-inline" alt="\Rightarrow" src="https://math.jianshu.com/math?formula=%5CRightarrow" mathimg="1"><br>
  (<code>\Leftarrow</code> ): <img class="math-inline" alt="\Leftarrow" src="https://math.jianshu.com/math?formula=%5CLeftarrow" mathimg="1"><br>
  (<code>\mapsto</code> ): <img class="math-inline" alt="\mapsto" src="https://math.jianshu.com/math?formula=%5Cmapsto" mathimg="1"></p>
<h3>逻辑运算符</h3>
<p>  (<code>\land</code> ): <img class="math-inline" alt="\land" src="https://math.jianshu.com/math?formula=%5Cland" mathimg="1"><br>
  (<code>\lor</code> ): <img class="math-inline" alt="\lor" src="https://math.jianshu.com/math?formula=%5Clor" mathimg="1"><br>
  (<code>\lnot</code> ): <img class="math-inline" alt="\lnot" src="https://math.jianshu.com/math?formula=%5Clnot" mathimg="1"><br>
  (<code>\forall</code> ): <img class="math-inline" alt="\forall" src="https://math.jianshu.com/math?formula=%5Cforall" mathimg="1"><br>
  (<code>\exists</code> ): <img class="math-inline" alt="\exists" src="https://math.jianshu.com/math?formula=%5Cexists" mathimg="1"><br>
  (<code>\top</code> ): <img class="math-inline" alt="\top" src="https://math.jianshu.com/math?formula=%5Ctop" mathimg="1"><br>
  (<code>\bot</code> ): <img class="math-inline" alt="\bot" src="https://math.jianshu.com/math?formula=%5Cbot" mathimg="1"><br>
  (<code>\vdash</code> ): <img class="math-inline" alt="\vdash" src="https://math.jianshu.com/math?formula=%5Cvdash" mathimg="1"><br>
  (<code>\vDash</code> ): <img class="math-inline" alt="\vDash" src="https://math.jianshu.com/math?formula=%5CvDash" mathimg="1"></p>
<h3>操作符</h3>
<p>  (<code>\star</code> ): <img class="math-inline" alt="\star" src="https://math.jianshu.com/math?formula=%5Cstar" mathimg="1"><br>
  (<code>\ast</code> ): <img class="math-inline" alt="\ast" src="https://math.jianshu.com/math?formula=%5Cast" mathimg="1"><br>
  (<code>\oplus</code> ): <img class="math-inline" alt="\oplus" src="https://math.jianshu.com/math?formula=%5Coplus" mathimg="1"><br>
  (<code>\circ</code> ): <img class="math-inline" alt="\circ" src="https://math.jianshu.com/math?formula=%5Ccirc" mathimg="1"><br>
  (<code>\bullet</code> ): <img class="math-inline" alt="\bullet" src="https://math.jianshu.com/math?formula=%5Cbullet" mathimg="1"></p>
<h3>等于</h3>
<p>  (<code>\approx</code> ): <img class="math-inline" alt="\approx" src="https://math.jianshu.com/math?formula=%5Capprox" mathimg="1"><br>
  (<code>\sim</code> ): <img class="math-inline" alt="\sim" src="https://math.jianshu.com/math?formula=%5Csim" mathimg="1"><br>
  (<code>\equiv</code> ): <img class="math-inline" alt="\equiv" src="https://math.jianshu.com/math?formula=%5Cequiv" mathimg="1"><br>
  (<code>\prec</code> ): <img class="math-inline" alt="\prec" src="https://math.jianshu.com/math?formula=%5Cprec" mathimg="1"></p>
<h3>范围</h3>
<p>  (<code>\infty</code> ): <img class="math-inline" alt="\infty" src="https://math.jianshu.com/math?formula=%5Cinfty" mathimg="1"><br>
  (<code>\aleph_o</code> ): <img class="math-inline" alt="\aleph_o" src="https://math.jianshu.com/math?formula=%5Caleph_o" mathimg="1"><br>
  (<code>\nabla</code> ): <img class="math-inline" alt="\nabla" src="https://math.jianshu.com/math?formula=%5Cnabla" mathimg="1"><br>
  (<code>\Im</code> ): <img class="math-inline" alt="\Im" src="https://math.jianshu.com/math?formula=%5CIm" mathimg="1"><br>
  (<code>\Re</code> ): <img class="math-inline" alt="\Re" src="https://math.jianshu.com/math?formula=%5CRe" mathimg="1"></p>
<h3>模运算</h3>
<p>  (<code>\pmod</code> ): <img class="math-inline" alt="b \pmod n" src="https://math.jianshu.com/math?formula=b%20%5Cpmod%20n" mathimg="1"><br>
  如<code>a \equiv b \pmod n</code> : <img class="math-inline" alt="a \equiv b \pmod n" src="https://math.jianshu.com/math?formula=a%20%5Cequiv%20b%20%5Cpmod%20n" mathimg="1"></p>
<h3>点</h3>
<p>  (<code>\ldots</code> ): <img class="math-inline" alt="\ldots" src="https://math.jianshu.com/math?formula=%5Cldots" mathimg="1"><br>
  (<code>\cdots</code> ): <img class="math-inline" alt="\cdots" src="https://math.jianshu.com/math?formula=%5Ccdots" mathimg="1"><br>
  (<code>\cdot</code> ): <img class="math-inline" alt="\cdot" src="https://math.jianshu.com/math?formula=%5Ccdot" mathimg="1"><br>
  其区别是点的位置不同，<code>\ldots</code> 位置稍低，<code>\cdots</code> 位置居中。</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>
a_1<span class="token operator">+</span>a_2<span class="token operator">+</span>\ldots<span class="token operator">+</span>a_n \\ 
a_1<span class="token operator">+</span>a_2<span class="token operator">+</span>\cdots<span class="token operator">+</span>a_n
\<span class="token keyword">end</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="\begin{equation} a_1+a_2+\ldots+a_n \\ a_1+a_2+\cdots+a_n \end{equation}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%20a_1%2Ba_2%2B%5Cldots%2Ba_n%20%5C%5C%20a_1%2Ba_2%2B%5Ccdots%2Ba_n%20%5Cend%7Bequation%7D" mathimg="1"></p>
<h2><strong>顶部符号</strong></h2>
<p>  对于单字符，<code>\hat x</code> ：<img class="math-inline" alt="\hat x" src="https://math.jianshu.com/math?formula=%5Chat%20x" mathimg="1"><br>
  多字符可以使用<code>\widehat {xy}</code> ：<img class="math-inline" alt="\widehat {xy}" src="https://math.jianshu.com/math?formula=%5Cwidehat%20%7Bxy%7D" mathimg="1"><br>
  类似的还有:<br>
  (<code>\overline x</code> ): <img class="math-inline" alt="\overline x" src="https://math.jianshu.com/math?formula=%5Coverline%20x" mathimg="1"><br>
  矢量(<code>\vec</code> ): <img class="math-inline" alt="\vec x" src="https://math.jianshu.com/math?formula=%5Cvec%20x" mathimg="1"><br>
  向量(<code>\overrightarrow {xy}</code> ): <img class="math-inline" alt="\overrightarrow {xy}" src="https://math.jianshu.com/math?formula=%5Coverrightarrow%20%7Bxy%7D" mathimg="1"><br>
  (<code>\dot x</code> ): <img class="math-inline" alt="\dot x" src="https://math.jianshu.com/math?formula=%5Cdot%20x" mathimg="1"><br>
  (<code>\ddot x</code> ): <img class="math-inline" alt="\ddot x" src="https://math.jianshu.com/math?formula=%5Cddot%20x" mathimg="1"><br>
  (<code>\dot {\dot x}</code> ): <img class="math-inline" alt="\dot {\dot x}" src="https://math.jianshu.com/math?formula=%5Cdot%20%7B%5Cdot%20x%7D" mathimg="1"></p>
<h2><strong>表格</strong></h2>
<p>  使用<code>\begin{array}{列样式}…\end{array}</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\hline</code> 在本行前加入一条直线。 例如:</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token operator">|</span>lcr<span class="token punctuation">}</span>
n <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Left</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Center</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Right</span><span class="token punctuation">}</span> \\
\hline
<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">0.24</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">125</span> \\
<span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">189</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">8</span> \\
<span class="token number">3</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">20</span> <span class="token operator">&amp;</span> <span class="token number">2000</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">10</span>i \\
\<span class="token keyword">end</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  得到：<br>
<img class="math-block" alt="\begin{array}{c|lcr} n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\ \hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\ 2 &amp; -1 &amp; 189 &amp; -8 \\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\ \end{array}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Clcr%7D%20n%20%26%20%5Ctext%7BLeft%7D%20%26%20%5Ctext%7BCenter%7D%20%26%20%5Ctext%7BRight%7D%20%5C%5C%20%5Chline%201%20%26%200.24%20%26%201%20%26%20125%20%5C%5C%202%20%26%20-1%20%26%20189%20%26%20-8%20%5C%5C%203%20%26%20-20%20%26%202000%20%26%201%2B10i%20%5C%5C%20%5Cend%7Barray%7D" mathimg="1"></p>
<h2><strong>矩阵</strong></h2>
<h3>基本内容</h3>
<p>  使用<code>\begin{matrix}…\end{matrix}</code> 这样的形式来表示矩阵，在<code>\begin</code> 与<code>\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\</code> 分隔，列之间使用<code>&amp;</code> 分隔，例如:</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>
<span class="token number">1</span> <span class="token operator">&amp;</span> x <span class="token operator">&amp;</span> x<span class="token operator">^</span><span class="token number">2</span> \\
<span class="token number">1</span> <span class="token operator">&amp;</span> y <span class="token operator">&amp;</span> y<span class="token operator">^</span><span class="token number">2</span> \\
<span class="token number">1</span> <span class="token operator">&amp;</span> z <span class="token operator">&amp;</span> z<span class="token operator">^</span><span class="token number">2</span> \\
\<span class="token keyword">end</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  得到：<br>
<img class="math-block" alt="\begin{matrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \end{matrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%201%20%26%20x%20%26%20x%5E2%20%5C%5C%201%20%26%20y%20%26%20y%5E2%20%5C%5C%201%20%26%20z%20%26%20z%5E2%20%5C%5C%20%5Cend%7Bmatrix%7D" mathimg="1"></p>
<h3>括号</h3>
<p>  如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\left</code> 与<code>\right</code> 配合表示括号符号。也可以使用特殊的<code>matrix</code> 。即替换<code>\begin{matrix}…\end{matrix}</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p>
<ol>
<li>pmatrix<code>$\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$</code> : <img class="math-inline" alt="\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bpmatrix%7D" mathimg="1">
</li>
<li>bmatrix<code>$\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$</code> : <img class="math-inline" alt="\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bbmatrix%7D" mathimg="1">
</li>
<li>Bmatrix<code>$\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$</code> : <img class="math-inline" alt="\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7BBmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7BBmatrix%7D" mathimg="1">
</li>
<li>vmatrix<code>$\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$</code> : <img class="math-inline" alt="\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bvmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bvmatrix%7D" mathimg="1">
</li>
<li>Vmatrix<code>$\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$</code> : <img class="math-inline" alt="\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7BVmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7BVmatrix%7D" mathimg="1">
</li>
</ol>
<h3>元素省略</h3>
<p>  可以使用<code>\cdots</code> ：⋯，<code>\ddots</code>：⋱ ，<code>\vdots</code>：⋮ 来省略矩阵中的元素，如：</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>pmatrix<span class="token punctuation">}</span>
<span class="token number">1</span><span class="token operator">&amp;</span>a_1<span class="token operator">&amp;</span>a_1<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_1<span class="token operator">^</span>n\\
<span class="token number">1</span><span class="token operator">&amp;</span>a_2<span class="token operator">&amp;</span>a_2<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_2<span class="token operator">^</span>n\\
\vdots<span class="token operator">&amp;</span>\vdots<span class="token operator">&amp;</span>\vdots<span class="token operator">&amp;</span>\ddots<span class="token operator">&amp;</span>\vdots\\
<span class="token number">1</span><span class="token operator">&amp;</span>a_m<span class="token operator">&amp;</span>a_m<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_m<span class="token operator">^</span>n\\
\<span class="token keyword">end</span><span class="token punctuation">{</span>pmatrix<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\ 1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\ \end{pmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D%201%26a_1%26a_1%5E2%26%5Ccdots%26a_1%5En%5C%5C%201%26a_2%26a_2%5E2%26%5Ccdots%26a_2%5En%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%201%26a_m%26a_m%5E2%26%5Ccdots%26a_m%5En%5C%5C%20%5Cend%7Bpmatrix%7D" mathimg="1"></p>
<h3>增广矩阵</h3>
<p>  增广矩阵需要使用前面的表格中使用到的<code>\begin{array} ... \end{array}</code> 来实现。</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-swift"><code class="  language-swift">$$
\<span class="token keyword">left</span><span class="token punctuation">[</span>  \begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  <span class="token punctuation">{</span>c c <span class="token operator">|</span> c<span class="token punctuation">}</span> <span class="token operator">%</span>这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示<span class="token number">2</span>、<span class="token number">3</span>列间插入竖线
<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token number">3</span> \\
\hline <span class="token operator">%</span>插入横线，如果去掉\hline就是增广矩阵
<span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">5</span> <span class="token operator">&amp;</span> <span class="token number">6</span>
\end<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  \<span class="token keyword">right</span><span class="token punctuation">]</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>显示为：<br>
<img class="math-block" alt="\left[ \begin{array} {c c | c} 1 &amp; 2 &amp; 3 \\ \hline 4 &amp; 5 &amp; 6 \end{array} \right]" src="https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Barray%7D%20%7Bc%20c%20%7C%20c%7D%201%20%26%202%20%26%203%20%5C%5C%20%5Chline%204%20%26%205%20%26%206%20%5Cend%7Barray%7D%20%5Cright%5D" mathimg="1"></p>
<h2><strong>公式标记与引用</strong></h2>
<p>  使用<code>\tag{yourtag}</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\label{yourlabel}</code> 在<code>\tag</code> 之后，如<code>$$a = x^2 - y^3 \tag{1}\label{1}$$</code> 显示为：<br>
<img class="math-block" alt="a := x^2 - y^3 \tag{1}\label{311}" src="https://math.jianshu.com/math?formula=a%20%3A%3D%20x%5E2%20-%20y%5E3%20%5Ctag%7B1%7D%5Clabel%7B311%7D" mathimg="1"><br>
  如果不需要被引用，只使用<code>\tag{yourtag}</code> ，<code>$$x+y=z\tag{1.1}$$</code>显示为：<br>
<img class="math-block" alt="x+y=z\tag{1.1}" src="https://math.jianshu.com/math?formula=x%2By%3Dz%5Ctag%7B1.1%7D" mathimg="1"><br>
  <code>\tab{yourtab}</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\label{}</code> 设置的内容来引用。为了引用公式，可以使用<code>\eqref{yourlabel}</code> ，如<code>$$a + y^3 \stackrel{\eqref{1}}= x^2$$</code> 显示为：<br>
<img class="math-block" alt="a + y^3 \stackrel{\eqref{1}}= x^2" src="https://math.jianshu.com/math?formula=a%20%2B%20y%5E3%20%5Cstackrel%7B%5Ceqref%7B1%7D%7D%3D%20x%5E2" mathimg="1"></p>
<p>或者使用<code>\ref{yourlabel}</code> 不带括号引用，如<code>$$a + y^3 \stackrel{\ref{111}}= x^2$$</code> 显示为:<br>
<img class="math-block" alt="a + y^3 \stackrel{\ref{1}}= x^2" src="https://math.jianshu.com/math?formula=a%20%2B%20y%5E3%20%5Cstackrel%7B%5Cref%7B1%7D%7D%3D%20x%5E2" mathimg="1"></p>
<h2><strong>字体</strong></h2>
<h3>黑板粗体字</h3>
<p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br>
<code>$\mathbb ABCDEF$</code>：<img class="math-inline" alt="\mathbb ABCDEF" src="https://math.jianshu.com/math?formula=%5Cmathbb%20ABCDEF" mathimg="1"><br>
<code>$\Bbb ABCDEF$</code>：<img class="math-inline" alt="\Bbb ABCDEF" src="https://math.jianshu.com/math?formula=%5CBbb%20ABCDEF" mathimg="1"></p>
<h3>黑体字</h3>
<p><code>$\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img class="math-inline" alt="\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ" src="https://math.jianshu.com/math?formula=%5Cmathbf%20ABCDEFGHIJKLMNOPQRSTUVWXYZ" mathimg="1"><br>
<code>$\mathbf abcdefghijklmnopqrstuvwxyz$</code> :<img class="math-inline" alt="\mathbf abcdefghijklmnopqrstuvwxyz" src="https://math.jianshu.com/math?formula=%5Cmathbf%20abcdefghijklmnopqrstuvwxyz" mathimg="1"></p>
<h3>打印机字体</h3>
<p><code>$\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img class="math-inline" alt="\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ" src="https://math.jianshu.com/math?formula=%5Cmathtt%20ABCDEFGHIJKLMNOPQRSTUVWXYZ" mathimg="1"></p>
<h2><strong>参考文档</strong></h2>
<table>
<thead>
<tr>
<th>#</th>
<th>链接地址</th>
<th>文档名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>blog.csdn.net/dabokele/article/details/79577072</code></td>
<td><a href="https://blog.csdn.net/dabokele/article/details/79577072" target="_blank" rel="nofollow">Mathjax公式教程</a></td>
</tr>
<tr>
<td>2</td>
<td><code>blog.csdn.net/ethmery/article/details/50670297</code></td>
<td><a href="https://blog.csdn.net/ethmery/article/details/50670297" target="_blank" rel="nofollow">基本数学公式语法</a></td>
</tr>
<tr>
<td>3</td>
<td><code>blog.csdn.net/lilongsy/article/details/79378620</code></td>
<td><a href="https://blog.csdn.net/lilongsy/article/details/79378620" target="_blank" rel="nofollow">常用数学符号的LaTeX表示方法</a></td>
</tr>
<tr>
<td>4</td>
<td><code>www.mathjax.org</code></td>
<td><a href="https://www.mathjax.org/" target="_blank" rel="nofollow">Beautiful math in all browsers</a></td>
</tr>
</tbody>
</table>
</article></section></div></div></div></div></body>
</html>











]]></content>
      <categories>
        <category>instructions</category>
        <category>notes</category>
      </categories>
      <tags>
        <tag>instructions</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>python多线程、多进程</title>
    <url>/2020/03/04/python-multithreading/</url>
    <content><![CDATA[<p>浅尝辄止,能用就行</p>
<hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock() <span class="comment"># 设置一个全局线程锁,某个线程在获得此锁之后其他线程不能再获得</span></span><br><span class="line"></span><br><span class="line">sem = threading.Semaphore(<span class="number">12</span>) <span class="comment"># 设置最大线程数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sem:</span><br><span class="line">    t = threading.Thread(target=function,args=(a,b,c))  <span class="comment"># 用function(a,b,c)创建一个线程</span></span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)   <span class="comment">#   设置t线程为主线程的守护线程,即主线程结束后会自动杀死子线程(默认为false)</span></span><br><span class="line">    t.start()   <span class="comment"># 启动线程</span></span><br><span class="line">    t.join(<span class="number">60</span>)  <span class="comment"># 线程同步，主线程任务结束之后，进入阻塞状态，一直等待其他的子线程执行结束之后，主线程再终止;如果超时主线程也会终止(默认为无)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#   若在function中执行lock.acquire(),则线程阻塞直到其他线程释放此锁</span></span><br><span class="line"><span class="comment">#   function中执行完lock.acquire()后必须进行lock.release(),否则其他线程将永远无法获得此锁</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>多进程与多线程运用方式相仿</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">lock = multiprocessing.Lock()   <span class="comment"># 设置一个全局进程锁,某个进程在获得此锁之后其他进程不能再获得</span></span><br><span class="line"></span><br><span class="line">p = multiprocessing.Pool(<span class="number">72</span>)    <span class="comment"># 建立一个进程池,设置最大的进程数量</span></span><br><span class="line"></span><br><span class="line">p.apply_async(func=function,args=(a,))  <span class="comment"># 用function(a)创建一个进程</span></span><br><span class="line"></span><br><span class="line">p.close()   <span class="comment">#   关闭进程池,不再接受新的进程</span></span><br><span class="line">p.join()    <span class="comment">#   主进程阻塞,等待其他进程结束</span></span><br></pre></td></tr></table></figure>

<p>注: windows中多线程的代码应当写道<code>if __name__ == &#39;main&#39;</code>中</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>python spider</title>
    <url>/2020/03/04/python-spider/</url>
    <content><![CDATA[<p>烂尾中…</p>
<hr>
<p>资料主要来源于北理工的<a href="https://www.icourse163.org/learn/BIT-1001870001?tid=1206951268#" target="_blank" rel="noopener">爬虫课程</a><br>有requests库、beautifulsoup库、scrapy框架等</p>
<h2 id="request库"><a href="#request库" class="headerlink" title="request库"></a>request库</h2><p><code>import requests</code></p>
<h3 id="request"><a href="#request" class="headerlink" title="request."></a>request.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.request()</span><br><span class="line">.get() 获取网页</span><br><span class="line">.head() 获取网页头</span><br><span class="line">.post() 提交post请求</span><br><span class="line">.put() 提交put请求</span><br><span class="line">.patch() 提交局部修改请求</span><br><span class="line">.delete() 提交删除请求</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="关于url"><a href="#关于url" class="headerlink" title="关于url"></a>关于url</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url:http:&#x2F;&#x2F;host[:port][path]</span><br><span class="line">http协议资源操作：</span><br><span class="line">GET 请求获取url位置的资源</span><br><span class="line">HEAD 获取url资源头部信息</span><br><span class="line">POST 请求向资源后附加的新数据</span><br><span class="line">PUT 请求向url位置存储资源，覆盖原有url位置资源</span><br><span class="line">PATCH 请求向资源进行局部更新</span><br><span class="line">DELETE 请求删除资源</span><br></pre></td></tr></table></figure>


<h3 id="request-get-url"><a href="#request-get-url" class="headerlink" title="request.get(url)"></a>request.get(url)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r=requests.get(<span class="string">'http://www.baidu.com'</span>,) <span class="comment">#Response</span></span><br><span class="line"></span><br><span class="line">r.status_code-&gt;200/404</span><br><span class="line">r.text-&gt;string text</span><br><span class="line">r.encodonig-&gt;header enconding</span><br><span class="line">r.apparent_encoding-&gt;text encoding</span><br><span class="line">r.content-&gt;binary text</span><br><span class="line">r.headers</span><br><span class="line"></span><br><span class="line">r.raise_for_status(</span><br><span class="line"></span><br><span class="line">requests.ConnectionError</span><br><span class="line">        HTTPError</span><br><span class="line">        URLRequired</span><br><span class="line">        TooManyRedirects</span><br><span class="line">        ConnectTimeout</span><br><span class="line">        TImeout</span><br></pre></td></tr></table></figure>

<h4 id="请求头部r-head"><a href="#请求头部r-head" class="headerlink" title="请求头部r.head"></a>请求头部r.head</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(r.headers)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'Cache-Control': 'private</span></span><br><span class="line"><span class="string">, no-cache, no-store, proxy-revalidate, no-transform', </span></span><br><span class="line"><span class="string">'Connection': 'keep-alive', 'Content-Encoding': 'gzip', </span></span><br><span class="line"><span class="string">'Content-Type': 'text/html', 'Date': 'Sat, 11 Jan 2020 08:39:34 GMT', </span></span><br><span class="line"><span class="string">'Last-Modified': 'Mon, 23 Jan 2017 13:27:36 GMT', 'Pragma': 'no-cache', </span></span><br><span class="line"><span class="string">'Server': 'bfe/1.0.8.18', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', </span></span><br><span class="line"><span class="string">'Transfer-Encoding': 'chunked'&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h4 id="在url中附加数据"><a href="#在url中附加数据" class="headerlink" title="在url中附加数据"></a>在url中附加数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>,data=payload)</span><br><span class="line">print(r.text)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123; ...</span></span><br><span class="line"><span class="string">  "form": &#123;</span></span><br><span class="line"><span class="string">    "key1": "value1", </span></span><br><span class="line"><span class="string">    "key2": "value2"</span></span><br><span class="line"><span class="string">  &#125;, </span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>,data=<span class="string">'ABC'</span>)</span><br><span class="line">print(r.text)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123; ...</span></span><br><span class="line"><span class="string">  "data": "ABC", </span></span><br><span class="line"><span class="string">  "form": &#123;&#125;, </span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># r = requests.post('http://httpbin.org/post',data=payload)</span></span><br></pre></td></tr></table></figure>

<h2 id="beautifulsoup库"><a href="#beautifulsoup库" class="headerlink" title="beautifulsoup库"></a>beautifulsoup库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>

<h3 id="整理网页格式"><a href="#整理网页格式" class="headerlink" title="整理网页格式"></a>整理网页格式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">"http://python123.io/ws/demo.html"</span>)</span><br><span class="line">demo = r.text   <span class="comment"># print(demo)</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(demo , <span class="string">"html.parser"</span>) <span class="comment"># demo-&gt;open("path.html")</span></span><br><span class="line">print(soup.prettify)</span><br></pre></td></tr></table></figure>

<h3 id="bf类的基本元素"><a href="#bf类的基本元素" class="headerlink" title="bf类的基本元素"></a>bf类的基本元素</h3><ul>
<li>tag: &lt;&gt;…&lt;/&gt; 标签,基本信息组织单元</li>
<li>Name:<tag>.name   标签名字</tag></li>
<li>Attributs:<tag>.attrs 标签属性</tag></li>
<li>NavigableString:<tag>.string  标签内字符串</tag></li>
<li>Comment:特殊注释:&lt;!content&gt;为注释   </li>
</ul>
<p><img src="/2020/03/04/python-spider/tag0.png" alt="tag"> </p>
<h3 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h3><p>HTML基本结构:树形结构</p>
<p><img src="/2020/03/04/python-spider/tag1.png" alt="tag"> </p>
<p>节点查找与遍历:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.title)</span><br><span class="line">print(soup.a) #返回第一个a标签</span><br><span class="line">print(soup.a.parent.name)</span><br><span class="line">print(soup.a.attrs)</span><br><span class="line">print(soup.a.string)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">&lt;tag&gt;.contents  儿子节点列表</span><br><span class="line">&lt;tag&gt;.children  儿子节点迭代器</span><br><span class="line">&lt;tag&gt;.descendent    子孙节点列表</span><br><span class="line"></span><br><span class="line">&lt;tag&gt;.parent 父亲节点</span><br><span class="line">&lt;tag&gt;.parents 父辈节点迭代器</span><br><span class="line"></span><br><span class="line">&lt;tag&gt;.next_sibling(s) 同一父节点下才构成兄弟关系</span><br><span class="line">&lt;tag&gt;.previous_sibling(s)</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.find_all(<span class="string">'a'</span>))</span><br><span class="line">print(soup.find_all(re.compile(<span class="string">'b'</span>))) <span class="comment"># 返回以b开头的标签</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs)</span></span><br><span class="line"><span class="string">            名字  属性  是否搜索子孙 字符串检索</span></span><br><span class="line"><span class="string">tag.find_all(True)-&gt;所有标签</span></span><br><span class="line"><span class="string">tag.find_all(id='link')-&gt;attrs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup()=soup.find_all</span></span><br><span class="line"><span class="string">&lt;tag&gt;()=&lt;tag&gt;.find_all()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.fing()</span></span><br><span class="line"><span class="string">.find_parents()</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="scrapy框架"><a href="#scrapy框架" class="headerlink" title="scrapy框架"></a>scrapy框架</h2><p>cmd命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install scapy</span><br><span class="line">scapy startproject &lt;name&gt; [<span class="built_in">dir</span>] //创建工程</span><br><span class="line">scrapy genspider [options] &lt;name&gt; &lt;domain&gt;  //创建爬虫</span><br><span class="line">scrapy crawl &lt;spider&gt;</span><br></pre></td></tr></table></figure>

<p>太乱了,写不下去了…</p>
<p>关于scrapy,可以参考<a href="https://www.jianshu.com/p/cecb29c04cd2" target="_blank" rel="noopener">https://www.jianshu.com/p/cecb29c04cd2</a></p>
<hr>
<p>等我哪天有兴趣了再回来整理整理这篇博文</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>毛概相关</title>
    <url>/2020/03/03/mao-theory/</url>
    <content><![CDATA[<p>水课，佛系更新</p>
<hr>
<h2 id="第一章问题"><a href="#第一章问题" class="headerlink" title="第一章问题"></a>第一章问题</h2><ul>
<li>如何理解毛泽东思想活的灵魂</li>
</ul>
<ol>
<li>思想路线: 坚持实事求是，一切从实际出发，理论联系实际，坚持在实践中检验和发展真理</li>
<li>根本工作路线: 群众路线;一切为了群众,一切依靠群众,从群众中来,到群众中去,把党的主张变为群众的自觉行动</li>
<li>根本政治原则: 独立自主;坚持独立思考,走自己的路;坚定不移地维护民族独立,捍卫国家主权,把立足点放在依靠自己力量的基础之上;同时积极争取外援,开展国际经济文化交流,学习外国一切对我们有益的先进事物</li>
</ol>
<a id="more"></a>]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>毛概</tag>
      </tags>
  </entry>
  <entry>
    <title>featured-chinese-culture</title>
    <url>/2020/02/26/featured-chinese-culture/</url>
    <content><![CDATA[<p>英语课，佛系更新</p>
<hr>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>中国园林文化与艺术</title>
    <url>/2020/02/25/chinese-garden/</url>
    <content><![CDATA[<p>选修课，佛系更新</p>
<hr>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucence相关</title>
    <url>/2020/02/24/Lucence0/</url>
    <content><![CDATA[<p><del>未完结,不定期更新</del>  完结</p>
<hr>
<p>Lucence是一个由Java实现的,支持纯文本文件索引和搜索的高效、可扩展、开源的的全文检索框架</p>
<p>因自己需要用到lucence.net相关知识, 学习时参阅了不少资料, 将一些要点记录在此, 以供参考</p>
<a id="more"></a>

<h2 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h2><p>参考:<br><a href="https://www.cnblogs.com/forfuture1978/archive/2010/06/13/1757479.html" target="_blank" rel="noopener">https://www.cnblogs.com/forfuture1978/archive/2010/06/13/1757479.html</a><br><a href="https://blog.csdn.net/PZ_eng/article/details/91977083" target="_blank" rel="noopener">https://blog.csdn.net/PZ_eng/article/details/91977083</a>  </p>
<p><a href="http://lucene.apache.org/" target="_blank" rel="noopener">http://lucene.apache.org/</a>  </p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><h4 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a>数据的分类</h4><p>生活中数据总体分为如下几种:</p>
<ul>
<li>结构化数据: 具有固定格式或有限长度的数据(数据库,元数据)</li>
<li>非结构化数据: 不定长或无固定格式数据(word文档)</li>
<li>半结构化数据: 可根据需要当成结构化数据处理,也可以抽取纯文本按非结构化数据处理  </li>
</ul>
<p>其中,非结构化数据又叫全文数据</p>
<h4 id="全文数据搜索的主要方法"><a href="#全文数据搜索的主要方法" class="headerlink" title="全文数据搜索的主要方法"></a>全文数据搜索的主要方法</h4><ul>
<li>顺序扫描法: 直接,方便,较慢</li>
<li>索引法: 将非结构化数据中一部分信息提取出来重新组织,使其有一定结构后再搜索  </li>
</ul>
<p>索引构成了全文检索的基本思路<br>这种先建立索引,再对索引进行搜索的过程就叫做全文检索</p>
<p>全文检索大体分为两个过程: 索引创建,搜索索引</p>
<h4 id="全文检索需要关注的问题"><a href="#全文检索需要关注的问题" class="headerlink" title="全文检索需要关注的问题"></a>全文检索需要关注的问题</h4><p>因此,全文检索需要关注下面三个问题:  </p>
<ol>
<li>索引里面应该存什么(index)</li>
<li>如何创建索引(indexing)</li>
<li>如何对索引进行搜索(search)</li>
</ol>
<h3 id="索引里面应该存什么–倒排索引"><a href="#索引里面应该存什么–倒排索引" class="headerlink" title="索引里面应该存什么–倒排索引"></a>索引里面应该存什么–倒排索引</h3><p>倒排索引一般形式如下:</p>
<blockquote>
<p>token1-&gt;doc1 doc2 doc3 …<br>token2-&gt;doc3 doc5 doc6 …</p>
</blockquote>
<p>其中:</p>
<ul>
<li>token所在的地方称为词典</li>
<li>每个token指向一个文档链表,此链表称为倒排表</li>
</ul>
<p>通过这种索引方式,加上对链表的一系列操作,可以大大加速全文搜索的速度</p>
<h3 id="索引创建一般过程"><a href="#索引创建一般过程" class="headerlink" title="索引创建一般过程"></a>索引创建一般过程</h3><p>创建索引一般分为如下几步:</p>
<ol>
<li>整理要索引的Document</li>
<li>将Document传给Tokenizer,得到Token(分词)</li>
<li>将Token传给Linguistic Processor进行预处理,得到Term(转变大小写,词性,单复数)</li>
<li>将Term传给Indexer进行倒排索引</li>
</ol>
<h3 id="搜索一般过程"><a href="#搜索一般过程" class="headerlink" title="搜索一般过程"></a>搜索一般过程</h3><p>对索引进行搜索一般分为如下几步:</p>
<ol>
<li>用户输入query</li>
<li>对query进行词法,语法分析以及语言处理,得到语法树</li>
<li>搜索索引,得到符合语法树的文档</li>
<li>根据得到的文档和query的相关性对结果进行排序</li>
</ol>
<h3 id="Lucence"><a href="#Lucence" class="headerlink" title="Lucence"></a>Lucence</h3><p>Lucence是一个由Java实现的,支持纯文本文件的索引和搜索的高效、可扩展的全文检索框架</p>
<h4 id="Lucence和外界的交互"><a href="#Lucence和外界的交互" class="headerlink" title="Lucence和外界的交互"></a>Lucence和外界的交互</h4><p><img src="/2020/02/24/Lucence0/Lucence0.png" alt="Lucence"></p>
<h4 id="Lucence内部结构"><a href="#Lucence内部结构" class="headerlink" title="Lucence内部结构"></a>Lucence内部结构</h4><p><img src="/2020/02/24/Lucence0/Lucence1.png" alt="Lucence"></p>
<p>其中:</p>
<ul>
<li>被索引的文档用Document对象表示  </li>
<li>IndexWriter通过函数addDocument将文档添加到索引中 ,实现创建索引的过程  </li>
<li>Lucene的索引是应用倒排索引  </li>
<li>当用户有请求时,Query代表用户的查询语句  </li>
<li>IndexSearcher通过函数search搜索Lucene Index  </li>
<li>IndexSearcher计算term weight和score并且将结果返回给用户</li>
<li>返回给用户的文档集合用TopDocsCollector表示  </li>
</ul>
<h4 id="Lucence索引过程"><a href="#Lucence索引过程" class="headerlink" title="Lucence索引过程"></a>Lucence索引过程</h4><ol>
<li>创建一个IndexWriter用来写索引文件,它有几个参数,INDEX_DIR 就是索引文件所存放的位置,Analyzer便是用来对文档进行词法分析和语言处理的 </li>
<li>创建一个 Document 代表我们要索引的文档 </li>
<li>将不同的Field加入到文档中;我们知道,一篇文档有多种信息,如题目,作者,修改时间,内容等;不同类型的信息用不同的Field来表示  </li>
<li>IndexWriter调用函数addDocument将索引写到索引文件夹中 　</li>
</ol>
<h4 id="Lucence搜索过程"><a href="#Lucence搜索过程" class="headerlink" title="Lucence搜索过程"></a>Lucence搜索过程</h4><ol>
<li>IndexReader将磁盘上的索引信息读入到内存</li>
<li>创建IndexSearcher准备进行搜索  </li>
<li>创建Analyer用来对查询语句进行词法分析和语言处理 </li>
<li>创建QueryParser用来对查询语句进行语法分析 </li>
<li>QueryParser调用parser进行语法分析,形成查询语法树,放到Query中  </li>
<li>IndexSearcher调用search对查询语法树Query进行搜索,得到结果TopScoreDocCollector</li>
</ol>
<h4 id="Lucence的包结构"><a href="#Lucence的包结构" class="headerlink" title="Lucence的包结构"></a>Lucence的包结构</h4><p><img src="/2020/02/24/Lucence0/Lucence2.png" alt="Lucence"></p>
<p>其中:</p>
<ul>
<li>Lucene的analysis模块主要负责词法分析及语言处理而形成Term  </li>
<li>Lucene的index模块主要负责索引的创建,里面有里面有IndexWriter</li>
<li>Lucene的store模块主要负责索引的读写</li>
<li>Lucene的QueryParser主要负责语法分析</li>
<li>Lucene的search模块主要负责对索引的搜索</li>
<li>Lucene的similarity模块主要负责对相关性打分的实现  </li>
</ul>
<h2 id="Lucence-net"><a href="#Lucence-net" class="headerlink" title="Lucence.net"></a>Lucence.net</h2><p>参考:<br><a href="http://lucenenet.apache.org/" target="_blank" rel="noopener">http://lucenenet.apache.org/</a><br><a href="https://www.cnblogs.com/xiaoyaodijun/p/4140507.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoyaodijun/p/4140507.html</a><br><a href="https://blog.csdn.net/xuezhongsong/article/details/4388241" target="_blank" rel="noopener">https://blog.csdn.net/xuezhongsong/article/details/4388241</a></p>
<h3 id="lucence-net中主要的几个类"><a href="#lucence-net中主要的几个类" class="headerlink" title="lucence.net中主要的几个类"></a>lucence.net中主要的几个类</h3><h4 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h4><p>Document用于描述一个文档,由多个Field(相当于属性)组成</p>
<p>常用方法: </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Document</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Document</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">puclib <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">IFieldable field</span>)</span>;  <span class="comment">//  添加字段/属性field</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Field <span class="title">GetField</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>; <span class="comment">//  获得第一个名为name的field,无则返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>; <span class="comment">// 获得第一个名为name的field 中的文本内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Field[] <span class="title">GetFields</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;  <span class="comment">//获得所有名为name的field,无则返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span>[] <span class="title">GetValues</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>; <span class="comment">//  获得所有名为name的field 中的文本内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p>Field用于描述一个文档的某个属性,一般由名字和属性值构成</p>
<p>常用方法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Field</span> : <span class="title">AbstractField</span>, <span class="title">IFieldable</span>&#123;</span><br><span class="line">    <span class="comment">//  inherited</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; &#125; <span class="comment">//  名字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> StringValue &#123; <span class="keyword">get</span>; &#125; <span class="comment">//  属性值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Field</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">string</span> <span class="keyword">value</span>, Store store, Index index</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="keyword">string</span> <span class="keyword">value</span></span>)</span>; <span class="comment">//更改属性值   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于构造函数中的参数的说明:</p>
<ul>
<li><p>name: 字段名称</p>
</li>
<li><p>value: 字段内容,也就是属性值</p>
</li>
<li><p>store: 存储类型</p>
<blockquote>
<p>Field.Store有三个属性：  </p>
<ul>
<li>Field.Store.YES: 索引文件本来只存储索引数据,此设计将原文内容直接也存储在索引文件中,如文档的标题</li>
<li>Field.Store.NO：原文不存储在索引文件中，搜索结果命中后，再根据其他附加属性如文件的Path，数据库的主键等，重新连接打开原文，适合原文内容较大的情况。</li>
<li>Field.Store.COMPRESS 压缩存储  </li>
</ul>
</blockquote>
</li>
<li><p>index: 索引类型</p>
<blockquote>
<p>Field.Index有四个属性：</p>
<ul>
<li>Field.Index.TOKENIZED：分词索引</li>
<li>Field.Index.UN_TOKENIZED：进行索引，但不对其进行分词，如作者名，日期等，Rod Johnson本身为一单词，不再需要分词。</li>
<li>Field.Index.NO 和 Field.Index.NO_NORMS: 不进行索引，存放不能被搜索的内容如文档的一些附加属性如文档类型, URL等  </li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h4><p>在一个文档被索引之前，首先需要对文档内容进行分词处理，这部分工作就是由 Analyzer 来做的。Analyzer 类是一个抽象类，它有多个实现。针对不同的语言和应用需要选择适合的 Analyzer。Analyzer 把分词后的内容交给 IndexWriter 来建立索引。</p>
<p>一般用法(不太会用,先这么写着吧):</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">StandardAnalyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT);</span><br></pre></td></tr></table></figure>

<h4 id="IndexWriter"><a href="#IndexWriter" class="headerlink" title="IndexWriter"></a>IndexWriter</h4><p>IndexWriter 是 Lucene 用来创建索引的一个核心的类，他的作用是把一个个的 Document 对象加到索引中来。建立索引必须从它开始。而且，从它的构造函数开始</p>
<p>一般用法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> IndexWriter writer = <span class="keyword">new</span> IndexWriter(<span class="keyword">string</span> idxDir,Analyzer analyzer,<span class="keyword">bool</span> isNewCreate,MaxFieldLength IndexWriter.MaxFieldLength.LIMITED);</span><br><span class="line"> </span><br><span class="line"> writer.AddDocument(doc);<span class="comment">//向索引文件中写数据 </span></span><br><span class="line">writer.Optimize();<span class="comment">// 索引优化，一般执行此步骤时，所消耗的内存是写入索引所需内存的2倍，在执行索引生成操作的时候本身就对内存有比较大的消耗，最好在索引创建完成之后，执行此步骤。 </span></span><br><span class="line">writer.Commit();<span class="comment">//数据提交 </span></span><br><span class="line">writer.Rollback();<span class="comment">//数据回滚 </span></span><br><span class="line">writer.Close();<span class="comment">//关闭流索引写入器，此步骤才真正将数据写入到索引文件中。</span></span><br></pre></td></tr></table></figure>

<h4 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h4><p>这个类代表了 Lucene 的索引的存储的位置，这是一个抽象类，它目前有两个实现，第一个是 FSDirectory，它表示一个存储在文件系统中的索引的位置。第二个是 RAMDirectory，它表示一个存储在内存当中的索引的位置</p>
<p>一般用法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> indexDir = <span class="string">"idx"</span>;</span><br><span class="line">DirectoryInfo dir = <span class="keyword">new</span> DirectoryInfo(indexDir);</span><br><span class="line"></span><br><span class="line">Lucene.Net.Store.Directory idxDir = <span class="keyword">new</span> SimpleFSDirectory(dir, <span class="keyword">new</span> SimpleFSLockFactory());  <span class="comment">//  创建上面的indexwriter需要用到</span></span><br></pre></td></tr></table></figure>

<h3 id="Lucence-net中的索引建立"><a href="#Lucence-net中的索引建立" class="headerlink" title="Lucence.net中的索引建立"></a>Lucence.net中的索引建立</h3><p>总结一下建立索引的一般过程</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  前期准备    */</span></span><br><span class="line"><span class="keyword">var</span> indexDir = <span class="string">"idx"</span>;   <span class="comment">//  索引目录</span></span><br><span class="line"><span class="keyword">var</span> isNewCreate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">DirectoryInfo dir = <span class="keyword">new</span> DirectoryInfo(indexDir);</span><br><span class="line">Lucene.Net.Store.Directory idxDir = <span class="keyword">new</span> SimpleFSDirectory(dir, <span class="keyword">new</span> SimpleFSLockFactory());</span><br><span class="line"></span><br><span class="line">StandardAnalyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT);</span><br><span class="line"></span><br><span class="line">IndexWriter writer = <span class="keyword">new</span> IndexWriter(idxDir, analyzer, isNewCreate, IndexWriter.MaxFieldLength.LIMITED);</span><br><span class="line"><span class="comment">// writer.MergeFactor(50); 多少个合并一次【优化缓存】 </span></span><br><span class="line"><span class="comment">// writer.MaxMergeDocs(5000); 一个segment最多有多少个document【优化索引存储的segment文件】 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  写索引   */</span></span><br><span class="line">Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">Field field = <span class="keyword">new</span> Field(<span class="string">"name"</span>, <span class="string">"content"</span>, Field.Store.YES, Field.Index.ANALYZED);</span><br><span class="line">doc.Add(field);</span><br><span class="line">writer.AddDocument(doc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  关文件   */</span></span><br><span class="line">writer.Optimize();</span><br><span class="line">writer.Commit(); </span><br><span class="line">writer.Rollback(); </span><br><span class="line">writer.Close();</span><br></pre></td></tr></table></figure>

<h3 id="Lucence-net中的索引搜索"><a href="#Lucence-net中的索引搜索" class="headerlink" title="Lucence.net中的索引搜索"></a>Lucence.net中的索引搜索</h3><p>下面是我自己写的一个索引搜索的流程模板</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> indexDir = <span class="string">"idx"</span>;   <span class="comment">//  指定索引的目录</span></span><br><span class="line">IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(LuceneConnection.GetIndexDirectory(indexDir));<span class="comment">// 建立搜索引擎; readOnly 为boolean值</span></span><br><span class="line"></span><br><span class="line">StandardAnalyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT);   <span class="comment">//  分词器用于分析query,此分词器应当与建立索引的分词器保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MultiFieldQueryParser parser = new MultiFieldQueryParser(Version.LUCENE_CURRENT, new string[] &#123; title, content &#125;, analyzer); 多字段搜索   </span></span><br><span class="line"><span class="keyword">var</span> q = <span class="keyword">new</span> QueryParser(Version.LUCENE_CURRENT, <span class="string">"name"</span>, <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT)).Parse(<span class="string">"content"</span>);   <span class="comment">//  单字段搜索,字段是name搜索词是content   </span></span><br><span class="line"></span><br><span class="line">SortField sfield = <span class="keyword">new</span> SortField(<span class="literal">null</span>, SortField.SCORE, <span class="literal">true</span>);</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(sfield);    <span class="comment">//  指定一个排序方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hits = searcher.Search(q, <span class="literal">null</span>, searcher.MaxDoc, sort); <span class="comment">//  搜索,返回前searcher.MaxDoc个Docs组成的TopFieldDocs</span></span><br><span class="line"><span class="comment">//TopFieldDocs docs = searcher.Search(q,null, searcher.MaxDoc, sort);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  下面是通过搜索结果获取Doc的一般方法  */</span></span><br><span class="line">ScoreDoc[] scoreDocs = hits.ScoreDocs;<span class="comment">//权值对象 包含document下标信息，能确定searcher中的document的下标。 </span></span><br><span class="line"><span class="keyword">int</span> docCount = scoreDocs.Length;<span class="comment">// 结果个数统计  </span></span><br><span class="line">Document doc = searcher.Doc(scoreDocs[docCount - <span class="number">1</span>].Doc); <span class="comment">// 通过document下标值，获取document对象 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出结果</span></span><br><span class="line">Console.WriteLine(<span class="string">"字段&#123;2&#125;搜索到:&#123;0&#125; 字段&#123;3&#125;搜索到:&#123;1&#125;"</span>, doc.Get(<span class="string">"name"</span>), doc.Get(<span class="string">"content"</span>), <span class="string">"name"</span>, <span class="string">"hello"</span>);</span><br><span class="line">searcher.Close();</span><br></pre></td></tr></table></figure>

<hr>
<p>说实话,本人没有对搜索引擎有过系统的学习,文中有些地方也是根据自己的理解来写的; 如果各位发现有写得不妥之处，欢迎指正！</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>learning</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成相关知识</title>
    <url>/2020/02/24/computer-composition0/</url>
    <content><![CDATA[<p><del>未完结,持续更新</del>完结</p>
<hr>
<p>网课资源: (智慧树)长春师范大学计算机组成</p>
<p>参考教材: 清华大学出版社《计算机组成与结构(第5版)》</p>
<p>课程内容:</p>
<ul>
<li>讨论单机系统范围内计算机各部件和系统的组成原理以及内部工作机制</li>
</ul>
<p>课程目标:</p>
<ul>
<li>计算机个大部件的组成原理</li>
<li>计算机各大部件的逻辑实现</li>
<li>计算机各大部件的设计方法</li>
<li>计算机各大部件互联构成整体系统的技术</li>
<li>(为后继课程的学习打好基础)</li>
</ul>
<p>课程地位: 承上启下</p>
<ul>
<li>先导课程: 计算机导论,数字逻辑</li>
<li>后继课程: 微机原理,接口技术,计算机系统结构</li>
</ul>
<p>重点难点:</p>
<ul>
<li>掌握五大基本部件的原理及实现</li>
<li>掌握各部件互联构成整机系统的知识(整机概念的建立)</li>
</ul>
<p>课程要求:</p>
<ul>
<li>重点掌握: 多层次的存储器,中央处理器</li>
<li>掌握: 运算方法和运算器,指令系统,总线系统</li>
<li>理解: 外存与io设备</li>
<li>了解: 计算机系统概论,输入输出系统</li>
</ul>
<a id="more"></a>

<h1 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h1><p>计算机的定义,分类.发展史</p>
<h2 id="1-1-计算机发展简史"><a href="#1-1-计算机发展简史" class="headerlink" title="1.1 计算机发展简史"></a>1.1 计算机发展简史</h2><p>计算机: 能够连续自动进行数值和逻辑运算的机器</p>
<p>分类:</p>
<ul>
<li>原理角度: 数字计算机,模拟计算机</li>
<li>性能指标: 巨型机,大型机,小型机,微型机</li>
<li>用途角度: 专用机,通用机</li>
</ul>
<p>计算机发展阶段:</p>
<ul>
<li>1946-1957: 电子管时代,ENIAC(1946)</li>
<li>1958-1964: 晶体管时代,整体性能大幅度提高,TRADIC(增加浮点运算)</li>
<li>1965-1971: 中小规模集成电路,进入文字处理和图形图像处理</li>
<li>1972-: 大和超大规模集成电路,出现微处理器</li>
</ul>
<h2 id="1-2-计算机硬件"><a href="#1-2-计算机硬件" class="headerlink" title="1.2 计算机硬件"></a>1.2 计算机硬件</h2><p>硬件系统的组成: 冯诺依曼结构,以存储器为中心</p>
<p>特点:</p>
<ul>
<li>计算机(硬件)应由运算器,存储器,控制器,输入设备,输出设备组成</li>
<li>计算机内部采用二进制来表示指令和数据</li>
<li>将编好的程序和原始数据实现存入存储器中然后再启动计算机工作</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/compo0.jpg" alt="composition">  </p>
<ul>
<li>运算器: 数据的加工处理  </li>
<li>控制器: 指令控制,操作控制,时序控制  </li>
<li>存储器: 存放数据和程序  </li>
<li>输入设备: 将外部数据送给计算机并转换成计算机能够识别的形式  </li>
<li>输出设备: 将计算机处理结果送出给外界并转换成外界能够识别的形式<blockquote>
<ul>
<li>运算器,控制器一般为cpu  </li>
<li>存储器一般由主存(内存)和辅存组成  </li>
<li>cpu和主存一般构成主机</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>以运算器为核心构造时,输入设备的数据得通过运算器才能进入存储器中;因此以存储器为核心的构造可以提高计算机系统运行的效率</p>
</blockquote>
<p>个计算结构时以总线连接起来的: 总线上有地址,数据,控制三种信号线,结构如下:<br><img src="/2020/02/24/computer-composition0/bus0.jpg" alt="bus"></p>
<h2 id="1-3-计算机软件"><a href="#1-3-计算机软件" class="headerlink" title="1.3 计算机软件"></a>1.3 计算机软件</h2><p>软件和硬件之间存在着逻辑等价关系</p>
<p>语言: 计算机语言经历了由机器语言-&gt;汇编语言-&gt;高级语言的发展过程</p>
<p>计算机系统的多级层次结构(由低到高):</p>
<ul>
<li>硬件(机器语言级)-&gt;操作系统级-&gt;中间件/平台级-&gt;应用程序级(高级语言)</li>
</ul>
<h1 id="二、计算机中常用的组合逻辑电路"><a href="#二、计算机中常用的组合逻辑电路" class="headerlink" title="二、计算机中常用的组合逻辑电路"></a>二、计算机中常用的组合逻辑电路</h1><h2 id="2-1-计算机种常用的组合逻辑电路"><a href="#2-1-计算机种常用的组合逻辑电路" class="headerlink" title="2.1 计算机种常用的组合逻辑电路"></a>2.1 计算机种常用的组合逻辑电路</h2><h3 id="三态门"><a href="#三态门" class="headerlink" title="三态门"></a>三态门</h3><p>三态: 0,1,高阻态Z<br><img src="/2020/02/24/computer-composition0/compo1.jpg" alt="composition"></p>
<p>三态门通常用于驱动总线,当控制端G=1时,数据线A和总线接通,G=0时,该数据线和总线断开</p>
<blockquote>
<p>当总线传输数据时,应当只有一个三态门是正常工作的</p>
</blockquote>
<h3 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h3><p>异或门是计算单元中常用的逻辑电路<br><img src="/2020/02/24/computer-composition0/compo2.jpg" alt="composition"></p>
<p>常见异或门应用:</p>
<ul>
<li>数码比较器 </li>
<li>原码/反码输出电路  </li>
<li>奇偶检测电路</li>
</ul>
<h3 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h3><p>加法器是计算机的基本运算部件之一</p>
<p>半加器不考虑前一位的进位输入:<br><img src="/2020/02/24/computer-composition0/compo3.jpg" alt="composition"></p>
<p>全加器考虑前一位的进位输入:<br><img src="/2020/02/24/computer-composition0/compo4.jpg" alt="composition"></p>
<h4 id="串行进位加法器"><a href="#串行进位加法器" class="headerlink" title="串行进位加法器"></a>串行进位加法器</h4><p>将多个全加器串联,可以得到多位的加法器,但后一位的计算需要等前一位计算完成后才能开始,导致加法效率较低  </p>
<h4 id="超前进位加法器"><a href="#超前进位加法器" class="headerlink" title="超前进位加法器"></a>超前进位加法器</h4><p>超前进位产生电路通过迭代各位进位的产生式,得到直接产生各位进位的表达式来实现的;后一位的进位无需等待前一位的进位就可以产生,高效但需要使用更多的组合逻辑单元</p>
<p>原理如下:</p>
<ol>
<li>考虑第每一位进位ci的产生条件:<br>$X_i,Y_i$均为1,或$X_i,Y_i$有一个为1且$C_{i-1}$为1,即<br>$C_i=X_iY_i+(X_i+Y_i)C_{i-1}$</li>
<li>由$C_1=X_1Y_1+(X_1+Y_1)C_0$不停对$C_i$进行迭代化简,得到:<br>$$C_i=X_iY_i+\sum_{n=i-1}^1(X_nY_n\prod_{k=i}^{n}(X_k+Y_k))+C_0\prod_{k=i}^{1}(X_k+Y_k)$$<br>如:$C_4=X_4Y_4+(X_4+Y_4)X_3Y_3+(X_4+Y_4)(X_3+Y_3)X_2Y_2+…+..C_0$</li>
<li>定义进位传递函数$P_i=X_i+Y_i$,表明$X_i,Y_i$有一个为1时,将前一位进位传给下一位,达到一种进位传递的效果<br>定义进位产生函数$G_i=X_iY_i$,表明$X_i,Y_i$都为1时,无论$P_i$如何必定向高位产生进位<br>如,此时$C_3=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0$</li>
<li>将各进位改成与非式,画出电路图,如下<br> <img src="/2020/02/24/computer-composition0/compo5.jpg" alt="composition"></li>
</ol>
<h4 id="ALU算数逻辑单元"><a href="#ALU算数逻辑单元" class="headerlink" title="ALU算数逻辑单元"></a>ALU算数逻辑单元</h4><p>考虑到超前进位电路的复杂程度是随着位数呈指数增加,一般可以将4位超前进位电路封装成算数逻辑单元,然后再通过组间的串行或超前进位组成16位的ALU</p>
<p>16位快速ALU:组间快速进位<br><img src="/2020/02/24/computer-composition0/compo6.jpg" alt="composition"></p>
<ul>
<li>$G_n=(片内)G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0$</li>
<li>$P_n=(片内)P_3P_2P_1P_0$</li>
<li>$C_11=G_{N_2}+P_{N_2}G_{N_1}+P_{N_2}P_{N_1}G_{N_0}+P_{N_2}P_{N_1}P_{N_0}C_n$,依次类推</li>
</ul>
<p>相比于组间串行进位,最高位进位需要等待前三次进位;16位快速ALU只需要等待一次片内的进位即可;ALU在保证一定运行速度间的同时使得电路规模没有过大</p>
<h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>由n个输入,最多$2^n$个输出组合而成的逻辑电路,包含:</p>
<ul>
<li>$\overline E$:使能端,一般低有效</li>
<li>$A,B,C(A_1,A_2,A_3)…$:输入端,高有效</li>
<li>$Y_1,Y_2,…,Y_8,…$:输出端,一般低有效</li>
</ul>
<p>通常将使能端连接另一个译码器的输出(CS:芯片选择功能),可以将译码器的译码范围进行扩展</p>
<h3 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h3><p>由$2^n$个输入,n个输出组合而成的逻辑电路,包含:</p>
<ul>
<li>$\overline G_1,\overline G_2$(双数据选择器):使能信号,由一个三态门控制,一般低有效</li>
<li>$S_0,S_1$:通道选择端,高有效</li>
<li>$D_0,D_1,D_2,D_3,…,D_7$(双4选1):通道输入端</li>
<li>$Y_1,Y_2$:输出端,输出所选择通道的电位</li>
</ul>
<p>在保证$\overline G_1,\overline G_2$反相的情况下,可以连接$Y_1,Y_2$来扩展选择通道数</p>
<h2 id="2-2-时序逻辑电路"><a href="#2-2-时序逻辑电路" class="headerlink" title="2.2 时序逻辑电路"></a>2.2 时序逻辑电路</h2><p>如果逻辑电路的输出状态不但和当时的输入状态有关，而且还与电路在此以前的输入状态有关，称这种电路为时序逻辑电路。</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="电位触发器"><a href="#电位触发器" class="headerlink" title="电位触发器"></a>电位触发器</h4><p><img src="/2020/02/24/computer-composition0/compo7.jpg" alt="composition"></p>
<p>普通触发器存在触发不能被同步的问题</p>
<h4 id="边沿D触发器"><a href="#边沿D触发器" class="headerlink" title="边沿D触发器"></a>边沿D触发器</h4><p>每当经过一个时钟周期时(CP上升沿或下降沿):<br>$Q^n=D$</p>
<p>边沿触发器存在空翻问题</p>
<h4 id="主从JK触发器"><a href="#主从JK触发器" class="headerlink" title="主从JK触发器"></a>主从JK触发器</h4><p>$Q^n=J \overline Q + \overline K Q$</p>
<h3 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h3><p><img src="/2020/02/24/computer-composition0/compo8.jpg" alt="composition"></p>
<p>每当经过一个时钟周期时,移位寄存器向最低位读取数据,将最高位数据输出,并进行移位</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>每当经过一个时钟周期,将计数加1,计数满则清零并输出进位信息</p>
<ul>
<li>$\overline R_D$:异步清零信号,一般低有效</li>
<li>$L$:同步置数信号,高有效</li>
<li>$Q_1,Q_2,…$:同步置数端</li>
<li>$P,T$:计数使能信号,均高有效,否则为保持状态</li>
<li>$CK$:时钟信号</li>
<li>$RC$:进位信号</li>
</ul>
<h2 id="2-3-阵列逻辑电路"><a href="#2-3-阵列逻辑电路" class="headerlink" title="2.3 阵列逻辑电路"></a>2.3 阵列逻辑电路</h2><p>阵列逻辑电路表明逻辑元件以阵列的形式在硅芯片上排列</p>
<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p>存储器:</p>
<ul>
<li>字:放置信息的单元,由多个位组成</li>
<li>位:一个二进制信息</li>
<li>地址(码):存储器中每个字的编号,用于寻找存入存储器的字</li>
</ul>
<p>ROM主要由地址译码器和存储单元体构成,通过在每个位置设置或不设置三极管、二极管、熔丝等元件来表示存入的二进制信息<br><img src="/2020/02/24/computer-composition0/rom0.jpg" alt="rom"><br><img src="/2020/02/24/computer-composition0/rom1.jpg" alt="rom"><br>由上图可以看出,ROM存储的是一种主析取范式的表达式</p>
<p>ROM主要有如下两个缺陷:</p>
<ul>
<li>ROM实际存储的字数常少于它所能提供的字数,造成存储单元的闲置和芯片面积的浪费</li>
<li>ROM中的地址和字之间有一一对应的关系,在存储大量重复内容时不能灵活节省空间</li>
</ul>
<h3 id="可编程序逻辑阵列PLA"><a href="#可编程序逻辑阵列PLA" class="headerlink" title="可编程序逻辑阵列PLA"></a>可编程序逻辑阵列PLA</h3><ul>
<li>相比于ROM,PLA能用较少的存储单元存储大量的信息</li>
<li>ROM存储的是一种主析取范式的表达式,而PLA可以存储最简的与或式,因此可以节省一些存储资源的消耗<br><img src="/2020/02/24/computer-composition0/rom2.jpg" alt="rom"> </li>
</ul>
<h3 id="可编程序阵列逻辑PAL"><a href="#可编程序阵列逻辑PAL" class="headerlink" title="可编程序阵列逻辑PAL"></a>可编程序阵列逻辑PAL</h3><ul>
<li>PAL中的与阵列是可编程的,但或阵列不可编程;而在PAL中,两者都可以编程,还有一些PAL中带有记忆元件或反馈电路</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/pal0.jpg" alt="pal"></p>
<h3 id="通用阵列逻辑GAL"><a href="#通用阵列逻辑GAL" class="headerlink" title="通用阵列逻辑GAL"></a>通用阵列逻辑GAL</h3><ul>
<li>ROM,PLA,PAL是一次性编程的,编程后不能修改</li>
<li>GAL是一种可用电擦除的,可重复编程的高速PLD(可编程逻辑电路)</li>
<li>可重复擦写100次以上,数据可保存20年以上,数秒内即可完成擦除和编程的过程</li>
</ul>
<h3 id="门阵列GA-宏单元阵列MCA，标准单元阵列SCA"><a href="#门阵列GA-宏单元阵列MCA，标准单元阵列SCA" class="headerlink" title="门阵列GA,宏单元阵列MCA，标准单元阵列SCA"></a>门阵列GA,宏单元阵列MCA，标准单元阵列SCA</h3><ul>
<li>这些芯片是用来实现批量较大的专用集成电路的</li>
<li>这三种芯片内部的单元都是以阵列形式排列的</li>
</ul>
<h4 id="门阵列"><a href="#门阵列" class="headerlink" title="门阵列"></a>门阵列</h4><p>门阵列设计利用预先制造好的“母片”来进行布图设计;母片上通常以一定的间距成行成列的排列着基本单元电路。</p>
<ul>
<li>这样可以降低设计成本,缩短设计周期:因为母片已完成了整个集成电路制造工艺的大部分流程,剩下只要进行布线连接,就可以实现各种逻辑需求</li>
<li>门阵列器件是一种半用户器件或半定制器件</li>
</ul>
<h4 id="宏单元阵列"><a href="#宏单元阵列" class="headerlink" title="宏单元阵列"></a>宏单元阵列</h4><p>宏单元阵列是一种对门阵列的改进,逻辑功能更强,布图密度更高,制造周期更短</p>
<h4 id="标准单元阵列"><a href="#标准单元阵列" class="headerlink" title="标准单元阵列"></a>标准单元阵列</h4><p>标准单元以预先设计好的功能单元(如门,触发器,加法器等)为基础进行设计生产</p>
<ul>
<li>不同于门阵列那样事先生产半成品芯片;在标准单元阵列中,所有单元都是根据用户逻辑图的需要安排在芯片上。</li>
<li>标准单元阵列是定制器件而非半定制器件,但布局布线更易于实现</li>
</ul>
<h3 id="现场可编程序门阵列FPGA"><a href="#现场可编程序门阵列FPGA" class="headerlink" title="现场可编程序门阵列FPGA"></a>现场可编程序门阵列FPGA</h3><ul>
<li>FPGA由大规模集成电路构成，门电路数达到几万个到几百万个</li>
<li>它主要由四个部分组成：<blockquote>
<ul>
<li>可编程序逻辑宏单元(CLB)</li>
<li>可编程序输入输出宏单元(IOB)</li>
<li>互连资源</li>
<li>重构逻辑的程序存储器: 可以允许多次逻辑的修改,适合在在产品试验或生产批蜇不大时使用</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="三、运算方法和运算部件"><a href="#三、运算方法和运算部件" class="headerlink" title="三、运算方法和运算部件"></a>三、运算方法和运算部件</h1><h2 id="3-1-数值型数据的表示方法和转换"><a href="#3-1-数值型数据的表示方法和转换" class="headerlink" title="3.1 数值型数据的表示方法和转换"></a>3.1 数值型数据的表示方法和转换</h2><ul>
<li>数制: $ (D_m…D_0.D_{-1} .. D_{-k})i $ 是一个i进制数,可以表示成 $ \sum_{n=-k}^mD_n*i^n $,其中i称为基数或底</li>
</ul>
<h3 id="不同数制之间的数据转换"><a href="#不同数制之间的数据转换" class="headerlink" title="不同数制之间的数据转换"></a>不同数制之间的数据转换</h3><h4 id="二进制-八进制-和十六进制转换"><a href="#二进制-八进制-和十六进制转换" class="headerlink" title="二进制,八进制,和十六进制转换"></a>二进制,八进制,和十六进制转换</h4><ul>
<li>二进制转八进制: 从小数点向两边三位成一组转换</li>
<li>二进制转十六进制: 从小数点向两边四位成一组转换</li>
</ul>
<h4 id="二进制-十进制的转换"><a href="#二进制-十进制的转换" class="headerlink" title="二进制,十进制的转换"></a>二进制,十进制的转换</h4><ul>
<li>二进制转十进制用公式$ \sum_{n=-k}^mD_n*2^n $</li>
<li>十进制转二进制用除2取余法(整数部分)和乘2取整法(小数部分)</li>
</ul>
<h3 id="十进制数的编码与运算"><a href="#十进制数的编码与运算" class="headerlink" title="十进制数的编码与运算"></a>十进制数的编码与运算</h3><h4 id="有权码"><a href="#有权码" class="headerlink" title="有权码"></a>有权码</h4><p>如8421,5421,2421BCD编码</p>
<ul>
<li>注意,这种编码是对十进制的每一位进行编码运算,而不是对整个十进制数的运算</li>
</ul>
<h4 id="无权码"><a href="#无权码" class="headerlink" title="无权码"></a>无权码</h4><p>如余3码,格雷码(循环码)</p>
<h2 id="3-2-带符号的二进制数在计算机中的表示方法及加减运算"><a href="#3-2-带符号的二进制数在计算机中的表示方法及加减运算" class="headerlink" title="3.2 带符号的二进制数在计算机中的表示方法及加减运算"></a>3.2 带符号的二进制数在计算机中的表示方法及加减运算</h2><ul>
<li>计算机中表示的带符号的二进制数称为机器数</li>
<li>机器数有原码,补码,反码三种表示方式</li>
<li>这里,假设机器数的真值为[-1,1]的小数,小数部分为数值,整数部分为符号<blockquote>
<p>如:1.0100=10100</p>
</blockquote>
</li>
</ul>
<h3 id="原码-反码-补码及其加减运算"><a href="#原码-反码-补码及其加减运算" class="headerlink" title="原码,反码,补码及其加减运算"></a>原码,反码,补码及其加减运算</h3><h4 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h4><ul>
<li>原码最高位是符号位,0表示正数,1表示负数</li>
<li>其他位是数值位,以绝对值的方式给出</li>
<li>数值0有+0和-0两种原码表示,即0.0000和1.0000</li>
</ul>
<p>原码的加减法需要判断正负号,比较麻烦</p>
<h4 id="反码表示"><a href="#反码表示" class="headerlink" title="反码表示"></a>反码表示</h4><p>正数不变;负数反码在原码的基础上,符号位不变,其他位取反</p>
<ul>
<li>反码的反码是原码</li>
<li>运算时，当最高位有进位而丢掉进位时,要在最低位加1(循环进位)。</li>
</ul>
<h4 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h4><p>正数不变;负数补码在反码的基础上,数值加1</p>
<ul>
<li>数值0的补码形式是唯一的,为0.0000</li>
<li>补码的补码是原码</li>
</ul>
<p>补码在运算中有如下性质:</p>
<ul>
<li>符号位与数值位一样参与运算</li>
<li>补码运算的结果仍为补码</li>
<li>[X]补+[Y]补=[X+Y]补</li>
<li>[X]补-[Y]补=[X]补+[-Y]补</li>
<li>注意,Y与-Y正负号不同,求补码的策略也不同</li>
<li>补码运算时最高位产生的进位直接舍去即可</li>
</ul>
<h3 id="加减运算的溢出处理"><a href="#加减运算的溢出处理" class="headerlink" title="加减运算的溢出处理"></a>加减运算的溢出处理</h3><p>溢出:运算结果超出机器数所能表示的范围</p>
<ul>
<li>异号相加或同号相减结果是不会溢出的,只考虑同号相加或异号相减的情况</li>
<li>注意,最高位是否产生进位和运算结果是否溢出没有关系</li>
</ul>
<p>溢出判断有如下几种方法:</p>
<ul>
<li>同号两数相加,结果符号与两加数不相同,则溢出<blockquote>
<p>$\overline f_A \overline f_B f_S + f_A f_B \overline f_S = 1,其中,f_A f_B f_S$分别为两运算数的符号和结果的符号</p>
</blockquote>
</li>
<li>最高位进位和符号位进位不相同,则溢出<ul>
<li>即,运算正确的情况下,最高位(符号位的前一位)的进位一定要导致符号位进<blockquote>
<p>$C \overline C_f +\overline  C C_f = 1; 其中C,C_f$分别是最高位的进位和符号位的进位</p>
</blockquote>
</li>
</ul>
</li>
<li>采用双符号位运算,正数符号为00,负数为11,此时当结果的两个符号位不同时,溢出<blockquote>
<p>$\overline f_{S2} f_{S1} + f_{S2} \overline f_{S1} = 1,其中f_{S2},f_{S1}$分别是两位符号位</p>
</blockquote>
</li>
</ul>
<h3 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h3><p>在计算机中的数据有定点数和浮点数两种表示方式</p>
<h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>定点数指小数点固定在某个位置上的数据,前面加减法中讨论的为定点数</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数指小数点位置可以浮动的数据,可以用$N = M*R^E$表示</p>
<ul>
<li>N为浮点数,M为尾数,E为阶码,R为阶的基数;一般情况下一个计算机中的R都是相同的,无需存储</li>
</ul>
<p>浮点数在计算机中一般以这样的形式显示:$M_S$–$E$–$M$</p>
<ul>
<li>$M_S$: 尾数的符号位(一般为一位),设置在最高位</li>
<li>$E$: 阶码,有n+1位,一般为整数,第一位为符号位</li>
<li>$M$: 尾数,有m位,和前面的$M_S$一同组成一个定点小数<blockquote>
<ul>
<li><p>规格化尾数:当R=2(二进制数)且尾数不为0时,其绝对值应大于或等于十进制的0.5(即最高位应当为1);对非规格化浮点数,需要将尾数左移或右移,并改变阶码使其满足规格化要求  </p>
<blockquote>
<p>如:0.0011 -&gt; (0.11)*2^(0010)</p>
</blockquote>
</li>
<li><p>机器零值:表示比机器数能表示的最小数还要小的值</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>浮点数国际标准: IEEE 754</p>
<ul>
<li>单精度浮点数(32位):阶码8位,尾数24位(含一位符号位)</li>
<li>双精度浮点数(64位):阶码11位,尾数53位(含一位符号位)</li>
<li>浮点数基数为2,阶码采用增码(移码),尾数采用原码</li>
<li>而在多数通用机中，浮点数的尾数用原码或补码表示，阶码用补码或移码表示。</li>
<li>注意,由于规格化后的原码最高位恒为1,存储时自动省略,需要在计算时自己加上去<blockquote>
<ul>
<li>移码:在补码基础上,将符号位取反;在阶码上的移码只执行加减运算,且需要对结果进行修正</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="数值范围和精度"><a href="#数值范围和精度" class="headerlink" title="数值范围和精度"></a>数值范围和精度</h3><p>数值范围指机器所能表示的一个数的最大值和最小值;精度是指一个数的有效位数</p>
<ul>
<li>32位定点小数(补码):$-1$(1000…)~$1-2^{-31}$(0111…)</li>
<li>32位定点整数(补码):$-2^{31}$(1000…)~$2^{31}-1$(0111…)</li>
<li>32位单精度浮点数:$-2^{127}$~$(1-2^{-23})*2^{127}$,精度为24位</li>
</ul>
<h2 id="3-3-二进制乘法运算"><a href="#3-3-二进制乘法运算" class="headerlink" title="3.3 二进制乘法运算"></a>3.3 二进制乘法运算</h2><h3 id="定点数一位乘法"><a href="#定点数一位乘法" class="headerlink" title="定点数一位乘法"></a>定点数一位乘法</h3><h4 id="定点原码一位乘"><a href="#定点原码一位乘" class="headerlink" title="定点原码一位乘"></a>定点原码一位乘</h4><p>人工算法:<br><img src="/2020/02/24/computer-composition0/multi0.jpg" alt="multipy"></p>
<p>机器算法:<br><img src="/2020/02/24/computer-composition0/multi1.jpg" alt="multipy"></p>
<ul>
<li>在机器中,有3个寄存器ABC,分别存放部分积,被乘数和乘数的绝对值,其中部分积和被乘数都以双符号位表示;具体过程如下:</li>
</ul>
<ol>
<li>初始化:A寄存器清零,被乘数X放在B中,n位乘数Y放在C中,Cd初始值设为n(用于判断C是否被乘完)</li>
<li>判断C的最低为是否为1,是则将A+B赋给A</li>
<li>将{A,C}向右移一位(A高位补符号位),此时A的最低位进入C的最高位,C的最低位丢失</li>
<li>Cd减1,若减1后Cd仍不为0,转2.继续进行循环</li>
<li>计算A的最高符号位,其为被乘数和乘数符号位的异或</li>
<li>得出结果,此时结果的高位在A中,低位在C中</li>
</ol>
<p>示意图如下,其中被乘数X=0.1101,乘数Y=0.1011<br><img src="/2020/02/24/computer-composition0/multi2.jpg" alt="multipy"><br>得到X*Y=0.10001111</p>
<h4 id="定点补码一位乘"><a href="#定点补码一位乘" class="headerlink" title="定点补码一位乘"></a>定点补码一位乘</h4><p>由于计算机中机器数常以补码形式存在,可以直接使用补码相乘</p>
<p>补码相乘规则如下:</p>
<blockquote>
<p>设被乘数$[X]_补=X_0.X_1X_2…X_n$,乘数$[Y]_补=Y_0.Y_1Y_2…Y_n$,则有:<br>$$ [X*Y]_补=[X]_补*(0.Y_1Y_2…Y_n)-[X]_补*Y_0 $$<br>可见,如果$Y$为负数,需要补充进行$-[X]_补$操作</p>
</blockquote>
<p>布斯补码乘法规则如下:</p>
<blockquote>
<p>考虑相邻的两位$Y_{i+1}$和$Y_i$(乘数的最后一位和倒数第二位),将定点原码一位乘中的2.3.策略改成如下</p>
<ul>
<li>最后两位为00或11,{A,C}右移一位</li>
<li>最后两位为01,将部分积A增加$[X]_补$,{A,C}右移一位</li>
<li>最后两位为10,将部分积A增加$[-X]_补$,{A,C}右移一位</li>
<li>最后一步运算结束后不需要移位<br>计算时,乘数末位需要添加附加位$Y_{n+1}=0$</li>
</ul>
</blockquote>
<p>示意图如下,其中被乘数X=-0.1101,乘数Y=0.1011,即[X]补=11.0011,[Y]补=0.1011,[-X]补=00.1101:<br><img src="/2020/02/24/computer-composition0/multi3.jpg" alt="multipy"> </p>
<h3 id="定点数二位乘"><a href="#定点数二位乘" class="headerlink" title="定点数二位乘"></a>定点数二位乘</h3><p>相比于定点一位乘法,定点数二位乘按乘数每两位的取值情况，一次求出对应于该两位的部分积。此时，只要增加少拭逻辑电路，就可使乘法速度提高一倍。 </p>
<h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><p>为了进一步提高乘法运算速度，可采用类似于人了计算的方法，用一个阵列乘法器完成乘法运算</p>
<h2 id="3-4-二进制除法运算"><a href="#3-4-二进制除法运算" class="headerlink" title="3.4 二进制除法运算"></a>3.4 二进制除法运算</h2><h3 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><p>人工算法:<br><img src="/2020/02/24/computer-composition0/div0.jpg" alt="div"> </p>
<p>机器算法:(要求被除数小于除数,即除法结果应小于1)</p>
<ul>
<li>使用3个寄存器ABC,存放余数(被除数),除数和商的绝对值,商的符号独立计算</li>
</ul>
<ol>
<li>初始化:被除数X放在A中,n位除数Y放在B中,C寄存器清零,计数器i=n+1,若X&gt;Y,则溢出</li>
<li>将A减去B;若余数大于等于0,则商C中的最低位上1,否则上0并恢复余数</li>
<li>i减1,若减1后i仍不为0,将A,C左移一位,重复2.过程</li>
<li>计算C的最高符号位,其为被除数和除数符号位的异或</li>
<li>得出结果,此时商在C中,余数在A中</li>
</ol>
<p>示意图如下,其中被除数X=0.1011,Y=0.1101,即[Y]补=00.1101, [-Y]补=11.0011:<br><img src="/2020/02/24/computer-composition0/div1.jpg" alt="div"><br>得到结果X/Y=0.1101,余数位0.0111</p>
<h4 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h4><p>加减交替法省略了恢复余数的操作,将恢复余数法中的2.策略改成如下</p>
<blockquote>
<ul>
<li>若A&gt;0,则将A减去B;结果余数A&gt;0,则商C中的最低位上1,否则上0(此时下一步就会执行减法操作)</li>
<li>若A&lt;0,则将A加上B;若余数A&gt;0,则商C中的最低位上1,否则上0<br>此时若最后一次上商为0,在计算余数时,依然需要为最后一步恢复余数</li>
</ul>
</blockquote>
<p>示意图如下,其中被除数X=0.1011,Y=0.1101,即[-Y]补=11.0011:<br><img src="/2020/02/24/computer-composition0/div2.jpg" alt="div">  </p>
<ul>
<li>实际上在上述除法运算策略中,被除数的位数可以是除数的两倍,初始化时其高位放在A中,低位在C中,在左移操作时将C中的高位移入A中的低位</li>
</ul>
<h3 id="提高除法运算速度的方法"><a href="#提高除法运算速度的方法" class="headerlink" title="提高除法运算速度的方法"></a>提高除法运算速度的方法</h3><ul>
<li>跳0跳1除法</li>
<li>除法运算通过乘法操作来实现</li>
</ul>
<h2 id="3-5-浮点数的运算方法"><a href="#3-5-浮点数的运算方法" class="headerlink" title="3.5 浮点数的运算方法"></a>3.5 浮点数的运算方法</h2><h3 id="浮点数的加减法运算"><a href="#浮点数的加减法运算" class="headerlink" title="浮点数的加减法运算"></a>浮点数的加减法运算</h3><p>考虑两个浮点数$X = M_X*2^E_X, Y = X = M_Y*2^E_Y$的运算</p>
<p>浮点数加减法运算需要如下五个过程:</p>
<ol>
<li>对阶操作,使得两个浮点数阶码相等(注意阶码是移码)<blockquote>
<ul>
<li>小阶向大阶对齐,将阶码小的数位数右移$\Delta$E位,使其阶码变成E(一般对于补码尾数,符号位参加移位,高位补符号位;但对于原码尾数对阶,符号位不参加移位,高位补0),右移所丢失的位可以保留下来以供舍入操作</li>
</ul>
</blockquote>
</li>
<li>尾数加减,即通常的尾数加减(两个符号位)</li>
<li>(补码)结果规格化操作<blockquote>
<ul>
<li>右规: 运算结果两个符号位的值不同,即运算尾数向上溢出,需要将尾数结果右移一位(高位补符号位),阶码E+1</li>
<li>左规: 运算结果最高数值位与符号位相同(补码),应将尾数连续左移直到最高位数值与符号位不同,并减去相应阶码</li>
</ul>
</blockquote>
</li>
<li>舍入操作: 用于右规和对阶操作时低位舍去的处理<blockquote>
<ul>
<li>截断法: 直接丢掉低位</li>
<li>置1法: 舍去后最低位直接置1</li>
<li>0舍1入法: 若舍去的最高位为1,则它前面的最低为加1,这是常用方法</li>
</ul>
</blockquote>
</li>
<li>检查阶码是否溢出: 在规格化和舍入时阶码可能发生溢出情况<blockquote>
<ul>
<li>阶码向下溢出: 运算结果为机器零</li>
<li>阶码向上溢出: 置溢出标记</li>
</ul>
</blockquote>
</li>
</ol>
<p>具体流程图如下:<br><img src="/2020/02/24/computer-composition0/float0.jpg" alt="float"></p>
<h3 id="浮点数的乘除法运算"><a href="#浮点数的乘除法运算" class="headerlink" title="浮点数的乘除法运算"></a>浮点数的乘除法运算</h3><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><ol>
<li>检测操作数是否为0，若其中有一个操作数为0，则置结果为0；</li>
<li>阶码相加，阶符相同的加可能会溢出，若溢出，则作溢出处理；(阶码一般是移码)</li>
<li>尾数相乘；</li>
<li>尾数乘积规格化,只有左规.</li>
<li>舍入</li>
<li>截断处理:无条件地丢掉正常尾数最低位之后的全部数值</li>
<li>舍入处理:运算过程中保留右移中移出的若干高位的值,然而再按某种规则用这些位上的值修正尾数</li>
<li>判溢出</li>
</ol>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>浮点数除法运算与乘法运算类似,也分求商的阶码、尾数相除、规格化、舍入和判溢这几个步骤</p>
<h2 id="3-6-运算部件"><a href="#3-6-运算部件" class="headerlink" title="3.6 运算部件"></a>3.6 运算部件</h2><h3 id="定点运算部件"><a href="#定点运算部件" class="headerlink" title="定点运算部件"></a>定点运算部件</h3><p>定点运算部件由算术逻辑运算部件ALU、多个寄存器、移位电路、计数器、门电路组成</p>
<ul>
<li>一般定点运算部件中有3个寄存器A、B、C,在不同运算中作用如下:<blockquote>
<ul>
<li>加法:A为被加数-&gt;运算结果,B为加数</li>
<li>减法:A为被减数-&gt;运算结果,B为减数</li>
<li>乘法:A为部分积-&gt;乘积高位,B为被乘数,C为乘数-&gt;乘积低位</li>
<li>除法:A为被除数-&gt;余数,B为除数,C为商</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="浮点运算部件"><a href="#浮点运算部件" class="headerlink" title="浮点运算部件"></a>浮点运算部件</h3><p>浮点运算部件通常由阶码运算部件和尾数运算部件组成</p>
<ul>
<li>阶码部分仅执行加减运算</li>
<li>尾数部分执行加减乘除运算</li>
</ul>
<h2 id="3-7-数据校验码"><a href="#3-7-数据校验码" class="headerlink" title="3.7 数据校验码"></a>3.7 数据校验码</h2><p>通过在数据为中加入一些冗余位,从而达到在数据传输过程中能自动发现错误和校正错误</p>
<ul>
<li>码距: 任意两个合法码之间至少由几个二进制位不同; 较大的码距能使得一个合法码变成另一个合法码的概率较小, 但会增加存储的代价</li>
</ul>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>方法: 在数据(开头)补充一个校验位,使得补充校验位后的数据编码中1值的个数为奇数(奇校验)或偶数(偶校验)</p>
<p><img src="/2020/02/24/computer-composition0/check0.jpg" alt="check"></p>
<ul>
<li>奇偶校验码只能发现一位或奇数个位的出错</li>
<li>奇偶校验码只能发现错误,不能校正错误</li>
<li>就校验码常用于存储器读写检查，或ASCII字符传送过程中的检查。</li>
</ul>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>方法: 在数据中加入多个校验位,将数据中的每一个二进制位分配在几个校验组中;当某一位出错时,就会导致多个校验组的数值发生变化,通过综合分析这些变化来发现出错的位置,为纠错提供依据</p>
<p>一位纠错海明码:</p>
<ul>
<li>设有r位校验位，则共有0到2^r-1个共2^r个组合。若用0表示无差错，则剩余2^r-1个值表示有差错，并指出错在第几位。由于差错可能发生在k个数据位中或r个校验位中，因此有: 2^r–1 &gt;= r+k<blockquote>
<ul>
<li>例如,5-11位数据可用4位校验位来校验</li>
</ul>
</blockquote>
</li>
<li>校验位的分布(下标从1开始):<blockquote>
<ul>
<li>将原数据按位从前向后标号,遇到第$2^{i-1}$个位时,插入第i个校验位$P_i$,得到海明码的数据排列</li>
</ul>
</blockquote>
</li>
<li>校验位的计算<blockquote>
<ul>
<li>按照上述的数据排列给每一位一个二进制编号(从1开始),则对于第i个校验位,它需要校验的是所有二进制编号中第i位为1的数<br>如,第二位校验码$P_2$就需要校验第2(010),3(011),6(110),7(111)位;注意,此时校验码本身也在这些校验位中</li>
<li>用上述方法按校验位进行分组,校验位计算是进行偶校验计算,它等于同组的其他数据的异或</li>
</ul>
</blockquote>
</li>
<li>还可以加入一个总校验位$P_{i+1}$,它等于前面所有位的异或,这时的校验码不仅能纠正一位错,还能发现两位错</li>
</ul>
<p>此时,原数据中每一位都至少由两位校验码校验,码距为4<br>检验方法: 对上述分组中的每一组进行异或检验(包括总校验位),所有检验结果都为0则无措,若有些组为1则可根据检验结果推理出哪一位出错(或者是两位错)</p>
<h3 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h3><p>CRC编码以模2运算为基础,可以发现并纠正多位错误</p>
<h1 id="四、主存储器"><a href="#四、主存储器" class="headerlink" title="四、主存储器"></a>四、主存储器</h1><p>主存储器(主存或内存)在现代计算机中处于中心地位</p>
<ul>
<li>计算机执行的程序和数据均放在存储器中</li>
<li>计算机系 统中输入输出设备数量增多,数据传送速度加快</li>
<li>共享存储器的多处理机的出现 </li>
</ul>
<h2 id="4-1-主存储器分类-技术指标和基本操作"><a href="#4-1-主存储器分类-技术指标和基本操作" class="headerlink" title="4.1 主存储器分类,技术指标和基本操作"></a>4.1 主存储器分类,技术指标和基本操作</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>随机存储器RAM<blockquote>
<ul>
<li>又称读写存储器,通过指令可以随机对各个存储单元进行访问的存储器;一般访问所需时间与存储单元的地址无关,但停电会造成信息丢失</li>
</ul>
</blockquote>
</li>
<li>非易失性存储器<blockquote>
<ul>
<li>停电仍能保持其内容</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h3><ul>
<li>容量<blockquote>
<ul>
<li>计算机可寻址的最小单位是一个存储字;一个存储字所包括的二进制位数称为字长</li>
<li>由于现代计算机中一个字节为8位,因此一个字的字长通常为8的倍数</li>
<li>以字节为单位来表示主存储器存储单元的总数就是主存储器的容量</li>
<li>指令中地址码的位数决定了主存储器可以直接寻址的最大空间,如32位微型机提供32位物理地址,支持对4G物理存储空间的访问</li>
</ul>
</blockquote>
</li>
<li>存取时间<blockquote>
<ul>
<li>存储器的存取时间又称存储器访问时间,是指启动一次存储器操作(读/写)到完成该操作所经历的时间<br>存储周期</li>
<li>存储周期指连续启动两次独立的存储器操作(例如连续两次读操作)所需间隔的最小时间</li>
<li>通常,存储周期略长于存取时间</li>
</ul>
</blockquote>
</li>
</ul>
<p>主存储器的速度和容址两项指标随着存储器件的发展得到了极大的提高。但是，具有 合适价格的主存储器能提供信息的速度总是跟不上CPU的处理指令和数据的速度。</p>
<h3 id="主存储器的基本操作"><a href="#主存储器的基本操作" class="headerlink" title="主存储器的基本操作"></a>主存储器的基本操作</h3><p>主存储器和CPU的连接是由总线支持的:<br><img src="/2020/02/24/computer-composition0/rw0.jpg" alt="rw"></p>
<ul>
<li>AR位地址寄存器</li>
<li>DR为数码寄存器</li>
</ul>
<h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p>读操作是将存储器的数据读取到CPU中:</p>
<ol>
<li>CPU把信息字的地址送到AR,经地址总线送往主存储器</li>
<li>CPU发读(Read)命令</li>
<li>CPU等待主存储器的Ready回答信号，Ready为 1，表示信息已读出经数据总线,送入DR</li>
</ol>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>写操作是将CPU中的数据写入存储器中</p>
<ol>
<li>CPU把信息字的地址送到AR，经地址总线送往主存储器,并将信息字送往DR</li>
<li>CPU发写(Write)命令</li>
<li>CPU等待主存储器的Ready回答信号，Ready为 1，表示信息已从DR经数据总线写入主存储器</li>
</ol>
<h2 id="4-2-读-写存储器-的发展"><a href="#4-2-读-写存储器-的发展" class="headerlink" title="4.2 读/写存储器(的发展)"></a>4.2 读/写存储器(的发展)</h2><h3 id="静态存储器SRAM"><a href="#静态存储器SRAM" class="headerlink" title="静态存储器SRAM"></a>静态存储器SRAM</h3><p>静态存储器利用触发器保存信息,只要不断电,信息就不会丢失</p>
<ul>
<li>集成度低,功耗较大</li>
</ul>
<h3 id="动态存储器DRAM"><a href="#动态存储器DRAM" class="headerlink" title="动态存储器DRAM"></a>动态存储器DRAM</h3><p>动态存储器利用MOS管存储电荷来保存信息,需要不断给电容充电使信息保存</p>
<ul>
<li>使用单管存储单元,通过电容充电来保存信息</li>
<li>再生: DRAM需要在电容的电荷漏掉之间进行充电,又称刷新,一般周期小于2ms</li>
<li>集成度高,功耗小,速度快;但读出是破坏性的,读出后需要立即对单元进行重写</li>
<li>单元读出信号很小,要求有高灵敏度的读出放大器</li>
<li>主要用于大容量存储器<blockquote>
<ul>
<li>相比SRAM,DRAM每片存储容量约是前者4倍,造价约为前者1/4,功率约为前者1/6</li>
</ul>
</blockquote>
</li>
</ul>
<p>DRAM发展:</p>
<ul>
<li>FPM快页式内存</li>
<li>EDO DRAM</li>
<li>同步DRAM(SDRAM):将RAM与CPU以相同的时钟频率进行控制,使RAM和CPU外频同步,取消等待时间</li>
<li>DDR SDRAM:双数据传送速率的SDRAM,在时钟的上升沿和下降沿都能读出数据(预取2位)</li>
<li>DDR 2:预读取能力为4位,降低电压和功耗,等效传输频率翻倍</li>
<li>DDR 3:预读取能力为8位</li>
</ul>
<h2 id="4-3-非易失性半导体存储器"><a href="#4-3-非易失性半导体存储器" class="headerlink" title="4.3 非易失性半导体存储器"></a>4.3 非易失性半导体存储器</h2><p>非易失性半导体存储器在停电时所存储的内容也不会丢失</p>
<ul>
<li><p>只读存储器ROM: 掩模式ROM由芯片制造商在制造时写入内容,以后只能读而不能再写入,前面叙述过它的存储原理</p>
</li>
<li><p>可编程序的只读存储器PROM: 一次性写入的存储器;如熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元的熔丝(写入)。</p>
</li>
<li><p>可擦除可编程序的只读存储器EPROM: 能多次修改数据的ROM;产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线照射后,浮置栅上的电子将逸散,即整体擦除</p>
</li>
<li><p>可电擦可编程序只读存储器E2PROM: 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写入周期要几毫秒,寿命为10万次。</p>
</li>
<li><p>快擦读写存储器Flash Memory: 用电擦除,但只能整体擦除或分区擦除; 可做成内存卡应用于各种电子产品</p>
</li>
</ul>
<h2 id="4-4-存储器的组成与控制"><a href="#4-4-存储器的组成与控制" class="headerlink" title="4.4 存储器的组成与控制"></a>4.4 存储器的组成与控制</h2><h3 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h3><p>一个存储器的芯片容量是有限的,要达到所需要的存储字数和存储字长,需要在字向和位向进行扩充; 这里展示静态存储器的位扩展和字扩展</p>
<p>静态存储芯片表示:</p>
<ul>
<li>芯片容量: 由字数*字长表示</li>
<li>地址线: 用于寻址,地址线的位数可由字数表示;如16K表示地址线有14条($16K=2^{14}$,其中1K的地址线是10条</li>
<li>数据线: 用于向芯片写入/读出数据,数据线的位数可由字长表示;如字长为4的芯片数据线有4条</li>
<li>使能(片选)端: 用于控制芯片是否能进行读写操作,一般低有效</li>
<li>读写控制端: 用于切换芯片的读/写操作,一般高位读取低位写入</li>
</ul>
<h4 id="位扩展-扩充数据线字长"><a href="#位扩展-扩充数据线字长" class="headerlink" title="位扩展(扩充数据线字长)"></a>位扩展(扩充数据线字长)</h4><ul>
<li>地址线,使能线(片选$\overline {CS}$),读写控制端$R/ \overline W$并联</li>
<li>数据线串联,分高低位分别引出<br>两片16K*4扩展成一片16K*8<br><img src="/2020/02/24/computer-composition0/sram0.jpg" alt="sram"></li>
</ul>
<h4 id="字扩展-扩充地址线字数"><a href="#字扩展-扩充地址线字数" class="headerlink" title="字扩展(扩充地址线字数)"></a>字扩展(扩充地址线字数)</h4><ul>
<li>地址线,读写控制线,使能线并联</li>
<li>片选连接译码器,用于区分各芯片的地址范围,地址高位通过译码器控制使能端来访问不同的芯片<br>四片16K*8扩展成一片64K*8<br><img src="/2020/02/24/computer-composition0/sram1.jpg" alt="sram"></li>
</ul>
<h4 id="字位扩展"><a href="#字位扩展" class="headerlink" title="字位扩展"></a>字位扩展</h4><p>同时对字向和位向进行扩展</p>
<ul>
<li>片内成组进行位扩展,然后组间进行字扩展</li>
<li>需要用MN/LK个芯片将L*K的存储器扩展成M*N的存储器<br><img src="/2020/02/24/computer-composition0/sram2.jpg" alt="sram"></li>
</ul>
<h3 id="存储控制"><a href="#存储控制" class="headerlink" title="存储控制"></a>存储控制</h3><p>在存储器中，往往需要增设附加电路。这些附加电路包括地址多路转换线路、地址选 通、刷新逻辑，以及读／写控制逻辑等。</p>
<ul>
<li>在大容量存储芯片中,为了减少芯片的地址线引出端的数目,将地址码分两次送到存储器芯片中,使得芯片地址线引出端减少一半</li>
<li>刷新逻辑: 通过定时刷新(读出)保证DRAM中的信息不丢失<blockquote>
<ul>
<li>刷新周期: 从上一次对整个存储器刷新结束到下一次刷新结束为止需要的时间,一般为2ms</li>
<li>分布式刷新:  在2ms内分散地将存储器的每一行刷新</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="存储校验线路"><a href="#存储校验线路" class="headerlink" title="存储校验线路"></a>存储校验线路</h3><ul>
<li>早期计算机多采用奇偶校验电路,只能发现一位错且不能纠正</li>
<li>由于大规模集成电路的发展，主存储器的位数可以做得更多，使多数计算机的存储器有纠正错误代码的功能(ECC)</li>
<li>一般采用的海明码校验线路可以纠正一位错</li>
</ul>
<h2 id="4-5-多体交叉存储器"><a href="#4-5-多体交叉存储器" class="headerlink" title="4.5 多体交叉存储器"></a>4.5 多体交叉存储器</h2><p>计算机中的大容量主存可由多个存储体构成,每个存储体都有自己的读写线路、地址寄存器和数据寄存器,称这种存储体为存储模块</p>
<ul>
<li>为了提高每个模块的使用率和总体的读取效率,对每个模块进行低位交叉编址,连续的地址分布在相邻的模块中<blockquote>
<p>M个交叉模块的使用率在$\sqrt M$和$M$之间</p>
</blockquote>
</li>
</ul>
<h1 id="五、存储系统"><a href="#五、存储系统" class="headerlink" title="五、存储系统"></a>五、存储系统</h1><p>(本章为原书第七章)</p>
<h2 id="5-1-存储系统的层次结构"><a href="#5-1-存储系统的层次结构" class="headerlink" title="5.1 存储系统的层次结构"></a>5.1 存储系统的层次结构</h2><h3 id="存储器类型"><a href="#存储器类型" class="headerlink" title="存储器类型"></a>存储器类型</h3><ul>
<li>主存储器:<blockquote>
<ul>
<li>一般为半导体存储器</li>
<li>存放当前正在执行的程序和数据</li>
<li>主存储器可以随机访问任一单元</li>
</ul>
</blockquote>
</li>
<li>辅助存储器(外存储器)<blockquote>
<ul>
<li>一般为磁盘,磁带,光盘等</li>
<li>存放当前不在运行的大量程序和数据</li>
<li>辅助存储器一般为串行访问存储器,需要顺序地按位进行访问,访问指定信息所需时间与信息所在位置有关   </li>
</ul>
<p>串行存储器:</p>
<ul>
<li>顺序存取存储器(磁带等): 磁带上的信息以顺序的方式存储在带上，读／写时要待磁带移动到合适位置后才能顺序读／写，需要耗费较多时间</li>
<li>直接存取存储器(磁盘等): 它对信息的存取包括移动磁头到信息所在区域(磁道)和从磁道的合适位置进行顺序读写;它比磁带快得多</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h3><p>操作系统和硬件结合,把主存和辅存统一在一起,形成了一个存储层次</p>
<ul>
<li>整体上看,其速度接近于主存</li>
<li>整体上看,其容量接近于辅存  </li>
<li>主存-辅存层次满足了存储器的大容量和低成本的需求<br>这种系统的发展和完善形成了现在广泛使用的虚拟存储系统</li>
</ul>
<p>cache-主存层次</p>
<ul>
<li>在速度方面,计算机的主存和CPU存在一个数量级的差距</li>
<li>高速缓冲存储器cache在速度上能满足CPU的要求</li>
<li>从CPU的角度看,cache-主存层次的速度接近于cache,容量与每位价格接近于主存</li>
<li>这个层次完全由硬件实现</li>
</ul>
<p>计算机的存储层次解决了速度与成本之间的矛盾</p>
<p>现代计算机同时采用上述两种存储层次,构成cache-主存-辅存三级存储层次</p>
<h2 id="5-2-高速缓冲存储器"><a href="#5-2-高速缓冲存储器" class="headerlink" title="5.2 高速缓冲存储器"></a>5.2 高速缓冲存储器</h2><h3 id="cache存在的合理性"><a href="#cache存在的合理性" class="headerlink" title="cache存在的合理性"></a>cache存在的合理性</h3><ul>
<li>程序访问的局部性原理: 在一个较短的时间间隔内,程序访问的地址往往集中在一个很小的范围内<blockquote>
<ul>
<li>程序指令地址本身就是连续分布的,且循环程序段和子程序段经常被反复执行</li>
<li>程序数据分布虽然不一定是集中的,但短时间内对数组的存储和访问以及对工作单元的选择也需要使用到局部范围的存储器地址</li>
</ul>
</blockquote>
</li>
</ul>
<p>根据局部性原理,在主存和CPU之间设置一个高速而容量相对较小的存储器,将当前执行的程序和数据存放在这个存储器中;当程序运行时,不需要再从主存储器中取指令和数据,访问cache即可</p>
<h3 id="cache的结构"><a href="#cache的结构" class="headerlink" title="cache的结构"></a>cache的结构</h3><p>cache一般由SRAM组成,它的工作速度数倍于主存,全部功能由硬件实现,并且对程序员是透明的</p>
<p>其基本结构如下:<br><img src="/2020/02/24/computer-composition0/cache0.jpg" alt="cache">  </p>
<ul>
<li>将n位的主存地址分块,前m位为主存块号,后b位为块内地址;将cache也分成同样大小的多个块,前c位为cache块号,后b位为块内地址(块内字节数与主存相同)</li>
<li>cache内每一个块外加一个标记地址,指明它是主存哪一块的副本,这个标记地址应该为m-c位</li>
<li>注意,cache的块号和它的标记地址不同</li>
</ul>
<p>当CPU发出读请求时,将主存地址m位(或m中的一部分)与cache某块的标记相比较,当结果相等时,说明需要的数据已经在cache中,直接访问cache即可,在CPU与cache之间,通常一次传送一个字块;当比较结果不相等时,说明需要的数据尚未调入cache,那么就要把该数据所在的整个字块从主存中调进来</p>
<ul>
<li>命中: CPU所要访问的信息在cache中,否则为不命中</li>
<li>命中率: CPU所要访问的信息在cache中的比率</li>
<li>失效率: 所要访问的信息不在cache中的比率</li>
</ul>
<p>具有cache的存储器的平均存取时间的计算:</p>
<ul>
<li>设cache本身的存取时间(周期)为tc,命中率为h,主存的存取时间为tm,则:<blockquote>
<p>平均存取时间t = h*tc+(1-h)(tc+tm) 或者估算为 h*tc+(1-h)tm</p>
</blockquote>
</li>
</ul>
<p>cache写策略:如何保证cache中的副本在更改后与主存一致</p>
<ul>
<li>标志交换或写回法: 暂时只修改cache中数据,待该字块被替换出去时写入主存</li>
<li>通过式写法或写通法: 每次修改cache的同时也修改主存</li>
<li>若被修改的单元根本不在cache中,也可以直接对主存进行写操作</li>
</ul>
<h3 id="cache映像"><a href="#cache映像" class="headerlink" title="cache映像"></a>cache映像</h3><h4 id="地址映射-映像-的概念"><a href="#地址映射-映像-的概念" class="headerlink" title="地址映射(映像)的概念"></a>地址映射(映像)的概念</h4><p>为了将信息存放到cache中,需要某种函数将主存的地址映射到cache中;执行程序时,需要通过地址变换将主存地址变换成cache地址,这种变换基于地址映像来实现</p>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><ul>
<li>特点: 主存中第$2^i+k$块只能映射到cache中第k块,其中,i&gt;c(c为cache字块地址位数)<blockquote>
<p>即: $cache字块号 = 主存字块号 mod 2^c$</p>
</blockquote>
</li>
</ul>
<p>从实现上,只需要将m位的主存分成t位主存字块标记和c位cache字块标记;cache中只需要t位进行标记,将其与t位主存字块标记对比即可判断是否命中</p>
<p><img src="/2020/02/24/computer-composition0/cache1.jpg" alt="cache"></p>
<p>由于cache块号与主存块号的部分相关连,因此标记只需要t位;实现简单,cache块的定位迅速(主存的块只能映射到一个cache块中),但不够灵活</p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><ul>
<li>特点: 主存中的每一块可以映射到cache中的任意一块<blockquote>
<p>cache中的标记需要m位,在定位cache块时需要将m位主存块号和所有的cache标记比对一次,才能判断是否”命中”</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/cache2.jpg" alt="cache"></p>
<p>这种方式最灵活,cache命中率最高,但成本也最高,开销大速度慢</p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><ul>
<li>特点: 是直接映射和全相联映射的一个折衷,主存中的每一块可以映射到cache中的$2^{c-r}$块<blockquote>
<ul>
<li>主存和cache分成r组,取主存块地址和cache块地址的后r位</li>
<li>组间为直接映射,组内为全相联映射</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/cache3.jpg" alt="cache"></p>
<p>上图中cache每一组(行)内都有多个全相联的块</p>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><p>新的主存字块需要调入cache而原可用位置已被占满时,就需要用替换算法来更新cache内容</p>
<h4 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h4><ul>
<li>按调入cache的先后顺序来决定需要被替换出去的cache块;最先被调入cache的块最先被替换成新的块<blockquote>
<ul>
<li>这种算法考虑了局部访问性原理</li>
<li>这种算法实现容易,开销小</li>
<li>但有些时候会使得命中率下降</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h4><ul>
<li>将近期长久未被访问过的块替换出去<blockquote>
<ul>
<li>这种算法按调用频繁程度来决定淘汰顺序,并没有考虑局部访问性原理,比较合理</li>
<li>这种算法的cache命中率较高</li>
<li>这种算法实现开销比FIFO稍大</li>
</ul>
</blockquote>
</li>
</ul>
<p>LRU+FIFO实现: 每次命中新块,都将它移动到队头;若未命中,则将队尾元素替换成新块,然后将它移动到队头</p>
<h4 id="cache地址的监听"><a href="#cache地址的监听" class="headerlink" title="cache地址的监听"></a>cache地址的监听</h4><p>在外部设备对存储器进行修改时,需要保证cache与主存对应快的内容一致,需要对地址进行监听</p>
<p>做法: 若某一IO设备直接对存储器而非cache写入数据时,将对应地址的cache(若有的话)标记有效的位清0,当CPU再次访问该cache时将产生不命中信号;保证CPU所取数据的正确性</p>
<h3 id="多层次cache"><a href="#多层次cache" class="headerlink" title="多层次cache"></a>多层次cache</h3><h4 id="指令cache和数据cache"><a href="#指令cache和数据cache" class="headerlink" title="指令cache和数据cache"></a>指令cache和数据cache</h4><p>将指令和数据放在同一cache中通常会使得存取数据操作和取指令操作发生冲突,延迟了指令的读取</p>
<p>哈佛结构: 将指令cache和数据cache独立分开来</p>
<h4 id="多层次cache-1"><a href="#多层次cache-1" class="headerlink" title="多层次cache"></a>多层次cache</h4><p>集成度高的芯片可用设计出高速的片内cache,与大容量的片外cache配合使用</p>
<p>一般一级cache和二级cache设计在片内,高性能处理器均已采用三级cache方案</p>
<h2 id="5-3-虚拟存储器"><a href="#5-3-虚拟存储器" class="headerlink" title="5.3 虚拟存储器"></a>5.3 虚拟存储器</h2><p>虚拟存储器指的是主存-辅存层次,程序员可以按虚存空间编址</p>
<p>几个单位: 段,页,段页</p>
<h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><p>段: 利用程序模块化性质,按照程序逻辑结构划分出的多个相对的独立部分</p>
<ul>
<li>如: 过程,子过程,数据表,阵列等</li>
<li>这些逻辑部分可以互相调用或者被外部程序调用,形成段间连接,产生规模较大的程序</li>
<li>一般用段表指明段在主存中的位置: 段号,段起点,装入位(表示段是否已经装入主存),段长等(段表本身也是由一个段存储)</li>
</ul>
<p>段式管理: 主存按段进行分配</p>
<ul>
<li>优点: 逻辑独立性好,与程序的自然分界相对应,易于编译、管理、修改和保护,也易于多道程序共享</li>
<li>缺点: 会在段间留下许多空余的零碎存储空间,造成存储资源的浪费</li>
</ul>
<h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>页面: 主存的物理空间被划分位等长的固定区域,称为页面</p>
<p>页式管理: 主存按页进行管理,信息传送单位是定长的页</p>
<ul>
<li>优点: 新页调入主存十分容易,,只要有空白页即可; 可能造成浪费的地方是程序最后一页的零头,它比段式管理系统的空间浪费要小得很多</li>
<li>缺点: 由于页不是逻辑上独立的实体,在处理、保护和共享都不及段式来得方便</li>
</ul>
<p>段页式管理: 将程序按模块分段,段内再分页; 出入主存仍以页为信息传送单位, 用段表和页表(每段一个页表)进行两级管理</p>
<p>####页式虚拟存储器</p>
<ul>
<li>逻辑页: 在页式虚拟存储器中,把虚拟空间分成页,称为虚页或逻辑页</li>
<li>物理页: 主存空间分成和虚存同样大小的页,称为实页或物理页</li>
<li>虚存地址: 虚拟地址由高低两个字段组成,高字段为逻辑页号,低字段为页内地址</li>
<li>实存地址: 主存实地址由高低两个字段组成, 高字段为物理页号,低字段为页内地址</li>
</ul>
<p>虚存地址到主存实地址的变换是由页表来实现的<br><img src="/2020/02/24/computer-composition0/page0.jpg" alt="page"></p>
<ul>
<li>对应每个虚页号有一个页表条目,该条目要包含虚页对应主存的物理页号</li>
<li>其他属性包含装入(有效)位,修改位(表示页面内容是否被修改),替换控制位(指出需要替换的页)和其他保护位等<blockquote>
<p>页表本身也在主存中,如果一次访问不命中,那么进行替换、修改再访问,需要和主存进行多次通讯,效率较低</p>
</blockquote>
</li>
</ul>
<p>快表TLB: 将频繁访问的页表信息存放在一个快速存储器中<br><img src="/2020/02/24/computer-composition0/TLB0.jpg" alt="tlb"></p>
<ul>
<li>首先按虚页号同时查询快表慢表</li>
<li>快表查到即访问,查不到即花费一个周期去主存中的慢表找</li>
<li>找到后用替换算法将该页号调入快表</li>
</ul>
<p>页式虚拟存储器优点:</p>
<ul>
<li>主存储器利用率较高</li>
<li>页表相对简单</li>
<li>地址变换速度较快</li>
<li>对磁盘管理比较容易</li>
</ul>
<p>缺点:</p>
<ul>
<li>程序模块化性能不好</li>
<li>页表很长,需要占用大量的存储空间</li>
</ul>
<p>内页表: 虚地址到主存物理地址的变换表<br>外页表: 虚地址和具体辅存地址之间的变换表</p>
<h3 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h3><p>在段页式管理的基础上,产生段页式虚拟存储器</p>
<ul>
<li>多道程序: 如果有多个用户在机器上运行,称为多道程序<blockquote>
<ul>
<li>每一道(每个用户)需要一个基号(用户标志号)</li>
<li>这个地址需要指明该道程序的段表起点(存放在基址寄存器中)</li>
</ul>
</blockquote>
</li>
<li>虚拟地址: 包括基号D,段号S,页号P,页内地址D</li>
</ul>
<p>段页式虚拟存储器地址变换过程见课本第174 175页<br><img src="/2020/02/24/computer-composition0/para0.jpg" alt="para"><br>查询过程:</p>
<ul>
<li>程序段起点+段号-&gt;页表起点</li>
<li>页表起点+页号+页内偏移量-&gt;实存地址</li>
</ul>
<h3 id="虚拟存储器工作过程"><a href="#虚拟存储器工作过程" class="headerlink" title="虚拟存储器工作过程"></a>虚拟存储器工作过程</h3><p><img src="/2020/02/24/computer-composition0/storage0.jpg" alt="storage"></p>
<h3 id="存储管理部件MMU"><a href="#存储管理部件MMU" class="headerlink" title="存储管理部件MMU"></a>存储管理部件MMU</h3><p>虚拟存储系统的特点:</p>
<ul>
<li>允许用户程序用比主存空间大得多的空间来访问主存</li>
<li>每次访存都要进行虚实地址的变换<br>整个虚拟存储器的管理是由存储管理部件MMU和操作系统共同完成的</li>
</ul>
<h2 id="5-4-相连存储器"><a href="#5-4-相连存储器" class="headerlink" title="5.4 相连存储器"></a>5.4 相连存储器</h2><p>在cache和虚拟存储器中,需要用到按内容寻址的相连存储器(页表查询等)</p>
<ul>
<li>相连存储器按照所存数据字的全部内容或部分内容进行查找(检索)访问<br><img src="/2020/02/24/computer-composition0/CR0.jpg" alt></li>
<li>CR是比较数寄存器</li>
<li>MR是屏蔽数寄存器,无需进行匹配的位置为0,置1的位为关键字段</li>
<li>WSR为字选择寄存器,对应位为0的字不参与查找(可以用这个进行二次或多次查找;将上一次的SRR放入WSR即可)</li>
<li>SRR为查找结果寄存器,满足要求的相应位为1</li>
<li>相联存储器能够进行比较操作(相等比较,大小比较,求最值)看,比较操作是并行的,时间复杂度为常数</li>
</ul>
<h2 id="5-5-存储保护"><a href="#5-5-存储保护" class="headerlink" title="5.5 存储保护"></a>5.5 存储保护</h2><p>多个用户对主存进行共享,需要防止由于一个用户程序出错导致其他用户程序和系统软件被破坏,也要防止一个用户程序不合法地访问其他的主存区域</p>
<h3 id="存储区域保护"><a href="#存储区域保护" class="headerlink" title="存储区域保护"></a>存储区域保护</h3><ul>
<li>在主存系统中由系统软件经特权指令设置上下界寄存器为每个程序划定存储区域,禁止越界访问</li>
</ul>
<p>虚拟存储系统中:</p>
<ul>
<li>页表保护: 每个程序都有自己的页表和段表,对它们进行保护; 除非地址变换出错,否则程序只能影响分配给它的几个主存页面</li>
<li>键保护: 为主存的每一页配一个由操作系统赋予的存储键,给相应的每个用户分配一个访问键,这个访问键赋予每道程序; 当访问键与存储键相符合时,这一页的数据才能被允许操作</li>
<li>环保护: 按系统程序和用户程序的重要性对整个系统正常运行的影响程度进行分层(环); 环号大小表示保护级别,环号越大等级越低; 某环内的程序只能转到环号大于等于它本身的页中去</li>
</ul>
<h3 id="访问方式保护"><a href="#访问方式保护" class="headerlink" title="访问方式保护"></a>访问方式保护</h3><p>对主存信息进行读R,写W和执行E(指将数据作为指令使用)保护</p>
<h3 id="管理状态和用户状态"><a href="#管理状态和用户状态" class="headerlink" title="管理状态和用户状态"></a>管理状态和用户状态</h3><p>大多数计算机在执行程序时把工作状态分成两种</p>
<ul>
<li>管理状态：执行操作系统或管理程序时所处的状态</li>
<li>用户状态：执行用户程序时所处的状态<br>为了防止因程序员编程出错而影响整个系统的工作，在机器中设置了一些特权指令(规定特权指令只有操作系统等系统程序才能使用，如在用户程序中出现特权指令)，则在执行到该指令时立即中止程序的执行并发出中断。</li>
</ul>
<h1 id="六、指令系统"><a href="#六、指令系统" class="headerlink" title="六、指令系统"></a>六、指令系统</h1><p>(原书第五章)</p>
<h2 id="6-1-指令系统的发展"><a href="#6-1-指令系统的发展" class="headerlink" title="6.1 指令系统的发展"></a>6.1 指令系统的发展</h2><h3 id="指令系统概念"><a href="#指令系统概念" class="headerlink" title="指令系统概念"></a>指令系统概念</h3><ul>
<li>指令: 计算机执行某种操作的命令</li>
<li>程序：程序是由一系列指令组成的</li>
</ul>
<p>指令分类:</p>
<ul>
<li>微指令: 微程序级的命令,属于硬件</li>
<li>宏指令: 由若干条机器指令组成的软件指令, 它属于软件级别</li>
<li>机器指令: 介于微指令和宏指令之间,每条指令可以完成一个独立的算数或逻辑运算</li>
</ul>
<p>指令系统: 一台计算机中所有机器指令的集合,指令系统是硬件和软件的分界面</p>
<ul>
<li>指令系统直接影响到机器的硬件结构</li>
<li>指令系统直接影响到系统软件</li>
<li>指令系统直接影响到机器的适用范围</li>
</ul>
<h3 id="指令系统的发展"><a href="#指令系统的发展" class="headerlink" title="指令系统的发展"></a>指令系统的发展</h3><ul>
<li>电子管和晶体管时代: 指令系统只有定点加减,逻辑运算,数据传送转移等几十条指令</li>
<li>晶体管和集成电路时代: 指令系统增加了乘除,浮点,十进制运算和字符串处理等指令; 寻址方式也趋于多样化<blockquote>
<p>系列计算机: 基本指令系统相同,基本体系结构相同的一系列计算机,这使得各机器软件能够得到兼容</p>
</blockquote>
</li>
<li>(大规模)集成电路计算机: 大多数计算机指令达到几百条,这时的计算机为复杂指令计算机CISC<blockquote>
<ul>
<li>复杂指令计算机指令系统负责庞大,指令数目多</li>
<li>指令格式多,字长不固定,寻址方式多</li>
<li>可访存指令不受限制</li>
<li>各种指令执行时间相差很大</li>
<li>采用微程序控制器</li>
</ul>
</blockquote>
</li>
<li>70年代后期: 精简指令系统计算机RISC<blockquote>
<ul>
<li>精简指令系统选取使用频率较高的简单指令</li>
<li>指令长度固定,指令格式少,寻址方式种类少</li>
<li>采用流水线技术</li>
<li>使用较多的通用寄存器,减少访存</li>
<li>控制器以组合逻辑控制为主</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="指令系统性能指标"><a href="#指令系统性能指标" class="headerlink" title="指令系统性能指标"></a>指令系统性能指标</h3><ul>
<li>完备性: 用汇编语言编写各种程序时,指令系统丰富,功能齐全,编程方便</li>
<li>有效性: 程序占用存储空间小,执行速度快</li>
<li>规整性: 指令格式和数据格式一致; 能够同等对待寄存器和存储单元; 不同寻址方法和各种数据类型能被指令支持</li>
<li>兼容性: 系列机之间具有相同的基本结构和共同的基本指令集,抵挡机上运行的软件也能在高档机上运行(向上兼容)</li>
</ul>
<h3 id="指令系统与硬件结构的关系"><a href="#指令系统与硬件结构的关系" class="headerlink" title="指令系统与硬件结构的关系"></a>指令系统与硬件结构的关系</h3><ul>
<li>高级语言: 面向人类的语言,与具体机器的指令系统无关</li>
<li>低级语言: 面向机器的语言,与具体机器的指令系统密切相关</li>
</ul>
<p>汇编语言:</p>
<ul>
<li>汇编语言通过指令助记符编写程序</li>
<li>指令助记符与机器指令一一对应,常用3或4个英文缩写字母表示</li>
</ul>
<h2 id="6-2-指令格式"><a href="#6-2-指令格式" class="headerlink" title="6.2 指令格式"></a>6.2 指令格式</h2><h3 id="指令的格式"><a href="#指令的格式" class="headerlink" title="指令的格式"></a>指令的格式</h3><p>指令包含的信息:</p>
<blockquote>
<ul>
<li>操作码: 一条操作码对应一个指令,计算机通过识别操作码来完成不同的操作</li>
<li>操作数(地址): 指出参与操作的数据的有关信息(内容或地址)</li>
<li>结果存放地址: 该地址存放操作完成后得到的结果</li>
<li>后继指令地址: 下一条指令的地址; 顺序执行的程序指令地址由程序计数器PC指出,仅当改变程序的运行顺序时下一条指令地址才由指令给出</li>
</ul>
</blockquote>
<p>可见,指令由一个操作码OP和若干个地址码A构成</p>
<p>指令可按照操作数或地址数来分类</p>
<blockquote>
<p>例: 常规双操作数指令(四地址格式)<br><code>OP-A1-A2-A3-A4</code></p>
<ul>
<li>执行操作: (A1)OP(A2)=&gt;A3,后继地址为A4</li>
<li>当然,现实情况中可能不需要显式地给出这么多地址<br>隐地址: 某地址在指令中以隐含的方式约定,指令中不给出该地址码; 这样可以减少存储空间与读取时间</li>
</ul>
</blockquote>
<p>寄存器传送语言</p>
<blockquote>
<ul>
<li>(A)表示地址码A中的内容,是数据</li>
<li>(B)=&gt;A表示将地址码B中的内容存入地址码A所指向的寄存器或主存储器</li>
</ul>
</blockquote>
<h4 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h4><p>格式:<code>OP</code></p>
<blockquote>
<p>执行操作: </p>
<ul>
<li>零操作数: OP,(PC)+1=&gt;PC</li>
<li>但操作数: OP(AC)=&gt;AC,(PC)+1=&gt;PC<br>注: 该指令为零操作数时,可以为空操作(延时)指令或停机指令; 该指令也可以是对累加器AC的操作指令或是对堆栈栈顶单元中的数据进行操作</li>
</ul>
</blockquote>
<h4 id="单地址指令"><a href="#单地址指令" class="headerlink" title="单地址指令"></a>单地址指令</h4><p>格式:<code>OP-A1</code></p>
<blockquote>
<p>执行操作: </p>
<ul>
<li>单操作数: OP(A1)=&gt;A1,(PC)+1=&gt;PC</li>
<li>双操作数: (AC)OP(A)=&gt;AC,(PC)+1=&gt;PC<br>注: AC为CPU中的累加器,一般为隐含规定,此时OP可以是加减乘除等</li>
</ul>
</blockquote>
<h4 id="二地址格式"><a href="#二地址格式" class="headerlink" title="二地址格式"></a>二地址格式</h4><p>格式:<code>OP-A1-A2</code></p>
<blockquote>
<p>执行操作(双操作数): (A1)OP(A2)=&gt;A1,(PC)+1=&gt;PC</p>
</blockquote>
<h4 id="三地址格式"><a href="#三地址格式" class="headerlink" title="三地址格式"></a>三地址格式</h4><p>格式:<code>OP-A1-A2-A3</code></p>
<blockquote>
<p>执行操作(双操作数): (A1)OP(A2)=&gt;A3,(PC)+1=&gt;PC<br>当然,某些性能较强的计算机中还有多地址指令</p>
</blockquote>
<h3 id="指令操作码的扩展技术"><a href="#指令操作码的扩展技术" class="headerlink" title="指令操作码的扩展技术"></a>指令操作码的扩展技术</h3><ul>
<li>定长操作码: 指令操作码的位置和长度固定,其余部分全部用于地址码; 此操作可以简化硬件操作,减少译码时间</li>
<li>扩展操作码: 指令操作码的位数和位置根据需要变化, 操作码的位数随地址数的减少而增加</li>
</ul>
<h4 id="15-15-15扩展法"><a href="#15-15-15扩展法" class="headerlink" title="15/15/15扩展法"></a>15/15/15扩展法</h4><p>机器字长16位,一条地址4位,可采用如下方法设计出15/15/15/16条三地址/双地址/单地址/零地址指令</p>
<ul>
<li>三地址指令: 0XXX-EXXX (X表示地址,变量)</li>
<li>双地址指令: F0XX-FEXX</li>
<li>单地址指令: FF0X-FFEX</li>
<li>零地址指令: FFF0-FFFF<blockquote>
<p>这里,前三位中的F为扩展标志,表示操作码已经被扩展到后面一个地址位中去</p>
</blockquote>
</li>
</ul>
<h4 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h4><p>霍夫曼编码: 根据程序中指令出现的频率高低赋予不同长度的操作码</p>
<h4 id="指令长度与数据字长"><a href="#指令长度与数据字长" class="headerlink" title="指令长度与数据字长"></a>指令长度与数据字长</h4><ul>
<li>字节: 由多个(一般8个)二进制位组成</li>
<li>字: 由多个字节组成</li>
<li>数据字: 计算机中的字表示一个数</li>
<li>指令字: 计算机中的字表示一条指令</li>
<li>机器字长: 计算机能直接处理的二进制数据位数</li>
<li>指令字长: 一个指令中的二进制位数<blockquote>
<p>指令字长有单字长,半字长,多字长,长度分别等于一个,半个,两个机器字长</p>
<ul>
<li>等字长指令: 指令字长不变,通常采用扩展操作码技术</li>
<li>变字长指令结构: 指令字长多为字节的整数倍,如单字节,双字节,三字节指令</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="6-3-寻址方式"><a href="#6-3-寻址方式" class="headerlink" title="6.3 寻址方式"></a>6.3 寻址方式</h2><p>寻址: 存取数据时,先给出地址码,再由硬件电路译码找到数据所在地址</p>
<p>寻址方式: 确定本条指令的数据地址以及下一条要执行指令的地址方式</p>
<h3 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h3><ul>
<li>顺序寻址: 由程序计数器PC对地址计数</li>
<li>跳跃寻址: 下一条指令地址由本条指令给出</li>
</ul>
<h3 id="操作数的寻址"><a href="#操作数的寻址" class="headerlink" title="操作数的寻址"></a>操作数的寻址</h3><p>操作数分类: 地址,数值,字符,逻辑数据</p>
<p>常见操作数寻址方式:</p>
<ul>
<li><p>隐含寻址: 不显式地给出操作数地址</p>
<blockquote>
<p>例: DAA – 将AL的内容调整为两位组合型的二进制数</p>
</blockquote>
</li>
<li><p>立即数寻址: 操作数直接包含在指令中,不需要访问存储器</p>
<blockquote>
<ul>
<li>一般用于提供一个常数或给寄存器初始化</li>
<li><code>MOV AL, 05H</code>: 05H为立即数</li>
</ul>
</blockquote>
</li>
<li><p>寄存器直接寻址: 提供的操作数存放在CPU内的寄存器中</p>
<blockquote>
<p><code>MOV AL, BL</code></p>
<ul>
<li>此时给出的地址是寄存器地址,不是主存储器地址</li>
</ul>
</blockquote>
</li>
<li><p>(寄存器)间接寻址: 操作数的地址存放在寄存器中</p>
<blockquote>
<p><code>MOV AL, [SI]</code>: SI中存放的是操作数在主存储器中的地址</p>
</blockquote>
</li>
<li><p>(存储器)直接寻址</p>
<blockquote>
<ul>
<li>直接给出操作数在主存储器中的地址</li>
<li><code>MOV AL, [2000H]</code></li>
</ul>
</blockquote>
</li>
<li><p>(存储器)间接寻址</p>
<blockquote>
<ul>
<li>主存储器中存放的是操作数的地址(指令中存的是地址的地址)</li>
<li><code>MOV AL, [[1000H]]</code></li>
</ul>
</blockquote>
</li>
<li><p>相对寻址</p>
<blockquote>
<ul>
<li>给出目标地址EA与当前执行指令地址(PC)的相对位移量Disp</li>
<li>这能够实现一个程序的内部跳转, Disp通常为补码,可正可负</li>
<li>EA = (PC) + Disp</li>
<li><code>MOV AL, DISP[PC]</code>: CPU需要将寄存器PC加上寄存器DISP得到目标地址</li>
</ul>
</blockquote>
</li>
<li><p>基址寻址</p>
<blockquote>
<ul>
<li>给出目标地址EA与基址BR的相对位移量A(Disp)</li>
<li>基址寻址可用于操作系统内部的程序定位</li>
<li>EA = (BR) + A</li>
<li><code>MOV AL, DISP[BR]</code></li>
</ul>
</blockquote>
</li>
<li><p>变址寻址</p>
<blockquote>
<ul>
<li>给出目标地址EA与变址DI的相对位移量A</li>
<li>变址寻址可以用于访问数组等结构,将A固定,改变DI内容即可</li>
<li>EA = (DI) + A</li>
<li><code>MOV AL, DISP[DI]</code></li>
</ul>
</blockquote>
</li>
<li><p>堆栈寻址</p>
<blockquote>
<ul>
<li>用于堆栈操作指令</li>
</ul>
</blockquote>
</li>
<li><p>复合寻址</p>
<blockquote>
<ul>
<li>基址,变址,程序当前地址可以重复相加来寻址</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="6-4-指令类型"><a href="#6-4-指令类型" class="headerlink" title="6.4 指令类型"></a>6.4 指令类型</h2><h3 id="算术逻辑运算指令"><a href="#算术逻辑运算指令" class="headerlink" title="算术逻辑运算指令"></a>算术逻辑运算指令</h3><p>对定点数进行运算</p>
<ul>
<li>常有与,或,非,异或及按位操作指令</li>
<li>运算结果有四个状态位: Z(零),N(结果为负),V(结果溢出),C(产生进位或借位)</li>
</ul>
<h3 id="移位操作指令"><a href="#移位操作指令" class="headerlink" title="移位操作指令"></a>移位操作指令</h3><p>类型:<br><img src="/2020/02/24/computer-composition0/move0.jpg" alt="move"></p>
<ul>
<li>移位指令可以实现较高速的乘除法运算</li>
</ul>
<h3 id="浮点数运算指令"><a href="#浮点数运算指令" class="headerlink" title="浮点数运算指令"></a>浮点数运算指令</h3><p>高级语言中的实数(real)运算通常是先转化为浮点数形式再进行处理</p>
<blockquote>
<ul>
<li>某些机器的浮点数运算是用子程序实现的,速度较慢</li>
<li>用于科学计算的计算机应设置浮点运算指令,能对32位单精度或64位双精度浮点数做处理</li>
</ul>
</blockquote>
<h3 id="十进制运算指令"><a href="#十进制运算指令" class="headerlink" title="十进制运算指令"></a>十进制运算指令</h3><p>设置指令直接对十进制数进行运算,不再需要用程序转换成二进制数</p>
<ul>
<li>在人机交互频繁的计算机系统中设置十进制运算指令可以提高数据处理的速度</li>
</ul>
<h3 id="字符串处理指令"><a href="#字符串处理指令" class="headerlink" title="字符串处理指令"></a>字符串处理指令</h3><p>字符串处理指令是一种非数值处理指令,一般包括:</p>
<blockquote>
<ul>
<li>字符串传送: 将数据块从主存储器的某区传送到另一区域</li>
<li>字符串比较: 按位确定两字符串是否相等</li>
<li>字符串查询: 查找字符串中是否含有某一字串或字符</li>
<li>字符串转换: 从一种数据表达形式转换成另一种表达形式(编码转换)</li>
</ul>
</blockquote>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>用于寄存器,存储单元,存储器之间的数据传送</p>
<ul>
<li>包括数据读写,数据复制,数据交换(双向数据传送)等,一次可以传送一个或一批数据</li>
</ul>
<h3 id="转移类指令"><a href="#转移类指令" class="headerlink" title="转移类指令"></a>转移类指令</h3><p>用以改变程序的顺序执行,控制程序流的转移,分类:</p>
<blockquote>
<ul>
<li>无条件转移: jump</li>
<li>条件转移: branch</li>
<li>过程的调用与返回: call, return</li>
<li>陷阱指令: 用于处理计算机的程序错误或意外情况</li>
</ul>
</blockquote>
<h3 id="堆栈及堆栈操作指令"><a href="#堆栈及堆栈操作指令" class="headerlink" title="堆栈及堆栈操作指令"></a>堆栈及堆栈操作指令</h3><p>堆栈是由若干个连续存储单元组成的FILO区域,栈底固定,存放最先送入栈中的数据(栈底地址大于栈顶地址)</p>
<blockquote>
<ul>
<li>SP: 堆栈指针,表示栈顶的位置</li>
<li>PUSH OPR: 压栈指令(压入单字节); (SP)-1=&gt;SP, OPR=&gt;SP</li>
<li>POP OPR: 弹出指令; (SP)=&gt;OPR, (SP)+1=&gt;SP</li>
</ul>
</blockquote>
<p>程序调用中的堆栈: A程序调用B程序</p>
<blockquote>
<p>(A中) call B</p>
<ol>
<li>将该指令的下一条指令(A1)及其他信息压入栈中</li>
<li>执行B</li>
<li>弹出A1作为返回地址,此时继续执行A程序</li>
</ol>
</blockquote>
<p>子程序调用中的参数传递: 利用堆栈</p>
<blockquote>
<p>先将参数压入栈中,然后调用子程序</p>
</blockquote>
<h3 id="输入输出指令"><a href="#输入输出指令" class="headerlink" title="输入输出指令"></a>输入输出指令</h3><p>格式:<code>OP-REG-A</code></p>
<ul>
<li>OP: 操作码,表示IO指令</li>
<li>REG: 寄存器名,用于和外部设备交换数据</li>
<li>A: 外部设备寄存器地址或设备码(输入/输出数据寄存器,控制寄存器)</li>
</ul>
<p>IO指令除了传输数据,还可以用来发送和接收控制命令和回答信号,用于控制外部设备的工作</p>
<p>在外部设备与存储器统一编址的计算机中,任何访问存储器的指令都可以访问外部设备,无需专设IO指令</p>
<h3 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h3><p>只能提供给操作系统或系统软件使用的指令</p>
<ul>
<li>这些指令使用不当会破坏系统或其他用户信息,不能提供给用户使用</li>
<li>主要为系统资源分配管理指令以及一些外部设备/输入输出管理指令</li>
</ul>
<h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><ul>
<li>向量指令: 用于对向量或矩阵进行运算</li>
<li>多处理机指令: 用于管理共享的公共资源和相互通信</li>
<li>控制指令: 包括等待,停机,空操,开关中断,设置条件码指令等</li>
</ul>
<h2 id="6-5-RISC计算机和CISC计算机"><a href="#6-5-RISC计算机和CISC计算机" class="headerlink" title="6.5 RISC计算机和CISC计算机"></a>6.5 RISC计算机和CISC计算机</h2><h3 id="CISC指令集"><a href="#CISC指令集" class="headerlink" title="CISC指令集"></a>CISC指令集</h3><p>代表: DEC的VAX11/780,303条指令,18种寻址方式; Intel的80x86</p>
<ul>
<li>庞大的指令系统使计算机研制周期变长, 增加了调试和维护的难度, 有可能导致系统性能的下降</li>
</ul>
<h3 id="RISC指令集"><a href="#RISC指令集" class="headerlink" title="RISC指令集"></a>RISC指令集</h3><h4 id="RISC的产生和发展"><a href="#RISC的产生和发展" class="headerlink" title="RISC的产生和发展"></a>RISC的产生和发展</h4><p>1975年IBM公司开始研究指令系统的合理性问题,发现CISC中20%的指令在程序种出现的频率为80%</p>
<p>复杂的指令系统</p>
<blockquote>
<ul>
<li>增加了硬件实现的复杂性</li>
<li>增加了研制时间和成本以及设计失误的可能性</li>
<li>很难实现流水线操作</li>
<li>降低了机器的速度</li>
</ul>
</blockquote>
<p>1987年,RISC产品被推出,RISC不包含复杂指令</p>
<h3 id="RISC特点"><a href="#RISC特点" class="headerlink" title="RISC特点"></a>RISC特点</h3><p>RISC希望通过简化指令使计算机结构更加简单合理,从而提高运算速度</p>
<p>计算机执行程序所需时间P的计算方法:</p>
<ul>
<li>P = I<em>CPI</em>T<blockquote>
<ul>
<li>I: 高级语言程序编译后在机器上运行的指令数</li>
<li>CPI: 指令执行的平均周期数</li>
<li>T: 每个机器周期时间</li>
</ul>
</blockquote>
</li>
</ul>
<p>RISC特点:</p>
<blockquote>
<ul>
<li>优先选择使用频率高的一些简单指令于有用的指令,避免复杂指令</li>
<li>指令长度固定,提供较少的指令格式和寻址方式; 在各指令间提供比较一致的字段划分和比较规整的字段功能</li>
<li>仅有存取指令访问存储器,其余指令的操作都在寄存器之间进行</li>
<li>CPU中寄存器数量相当多,算术逻辑运算的操作数都在通用寄存器中存取</li>
<li>大部分指令在一个或小于一个机器周期内完成</li>
<li>以硬布线控制逻辑为主,不用或少用微码控制</li>
<li>特别重视编译优化工作,减少程序执行时间</li>
</ul>
</blockquote>
<h2 id="6-6-指令系统举例"><a href="#6-6-指令系统举例" class="headerlink" title="6.6 指令系统举例"></a>6.6 指令系统举例</h2><h3 id="SPARC指令系统"><a href="#SPARC指令系统" class="headerlink" title="SPARC指令系统"></a>SPARC指令系统</h3><p>指令字长32位,3种指令格式,6种指令类型</p>
<p>指令类型:</p>
<blockquote>
<ul>
<li>31条算数/逻辑运算和移位指令</li>
<li>22条LOAD/STORE指令</li>
<li>5条控制转移指令</li>
<li>8条读写专用寄存器指令</li>
<li>浮点运算指令</li>
<li>协处理器指令: SPARC为整数运算部件, 需要用协处理器或子程序实现浮点数运算</li>
</ul>
</blockquote>
<p>指令格式:</p>
<blockquote>
<ul>
<li>CALL指令: <code>OP(2位)-Disp(30位)</code></li>
<li>SETHI指令和Branch指令: <code>OP(2)-rd(5)-OP2(2)-imm(22)</code>; <code>OP(2)-a(1)-Cond(4)-OP2(2)-disp(22)</code></li>
<li>其他指令</li>
</ul>
</blockquote>
<h3 id="Pentium微处理器指令系统"><a href="#Pentium微处理器指令系统" class="headerlink" title="Pentium微处理器指令系统"></a>Pentium微处理器指令系统</h3><p>程序员能见到的寄存器:</p>
<blockquote>
<ul>
<li>32位数据寄存器: E(xtended)AX,EBX,ECX,EDX; 低位可以分为AX等16位寄存器; 每个16位可以分为如AL和AH等两个8位高低寄存器</li>
<li>5个32位指针/变址寄存器: 堆栈指针ESP; 基址指针EBP; 源变址寄存器ESI; 目的变址寄存器EDI; 指令指针EIP(即PC)</li>
<li>6个段寄存器(访问主存和外设IO端口): 取指令CS(CS:IP); (默认)读写数据DS; 堆栈操作指针SS; ES,FS,GS可任意使用</li>
</ul>
</blockquote>
<p>指令系统:<code>OP-MOD/RM-SIB-Disp-Imm</code></p>
<blockquote>
<ul>
<li>OP: 操作码,1或2个字节,可扩展</li>
<li>MOD/RM: 指出操作数的位置,指出寻址方式,0或1个字节</li>
<li>SIB: 配合前面指出寻址方式,0或1个字节</li>
<li>Disp: 在特定寻址方式下指出地址偏移量,0、1、2或4个字节</li>
<li>Imm: 立即数寻址,0、1、2或4个字节</li>
</ul>
</blockquote>
<h2 id="6-7-机器语言-汇编语言和高级语言"><a href="#6-7-机器语言-汇编语言和高级语言" class="headerlink" title="6.7 机器语言,汇编语言和高级语言"></a>6.7 机器语言,汇编语言和高级语言</h2><ul>
<li>机器语言: 由二进制代码组成的指令和数据, 在计算机硬件设计时产生</li>
<li>汇编语言: 用助记符标注的机器语言, 易于阅读</li>
<li>高级语言: 扩展功能,简化编程复杂度</li>
</ul>
<h1 id="七、中央处理器"><a href="#七、中央处理器" class="headerlink" title="七、中央处理器"></a>七、中央处理器</h1><p>（原书第六章）<br>CPU是计算机中最重要的部分, 对指令流和数据流在时间和空间上实施正确的布控</p>
<blockquote>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>时序控制</li>
<li>数据加工处理</li>
</ul>
</blockquote>
<p>组成部件:</p>
<blockquote>
<ul>
<li>运算逻辑单元ALU</li>
<li>寄存器</li>
<li>中断系统</li>
<li>控制部件</li>
<li>(外部数据交换): 控制总线,数据总线,地址总线(单向,由CPU发出)</li>
</ul>
</blockquote>
<h2 id="7-1-控制器的组成"><a href="#7-1-控制器的组成" class="headerlink" title="7.1 控制器的组成"></a>7.1 控制器的组成</h2><h3 id="控制器组成"><a href="#控制器组成" class="headerlink" title="控制器组成"></a>控制器组成</h3><p><img src="/2020/02/24/computer-composition0/control0.jpg" alt="control">  </p>
<p>控制器组成:</p>
<blockquote>
<ul>
<li>程序计数器PC: 用于存放当前或即将执行的指令地址, 形成顺序执行指令地址(PC+1)或转移类指令地址</li>
<li>指令寄存器IR: 用于存放当前正在执行的指令</li>
<li>地址寄存器AR: 存储当前CPU访问的内存单元的地址</li>
<li>数据寄存器DR: 暂存由内存中读出或写入的指令/数据</li>
<li>指令译码器: 对IR中的操作码进行分析解释,产生相应的控制信号或有一定时序关系的控制信号序列</li>
<li>脉冲源CLK以及启停线路: CLK产生机器周期和工作脉冲的基准信号以及机器刚加点时的reset信号; 启停线路保证完整的时钟信号能够被可靠地送出或封锁,控制CLK的发生或停止,从而控制机器的启停</li>
<li>时序控制信号形成部件: 在CLK作用下根据指令需要产生时序控制信号并根据被控制部件的反馈信号进行时序信号的调整</li>
<li>程序状态寄存器PS(W)R: 保存程序状态字PSW</li>
</ul>
</blockquote>
<p>组成控制器的基本电路是具有记忆功能的触发器以及没有记忆功能的门电路</p>
<h3 id="控制器功能"><a href="#控制器功能" class="headerlink" title="控制器功能"></a>控制器功能</h3><p>控制器用于控制程序的执行,有如下功能:</p>
<blockquote>
<ul>
<li>取指令: 发出指令地址及控制信号,从程序入口取出第一条指令,然后不断地取出指令</li>
<li>分析指令: 对当前的指令进行分析, 根据指令要求产生相应的操作控制命令</li>
<li>执行指令: 对上述产生的操作控制命令进行执行,实现每条指令的功能</li>
<li>控制程序的数据输入与结果输出: 在适当的时候向输入输出设备发出一些命令来完成IO功能</li>
<li>处理异常情况和某些请求</li>
</ul>
</blockquote>
<p>指令执行过程</p>
<blockquote>
<ol>
<li>取指令: (PC)=&gt;AR, (AR)=&gt;DR, (DR)=&gt;IR, (PC)+1=&gt;PC</li>
<li>分析指令: 分析指令,计算操作数的有效地址</li>
<li>执行指令: 根据一系列操作控制信号执行指令</li>
</ol>
</blockquote>
<p>一些概念:</p>
<blockquote>
<ul>
<li>指令周期: 取出并执行一条指令的时间,由若干个机器周期组成</li>
<li>机器周期(CPU周期): 一般由从内存中读取一个指令字的最短时间规定CPU周期, 由若干个时钟周期组成</li>
<li>时钟周期: 处理操作的最基本单位, 又称为节拍脉冲或T周期</li>
</ul>
</blockquote>
<p>举例: ADD指令</p>
<blockquote>
<p>ADD指令的指令周期由3个CPU周期组成: </p>
<ol>
<li>取指与译码: 取指令,指令译码(得到操作性质和操作数)</li>
<li>执行指令: 送操作数地址,地址译码(计算地址)</li>
<li>执行指令: 取出操作数,执行操作</li>
<li>取下一条指令…</li>
</ol>
</blockquote>
<p>信息传输方向:</p>
<blockquote>
<ul>
<li>指令: M-DR-DBUS-IR</li>
<li>(指令)地址: PC-ABUS-AR-…</li>
<li>寄存器-寄存器数据: 直接通过总线</li>
<li>寄存器-存储器: R-DBUS-DR-M</li>
<li>存储器-寄存器: M-DR-DBUS-R</li>
</ul>
</blockquote>
<h3 id="时序产生和控制方式"><a href="#时序产生和控制方式" class="headerlink" title="时序产生和控制方式"></a>时序产生和控制方式</h3><p>操作控制器发出的各种控制信号都是时序信号和部件的函数</p>
<p>时序产生控制器:</p>
<blockquote>
<ul>
<li>硬布线控制器: 由组合逻辑实现,注状态周期-节拍电位-节拍脉冲</li>
<li>微程序控制器: 节拍电位-节拍脉冲</li>
</ul>
</blockquote>
<p>控制器控制方式:</p>
<blockquote>
<ul>
<li>同步控制: 一条已定的指令在执行时所需的机器周期数和节拍数固定不变</li>
<li>异步控制: 采用应答方式执行指令,每个微操作需要多少时间就占用多少时间</li>
<li>混合控制方式: 结合两种控制方式, 大部分操安排在固定的机器周期中同步控制, 对时间难以确定的操作以问答方式控制</li>
<li>人工控制: 用于调机和软件开放的需要,如reset键和单条指令执行切换开关</li>
</ul>
</blockquote>
<h2 id="7-2-微程序控制的计算机"><a href="#7-2-微程序控制的计算机" class="headerlink" title="7.2 微程序控制的计算机"></a>7.2 微程序控制的计算机</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>微程序控制器利用软件方法(微程序控制技术)来设计硬件,将存储逻辑和程序技术引入CPU</p>
<blockquote>
<ul>
<li>微命令: 控制部件向执行部件发出的控制命令</li>
<li>微操作: 执行一条指令所进行的一系列基本操作,如取指令,计算地址等; 是执行部件接受微命令后进行的操作</li>
<li>微指令: 实现一定操作功能的一组微命令</li>
<li>微程序: 实现一条机器指令功能的微指令序列</li>
</ul>
</blockquote>
<h3 id="微程序的实现原理"><a href="#微程序的实现原理" class="headerlink" title="微程序的实现原理"></a>微程序的实现原理</h3><p>控制存储器: 存放微程序的只读存储器,内部结构如下</p>
<blockquote>
<p>控制命令-下一条执行的微指令地址(下址)<br>控制命令-下一条执行的微指令地址<br>…</p>
</blockquote>
<p>微程序控制器执行流程:</p>
<blockquote>
<ul>
<li>OP-&gt;编码器-&gt;(取指微程序入口)</li>
<li>(取指微程序入口)=&gt;顺序控制逻辑=&gt;微地址寄存器=&gt;控制存储器=&gt;控制字段+下址</li>
<li>控制字段=&gt;产生控制信号</li>
<li>下址=&gt;顺序控制逻辑(转上面循环)</li>
</ul>
</blockquote>
<p>微程序控制器特点: 规整,灵活,可维护</p>
<p>确定微指令的结构</p>
<blockquote>
<ul>
<li>缩短微指令的长度</li>
<li>减少控制存储器的容量</li>
<li>提高微程序的执行速度</li>
<li>有利于对微指令的修改</li>
<li>有利于提高微程序设计的灵活性</li>
</ul>
</blockquote>
<p>微指令结构: 操作控制字段-顺序控制字段<br>微操作: 相容(能够在一个CPU周期内并行),相斥(不能并行)</p>
<p>微指令编码: 对微指令中的操作控制字段采用的表示方法</p>
<blockquote>
<ul>
<li>直接编码: 操作控制字段存储一组微命令,可以直接发出控制命令(一般每一位代表一个微命令); 这会导致微指令较长</li>
<li>译码控制法: 操作控制字段被分为若干个字段,每个字段通过译码器翻译成一个互斥的微命令执行; 这可以缩短微指令,但会增加微程序的执行时间</li>
<li>混合编码: 混合使用直接编码和译码编码, 综合两者特点</li>
</ul>
</blockquote>
<p>下址(微地址)生成方式:</p>
<blockquote>
<ul>
<li>计数器方式(增量方式): (uPC)+1=&gt;uPC</li>
<li>断定方式: 根据当前微指令的判定条件BCF断定下条指令的微地址BAF,BAF=&gt;uPC</li>
<li>增量和断定方式结合</li>
</ul>
</blockquote>
<p>微指令执行过程: 取微指令,执行微指令中的各个操作</p>
<blockquote>
<p>执行一条微指令所需时间为微周期</p>
<ul>
<li>串行执行: 取微指令和执行微指令串行执行, 此时微周期为控制存储器的工作周期</li>
<li>并行执行: 执行本条微指令和取下一条微指令操作同时进行; 取微指令执行时间和取指时间最长的作为微周期时间; 若遇到条件转移微指令,则延迟一个微周期再取指</li>
</ul>
</blockquote>
<p>多路转移: 有些微指令存在多个转移分支,根据不同操作码产生不同下址</p>
<blockquote>
<ul>
<li>实现电路: PROM/MAPROM, 输入指令操作码,输出下址; 该存储器容量略大于机器指令数,容量小速度快</li>
<li>一般只需要2路或4路转移,涉及的微地址变化仅有1或2位,多路转移可以减少微程序的长度</li>
</ul>
</blockquote>
<p>微中断: 终止当前执行的程序,转去执行微中断处理程序(已定义)</p>
<blockquote>
<ul>
<li>微中断请求信号是由程序中断请求信号引起的</li>
</ul>
</blockquote>
<p>毫微程序设计: 用于解释微程序的一种微程序; 毫微指令为解释微指令的微指令</p>
<blockquote>
<ul>
<li>目的: 采用两级微程序设计方法,减少控制存储器的容量</li>
<li>通常第一级采用垂直微程序,第二级采用水平微程序</li>
</ul>
</blockquote>
<h3 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h3><ul>
<li><p>水平型微指令: 一次能定义并执行多个并行微命令的微指令</p>
<blockquote>
<p>结构: <code>控制字段-判断测试字段-下址字段</code></p>
<ul>
<li>控制字段有全水平型译码,字段译码和混合译码法</li>
</ul>
</blockquote>
</li>
<li><p>垂直型微指令: 设有微操作码字段,不强调实现微指令的并行控制功能,一般能实现一到两个操作</p>
<blockquote>
<ul>
<li>相比于水平型微指令,垂直型微指令指令字较短,组成的微程序较长,效率较低但容易掌握</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="机器周期的确定"><a href="#机器周期的确定" class="headerlink" title="机器周期的确定"></a>机器周期的确定</h3><ul>
<li>所有的微操作都应当在一个机器周期内完成</li>
<li>当使用ready信号(低电平)时,若其出现时间较晚,则CPU会延长一个或以上的节拍信号</li>
</ul>
<h3 id="微程序控制计算机给简单工作流程"><a href="#微程序控制计算机给简单工作流程" class="headerlink" title="微程序控制计算机给简单工作流程"></a>微程序控制计算机给简单工作流程</h3><ul>
<li>机器加电,由reset信号在PC寄存器中置入第一条指令地址,在微指令寄存器中置入一条”取指”指令,同时初始化其他状态位和寄存器</li>
<li>电压稳定后,启动机器工作,产生节拍电位和CP信号,检查第一个机器周期信号的完整性</li>
<li>产生开机后第一个工作脉冲CP,开始工作</li>
<li>遇到停机指令或外来停机命令</li>
<li>待当前指令执行完或至少在这个机器周期结束时停机<blockquote>
<ul>
<li>停机: 停机时电压仍维持正常,寄存器和存储器的信息不变,重启后仍能从断点处继续执行下去</li>
<li>停电: 寄存器和存储器内容丢失,加点后重新从reset信号开始运行; 某些机器有停电后自动再启动功能,依靠后备电源将主存和程序断点及状态信息调入外存中,恢复电源后从断点处继续工作</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="7-4-硬布线控制的计算机"><a href="#7-4-硬布线控制的计算机" class="headerlink" title="7.4 硬布线控制的计算机"></a>7.4 硬布线控制的计算机</h2><p>硬布线控制器将控制部件看成专门固定时序控制信号的逻辑电路,由逻辑电路直接连线产生<br><img src="/2020/02/24/computer-composition0/hard0.jpg" alt="hard"></p>
<blockquote>
<p>cy1-cy4表示4个机器周期</p>
</blockquote>
<ul>
<li>设计目标: 使用最少的元件,取得最高的操作速度</li>
<li>设计原理: 以指令功能要实现的微操作序列为依据</li>
</ul>
<p>硬布线控制器修改指令很复杂,但性能高</p>
<h2 id="7-5-流水线工作原理"><a href="#7-5-流水线工作原理" class="headerlink" title="7.5 流水线工作原理"></a>7.5 流水线工作原理</h2><p>将两条或多条指令再时间上重叠起来运行,提高程序的执行速度</p>
<p>特点:</p>
<blockquote>
<ul>
<li>连续执行同类任务时效率最高</li>
<li>每个流水线都要设置一个流水寄存器</li>
<li>个流水段的时间应尽量相等</li>
<li>需要有装入时间和排空时间</li>
</ul>
</blockquote>
<p>执行N条K个机器周期的指令,流水线需要N+K-1个机器周期</p>
<p>流水线的问题:</p>
<ul>
<li>结构上,不同指令会争用同一部件</li>
<li>数据上,不同指令可能会因重叠操作改变读写访问顺序</li>
<li>控制上,转移指令可能会使流水线停顿</li>
</ul>
<h2 id="7-6-CPU举例"><a href="#7-6-CPU举例" class="headerlink" title="7.6 CPU举例"></a>7.6 CPU举例</h2><p>RISC: SPARC处理器<br>CISC: Pentium微处理器</p>
<h2 id="7-7-计算机的供电"><a href="#7-7-计算机的供电" class="headerlink" title="7.7 计算机的供电"></a>7.7 计算机的供电</h2><p>计算机的直流电源是由交流电源经过整流稳压而得到的</p>
<blockquote>
<ul>
<li>一般逻辑电路需要+5V直流电</li>
<li>为减少机器功耗,电源朝着降低电压值方向发展,出现3.5V和1.8V等</li>
<li>还有-5V,+-12V等直流电源供磁盘存储器等电路的使用</li>
</ul>
</blockquote>
<p>不间断电源UPS: 后备式,在线式</p>
<h1 id="八、辅助存储器"><a href="#八、辅助存储器" class="headerlink" title="八、辅助存储器"></a>八、辅助存储器</h1><p>辅助存储器容量大而成本低,是非易失性存储器</p>
<p>辅存主要由磁表面存储器和光存储器两大类</p>
<blockquote>
<ul>
<li>磁表面存储器将磁性材料沉积再盘片(或带)的基体上形成磁记录介质,并用饶有线圈的磁头与介质的相对运动来写入或读出信息</li>
<li>光存储器介质主要是光盘,它利用激光束在具有感光特性的表面上存储信息</li>
</ul>
</blockquote>
<h2 id="8-1-磁表面存储器的种类与技术指标"><a href="#8-1-磁表面存储器的种类与技术指标" class="headerlink" title="8.1 磁表面存储器的种类与技术指标"></a>8.1 磁表面存储器的种类与技术指标</h2><h3 id="存储密度"><a href="#存储密度" class="headerlink" title="存储密度"></a>存储密度</h3><p>单位长度或面积磁层表面所存储的二进制信息量</p>
<blockquote>
<ul>
<li>磁盘: 道密度和位密度或面密度</li>
<li>磁带: 位密度</li>
</ul>
<p>磁道: 存储在介质表面上信息的磁化轨迹</p>
</blockquote>
<p>磁盘存储器中:</p>
<blockquote>
<ul>
<li>磁道: 磁盘表面上的同心圆</li>
<li>扇区: 磁道组成的扇形表面</li>
<li>柱面: 多个盘片在同一半径的磁道形成的整体</li>
<li>道宽: 磁道宽度</li>
<li>道距: 两磁道中心线距离,一般比道宽大</li>
<li>道密度: 沿磁盘半径方向单位长度的磁道数(道/英寸 tpi)</li>
<li>位密度(线密度): 单位长度磁道所能记录的二进制信息(位/英寸 bpi)；内圈位密度大于外圈位密度</li>
<li>面密度: 道密度*位密度</li>
</ul>
</blockquote>
<p>磁带中,存储密度用位密度衡量</p>
<h3 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h3><p>存储容量: 存储器能存的二进制信息总量,一般以字节位单位</p>
<ul>
<li>格式化容量: 按照某种记录格式所能存储的信息的总量,为用户可由使用的容量</li>
<li>非格式化容量: 磁记录表面可以利用的磁化单元总量<blockquote>
<ul>
<li>低级格式化: 在盘片上建立扇区和磁道,并将每个扇区的开始和结束部分写入到盘片上</li>
<li>高级格式化: 写入文件储存的结构,如将文件分配表写入扇区</li>
</ul>
</blockquote>
</li>
</ul>
<p>格式化容量一般为非格式化容量的60%-70%</p>
<h3 id="寻址时间"><a href="#寻址时间" class="headerlink" title="寻址时间"></a>寻址时间</h3><p>磁盘存储器采用直接存取方式:</p>
<blockquote>
<ul>
<li>寻道时间$t_s$: 磁头寻找目标磁道所需的时间</li>
<li>等待时间$t_w$: 磁头等待目标区域旋转到其下方所需的时间</li>
</ul>
</blockquote>
<p>平均寻址时间$T_a = T_s+T_w = \overline t_s + \overline t_w$</p>
<p>一般硬盘平均寻址时间在10ms左右,磁带平均寻址时间更长</p>
<h3 id="数据传输速率"><a href="#数据传输速率" class="headerlink" title="数据传输速率"></a>数据传输速率</h3><ul>
<li>数据传输速率$D_r$: 单位时间内存储器与主机之间传送数据的位数或字节数</li>
<li>传输率与存储设备和主机接口逻辑有关</li>
<li>从设备方面考虑，传输率等于记录密度D和记录介质的运动速度V的乘积。</li>
<li>从主机接口逻辑考虑，应有足够快的传送速度接收／发送信息，以便主机与辅存之间的传输正确无误</li>
</ul>
<h3 id="误码率和价格"><a href="#误码率和价格" class="headerlink" title="误码率和价格"></a>误码率和价格</h3><p>误码率: 衡量磁表面存储器出错概率的参数; 它等于从辅存读出时，出错信息位数和读出的总信息位数之比。</p>
<p>价格: 通常用位价格来比较各种存储器。位价格是设备价格除以容量，在所有存储设备中，磁表面存储器和光盘存储器的位价格是很低的。</p>
<h2 id="8-2-磁记录原理与记录方式"><a href="#8-2-磁记录原理与记录方式" class="headerlink" title="8.2 磁记录原理与记录方式"></a>8.2 磁记录原理与记录方式</h2><ul>
<li>磁记录原理: 磁表面存储器通过磁头和记录介质的相对运动完成写入和读出, 本质是电和磁之间的转换</li>
<li>磁记录介质: 涂有薄层磁性材料的信息载体,又称为磁记录媒体; 可分为软性介质和硬性介质</li>
<li>磁头: 一个电磁转换装置,可以将电脉冲表示的二进制代码和磁化信息相互转化</li>
<li>磁记录方式: 按照某种规律将二进制数字信息变换成存储介质的磁化翻转方式<br><img src="/2020/02/24/computer-composition0/disc0.jpg" alt="disc"></li>
</ul>
<h2 id="8-3-磁盘存储器"><a href="#8-3-磁盘存储器" class="headerlink" title="8.3 磁盘存储器"></a>8.3 磁盘存储器</h2><p>种类:</p>
<blockquote>
<ul>
<li>硬磁盘存储器：硬盘存储器和软盘存储器。</li>
<li>根据磁头的工作方式分类：移动头磁盘存储器和固定头磁盘存储器</li>
<li>根据磁盘可换与否分类：可换盘存储器和固定盘存储器两</li>
</ul>
</blockquote>
<p>结构:</p>
<blockquote>
<ul>
<li>驱动器HDD: 独立于主机之外的一个完整的磁盘驱动器装置</li>
<li>控制器HDC: 在主机总线上的一个控制电路板</li>
</ul>
</blockquote>
<p>磁盘阵列存储器: 廉价冗余磁盘阵列(Redundent Array Of Inexpensive Disk，简称RAID)是用多台磁盘存储器组成的大容量外存储子系统</p>
<blockquote>
<ul>
<li>数据分块技术: 在多个磁盘上交错存放数据,使之可以并行存取</li>
<li>数据冗余技术: 阵列中的一部分磁盘存有冗余信息</li>
</ul>
</blockquote>
<p>RAID分类:</p>
<blockquote>
<ul>
<li>RAID0: 无冗余无校验的数据分块; 磁盘利用率和IO性能最高,但可靠性最低</li>
<li>RAID1: 镜像磁盘阵列; 安全性高,IO性能不变,利用率为50%</li>
<li>RAID2: 纠错海明码和位交叉存取; 对数据的访问涉及磁盘阵列中的每一个盘,很少使用</li>
<li>RAID3: 奇偶校验码和位交叉存取; 计算较为费时</li>
<li>RAID4: 奇偶校验码和块交叉存取; 有专用校验盘,对少量数据(块)读写只涉及数据盘和校验盘两个盘</li>
<li>RAID5: 奇偶校验码和块交叉存取; 无专用校验盘,校验信息分布到组内所有盘上,性能较号,普遍采用</li>
<li>RAID6: 两种奇偶校验码和块交叉; 需要多两个盘的容量来存储校验信息,可靠性高</li>
<li>RAID7: 独立接口的磁盘阵列; 主机可以独立地对每个磁盘驱动器进行访问</li>
<li>RAID10: RAID0和RAID1的组合,性能好安全性高,但利用率低</li>
</ul>
</blockquote>
<h2 id="8-4-磁带存储器"><a href="#8-4-磁带存储器" class="headerlink" title="8.4 磁带存储器"></a>8.4 磁带存储器</h2><p>读写工作原理基本上与磁盘存储器相同,区别如下</p>
<blockquote>
<ul>
<li>磁带是顺序存取设备</li>
<li>介质时涂上磁粉的薄塑料带</li>
<li>读写某点信息需要进行快进或者倒转</li>
<li>读写时磁头会直接接触磁带</li>
<li>磁带移动速度较慢</li>
</ul>
</blockquote>
<h2 id="8-5-光盘存储器"><a href="#8-5-光盘存储器" class="headerlink" title="8.5 光盘存储器"></a>8.5 光盘存储器</h2><p>光盘是使用光学方式进行读写信息的圆盘</p>
<blockquote>
<ul>
<li>只读型光盘CD-ROM: 由厂商预先写入信息,只读不可写</li>
<li>一次性写入型WORM: 用户只能一次写入,可以多次读出</li>
<li>可擦写型: 可以重复读写; 其采用磁光可重写技术,即利用激光在磁记录介质上存储信息</li>
</ul>
</blockquote>
<h2 id="8-6-固态盘"><a href="#8-6-固态盘" class="headerlink" title="8.6 固态盘"></a>8.6 固态盘</h2><ul>
<li>固态盘是用半导体存储介质和传统磁盘接口构成的存储器</li>
<li>存储器介质可以是DRAM或NVRAM,也有用NAND闪存为核心的SSD</li>
<li>U盘,闪盘,存储卡等都是SSD</li>
</ul>
<h1 id="九、输入输出IO设备"><a href="#九、输入输出IO设备" class="headerlink" title="九、输入输出IO设备"></a>九、输入输出IO设备</h1><h2 id="9-1-外部设备概述"><a href="#9-1-外部设备概述" class="headerlink" title="9.1 外部设备概述"></a>9.1 外部设备概述</h2><p>中处理器和主存储器构成计算机主体，输入输出设备、外存储器、脱机输入输出设备构成外部设备</p>
<ul>
<li>IO设备由信息载体、设备及设备控制器组成<blockquote>
<ul>
<li>IO设备的工作速度比主机慢</li>
<li>各IO设备的信息类型和结构均不同</li>
<li>各IO设备的电气特性不同</li>
</ul>
</blockquote>
</li>
</ul>
<p>结构：</p>
<blockquote>
<ul>
<li>CPU和主存构成主机</li>
<li>主机由总线与外部设备控制器相连</li>
<li>外部设备控制器包括外存设备控制器、输入设备控制器、输出设备控制器、通信控制器和过程控制器等</li>
<li>不同控制器和不同外设相连 </li>
</ul>
</blockquote>
<p>信息交换代码格式：ASCII码 </p>
<p>传送格式：串行传送、并行传送</p>
<h2 id="9-2-输入设备"><a href="#9-2-输入设备" class="headerlink" title="9.2 输入设备"></a>9.2 输入设备</h2><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>键盘是由一组排列成阵列形式的按键开关组成的</p>
<p>ASCII码：</p>
<blockquote>
<ul>
<li>ASCII码每一个字符都由7位二进制表示，正常情况下最高一位为0；奇偶校验时它也可以存放校验位</li>
<li>ASCII是由128个字符组成的字符集<br>字符集中，0－31为控制字符，其余94个字符为可印刷字符</li>
</ul>
</blockquote>
<h3 id="光笔、图形板和画笔（游动标）输入"><a href="#光笔、图形板和画笔（游动标）输入" class="headerlink" title="光笔、图形板和画笔（游动标）输入"></a>光笔、图形板和画笔（游动标）输入</h3><p>这些设备输入的是绝对坐标</p>
<p>光笔：</p>
<blockquote>
<ul>
<li>外形似钢笔，头部有一个透镜系统</li>
<li>它可以拾取显示器屏幕上的坐标，和屏幕上的光标配合可以修改或画出图形</li>
</ul>
</blockquote>
<p>图形板和画笔：</p>
<blockquote>
<ul>
<li>图形板是一个二维的数字化板</li>
<li>图形板 和画笔结合构成二维坐标输入系统，主要用于输入工程图等</li>
</ul>
</blockquote>
<p>游动标：一种高精度的读图设备</p>
<h3 id="鼠标器、跟踪球和操纵杆"><a href="#鼠标器、跟踪球和操纵杆" class="headerlink" title="鼠标器、跟踪球和操纵杆"></a>鼠标器、跟踪球和操纵杆</h3><p>鼠标器，跟踪球操纵杆输入的是相对坐标</p>
<h3 id="触摸屏"><a href="#触摸屏" class="headerlink" title="触摸屏"></a>触摸屏</h3><p>触摸屏是一种透明的，安装在显示器屏幕的外表面的一种设备</p>
<p>分类：电阻式、电容式、红外线式、表面声波技术和底坐式矢量压力测力技术</p>
<h3 id="图像输入设备"><a href="#图像输入设备" class="headerlink" title="图像输入设备"></a>图像输入设备</h3><p>摄像机和摄像头，数字照相机</p>
<h3 id="条形码"><a href="#条形码" class="headerlink" title="条形码"></a>条形码</h3><p>条码：由一组宽度和反射率不同的平行相邻的“条”和“空”，按照预先规定的编码规则组合起来，用以表示一组数据的符号。这组数据可以是数字、字母或某些符号。</p>
<h3 id="光学字符识别（OCR）技术和语音文字输入系统"><a href="#光学字符识别（OCR）技术和语音文字输入系统" class="headerlink" title="光学字符识别（OCR）技术和语音文字输入系统"></a>光学字符识别（OCR）技术和语音文字输入系统</h3><p>NaN</p>
<h2 id="9-3-显示器"><a href="#9-3-显示器" class="headerlink" title="9.3 显示器"></a>9.3 显示器</h2><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul>
<li>图形：最初指没有亮暗层次变化的线条图，早期的图形显示局限在二值化的范围</li>
<li>图像最初指具有亮暗层次的图，经计算机处理后显示的图像称作数字图像</li>
<li>分辨率：显示屏光点的多少</li>
<li>灰度级：所显示像素点的亮暗差别</li>
<li>亮度：单位为坎德拉每平方米</li>
<li>对比度：显示器画面上最大亮度和最小亮度的比值</li>
<li>刷新屏率（扫描频率）：显示器每秒刷新的次数 </li>
<li>刷新存储器：用来存放一帧图像信息的存储器，其容量为分辨率*灰度</li>
<li>帧存储器：为连续提供刷新图像的信号而用于存储图像的存储器（VRAM）；一般在适配器或显卡内，性能比一般DRAM好</li>
<li>光栅扫描：一种电视中采用的扫描方法，一般为从上到下的逐行扫描或隔行扫描</li>
</ul>
<h3 id="显示器种类"><a href="#显示器种类" class="headerlink" title="显示器种类"></a>显示器种类</h3><ul>
<li>阴极射线管：一个电真空器件，由电子枪、偏转装置和荧光屏构成</li>
<li>液晶显示器</li>
<li>彩色等离子体显示器</li>
</ul>
<h2 id="9-4-打印机"><a href="#9-4-打印机" class="headerlink" title="9.4 打印机"></a>9.4 打印机</h2><p>打印机是计算机系统最基本的输出形式</p>
<p>分类：击打式、非击打式；串行打印机、行式打印机等</p>
<h3 id="点阵式打印机"><a href="#点阵式打印机" class="headerlink" title="点阵式打印机"></a>点阵式打印机</h3><p>特点：结构简单，体积小，重量轻，价格低</p>
<h3 id="激光打印机"><a href="#激光打印机" class="headerlink" title="激光打印机"></a>激光打印机</h3><p>速度快，打印质量高</p>
<h3 id="喷墨打印机"><a href="#喷墨打印机" class="headerlink" title="喷墨打印机"></a>喷墨打印机</h3><p>有压电式喷墨技术和热电式喷墨技术</p>
<h3 id="热转打印机"><a href="#热转打印机" class="headerlink" title="热转打印机"></a>热转打印机</h3><p>分为串式印字和行式印字</p>
<h2 id="9-5-汉子处理技术"><a href="#9-5-汉子处理技术" class="headerlink" title="9.5 汉子处理技术"></a>9.5 汉子处理技术</h2><h3 id="汉子交换编码"><a href="#汉子交换编码" class="headerlink" title="汉子交换编码"></a>汉子交换编码</h3><p>国标码：GB2312－80，共计收录一级汉字3755个，二级汉子3008个，各种符号682个</p>
<h3 id="汉字处理技术"><a href="#汉字处理技术" class="headerlink" title="汉字处理技术"></a>汉字处理技术</h3><p>汉字内码：用于汉字信息的存储、检索等操作的机内代码，一般由两个字节组成</p>
<p>一般以国标码为基础进行编码，如将国标码最高位置1</p>
<p>汉字点阵编码：用于汉字的输出显示</p>
<p>汉字表示方法：字符代码化，输入码向机内码转换，处理机内码，机内码向字形码转换，显示/打印输出</p>
<h1 id="十、输入输出IO系统"><a href="#十、输入输出IO系统" class="headerlink" title="十、输入输出IO系统"></a>十、输入输出IO系统</h1><h2 id="10-1-输入输出系统概述"><a href="#10-1-输入输出系统概述" class="headerlink" title="10.1 输入输出系统概述"></a>10.1 输入输出系统概述</h2><p>输入输出系统包括外部设备（辅存和输入输出设备）及其与主机之间的控制设备</p>
<blockquote>
<p>控制部件又称为设备控制器（设备适配器或接口）</p>
<ul>
<li>如磁盘控制器、打印机控制器等</li>
<li>作用：控制并实现主机与外部设备之间的数据传送</li>
<li>设备控制器与主机之间传送数据的协议：系统总线</li>
</ul>
</blockquote>
<p>输入输出设备的编址</p>
<blockquote>
<ul>
<li>设备号或设备代码：每台设备的一个地址码，为了CPU对IO设备进行寻址和选择</li>
</ul>
<p>两种寻址方式：</p>
<ul>
<li>专设IO指令：指令的地址码字段直接指出输入输出设备的设备代码</li>
<li>利用访存指令完成IO功能：此时需要从主存地址空间中分出一部分地址码作为IO的设备代码，当IO指令访问到这些地址时表示对IO设备寄存器的访问</li>
</ul>
<p>IBM PC中有专门IO指令，设备编址可达512个；每台设备占用若干个地址码，分别表示相应的设备控制器中的寄存器地址</p>
</blockquote>
<p>设备控制器的基本功能：</p>
<blockquote>
<ul>
<li>实现主机和外部设备之间的数据传送</li>
<li>实现数据缓冲，使得主机和外部设备之间的速度相匹配</li>
<li>接受主机的命令，提供设备接口的状态，并按照主机的命令控制设备</li>
</ul>
</blockquote>
<p>输入输出接口类型：</p>
<blockquote>
<ul>
<li>并行接口（按数据传送宽度分类）：设备和接口将一个字（节）的所有位同时传送</li>
<li>串行接口：设备和接口之间数据是一位一位串行传送，然后接口完成数据格式的串并转换；接口和主机之间按字节或并行传送</li>
<li>程序控制输入输出接口（按数据传送控制方式分类）</li>
<li>程序中断输入输出接口</li>
<li>直接存储器存取（DMA）接口</li>
</ul>
</blockquote>
<p>IO设备数据传送控制方式：</p>
<blockquote>
<p>程序直接控制方式：</p>
<ul>
<li>完全通过程序控制主机和外设之间的信息传送；CPU和外设串行工作，效率较低</li>
<li>策略：在用户程序中安排一段由IO指令和其他指令组成的程序段直接控制外围设备的工作</li>
<li>工作流程：发出启动命令启动设备，重复用一条测试指令检测IO设备的工作状态，待检测到“完成“状态时，进行数据传送</li>
</ul>
<p>程序中断传送方式</p>
<ul>
<li>一定程度上实现了CPU和外设的并行工作；但对于一些工作频率较高的外设这么传送数据有可能造成信息丢失</li>
<li>在程序中安排一条启动外围设备的指令，发出指令后原程序继续执行直到IO设备完成准备，此时IO设备向CPU发送中断请求INT信号</li>
<li>接收到信号后CPU停止正在运行的程序，转去执行中断服务程序，完成数据传送工作后，返回继续执行原来的程序</li>
</ul>
<p>直接存储器存取（DMA）</p>
<ul>
<li>策略：在外围设备和主存之间开辟直接的数据传送通路；无需CPU频繁干预，但多个DMA的同时使用会引起访问主存的冲突增加</li>
<li>正常工作时，所有工作周期用于执行CPU程序；当外围设备完成输入输出数据准备后，占用一个总线周期来和主存直接交换数据；然后CPU继续控制主线；如此重复直到所有数据传送完成</li>
<li>数据交换这个工作由DMA控制器完成，它给出每次传送数据的主存地址，并统计确定传送是否结束</li>
</ul>
<p>IO通道控制方式：</p>
<ul>
<li>IO通道是一个专用的设备；通道能独立执行用通道命令编写的IO控制程序，产生相应的控制信号，完成复杂的输入输出过程</li>
</ul>
<p>外围处理机方式</p>
<ul>
<li>外围处理机结构更接近于计算机；它除了能完成IO通道所要完成的控制功能，还能完成码制变换、格式处理、纠错等功能</li>
<li>它可以简化设备控制器，基本上能够独立于主机工作</li>
</ul>
</blockquote>
<h2 id="10-2-程序中断输入输出方式"><a href="#10-2-程序中断输入输出方式" class="headerlink" title="10.2 程序中断输入输出方式"></a>10.2 程序中断输入输出方式</h2><h3 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h3><p>中断是由IO设备或其他非预期的急需处理的事件引起的，它需要CPU中断现在正在执行的程序，转而去处理中断程序；处理完之后再返回执行原程序</p>
<p>作用：</p>
<blockquote>
<ul>
<li>宏观上使得CPU和IO设备并行工作：处理中断的时间是很短的</li>
<li>处理硬件故障</li>
<li>实现人机联系：利用中断系统实现用户干预机器</li>
<li>实现实时处理：通过要求计算机执行中断服务程序来实现实时处理</li>
<li>多处理机系统之间的联系</li>
</ul>
</blockquote>
<p>一些概念：</p>
<blockquote>
<ul>
<li>中断源：引起中断的事件，即发出中断请求的来源<ul>
<li>外中断：IO设备、定时钟等来自处理机外部设备的中断</li>
<li>内中断：处理器硬件故障或程序引起的中断；外中断和内中断是随机发生的</li>
<li>软中断：由“Trap”指令产生的中断，它在程序中是预先安排好的</li>
<li>中断触发器：在设备控制器中断用于保存中断事件的触发器，当其为1时向CPU发出中断请求信号；多个中断触发器构成中断寄存器，用于存储中断码；CPU处理中断时，根据中断码确定中断源，转入执行相应的服务程序</li>
</ul>
</li>
<li>中断的分级与优先权：按中断级确定中断的优先次序，然后同一级内再确定各个中断源的优先权</li>
<li>禁止中断：请求中断后，CPU由于某种原因不能中止执行现在的程序；当禁止中断触发器为1时，不响应所有中断申请</li>
<li>中断屏蔽：用程序方式封锁部分中断请求，其余部分中断仍会得到相应；有些中断是不可屏蔽的（如掉电中断），非屏蔽中断具有最高优先权</li>
</ul>
</blockquote>
<h3 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h3><h4 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h4><blockquote>
<ul>
<li>关中断：进入不可再次响应中断的状态，由硬件自动实现</li>
<li>保存断点和现场：用于恢复现场继续执行程序</li>
<li>判别中断源，转入中断服务程序：判别中断源，相应优先级最高的中断</li>
<li>开中断：此时允许更高级别的中断请求得到相应，实现中断嵌套</li>
<li>执行中断服务程序，实现有效的中断处理</li>
<li>退出中断：顺序执行关中断、恢复断点和现场、开中断、返回断点的操作，继续执行原程序</li>
</ul>
<p>关中断、保存断点等操作一般由硬件实现，这种指令不会出现在程序中，称为“中断隐指令”</p>
</blockquote>
<h4 id="判断中断源"><a href="#判断中断源" class="headerlink" title="判断中断源"></a>判断中断源</h4><p>有软件和硬件两种方式来确定中断源</p>
<blockquote>
<ul>
<li>查询法：测试程序按一定优先级排队检查各个设备的中断触发器，当遇到第一个1时取出其对应设备码，进入进入中断服务程序</li>
<li>串行排队链法：由硬件确定中断源</li>
</ul>
</blockquote>
<p>转向中断程序入口方法</p>
<blockquote>
<ul>
<li>在中断程序中设置一条专门接收终端设备码的指令，取到设备号后，通过主存的跳转表产生程序入口地址</li>
<li>向量中断：为每个中断源设置一个中断向量，该向量包括程序入口地址，该向量可由被选中的设备直接产生或由主存中的中断跳转表产生</li>
</ul>
</blockquote>
<p>多中断处理：</p>
<blockquote>
<ul>
<li>多中断：在处理某中断的过程中又发生了新的中断请求，又称中断嵌套</li>
<li>CPU能够相应更高级别的中断</li>
</ul>
</blockquote>
<h2 id="10-3-DMA输入输出方式"><a href="#10-3-DMA输入输出方式" class="headerlink" title="10.3 DMA输入输出方式"></a>10.3 DMA输入输出方式</h2><blockquote>
<ul>
<li>DMA是I/O设备与主存储器之间由硬件组成的直接数据通路，用于高速I/O设备与主存之间的成组数据传送。</li>
<li>数据传送是在DMA控制器控制下进行的，由DMA控制器给出当前正在传送的数据字的主存地址，并统计传送数据的个数以确定一组数据的传送是否已结束。</li>
<li>需要在主存中要开辟连续地址的专用缓冲器，用来提供或接收传送的数据。</li>
<li>在数据传送前和结束后要通过程序或中断方式对缓冲器和DMA控制器进行预处理和后处理。</li>
</ul>
</blockquote>
<h3 id="DMA工作方式"><a href="#DMA工作方式" class="headerlink" title="DMA工作方式"></a>DMA工作方式</h3><ul>
<li>CPU暂停方式：主机相应DMA请求后，让出存储总线，使DMA控制并使用内存，待一组数据传输完成后，DMA交还总线控制权</li>
<li>CPU周期窃取方式：DMA控制器与主存储器之间一次传送一个数据，窃取一个CPU周期，然后CPU继续执行程序</li>
<li>直接访问存储器：这是标准的DMA工作方式；如果传送数据时CPU不占用存储总线，则DMA对CPU不产生任何影响，若DMA和CPU需要同时访问存储总线，则DMA优先级高于CPU；在DMA传输数据时，不能占用或破坏CPU硬件资源或工作状态</li>
</ul>
<h3 id="DMA控制器组成"><a href="#DMA控制器组成" class="headerlink" title="DMA控制器组成"></a>DMA控制器组成</h3><p><img src="/2020/02/24/computer-composition0/DMA0.jpg" alt="DMA"></p>
<ul>
<li>设备寄存器：<blockquote>
<ul>
<li>主存地址寄存器MAR：主存缓冲区首地址，传送数据前由程序送入</li>
<li>外围设备地址寄存器ADR：存放IO设备的设备码，或表示该设备存储器的寻址信息</li>
<li>字数计数器WC：统计传送数据的总字数</li>
<li>控制与状态寄存器CSR：存放控制字和状态字</li>
<li>数据缓冲寄存器DBR：暂存IO设备与主存之间传送的数据</li>
</ul>
</blockquote>
</li>
<li>中断控制逻辑：负责申请CPU对DMA进行预处理和后处理</li>
<li>DMA控制逻辑：负责在DMA取得总线控制权之后控制主存和设备之间的数据传输<blockquote>
<ul>
<li>设备码选择电路</li>
<li>DMA优先排队电路</li>
<li>DMA请求线路</li>
</ul>
</blockquote>
</li>
<li>DMA接口连接线：包括DMA接口与主机和IO设备两个方向的数据线、地址线和控制信号线以及有关的收发和驱动线路</li>
</ul>
<h3 id="DMA数据传送过程"><a href="#DMA数据传送过程" class="headerlink" title="DMA数据传送过程"></a>DMA数据传送过程</h3><p><img src="/2020/02/24/computer-composition0/DMA1.jpg" alt="DMA"></p>
<blockquote>
<ul>
<li>DMA传送前预处理</li>
<li>数据传送</li>
<li>传送后处理<br>其中，预处理和后处理由CPU执行程序完成</li>
</ul>
</blockquote>
<h2 id="10-4-IO通道控制方式"><a href="#10-4-IO通道控制方式" class="headerlink" title="10.4 IO通道控制方式"></a>10.4 IO通道控制方式</h2><p>IO通道是计算机系统中代替CPU管理控制外部设备的独立部件，是一种能执行有限条IO指令集合的IO处理机</p>
<p>在通道控制方式下，一个主机可以连接多个通道，每个通道下面又可以连接多个不同的IO设备；这增强了主机与通道操作的并行能力以及增减外围设备的灵活性</p>
<p>IO通道控制方式:</p>
<blockquote>
<ul>
<li>四级连接方式: 主机-通道-设备控制器-IO设备</li>
</ul>
<ol>
<li>CPU启动通道,通道自动地去内存中取出通道指令并执行,实施对IO系统的统一管理和控制</li>
<li>数据交换过程结束,通道像CPU发出中断请求,进行通道结束处理工作<br>通道除了承担DMA的全部功能外,还承担了设备控制器的初始化工作,分担了计算机系统中全部或大部分IO功能,提高了计算机系统功能的分散化程度</li>
</ol>
</blockquote>
<p>分类:<br><img src="/2020/02/24/computer-composition0/IO0.jpg" alt="io">  </p>
<blockquote>
<ul>
<li>字节多路通道</li>
<li>选择通道</li>
<li>数组多路通道</li>
</ul>
</blockquote>
<p>字节多路通道:</p>
<blockquote>
<ul>
<li>以字节为单位轮流为多个中低速设备进行数据传输</li>
<li>多个设备可以同时处于工作状态,能交叉进行数据传输</li>
<li>数据传输率是各个外设传输率之和</li>
</ul>
</blockquote>
<p>数组多路通道:</p>
<blockquote>
<ul>
<li>将数据分成多个固定大小的数据块,以块为单位选择传输的外设</li>
<li>多个设备可以同时处于工作状态,当一个设备传输一个数据块之后就换一台外部设备</li>
<li>最大传输率为外设中传输率最大的一个</li>
</ul>
</blockquote>
<p>选择通道:</p>
<blockquote>
<ul>
<li>适合对高速设备进行数据传输,对多个不同外设进行控制,但一次只能有一台外设处于工作状态</li>
<li>在连接多个块设备时，采用轮流选择设备的方法，一次选择一个外部设备，在完成所要求的数据传输之后，再选择另一个外部设备进行数据传输</li>
<li>最大传输率应为所接外部设备传输率中最大的一个</li>
</ul>
</blockquote>
<h2 id="10-5-总线结构"><a href="#10-5-总线结构" class="headerlink" title="10.5 总线结构"></a>10.5 总线结构</h2><p>计算机系统多采用模块结构,一个模块就是一个部件,如主机板等</p>
<p>各模块之间传送信息的通路称为总线</p>
<p>为便于不同厂家生产的模块能灵活构成系统，形成了总线标准</p>
<h3 id="总线类型"><a href="#总线类型" class="headerlink" title="总线类型"></a>总线类型</h3><ul>
<li>内总线: 连接计算机内部各模块的总线; 如连接CPU,存储器,IO接口的总线</li>
<li>外总线: 系统之间或系统与外部设备之间的总线</li>
<li>单总线: 所有模块都连接到单一总线上; 如地址线,数据线,控制线和电源(地)线</li>
<li>多总线: 将速度较低的IO设备从总线上分出去,形成系统总线与IO总线的双总线结构,还有三总线结构等</li>
</ul>
<h3 id="总线组成"><a href="#总线组成" class="headerlink" title="总线组成"></a>总线组成</h3><p>总线是从两个或以上的源部件传送信息到一个或过高部件的一组数据传输线; 是一个源部件到多个目标部件的数据传输线不称为总线</p>
<h4 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h4><p>多个模块连接到一条共用总线上,需经过选择判优来避免多个部件同时发送信息的矛盾</p>
<blockquote>
<ul>
<li>同一个时间只能有一个申请者使用总线,总线判优机构按照申请者的优先权选择可以控制总线的设备或部件</li>
<li>主控器或主设备: 可以控制总线并启动数据传送的设备,如CPU和IO设备等</li>
<li>受控器或从设备: 能够响应总线主控器发出的总线命令的设备,如存储器和IO设备等</li>
</ul>
</blockquote>
<p>分类:</p>
<blockquote>
<ul>
<li>集中式控制: 总线控制逻辑基本上集中于一个设备(如CPU)</li>
<li>分布式总线控制: 总线控制逻辑分散在连接总线的各个部件或设备中</li>
</ul>
</blockquote>
<p>优先仲裁方式: 串行链接方式; 其优先次序是由“总线可用”线所接部件的位置决定的，离总线控制器越近的部件其优先权越高<br><img src="/2020/02/24/computer-composition0/BUS1.jpg" alt="bus"></p>
<h4 id="总线通信"><a href="#总线通信" class="headerlink" title="总线通信"></a>总线通信</h4><ul>
<li><p>同步通信</p>
<blockquote>
<ul>
<li>通信双方由统一的时钟 控制数据的传送</li>
<li>时钟通常由CPU发出,送到总线上的所有部件</li>
<li>经过一段固定时间，本次总线传送周期结束，开始下一个新的总线传送周期</li>
</ul>
</blockquote>
</li>
<li><p>异步通信</p>
<blockquote>
<ul>
<li>利用数据发送部件和接收部件之间的相互“握手”信号来实现总线数据传送</li>
</ul>
</blockquote>
</li>
<li><p>并行通信</p>
<blockquote>
<ul>
<li>数据的多个位同时进行传送,相同频率下位数多则传输率高</li>
<li>距离较短,限制在一个机柜内使用</li>
</ul>
</blockquote>
</li>
<li><p>串行通信</p>
<blockquote>
<ul>
<li>数据一位一位地顺序传送</li>
<li>通信线路简单,只需一对传输线即可双向通信,适合远距离通信</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h4><p>数据传送过程可能产生错误，有些接收部件有自动纠错能力，可以自动纠正错误；而有些部件无自动纠错能力但能发现错误，可发出“数据出错”信号，通常向 CPU 发出中断请求信号，CPU 响应中断后，转入出错处理程序。</p>
<h4 id="总线驱动"><a href="#总线驱动" class="headerlink" title="总线驱动"></a>总线驱动</h4><p>总线上可连接多个部件，具有扩充灵活的优点，但总线的驱动能力总是有限制的，因此在扩充时要加以注意。通常一个模块或一个部件限制在1～2个负载以内。</p>
<h3 id="微机总线"><a href="#微机总线" class="headerlink" title="微机总线"></a>微机总线</h3><h4 id="ISA总线和EISA总线"><a href="#ISA总线和EISA总线" class="headerlink" title="ISA总线和EISA总线"></a>ISA总线和EISA总线</h4><p>ISA总线:</p>
<blockquote>
<ul>
<li>最初8根,80年代中期扩展成16根,时钟为8MHz</li>
<li>CPU速度提高后,CPU与存储器之间交换数据不再通过ISA总线</li>
<li>ISA总线用于连接外设,最大传输速率16.6MB/s</li>
</ul>
</blockquote>
<p>EISA总线:</p>
<blockquote>
<ul>
<li>32位,时钟为8MHz</li>
<li>传输速率可达33MB/s</li>
</ul>
</blockquote>
<h4 id="PCI总线"><a href="#PCI总线" class="headerlink" title="PCI总线"></a>PCI总线</h4><blockquote>
<ul>
<li>PC: 32位,时钟频率33MHz,传输率132MB/s</li>
<li>服务器和中高端工作站：64位、33MHz(266MB/s)、66MHz(533MB/s)</li>
<li>有即插即用功能</li>
</ul>
</blockquote>
<p><img src="/2020/02/24/computer-composition0/PCI0.jpg" alt="pci"></p>
<blockquote>
<ul>
<li>系统总线：连接一个或多个微处理器、cache和主存储器</li>
<li>PCI设备：PCI总线连接的高速I/O设备</li>
<li>主机桥：PCI总线控制器，含有集中式总线仲裁器</li>
<li>PCI-PCI桥：PCI总线扩展，形成多层次PCI结构，减轻单个PCI总线的负载</li>
<li>PCI-ISA桥：连接PCI总线和ISA总线，接入ISA设备</li>
</ul>
</blockquote>
<h4 id="PCI-X"><a href="#PCI-X" class="headerlink" title="PCI-X"></a>PCI-X</h4><blockquote>
<ul>
<li>处理器和外部设备之间数据的传输速度与千兆以太网和光纤通道的要求相比差距很大</li>
<li>PCI-X 2.0：频率提升到266MHz(传输率2.1GB/s)和533MHz(传输率4.3GB/s)</li>
<li>PCI-X DDR（双倍数据速率）可在一个时钟周期中传输两次数据</li>
</ul>
</blockquote>
<h4 id="PCI-Express"><a href="#PCI-Express" class="headerlink" title="PCI Express"></a>PCI Express</h4><blockquote>
<ul>
<li>采用点到点的串行连接技术: 每个设备有自己专用的连接，独享带宽，不必向共享总线请求带宽</li>
<li>一个PCI Express连接可以包含多个信道(lane)</li>
<li>采用串行传输技术，传输率比PCI高</li>
<li>单个信道的PCI Express X1提供单向250MB/s带宽; 16个信道的PCI Express X16带宽4GB/s</li>
</ul>
</blockquote>
<p><img src="/2020/02/24/computer-composition0/pcie0.jpg" alt="pcie"></p>
<h2 id="10-6-外设接口"><a href="#10-6-外设接口" class="headerlink" title="10.6 外设接口"></a>10.6 外设接口</h2><p>ATA(IDE):</p>
<blockquote>
<ul>
<li>并行ATA</li>
<li>串行ATA(SATA)</li>
</ul>
</blockquote>
<p>还有SCSI,SAS,光纤,USB串口等</p>
<h2 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h2><ul>
<li>DAS: 直接连接存储器</li>
<li>SAN: 存储区域网络,建立在光纤通道技术上</li>
<li>NAS: 网络附加存储,以文件为传输单位的存储网络,按照TCP/IP协议进行数据传输</li>
</ul>
<hr>
<p>博文创建时间: 2020-02-24 10:32:00</p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/02/24/java0/</url>
    <content><![CDATA[<p>未完结,持续更新</p>
<hr>
<h2 id="Java常识"><a href="#Java常识" class="headerlink" title="Java常识"></a>Java常识</h2><p>Java: 一次编译，处处运行</p>
<h3 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h3><p>c++ - -</p>
<ul>
<li>无直接指针操作</li>
<li>自动内存管理</li>
<li>数据类型长度固定</li>
<li>不用头文件</li>
<li>不包含结构和联合</li>
<li>不支持宏</li>
<li>不用多重继承(接口实现)</li>
<li>无类外全局变量</li>
<li>无goto</li>
</ul>
<p>Java三种核心机制</p>
<ul>
<li>Java虚拟机</li>
<li>代码安全性监测</li>
<li>垃圾回收机制</li>
</ul>
<p><em>Java程序都是运行在虚拟机之上的,与平台无关</em></p>
<ul>
<li>JRE(java运行环境)=JVM+API</li>
<li>JDK(Java开发工具包)=JRE+Tools</li>
</ul>
<a id="more"></a>

<h3 id="Java面向对象程序设计"><a href="#Java面向对象程序设计" class="headerlink" title="Java面向对象程序设计"></a>Java面向对象程序设计</h3><p>类</p>
<ul>
<li>属性: 变量,字段</li>
<li>行为: 函数,方法</li>
</ul>
<p>类与对象的关系</p>
<ul>
<li>类是对象的抽象</li>
<li>对象是类的实例</li>
</ul>
<p>面向对象三大特性</p>
<ul>
<li>封装: 模块化,信息隐蔽</li>
<li>继承: 父类子类间共享数据,更好地抽象和分类,增强代码重用性和可维护性</li>
<li>多态: 方法重载</li>
</ul>
<h3 id="简单Java程序"><a href="#简单Java程序" class="headerlink" title="简单Java程序"></a>简单Java程序</h3><p>Java程序类型:</p>
<ul>
<li>Application: 独立程序,需要执行器(虚拟机)来运行</li>
<li>Applect: 非独立程序,嵌入在HTML网页中运行</li>
</ul>
<p>应用程序要点(helloword)</p>
<ul>
<li>class是主体</li>
<li>public类名与文件名同名</li>
<li>main()的写法是固定的: public static void main()</li>
<li>System.out.print及println及printf</li>
</ul>
<p>Applet程序(helloword)</p>
<ul>
<li>import表示导入</li>
<li>extends JApplet表示继承</li>
<li>有paint()方法,表示如何绘制</li>
<li>没有main()方法</li>
</ul>
<p>Java程序基本构成</p>
<ul>
<li>package语句(0或1句)</li>
<li>import语句(0或多句)</li>
<li>类定义(1或多个,但只能有一个public类,与文件同名)</li>
</ul>
<h3 id="Java程序开发过程"><a href="#Java程序开发过程" class="headerlink" title="Java程序开发过程"></a>Java程序开发过程</h3><p>编辑,编译与运行</p>
<ul>
<li>编辑: 编辑器编辑,文件名要与public class类名一致</li>
<li>程序编译: 转换程序为字节码,扩展名.class  javac name.java</li>
<li>程序运行: 执行.class中的文件    java name</li>
</ul>
<p>JDK安装目录</p>
<blockquote>
<p>Bin 存放工具文件<br>Jre 存放与Java运行环境相关的文件<br>Demo 存放示例文件<br>Include 存放与C相关的头文件<br>Lib 存放程序库<br>DB 数据库相关</p>
</blockquote>
<h3 id="Java的几个工具"><a href="#Java的几个工具" class="headerlink" title="Java的几个工具"></a>Java的几个工具</h3><p>主要工具</p>
<ul>
<li>javac 编译</li>
<li>java 运行(控制台及图形界面程序)</li>
<li>javaw 运行图形界面程序</li>
<li>appletViewer 运行applet程序</li>
</ul>
<p>另外常用工具</p>
<ul>
<li>jar 打包工具</li>
<li>javadoc 生成文档</li>
<li>javap 查看类信息及反汇编</li>
</ul>
<h3 id="Java的输入和输出"><a href="#Java的输入和输出" class="headerlink" title="Java的输入和输出"></a>Java的输入和输出</h3><h4 id="文本界面-使用Scanner类"><a href="#文本界面-使用Scanner类" class="headerlink" title="文本界面: 使用Scanner类"></a>文本界面: 使用Scanner类</h4><p>使用java.util.Scanner类</p>
<ul>
<li>Scanner.nextInt()</li>
<li>Scanner.nextDouble()</li>
<li>Scanner.next 得到下一个单词<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用in及out"><a href="#使用in及out" class="headerlink" title="使用in及out"></a>使用in及out</h4><p>使用java.io包</p>
<ul>
<li>System.in.read()</li>
<li>System.out.print()<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">''</span>;</span><br><span class="line">System.out.print(<span class="string">'Hello'</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    c = (<span class="keyword">char</span>)System.in.read();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOExceprion e)&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="图形界面输入输出"><a href="#图形界面输入输出" class="headerlink" title="图形界面输入输出"></a>图形界面输入输出</h4><p>添加按钮,监听事件…</p>
<h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><p>NaN</p>
<h4 id="eclips"><a href="#eclips" class="headerlink" title="eclips"></a>eclips</h4><p>java里的程序应当都以工程的形式存在</p>
<ul>
<li>新建一个工程，起一个名字(文件夹的名字)</li>
<li>在src文件夹中建立package包(一般小写字母)</li>
<li>在package里面建立类(首字母大写)</li>
<li>写主函数…</li>
<li>右击包文件 run as application</li>
</ul>
<h2 id="Java数据运算-流程控制和数组"><a href="#Java数据运算-流程控制和数组" class="headerlink" title="Java数据运算,流程控制和数组"></a>Java数据运算,流程控制和数组</h2><p>数据类型决定数据的存储方式和运算方式</p>
<p>主要有两类数据类型:</p>
<ul>
<li>基本数据类型(实体直接存储在栈里)</li>
<li>引用数据类型(实体存储在堆里)<blockquote>
<p>赋值时,基本类型复制的是值,引用类型复制的是引用</p>
</blockquote>
</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>整数型(byte,short,int,long(3.14L))</li>
<li>浮点数型</li>
<li>逻辑型</li>
<li>字符型</li>
</ul>
<h3 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h3><ul>
<li>短路与:&amp;&amp; 短路或||</li>
<li>注意: ^不是乘方,是位运算异或</li>
<li>赋值的强制类型转换</li>
<li>字符串连接运算符:+ 可以将非字符串类型转换成字符串类型并连接</li>
</ul>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><p><em>类似C++</em></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><em>类似C++</em></p>
<h2 id="Java的类"><a href="#Java的类" class="headerlink" title="Java的类"></a>Java的类</h2><h3 id="字段和方法"><a href="#字段和方法" class="headerlink" title="字段和方法"></a>字段和方法</h3><ul>
<li>字段是类的属性</li>
<li>方法时类内部的函数</li>
</ul>
<p>Java的对象时通过引用来表示的，没有指针</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载是指多个方法有相同的名字，但编译的时候能识别出来</p>
<ul>
<li>同通过方法重载可以实现多态</li>
</ul>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>类中this可以解决局部变量与域同名的问题，也可以用来调用另一个构造方法:<code>this(args**)</code></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>java一个类只能有一个直接父类</p>
<ul>
<li>子类继承父类的状态和行为</li>
<li>子类可以修改父类的状态或重载父类的行为</li>
<li>子类可以添加新的状态和行为<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c1</span> <span class="keyword">extends</span> <span class="title">c2</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在UML图中,继承用箭头表示</li>
</ul>
<h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><p>方法覆盖可以用<code>@override</code>标注</p>
<h3 id="super的使用"><a href="#super的使用" class="headerlink" title="super的使用"></a>super的使用</h3><ul>
<li>使用super在同名的情况下可以在类内访问父类的方法</li>
<li>super可以在子类的构造函数中调用父类的构造函数<code>super(args**)</code></li>
</ul>
<h3 id="父类对象和子类对象转换"><a href="#父类对象和子类对象转换" class="headerlink" title="父类对象和子类对象转换"></a>父类对象和子类对象转换</h3><p>子类对象可以赋值给父类对象,反之不行</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包和子包的定义,实际上时为了解决名字空间,名字冲突的问题</p>
<ul>
<li>同一个包中的类,默认情况下可以互相访问</li>
</ul>
<h4 id="package语句和import导入语句"><a href="#package语句和import导入语句" class="headerlink" title="package语句和import导入语句"></a>package语句和import导入语句</h4><p>package可以封装包,import可以导入包</p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问修饰符和C++类似C</p>
<ul>
<li>默认情况是一种包内可访问性</li>
</ul>
<p>非访问控制符:</p>
<ul>
<li>static静态类,静态成员</li>
<li>final最终的类,成员,方法</li>
<li>abstract抽象类,抽象成员</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>定义接口<code>interface i1</code></p>
<ul>
<li>接口所有方法都自动是public abstract<br>实现接口implements</li>
<li>实现接口可以解决多继承问题</li>
<li>实现接口与类的继承无关</li>
</ul>
<h2 id="Java内的一些机制"><a href="#Java内的一些机制" class="headerlink" title="Java内的一些机制"></a>Java内的一些机制</h2><h3 id="变量及其传递"><a href="#变量及其传递" class="headerlink" title="变量及其传递"></a>变量及其传递</h3><p>变量分为基本类型和引用类型</p>
<p>变量也可以分为字段变量和局部变量</p>
<ul>
<li>字段变量在堆中存储，局部变量在栈中存储</li>
<li>字段变量可以自动赋初始值，局部变量要显式赋值</li>
<li>相对于字段变量，局部变量不能被访问控制符或static修饰，但可以被final修饰</li>
<li>Java参数传递是值传递(引用变量传递的是引用值)</li>
</ul>
<h3 id="多态和虚方法调用"><a href="#多态和虚方法调用" class="headerlink" title="多态和虚方法调用"></a>多态和虚方法调用</h3><ul>
<li>编译时的多态: 重载</li>
<li>运行时的多态: 覆盖,动态绑定(虚方法调用)<blockquote>
<ul>
<li>所有的非final方法都会进行动态绑定</li>
</ul>
</blockquote>
</li>
</ul>
<p>上溯造型: 将派生类当作基本类处理</p>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><ul>
<li>Java中,普通的方法是虚方法</li>
<li>static,private方法不是虚方法调用(编译后的指令是不同的)</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>对象都有构造方法,包括抽象类</p>
<ul>
<li>实例初始化: 在类中直接写{}</li>
<li>静态初始化: 在类中写static {}</li>
</ul>
<h3 id="构造方法执行过程"><a href="#构造方法执行过程" class="headerlink" title="构造方法执行过程"></a>构造方法执行过程</h3><ul>
<li>调用本类或父类构造方法直到objct类</li>
<li>按照声明顺序执行字段的初始化赋值</li>
<li>执行构造方法中的语句</li>
</ul>
<h3 id="对象清除与对象回收"><a href="#对象清除与对象回收" class="headerlink" title="对象清除与对象回收"></a>对象清除与对象回收</h3><p>Java中对象销毁是自动的,不需要进行delete</p>
<p>System.gc()可以建议系统进行垃圾回收</p>
<p>Java中没有析构方法,但子类可以重写finalize()方法</p>
<h3 id="内部类和匿名类"><a href="#内部类和匿名类" class="headerlink" title="内部类和匿名类"></a>内部类和匿名类</h3><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>在类内定义class即为内部类</p>
<h3 id="java异常处理"><a href="#java异常处理" class="headerlink" title="java异常处理"></a>java异常处理</h3><p>Java中用try-catch捕获并处理异常，用throw来抛出异常</p>
<hr>
<p><em>待更新…</em></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>专业选修</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>python作图</title>
    <url>/2020/02/12/python-plot1/</url>
    <content><![CDATA[<p>一些参考网站:<br><a href="https://zhuanlan.zhihu.com/p/39077155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39077155</a><br><a href="https://zhuanlan.zhihu.com/p/49035741" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49035741</a><br><a href="https://zhuanlan.zhihu.com/p/27401041" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27401041</a><br><a href="https://zhuanlan.zhihu.com/p/37360133" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37360133</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUzODYwMDAzNA==&amp;mid=2247488701&amp;idx=4&amp;sn=73c8ca23d8eced3590ab285f9f43d99b&amp;chksm=fad463b0cda3eaa6f9be051e3c1e0c1a7ddc8922c5c6bf1dfa75f2db84affb88fa248760b781&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1581401241375&amp;sharer_shareid=ab6f5905c1aa5f4891f8d87e4501862b#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzUzODYwMDAzNA==&amp;mid=2247488701&amp;idx=4&amp;sn=73c8ca23d8eced3590ab285f9f43d99b&amp;chksm=fad463b0cda3eaa6f9be051e3c1e0c1a7ddc8922c5c6bf1dfa75f2db84affb88fa248760b781&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1581401241375&amp;sharer_shareid=ab6f5905c1aa5f4891f8d87e4501862b#rd</a>  </p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab常用语法</title>
    <url>/2020/02/09/matlab/</url>
    <content><![CDATA[<p>仅作随笔用,不完善不严谨</p>
<h3 id="变量-符号-数组-矩阵"><a href="#变量-符号-数组-矩阵" class="headerlink" title="变量 符号 数组 矩阵"></a>变量 符号 数组 矩阵</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&lt;var&gt; = &lt;expression&gt;</span><br></pre></td></tr></table></figure>

<p>预定义变量   </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pi</span>  <span class="comment">% 圆周率</span></span><br><span class="line"><span class="built_in">inf</span> <span class="comment">% 又Inf,无穷大</span></span><br><span class="line"><span class="built_in">nan</span> <span class="comment">% 又NaN,不定值</span></span><br><span class="line"><span class="built_in">eps</span> <span class="comment">% 浮点数运算相对精度,无穷小</span></span><br><span class="line"><span class="built_in">i</span>   <span class="comment">% 又j,虚部单位</span></span><br><span class="line"><span class="built_in">ans</span> <span class="comment">% 上一次运算结果</span></span><br></pre></td></tr></table></figure>

<p>变量存储 读取 清除  </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">save [filename.mat] [var1] [var2] ...</span><br><span class="line">load &lt;filename.mat&gt; [var1] [var2] ...</span><br><span class="line">clear [var1] [var2]</span><br></pre></td></tr></table></figure>

<p>相关命令</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">who <span class="comment">% 显示工作空间中的所有变量  </span></span><br><span class="line">whos    <span class="comment">% 查看工作空间中变量的详细属性 </span></span><br><span class="line"><span class="built_in">realmin</span> <span class="comment">% 最小可用正实数</span></span><br><span class="line"><span class="built_in">realmax</span> <span class="comment">% 最大可用正实数</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="符号-符号表达式"><a href="#符号-符号表达式" class="headerlink" title="符号 符号表达式"></a>符号 符号表达式</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">syms [symbol1] &lt;symbol2&gt; &lt;symbol3&gt; ...  <span class="comment">% 创建多个符号变量, 相当于symbol1 = sym('symbol'); symbol2 = sym('symbol2'); ...</span></span><br><span class="line">[symbol] = sym([symbol/value/symbolexpression])  <span class="comment">% 用符号/数值/表达式来创建符号变量/常量/表达式</span></span><br></pre></td></tr></table></figure>

<p>相关函数  </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">findsym(expression [, N])   <span class="comment">% 查找符号表达式中的[离x最近的N个]符号变量</span></span><br><span class="line">subs(expression, symbol1, symbol2)  <span class="comment">% 在表达式中用s2替换s1</span></span><br></pre></td></tr></table></figure>

<h4 id="数组-矩阵"><a href="#数组-矩阵" class="headerlink" title="数组 矩阵"></a>数组 矩阵</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[matrix] = [row1 ; row2 ; ... ]</span><br><span class="line">[row] = [sym1 sym2 ...] <span class="comment">% row = start: step: end</span></span><br><span class="line">[matrix](n) = value <span class="comment">% 元素赋值</span></span><br><span class="line">[matrix] = [matrix ; matrix2]   <span class="comment">% 矩阵列拼接</span></span><br><span class="line">[matrix] = [matrix matrix2] <span class="comment">% 矩阵行拼接</span></span><br></pre></td></tr></table></figure>

<p>相关操作</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A(i1 : step : i2, j1 : step : j2)   <span class="comment">% 矩阵切片</span></span><br><span class="line">.* ./ .^    <span class="comment">% 点乘点除点幂乘</span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sin</span>、<span class="built_in">cos</span>、<span class="built_in">tan</span>、<span class="built_in">cot</span>、<span class="built_in">sec</span>、<span class="built_in">csc</span>、…</span><br><span class="line"><span class="built_in">asin</span>、<span class="built_in">acos</span>、<span class="built_in">atan</span>、<span class="built_in">acot</span>、<span class="built_in">asec</span>、<span class="built_in">acsc</span>、…</span><br><span class="line"><span class="built_in">exp</span>、<span class="built_in">log</span>、<span class="built_in">log2</span>、<span class="built_in">log10</span>、<span class="built_in">sqrt</span></span><br><span class="line"><span class="built_in">abs</span>、<span class="built_in">conj</span>、<span class="built_in">real</span>、<span class="built_in">imag</span></span><br><span class="line">rank、det、inv、eig、lu、qr、svd</span><br><span class="line"><span class="built_in">diag</span>、<span class="built_in">triu</span>、<span class="built_in">tril</span>、expm</span><br></pre></td></tr></table></figure>

<p>相关命令  </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">findsym(expr)   <span class="comment">% 按字母顺序列出符号表达式 expr 中的所有符号变量</span></span><br><span class="line">findsym(expr, N)    <span class="comment">% 按顺序列出 expr 中离 x 最近的 N 个符号变量</span></span><br><span class="line">nargin  <span class="comment">% 所用函数的输入变量数目</span></span><br><span class="line">nargout <span class="comment">% 所用函数的输出变量数目</span></span><br></pre></td></tr></table></figure>

<p>####　运算函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">factor</span>(f)   <span class="comment">% 因式分解或质因数分解</span></span><br><span class="line">expand(f)   <span class="comment">% 函数展开</span></span><br><span class="line">taylor(f,x,a)   <span class="comment">% f关于符号x在a处进行5项泰勒展开</span></span><br><span class="line">collect(f,v)    <span class="comment">% f对(默认变量)v进行合并同类项</span></span><br><span class="line">simplify(f) <span class="comment">% 对f化简函数</span></span><br><span class="line">numden(f)   <span class="comment">% 函数化简 -&gt; [N,D] N为分子,D为分母</span></span><br><span class="line">horner(f)   <span class="comment">% 多项式转嵌套多项式 x(...x(x+i)+j)+k</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">limit(fun,x,x0 [, <span class="string">'left'</span>/<span class="string">'right'</span>])  <span class="comment">% 在fun中对符号x在x0处求极限</span></span><br><span class="line">int(f [, v, a, b])  <span class="comment">% 在f中对(默认)变量[v][在区间(a,b)上]的(不)定积分</span></span><br><span class="line">symsum(f, v, a, b)  <span class="comment">% 在v=a,a+1....b上对f(v)进行求和</span></span><br><span class="line">solve(f,v)  <span class="comment">% 求方程(组)关于指定自变量的解</span></span><br><span class="line">y=dsolve(eq1, eq2, ..., cond1, cond2, ..., v)   <span class="comment">% 微分方程eq1,eq2...在cond1,cond2...为初值条件下自变量v的解 -&gt; 输出解y,若无显式函数,则输出[x,y]</span></span><br><span class="line">finverse(f,v)   <span class="comment">% f关于(默认变量)v的反函数</span></span><br></pre></td></tr></table></figure>

<h4 id="多项式函数"><a href="#多项式函数" class="headerlink" title="多项式函数"></a>多项式函数</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = [a1, a2, a3, a4 ...]    <span class="comment">% 多项式降幂系数的行向量表示</span></span><br><span class="line">r = roots(p)    <span class="comment">% 求出多项式为0的根</span></span><br><span class="line">p = poly(r) <span class="comment">% 通过多项式为0的根求出多项式</span></span><br><span class="line">c = conv(a,b)   <span class="comment">% 多项式相乘</span></span><br><span class="line">[q, r] = deconv(c, b)   <span class="comment">% 多项式相除</span></span><br><span class="line">d = polyder(a)  <span class="comment">% 微分多项式</span></span><br><span class="line">n = polyval(a, <span class="number">2</span>)   <span class="comment">% 多项式函数求值</span></span><br><span class="line">p = polyfit(x,y,n)  <span class="comment">% 在x, y样本点向量下求出一个n阶多项式的拟合p</span></span><br><span class="line">[a,Jm] = lsqcurvefit(Fun,a0,x,y)    <span class="comment">% 最小二乘曲线拟合,Fun为原函数，x,y 为原始输入数据,a0为最优化初值，a为最小二乘系数，Jm为目标</span></span><br><span class="line">yi = interp1(x, y, xi, <span class="string">'method'</span>)    <span class="comment">% 一维插值计算</span></span><br><span class="line">zi = interp2(x，y，z，xi，yi，<span class="string">'method'</span>)  <span class="comment">% 二维插值计算</span></span><br></pre></td></tr></table></figure>

<h4 id="作图函数"><a href="#作图函数" class="headerlink" title="作图函数"></a>作图函数</h4><p>参考<a href="https://www.cnblogs.com/ileanj1998/p/9060664.html" target="_blank" rel="noopener">https://www.cnblogs.com/ileanj1998/p/9060664.html</a></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x,y)   <span class="comment">% x 为向量, y为x的函数或者同长度向量</span></span><br><span class="line">xlabel(<span class="string">'x'</span>) ylabel(<span class="string">'y'</span>) <span class="comment">% 坐标轴信息]</span></span><br></pre></td></tr></table></figure>

<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><ul>
<li>若不想在屏幕上输出结果，可以在语句最后加分号  </li>
<li>如果语句很长，可用续行符 “…”（三个点）续行,续行符的前面最好留一个空格</li>
<li>Matlab 的命令记忆功能：上下箭头键  </li>
<li>命令补全功能： Tab 键   </li>
<li>用 Esc 键 删除命令行</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>From Flour to Rolls</title>
    <url>/2020/02/08/making-rolls/</url>
    <content><![CDATA[<p><em>这是一次从面粉到面花卷过程</em>  </p>
<hr>
<a id="more"></a>

<ol>
<li>一斤玉米面、一斤荞麦面、一斤白面、一包奶粉一勺糖，混合均匀  </li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour1.jpg" alt="alt">  </p>
<ol start="2">
<li>35度以下,将干酵母放入水中,混合搅拌均匀  </li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour2.jpg" alt="alt">  </p>
<p><em>一斤面粉放2g干酵母</em>  </p>
<p><img src="/2020/02/08/making-rolls/flour3.jpg" alt="alt"></p>
<p><em>倒入水中混合</em>  </p>
<ol start="3">
<li>将水和面粉混合  </li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour4.jpg" alt="alt"> </p>
<ol start="4">
<li>搅匀  </li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour5.jpg" alt="alt">  </p>
<p><img src="/2020/02/08/making-rolls/flour6.jpg" alt="alt"> </p>
<p><em>最后的样子</em></p>
<ol start="5">
<li>将面放在温暖的地方静置一会</li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour7.jpg" alt="alt">  </p>
<p><img src="/2020/02/08/making-rolls/flour8.jpg" alt="alt">  </p>
<p><em>等待发面中…</em></p>
<ol start="6">
<li>稍微加亿点处理……  </li>
</ol>
<p><em>这儿没有图</em></p>
<ol start="7">
<li>结束</li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour9.jpg" alt="alt">  </p>
<p><em>结束!成品如上</em></p>
<hr>
<p>至于这个花卷最后嘛…<br>嗯,有点丑,但能吃</p>
<!--本来其实是想写一篇关于如何在hexo上发图片的博客,但是感觉没啥意思...  
如果是真的想知道如何在markdown中插入图片,可以看这儿<https://www.jianshu.com/p/81ce308e894c>  
这一篇就当是我拿来练练手发发图片的吧  
还是吃太饱了... --> 
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>playing</tag>
      </tags>
  </entry>
  <entry>
    <title>使用termux在安卓系统下搭建hexo-github博客编写环境</title>
    <url>/2020/02/07/android-hexo-setting/</url>
    <content><![CDATA[<p>在hexo已经部署到github的情况下，本文将记录如何把自己的移动设备(安卓手机、平板)变成可以编辑并上传博客的平台。  </p>
<p>关于如何在github上搭建hexo，详见<a href="https://zhuanlan.zhihu.com/p/44213627" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44213627</a><br>注意：使用多终端更新博客之前，请确保自己的博客系统在github上面同时有编译前、后两个分支，多终端更新方法可参考<a href="https://keyanbu.club/2020/02/05/guide/" target="_blank" rel="noopener">https://keyanbu.club/2020/02/05/guide/</a></p>
<p>本博文使用matepad pro在安卓环境下编写完成。  </p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于安卓系统下没有直接支持git及hexo的软件，我们使用termux来虚拟出一个linux环境，在终端中安装git及相关包，使用vim或安卓的相关文本编辑器(我用的920编辑器)来编写博文，用termux终端同步博客。  </p>
<p>相关问题：</p>
<ul>
<li>使用termux的pkg安装nodejs时可能会出现与npm版本不兼容的情况，安装nodejs-lts可解决。</li>
<li>使用在使用hexo generate生成博客时可能会出现网页排版错误，尚未解决。  </li>
</ul>
<p>以下所有操作都相对小白，懂的可以直接略过  </p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>除了安装termux之外，其他操作几乎和电脑上是一样的</p>
<ul>
<li>安装termux</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己去网上找安装包安装，这里不说了</span></span><br><span class="line"><span class="comment"># 安装好之后进入termux，应该是一个显示如下的终端</span></span><br><span class="line"></span><br><span class="line">Welcome to Termux!</span><br><span class="line"></span><br><span class="line">Wiki:            https://wiki.termux.com</span><br><span class="line">Community forum: https://termux.com/community</span><br><span class="line">Gitter chat:     https://gitter.im/termux/termux</span><br><span class="line">IRC channel:     <span class="comment">#termux on freenode</span></span><br><span class="line"></span><br><span class="line">Working with packages:</span><br><span class="line"></span><br><span class="line"> * Search packages:   pkg search &lt;query&gt;</span><br><span class="line"> * Install a package: pkg install &lt;package&gt;</span><br><span class="line"> * Upgrade packages:  pkg upgrade</span><br><span class="line"></span><br><span class="line">Subscribing to additional repositories:</span><br><span class="line"></span><br><span class="line"> * Root:     pkg install root-repo</span><br><span class="line"> * Unstable: pkg install unstable-repo</span><br><span class="line"> * X11:      pkg install x11-repo</span><br><span class="line"></span><br><span class="line">Report issues at https://termux.com/issues</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<ul>
<li>安装git</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pkg install git</span><br></pre></td></tr></table></figure>

<ul>
<li>设置git全局邮箱和用户名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">$ git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置ssh key  </li>
</ul>
<p>这里得先安openssh  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pkg install openssh</span><br></pre></td></tr></table></figure>
<p>然后生成ssh key  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br><span class="line"><span class="comment"># 然后一路默认回车即可</span></span><br></pre></td></tr></table></figure>
<p>这里注意，生成的ssh_key路径是在隐藏目录home/.ssh下的，需要进入˜/.ssh用vim打开id_rsa.pub复制公钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时是默认home路径</span></span><br><span class="line">$ <span class="built_in">cd</span> .ssh    <span class="comment"># 切换到.ssh目录</span></span><br><span class="line">$ vim id_rsa.pub</span><br><span class="line"><span class="comment"># 此时进入vim编辑器，屏幕上显示内容应该和如下类似</span></span><br><span class="line"></span><br><span class="line">ssh-rsa AAAADAQABAAABgQC8uwcEZdQna+zv/HTa2W4I</span><br><span class="line">AvqiNyKxgVdi07ce8hRTpb/lejdVK5rux7jOkWM00Pl73</span><br><span class="line">7qTKXAgWkgVckflinjfd6bxgOEA0ZUYRcFjuMYNccOdWO</span><br><span class="line">XDfmX0w4GYaKhGG5RMsWxVsNSfoskjYpCs1fiSTvM49Y6</span><br><span class="line">FWsEzyXaQ46VWedZJKqEhVPoAtZOEmNOi0krsqymzfjZj</span><br><span class="line">7/iVzuZiFP/zN5itPJXHvYMTA0OzDiPo3qHGHW8yvUpPd</span><br><span class="line">mSY65mXUk1odGmUMBo3/VoOW9ki9t0G6BTqK4lW4qijII</span><br><span class="line">lhrVocrs6APlyAuyPbi5cCtrwQxJSd6J+h8d9t9qdZD/E</span><br><span class="line">DUUdh63jdk07vmlv/+qUza15SZaAptfmFFbKOES8b7qfk</span><br><span class="line">iUXvCr+kCH36lz+rTbF75cW1aU3dJ1/WWj3jgumVyqeMU</span><br><span class="line">bE/OiF3ZBQA7mmz93Jho+Wis5mG07QjI3f18d+ZG0xonf</span><br><span class="line">wg+sjQf3fIujCPq99PcKlM= georgechen1827@gmail.</span><br><span class="line">com</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">id_rsa.pub                1,1            All</span><br></pre></td></tr></table></figure>
<p>复制从ssh到.com的内容，粘贴到你的github-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH key-&gt;Key中(Title随便取个名就行),Add SSH key即可<br>然后回到终端，退出vim并且测试一下是否可以通过git连上github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关于退出vim，只要输入':q'回车就行</span></span><br><span class="line">$ ssh -T git@github.com    <span class="comment"># 测试是否能够连上github，第一次可能需要连接确认</span></span><br></pre></td></tr></table></figure>
<p>顺便说一句，这个终端中所有的目录和文件都是termux应用的内部数据，从外部(如安卓手机上的文件管理器)一般是访问不到的(比如这个id_rsa.pub就无法从外部来访问)，如果你所操作的文件是在外部存储中；或者想将文件保存在外部存储中，需要给予termux访问存储设备的权限，具体操作下一节会讲到。  </p>
<ul>
<li>安装nodejs</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pkg install nodejs-lts</span><br><span class="line"><span class="comment"># 如果这里 pkg install nodejs 可能会出现npm与nodejs版本不兼容问题，具体原因未知</span></span><br><span class="line"><span class="comment"># 如果termux没有安装npm，需要pkg install npm</span></span><br><span class="line"><span class="comment"># 通过node -v和npm -v可以查看相应的版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<ul>
<li>git自己的博客源文件</li>
</ul>
<p>先cd到你想存放博客的某个文件夹下(如果可以的话，我建议将这个文件夹设在一个能被其他应用访问到的地方，具体操作见下一节)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:yourname/yourname.github.io.git</span><br><span class="line"><span class="comment"># clone你的博客源文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成部署编写…</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> yourname.github.io</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>然后就可以开始写博客啦！</p>
<h3 id="关于termux访问外部存储"><a href="#关于termux访问外部存储" class="headerlink" title="关于termux访问外部存储"></a>关于termux访问外部存储</h3><p>上面讲过，termux终端中所有的目录和文件都是作为应用的内部数据存在的，从外部一般访问不到(当然理论上是能访问到的，只是我水平有限)，如果你将博客源文件放在了home目录中，那就意味着你只能用termux中的vim编辑器写博文了，这既不方便也不优雅。  </p>
<p>在此，我的建议是，将你的博客文件存到外部存储(一个容易被你手机/平板的文件管理器访问到的)中，然后做一个文件夹的软链接到你的home目录下，这样即能够使用你手机/平板上其他的app来编辑博文，又方便你在终端中用命令同步文件(软链接可以省去输入难以记住的路径信息)。  </p>
<p>具体操作如下:  </p>
<ul>
<li>开放存储访问权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install termux-tools <span class="comment"># 这是termux自带的管理工具</span></span><br><span class="line">$ termux-setup-storage <span class="comment"># 设置存储访问权限</span></span><br><span class="line"><span class="comment"># 这个时候手机应该会跳出一个权限确认弹窗，点击确定</span></span><br></pre></td></tr></table></figure>

<ul>
<li>链接一个合适的文件夹到home目录下  </li>
</ul>
<p>开放存储访问权限之后，你可以在home目录下发现一个新目录storage，如下:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># home目录下</span></span><br><span class="line">$ dir</span><br><span class="line">storage</span><br><span class="line">$ <span class="built_in">cd</span> storage <span class="comment"># storage目录里面是一些常用文件夹</span></span><br><span class="line">$ dir</span><br><span class="line">dcim       movies  pictures</span><br><span class="line">downloads  music   shared</span><br><span class="line">$ <span class="built_in">cd</span> shared <span class="comment"># shared文件夹里面就是你安卓设备能访问到的根目录(不严谨地说)</span></span><br><span class="line">$ dir</span><br><span class="line">ANRSnap        Alarms         </span><br><span class="line">Android        BaiduMapAuto   </span><br><span class="line">DCIM           Documents      </span><br><span class="line">Download       Fonts          </span><br><span class="line">Foxit          GDTDOWNLOAD    </span><br><span class="line">Huawei         HuaweiSystem   </span><br><span class="line">Movies         Music          </span><br><span class="line">Notifications  Pictures</span><br></pre></td></tr></table></figure>

<p>我个人是这样做的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shared目录下</span></span><br><span class="line">$ mkdir github <span class="comment"># 创建一个github文件夹，以后里面也可以clone其他项目</span></span><br><span class="line">$ <span class="built_in">cd</span> ˜ <span class="comment"># 回到home目录</span></span><br><span class="line">$ ln -s ˜/storage/shared/github github <span class="comment"># 将刚刚创建的文件夹链接到home目录下，方便以后访问</span></span><br><span class="line">$ <span class="built_in">cd</span> github</span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:yourname/yourname.github.io.git <span class="comment"># 做clone，具体不细讲，上一节有</span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ ln -s ˜/github/yourname.github.io hexo <span class="comment"># 链接博客目录</span></span><br><span class="line">$ ln -s ˜/hexo/<span class="built_in">source</span>/_posts <span class="comment"># 链接博客文章</span></span><br><span class="line"><span class="comment"># 这样，你的home目录下面应该有博客文章、github、博客三个快速访问链接</span></span><br><span class="line">$ ls</span><br><span class="line">blog  github  hexo  storage</span><br></pre></td></tr></table></figure>

<hr>
<p>到此所有的操作就结束了，如果各位发现我有写得不妥之处，欢迎指正！</p>
]]></content>
      <categories>
        <category>instructions</category>
      </categories>
      <tags>
        <tag>instructions</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>c# notes</title>
    <url>/2020/02/06/csharp-learing/</url>
    <content><![CDATA[<p>未完结,不定期更新</p>
<hr>
<p>源:<a href="https://www.runoob.com/csharp/csharp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-tutorial.html</a></p>
<h2 id="c-入门"><a href="#c-入门" class="headerlink" title="c#入门"></a>c#入门</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>特性:</p>
<blockquote>
<p>现代的、通用的编程语言<br>面向对象<br>面向组件<br>容易学习<br>结构化语言<br>它产生高效率的程序<br>它可以在多种计算机平台上编译<br>.Net 框架的一部分  </p>
</blockquote>
<p>重要功能:</p>
<blockquote>
<p>布尔条件（Boolean Conditions）<br>自动垃圾回收（Automatic Garbage Collection）<br>标准库（Standard Library）<br>组件版本（Assembly Versioning）<br>属性（Properties）和事件（Events）<br>委托（Delegates）和事件管理（Events Management）<br>易于使用的泛型（Generics）<br>索引器（Indexers）<br>条件编译（Conditional Compilation）<br>简单的多线程（Multithreading）<br>LINQ 和 Lambda 表达式<br>集成 Windows  </p>
</blockquote>
<p>.net框架:<br>.Net 框架是一个创新的平台，能帮您编写出下面类型的应用程序：</p>
<blockquote>
<p>Windows 应用程序<br>Web 应用程序<br>Web 服务  </p>
</blockquote>
<p>.Net 框架应用程序是多平台的应用程序。框架的设计方式使它适用于下列各种语言：C#、C++、Visual Basic、Jscript、COBOL 等等。所有这些语言可以访问框架，彼此之间也可以互相交互。</p>
<blockquote>
<p>.Net 框架由一个巨大的代码库组成，用于 C# 等客户端语言。下面列出一些 .Net 框架的组件：<br>公共语言运行库（Common Language Runtime - CLR）<br>.Net 框架类库（.Net Framework Class Library）<br>公共语言规范（Common Language Specification）<br>通用类型系统（Common Type System）<br>元数据（Metadata）和组件（Assemblies）<br>Windows 窗体（Windows Forms）<br>ASP.Net 和 ASP.Net AJAX<br>ADO.Net<br>Windows 工作流基础（Windows Workflow Foundation - WF）<br>Windows 显示基础（Windows Presentation Foundation）<br>Windows 通信基础（Windows Communication Foundation - WCF）<br>LINQ    </p>
</blockquote>
<a id="more"></a>

<h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;   <span class="comment">//使用名字空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorldApplication</span> <span class="comment">//一个名字空间</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="comment">//一个类</span></span><br><span class="line">   &#123;    <span class="comment">//类方法、类属性</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)   <span class="comment">//main方法</span></span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">         <span class="comment">/* 我的第一个 C# 程序*/</span></span><br><span class="line">         Console.WriteLine(<span class="string">"Hello World"</span>);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li>程序的第一行 using System; - using 关键字用于在程序中包含 System 命名空间。 一个程序一般有多个 using 语句。</li>
<li>下一行是 namespace 声明。一个 namespace 里包含了一系列的类。HelloWorldApplication 命名空间包含了类 HelloWorld。</li>
<li>下一行是 class 声明。类 HelloWorld 包含了程序使用的数据和方法声明。类一般包含多个方法。方法定义了类的行为。在这里，HelloWorld 类只有一个 Main 方法。</li>
<li>下一行定义了 Main 方法，是所有 C# 程序的 入口点。Main 方法说明当执行时 类将做什么动作。</li>
<li>下一行 /<em>…</em>/ 将会被编译器忽略，且它会在程序中添加额外的 注释。</li>
<li>Main 方法通过语句 Console.WriteLine(“Hello World”); 指定了它的行为。 </li>
<li>WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法。该语句会在屏幕上显示消息 “Hello, World!”。</li>
<li>最后一行 Console.ReadKey(); 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。  </li>
</ul>
<p>以下几点值得注意：</p>
<ul>
<li>C# 是大小写敏感的。</li>
<li>所有的语句和表达式必须以分号（;）结尾。</li>
<li>程序的执行从 Main 方法开始。</li>
<li>与 Java 不同的是，文件名可以不同于类的名称</li>
</ul>
<h3 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h3><h4 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h4><p>&lt;data_type&gt;?或Nullable&lt;data_type&gt;表示一个可空类型,其除了可以被data_type范围内的对象赋值之外还可以被赋值为null  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>? i = <span class="number">3</span> </span><br><span class="line">等同于</span><br><span class="line">Nullable&lt;<span class="keyword">int</span>&gt; i = <span class="keyword">new</span> Nullable&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">//默认值0</span></span><br><span class="line"><span class="keyword">int</span>? i; <span class="comment">//默认值null</span></span><br></pre></td></tr></table></figure>

<p>‘??’运算:Null合并运算符  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NullablesAtShow</span></span><br><span class="line">   &#123;</span><br><span class="line">         </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">double</span>? num1 = <span class="literal">null</span>;</span><br><span class="line">         <span class="keyword">double</span>? num2 = <span class="number">3.14157</span>;</span><br><span class="line">         <span class="keyword">double</span> num3;</span><br><span class="line">         num3 = num1 ?? <span class="number">5.34</span>;      <span class="comment">// num1 如果为空值则返回 5.34</span></span><br><span class="line">         Console.WriteLine(<span class="string">"num3 的值： &#123;0&#125;"</span>, num3);</span><br><span class="line">         num3 = num2 ?? <span class="number">5.34</span>;</span><br><span class="line">         Console.WriteLine(<span class="string">"num3 的值： &#123;0&#125;"</span>, num3);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>数据类型<a href="https://www.runoob.com/csharp/csharp-data-types.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-data-types.html</a><br>类型转换<a href="https://www.runoob.com/csharp/csharp-type-conversion.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-type-conversion.html</a><br>变量<a href="https://www.runoob.com/csharp/csharp-variables.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-variables.html</a><br>常量<a href="https://www.runoob.com/csharp/csharp-constants.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-constants.html</a><br>运算符<a href="https://www.runoob.com/csharp/csharp-operators.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-operators.html</a><br>数组<a href="https://www.runoob.com/csharp/csharp-array.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-array.html</a><br>字符串<a href="https://www.runoob.com/csharp/csharp-string.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-string.html</a><br>枚举<a href="https://www.runoob.com/csharp/csharp-enum.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-enum.html</a>   </p>
<p>名字空间<a href="https://www.runoob.com/csharp/csharp-namespace.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-namespace.html</a><br>预处理命令<a href="https://www.runoob.com/csharp/csharp-preprocessor-directives.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-preprocessor-directives.html</a><br>正则表达式<a href="https://www.runoob.com/csharp/csharp-regular-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-regular-expressions.html</a><br>异常处理<a href="https://www.runoob.com/csharp/csharp-exception-handling.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-exception-handling.html</a><br>文件操作<a href="https://www.runoob.com/csharp/csharp-file-io.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-file-io.html</a>  </p>
<h3 id="判断循环"><a href="#判断循环" class="headerlink" title="判断循环"></a>判断循环</h3><p>判断:  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">jiecheng</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">jiecheng</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Jc</span>(<span class="params"><span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">0</span> ? num *Jc(num - <span class="number">1</span>):<span class="number">1</span>;  <span class="comment">//如果num&gt;0则返回num *Jc(num - 1)，否则返回1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">excutejiecheng</span></span><br><span class="line">  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            jiecheng n = <span class="keyword">new</span> jiecheng();</span><br><span class="line">            <span class="keyword">int</span> result = n.Jc(Convert.ToInt16(Console.ReadLine()));</span><br><span class="line">            Console.WriteLine(<span class="string">"result is &#123;0&#125;"</span>,result);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环:  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Loops</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; )</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Hey! I am Trapped"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//成员变量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> length;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetArea</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"长度： &#123;0&#125;"</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">"宽度： &#123;0&#125;"</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">"面积： &#123;0&#125;"</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// Rectangle 结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">            r.length = <span class="number">4.5</span>;</span><br><span class="line">            r.width = <span class="number">3.5</span>;</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装<a href="https://www.runoob.com/csharp/csharp-encapsulation.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-encapsulation.html</a><br>方法<a href="https://www.runoob.com/csharp/csharp-methods.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-methods.html</a><br>结构体<a href="https://www.runoob.com/csharp/csharp-struct.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-struct.html</a><br>类<a href="https://www.runoob.com/csharp/csharp-class.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-class.html</a><br>继承<a href="https://www.runoob.com/csharp/csharp-inheritance.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-inheritance.html</a><br>多态<a href="https://www.runoob.com/csharp/csharp-polymorphism.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-polymorphism.html</a><br>重载运算符<a href="https://www.runoob.com/csharp/csharp-operator-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-operator-overloading.html</a><br>接口<a href="https://www.runoob.com/csharp/csharp-interface.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-interface.html</a></p>
<h2 id="关于NuGet"><a href="#关于NuGet" class="headerlink" title="关于NuGet"></a>关于NuGet</h2><p>参考<a href="https://www.cnblogs.com/nizhenghua/p/6422078.html" target="_blank" rel="noopener">https://www.cnblogs.com/nizhenghua/p/6422078.html</a><br>NuGet（读作New Get）是用于微软.NET开发平台的软件包管理器，是一个Visual Studio的扩展。在使用Visual Studio开发基于.NET Framework的应用时，NuGet能够令你在项目中添加、移除和更新引用的工作变得更加快捷方便。  </p>
<p>可以在VS中打开安装相应的包, 相当于pip之于python、npm之于nodejs</p>
<h2 id="WPF应用程序-程序和界面分离"><a href="#WPF应用程序-程序和界面分离" class="headerlink" title="WPF应用程序,程序和界面分离"></a>WPF应用程序,程序和界面分离</h2><p>参考<a href="https://www.cnblogs.com/zpfbuaa/p/5380352.html" target="_blank" rel="noopener">https://www.cnblogs.com/zpfbuaa/p/5380352.html</a></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>About the Blog</title>
    <url>/2020/02/06/about-the-blog/</url>
    <content><![CDATA[<h3 id="搭建参考"><a href="#搭建参考" class="headerlink" title="搭建参考"></a>搭建参考</h3><p>搭建：<a href="https://zhuanlan.zhihu.com/p/44213627" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44213627</a><br>主题使用：<a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank" rel="noopener">https://github.com/Shen-Yu/hexo-theme-ayer</a><br>分类设置：<a href="https://www.zhihu.com/question/29017171" target="_blank" rel="noopener">https://www.zhihu.com/question/29017171</a></p>
<a id="more"></a>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地运行博客</span></span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo server </span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署博客到github</span></span><br><span class="line">$ hexo clean    <span class="comment"># 可不加</span></span><br><span class="line">$ hexo generate <span class="comment"># hexo g</span></span><br><span class="line">$ hexo deploy   <span class="comment"># hexo d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新hexo分支</span></span><br><span class="line">$ git pull origin hexo  <span class="comment"># 同步博客</span></span><br><span class="line">$ git add .     <span class="comment"># .github.io目录下</span></span><br><span class="line">$ git commit -m <span class="string">"update hexo branch"</span> <span class="comment"># 带解释地提交</span></span><br><span class="line">$ git push      <span class="comment"># 默认分支为hexo, -f 进行强制覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建博文</span></span><br><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建菜单页</span></span><br><span class="line">$ hexo new page &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建草稿</span></span><br><span class="line">$ hexo new draft &lt;title&gt;</span><br><span class="line">$ hexo server --draft   <span class="comment"># 预览草稿</span></span><br><span class="line">$ hexo publish draft newpage    <span class="comment"># 发布草稿</span></span><br></pre></td></tr></table></figure>

<h3 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h3><p><a href="https://www.jianshu.com/p/ebe52d2d468f" target="_blank" rel="noopener">https://www.jianshu.com/p/ebe52d2d468f</a><br><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a></p>
]]></content>
      <categories>
        <category>instructions</category>
      </categories>
      <tags>
        <tag>instructions</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2000/02/28/hello-world/</url>
    <content><![CDATA[<p>欢迎来访！<br>本人初建博客，水平有限，请大家多谅解。</p>
<p><em>以下为原博文</em></p>
<hr>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
</search>
