<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据库原理与设计(高级篇)</title>
    <url>/2020/04/16/data-base1/</url>
    <content><![CDATA[<p>未完结,持续更新</p>
<hr>
<p>任课教师: 赵朋朋<a href="http://web.suda.edu.cn/ppzhao/" target="_blank" rel="noopener">http://web.suda.edu.cn/ppzhao/</a></p>
<p>网课资源: 慕课中国人民大学数据库系统概论<a href="https://www.icourse163.org/course/RUC-488001" target="_blank" rel="noopener">https://www.icourse163.org/course/RUC-488001</a></p>
<p>参考教材: 高等教育出版社《数据库系统概论(第5版)》</p>
<p>课程主要讲述关系型数据库的原理, 不着重于具体数据库的使用</p>
<p>在高级篇中,从管理系统的角度来介绍DBMS系统,用使用和应用的角度来讲解数据库设计的方法</p>
<p>数据库原理与设计(基础篇)见<a href="http://georgechen.top/2020/02/27/data-base0/" target="_blank" rel="noopener">http://georgechen.top/2020/02/27/data-base0/</a></p>
<h1 id="六、关系数据理论"><a href="#六、关系数据理论" class="headerlink" title="六、关系数据理论"></a>六、关系数据理论</h1><h2 id="6-1-关系数据理论的提出"><a href="#6-1-关系数据理论的提出" class="headerlink" title="6.1 关系数据理论的提出"></a>6.1 关系数据理论的提出</h2><p>需要解决的问题:怎么根据具体问题构造出一个合适的数据模式;即,什么是一个好的数据库逻辑设计</p>
<p>好的关系模式不会因为数据冗余而发生:</p>
<ul>
<li>存储空间浪费</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常<blockquote>
<p>因此,好的关系模式数据冗余应尽可能少(但较少的冗余度可能会降低增删改查时的效率)</p>
</blockquote>
</li>
</ul>
<p>问题的根源:数据依赖</p>
<h3 id="数据依赖"><a href="#数据依赖" class="headerlink" title="数据依赖"></a>数据依赖</h3><p>数据库中,数据依赖是完整性约束的一种表现形式,是数据库模式设计的关键</p>
<ul>
<li>限定属性的取值范围</li>
<li>定义属性间的相互关联(一般以相等关系体现)</li>
</ul>
<p>现实生活中,数据依赖是</p>
<ul>
<li>现实世界属性间相互联系的抽象</li>
<li>数据内在的性质</li>
<li>语义的体现</li>
</ul>
<p>数据依赖的类型</p>
<ul>
<li>函数依赖FD</li>
<li>多值依赖MVD</li>
<li>连接依赖</li>
<li>…</li>
</ul>
<p>不适合的数据依赖会造成插入、删除、更新异常和数据冗余问题</p>
<h3 id="关系模式的简化表示"><a href="#关系模式的简化表示" class="headerlink" title="关系模式的简化表示"></a>关系模式的简化表示</h3><p>$R&lt;U,F&gt;$是一个简化表示的关系模式</p>
<ul>
<li>$U$:关系的属性集合</li>
<li>$F$: 属性间数据依赖的关系集合<blockquote>
<p>当且仅当$U$上的一个关系r满足$F$时,r为关系模式$R$的一个关系</p>
</blockquote>
</li>
</ul>
<h2 id="6-2-规范化"><a href="#6-2-规范化" class="headerlink" title="6.2 规范化"></a>6.2 规范化</h2><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集.若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等;则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y。X称为这个函数依赖的决定属性组，也称为决定因素(Determinant)。</p>
<ul>
<li>Y依赖于X:X相等则Y相等</li>
<li>X确定了那么Y也确定了</li>
</ul>
<p>注意: </p>
<ul>
<li>函数依赖是语义范畴的概念,只能根据数据的语义来确定函数依赖,而不能根据数据的具体形式来反推可能的函数依赖</li>
<li>函数依赖确定后,所有的关系实例都要满足该约束条件<blockquote>
<p>当然,数据库设计者可以对现实世界做强制的规定来使得某两个属性产生函数依赖;如:不允许有学生重名,则学生的其他信息可以依赖于学生姓名</p>
</blockquote>
</li>
</ul>
<h4 id="平凡函数依赖和非平凡函数依赖"><a href="#平凡函数依赖和非平凡函数依赖" class="headerlink" title="平凡函数依赖和非平凡函数依赖"></a>平凡函数依赖和非平凡函数依赖</h4><ul>
<li>$X\to Y,Y\subseteq X,X\to Y$为非平凡函数依赖</li>
<li>$X\to Y,Y\not \subseteq X,X\to Y$为平凡函数依赖</li>
</ul>
<p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明， 我们总是讨论非平凡 函数依赖。</p>
<h4 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h4><ul>
<li>$X\to Y$,且对于任意的$X’ \subsetneq X,X \not \to Y$,则$X\to Y$为完全函数依赖,记作$X$-F-&gt;$Y$(Full)</li>
<li>非完全函数依赖记作$X$-P-&gt;$Y$(Part)<blockquote>
<p>注意,X是一个属性的集合</p>
</blockquote>
</li>
</ul>
<h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><ul>
<li>$X\to Y,Y \to Z 且 Y \not \subseteq X,Y \not \to X$时,称Z传递函数依赖于X,X传递(函数)确定Z,记作$X$-传递-&gt;$Z$<blockquote>
<p>注意,若$Y\to X$,则$Z$直接依赖于$X$</p>
</blockquote>
</li>
</ul>
<h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="*多值依赖"></a>*多值依赖</h3><p>函数依赖中X确定一个单值Y,但有时给定X的值x,它能确定多个Y的值;在插入x时,需要插入多条(x,y)元组才能符合这种依赖关系,而且这种依赖关系是隐式的,十分不方便.</p>
<h3 id="码"><a href="#码" class="headerlink" title="码"></a>码</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>候选码: $R&lt;U,F&gt;$中,$K \subset U,K$-F-&gt;$U$,则K为R的一个(候选)码</li>
<li>超码: 上述情况下$K$-P-&gt;$U$</li>
<li>主码: 若R有多个候选码,则选定其中一个作为主码</li>
<li>全码: 整个属性组都是码,称为全码(候选码为整个属性组)<blockquote>
<ul>
<li>候选码长度是超码长度的一个极小值,即候选码的任意一个真子集都不是候选码</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="主属性和非主属性"><a href="#主属性和非主属性" class="headerlink" title="主属性和非主属性"></a>主属性和非主属性</h4><ul>
<li>任意一个候选码中的任意一个属性都为主属性</li>
<li>不包含在任何码中的属性为非主属性(非码属性)</li>
</ul>
<h4 id="外码"><a href="#外码" class="headerlink" title="外码"></a>外码</h4><ul>
<li>$R&lt;U,F&gt;$中属性(组)$X$不是$R$的(候选)码,但$X$是另外一个关系模式的码,则称$X$是$R$的外部码</li>
</ul>
<p>主码与外码一起提供了表示关系间联系的手段</p>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>范式是符合某一种级别的关系模式的集合</p>
<p>关系数据库中的关系必须满足一定的要求,满足不同程度要求的为不同范式</p>
<p>范式种类(级别由低到高):</p>
<ul>
<li>第一范式1NF: 关系模式的最低要求</li>
<li>第二范式2NF: 消除非主属性对码的部分函数依赖</li>
<li>第三范式3NF: 消除非主属性对码的传递函数依赖</li>
<li>修正的第三范式BCNF: 消除主属性对码的部分和传递函数依赖</li>
<li>第四范式4NF: 消除非平凡且非函数依赖的多值依赖</li>
<li>第五范式5NF: 消除非候选码所蕴含的连接依赖<blockquote>
<ul>
<li>低级别的范式一定包含高级别的范式</li>
<li>某一关系模式R为第n范式,记为$R \in nNF$</li>
</ul>
</blockquote>
</li>
</ul>
<p>一个低一级范式的关系模式,通过模式分解可以转化成若干个高一级范式的关系模式的集合,这种过程叫做规范化</p>
<p>关系数据库的规范化理论是数据库逻辑设计的工具</p>
<h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>如果一个关系模式$R$的所有属性都是不可分的基本数据项,则$R\in 1NF$</p>
<ul>
<li>即,不能表中嵌表</li>
<li>所有的关系数据库模式都满足第一范式,第一范式是对关系模式的最起码的要求;不满足第一范式的数据库模式不能称为关系数据模式</li>
</ul>
<p>然而,满足第一范式的关系模式不一定是一个好的关系模式</p>
<h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>若关系模式$R \in 1NF$,且每一个非主属性都完全依赖于$R$的码,则$R \in 2NF$</p>
<ul>
<li>即,$R$中码的任何一部分都不能单独决定一些属性,这些属性必须由整个码来确定<blockquote>
<p>能够单独决定一些属性的码需要被独立成另外的关系</p>
</blockquote>
</li>
<li>不符合第二范式的关系模式会产生问题<blockquote>
<ul>
<li>插入异常: 数据库不能插入一些只包含部分合理信息的元组(码的其他部分也得被确定下来)</li>
<li>删除异常: 数据库有时不能将元组的部分信息合理删除(这些信息可能包含码的部分)</li>
<li>数据冗余</li>
<li>修改复杂: 修改元组部分信息时,表中其他元组的部分信息也得被修改(数据冗余造成的)<br>根本原因: 一些属性部分依赖于码</li>
</ul>
</blockquote>
</li>
<li>解决上述问题的方法: 投影分解法,消除部分依赖,使得关系符合第二范式</li>
</ul>
<p>但是,第二范式并不能完全消除关系模式中异常情况和修改复杂、数据冗余情况,因为有传递函数依赖的存在</p>
<h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>若关系模式$R \in 1NF$,且不存在这样的码$X$、属性<strong>组</strong>$Y$以及非主属性$Z(Z\not \subset Y)$,使得$X\to Y,Y \to Z,Y \not \to X$成立($Z$不传递依赖于X),则$R \in 2NF$</p>
<ul>
<li>传递函数依赖的存在使得一些信息被”隐式”地存储在表中,需要将它们独立成另外的关系</li>
</ul>
<p>性质:</p>
<ul>
<li>第三范式关系中的每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码</li>
<li>若R属于第三范式,那么R必定属于第二范式</li>
<li>采用投影分解法能将一个第二范式关系分解成多个第三范式关系</li>
</ul>
<p>然而,第三范式还是不能完全消除关系模式中的各种异常情况和数据冗余,因为主属性之间也会存在依赖</p>
<h4 id="修正的第三范式-BCNF"><a href="#修正的第三范式-BCNF" class="headerlink" title="修正的第三范式(BCNF)"></a>修正的第三范式(BCNF)</h4><p>若关系模式$R \in 1NF$,且对$R$中每个函数依赖$X\to Y 且 Y\not \in X时$,X必含有码,则$R \in 2NF$</p>
<p>性质:</p>
<ul>
<li>所有非主属性对每一个码都是完全函数依赖</li>
<li>所有主属性对每一个不包含它的码都是完全函数依赖</li>
<li>没有任何属性完全函数依赖于一些非码属性(不存在传递函数依赖)</li>
<li>符合BCNF的范式一定符合3NF,反之不然<blockquote>
<p>BCNF在函数依赖范畴内已经实现了模式的彻底分解,达到了最高的规范化程度,消除了操作异常的诸多问题</p>
</blockquote>
</li>
</ul>
<h2 id="6-3-数据依赖的公理系统"><a href="#6-3-数据依赖的公理系统" class="headerlink" title="6.3 数据依赖的公理系统"></a>6.3 数据依赖的公理系统</h2><p>数据依赖的公理系统式模式分解算法的理论基础</p>
<p>Armstrong公理系统式函数依赖的一个有效而完备的公理系统</p>
<h3 id="Armstrong公理系统"><a href="#Armstrong公理系统" class="headerlink" title="Armstrong公理系统"></a>Armstrong公理系统</h3><p>Armstrong公理系统是一套推理规则,用于回答某个函数依赖是否被某组函数依赖F蕴含</p>
<ul>
<li>有效性: 由F出发根据Armstrong公理推导出的每一个函数依赖一定在$F^+$中</li>
<li>完备性: $F^+$中的每一个函数依赖必定可以由Armstrong公理推导出来</li>
</ul>
<h3 id="逻辑蕴涵的定义"><a href="#逻辑蕴涵的定义" class="headerlink" title="逻辑蕴涵的定义"></a>逻辑蕴涵的定义</h3><p>对于满足一组函数依赖F的关系模式$R(U,F)$,对符合它的任意关系r,若都有函数依赖$X\to Y$成立,则称F(逻辑)蕴涵$X\to Y$</p>
<h3 id="几个导出的推理规则"><a href="#几个导出的推理规则" class="headerlink" title="几个导出的推理规则"></a>几个导出的推理规则</h3><p>设U为属性集总体, F是U上的一组函数依赖, 对关系$R&lt;U,F&gt;$ 来说, 有以下的推理规则: </p>
<ul>
<li>自反律: 若$Y \subseteq X \subseteq U$,则F蕴含$X\to Y$</li>
<li>增广律: 若F蕴含$X\to Y$且$Z\subseteq U$,则F蕴含$XZ\to YZ$</li>
<li>传递律: 若F蕴含$X\to Y和Y\to Z$,则F蕴含$X\to Z$</li>
</ul>
<p>上述三个推理规则可以进一步得到以下几个推理规则:</p>
<ul>
<li>合并规则: 由$X\to Y,X\to Z$,可以得到$X\to YZ$</li>
<li>伪传递规则: 由$X\to Y,YW\to Z$,可以得到$XW\to Z$</li>
<li>分解规则: 由$X\to Y,Z \subseteq Y$,可以得到$X\to Z$</li>
</ul>
<p>根据合并规则和分解规则可以得到下述重要引理:</p>
<ul>
<li>$X\to A_1A_2…A_n$成立的充要条件是$X\to A_i(i=1,2,…n)$</li>
</ul>
<h3 id="函数依赖闭包"><a href="#函数依赖闭包" class="headerlink" title="函数依赖闭包"></a>函数依赖闭包</h3><h4 id="定义和一些引理"><a href="#定义和一些引理" class="headerlink" title="定义和一些引理"></a>定义和一些引理</h4><ul>
<li>在关系模式$R&lt;U,F&gt;$中被F所蕴含的函数依赖的全体称为F的闭包,记作$F^+$</li>
<li>设F为属性集U上的一组函数依赖,$X\subseteq U$,$X_{F^+} = \lbrace A | X\to A能由F根据Armstrong公理导出 \rbrace$,称为属性集X关于函数依赖集F的闭包<blockquote>
<ul>
<li>$X_{F^+}$表示属性组X能根据F推导出的所有属性</li>
<li>$F^+$不容易直接求出,在考虑某函数依赖是否在$F^+$中时,需要转化成对$X_{F^+}$的判定</li>
</ul>
</blockquote>
</li>
</ul>
<p>关于闭包的引理</p>
<ul>
<li>F为属性集U上的一组函数依赖,X Y为U上的两个属性组;$X\to Y$能由F根据Armstrong公理导出的充要条件是$Y\subseteq X_{F^+}$<blockquote>
<ul>
<li>判断$X\to Y$是否在$F^+$中,只需判断Y是否是$X_{F^+}$的子集</li>
<li>若$X_{F^+}=U$,则X为R的候选码</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="求-X-F-的算法"><a href="#求-X-F-的算法" class="headerlink" title="求$X_{F^+}$的算法"></a>求$X_{F^+}$的算法</h4><p>遵循如下迭代算法求取$X_{F^+}$:</p>
<ol>
<li>令$X_{add} = \emptyset$</li>
<li>扫描F,将能根据X或部分X推导出的元素加入$X_{add}$</li>
<li>$X = X \cup X_{add}$</li>
<li>若X并没有改变,则得到结果$X_{F^+}$,否则转1.</li>
</ol>
<h3 id="函数依赖集的一些性质"><a href="#函数依赖集的一些性质" class="headerlink" title="函数依赖集的一些性质"></a>函数依赖集的一些性质</h3><h4 id="函数依赖集的等价"><a href="#函数依赖集的等价" class="headerlink" title="函数依赖集的等价"></a>函数依赖集的等价</h4><p>两个函数依赖集$F$和$G$,若$F^+=G^+$,则$F$与$G$等价(F覆盖G,F是G的覆盖或反之)</p>
<ul>
<li>函数依赖集的等价是指它们的闭包等价</li>
</ul>
<h4 id="最小-极小-依赖集"><a href="#最小-极小-依赖集" class="headerlink" title="最小(极小)依赖集"></a>最小(极小)依赖集</h4><p>满足下列条件的依赖集F称为一个最小依赖集</p>
<ul>
<li>F中任意一个函数依赖的右边只含有一个属性</li>
<li>F中的每个函数依赖的左边均为最小属性集<blockquote>
<p>若存在一个函数依赖$X\to A$,使得去掉这条依赖中X的部分属性,得到的函数依赖集F’与F等价,则原F不是最小依赖集</p>
</blockquote>
</li>
<li>F中的每个函数依赖均不能由F中其他的函数依赖导出</li>
</ul>
<h4 id="求最小依赖集的算法"><a href="#求最小依赖集的算法" class="headerlink" title="求最小依赖集的算法"></a>求最小依赖集的算法</h4><ol>
<li>扫描F中的函数依赖,将所有依赖项的右边拆分成单属性</li>
<li>扫描每个函数依赖的左边,去除左边冗余的属性</li>
<li>去掉F中冗余的函数依赖关系</li>
</ol>
<ul>
<li>F的最小依赖集不是唯一的</li>
</ul>
<h2 id="6-4-模式的分解"><a href="#6-4-模式的分解" class="headerlink" title="6.4 模式的分解"></a>6.4 模式的分解</h2><p>关系模式的规范化是通过模式分解来实现的</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>投影:</p>
<ul>
<li>$F_i = \lbrace X\to Y | X\to Y \in F^+ , XY \subseteq U_i \rbrace$ 称为$F$在$U_i$上的投影</li>
</ul>
<p>关系模式的分解:</p>
<ul>
<li>$R&lt;U,F&gt;的一个分解为$\rho = \lbrace R_1&lt;U_1,F_1&gt;,…,R_n&lt;U_n,F_n&gt;\rbrace$,其中$U = U_1\cup … U_n$, 且不存在$U_i\subseteq U_j$</li>
</ul>
<p>模式分解主要涉及到投影和自然连接两个运算</p>
<h3 id="模式分解的三个目标"><a href="#模式分解的三个目标" class="headerlink" title="模式分解的三个目标"></a>模式分解的三个目标</h3><p>一个模式有多种分解方法,符合一些要求的分解方法才有意义</p>
<ul>
<li><p>无损连接分解: 将分解后的多个模式进行自然连接,结果应和原模式一样</p>
</li>
<li><p>保持函数依赖: 分解前F的最小依赖集中的每个函数依赖都应该被投影到分解后的某个关系模式中去</p>
<blockquote>
<p>即:$F^+ = (F_1\cup … \cup F_n)^+</p>
</blockquote>
</li>
<li><p>达到更高级范式: 分解得到的每个关系模式应该相比于分解前的关系模式达到更高级别的范式</p>
</li>
</ul>
<h3 id="模式分解算法"><a href="#模式分解算法" class="headerlink" title="模式分解算法"></a>模式分解算法</h3><h4 id="达到BCNF并保持无损连接的算法"><a href="#达到BCNF并保持无损连接的算法" class="headerlink" title="达到BCNF并保持无损连接的算法"></a>达到BCNF并保持无损连接的算法</h4><ol>
<li>令$\rho = \lbrace R&lt;U,F&gt; \rbrace$</li>
<li>检查$\rho$中各关系模式是否属于BCNF,若是则返回结果</li>
<li>发现有$R_i&lt;U_i,F_i&gt;$不是BCNF,即有$X\to A$在$F_i^+$中且X不包含$R_i$的码,则将$X\to A$单独从$R_i$中分出来,指定X为新模式的码,将新模式加入$\rho$中(原$R_i$中不再有$X\to A$),转2.</li>
</ol>
<blockquote>
<p>这种分解方法能达到BCNF,但不一定保持原有的函数依赖</p>
</blockquote>
<h4 id="达到3NF并保持函数依赖的算法"><a href="#达到3NF并保持函数依赖的算法" class="headerlink" title="达到3NF并保持函数依赖的算法"></a>达到3NF并保持函数依赖的算法</h4><ol>
<li>求出$F$的最小覆盖$F_m$</li>
<li>找出不在$F_m$中出现的属性,将它们从U中分离出来构成一个新的关系模式(这个关系模式的码是全码)</li>
<li>若有$X\to A \in F_m$ ，且XA=U，则$\rho$={R}，算法终止</li>
<li>对FC按具有相同左部的原则进行分组（设为k组），每一组函数依赖所涉及的属性全体为Ui，令$F_i$为$F_m$在$U_i$上的投影，则$\rho$ = {R1&lt;U1 ,F1&gt; ,… , Rk&lt;Uk , Fk&gt;}是R&lt;U , F&gt;的一个保持函数依赖的分解，并且每个Ri&lt;Ui , Fi&gt; $\in$ 3NF</li>
</ol>
<blockquote>
<p>这种分解算法可能有损</p>
</blockquote>
<h4 id="达到3NF并保持无损分解和函数依赖的算法"><a href="#达到3NF并保持无损分解和函数依赖的算法" class="headerlink" title="达到3NF并保持无损分解和函数依赖的算法"></a>达到3NF并保持无损分解和函数依赖的算法</h4><p>在上一个算法后继续进行操作</p>
<ol start="5">
<li>考虑R的码X,若X在某个$U_i$中,则无需进行操作,否则需要将{&lt;X,$F_X$&gt;}加入到$\rho$中</li>
</ol>
<blockquote>
<p>这种分解算法不一定能达到BCNF</p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Unithon 项目计划书模板</title>
    <url>/2020/04/12/Unithon%20%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92%E4%B9%A6%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="一-团队信息"><a href="#一-团队信息" class="headerlink" title="一. 团队信息"></a>一. 团队信息</h2><ol>
<li><p>团队名称：</p>
<p>坐等全境封锁免费小队</p>
</li>
<li><p>成员信息：</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="left">学校</th>
<th align="left">专业</th>
<th align="left">年级</th>
<th align="left">邮箱</th>
<th align="left">QQ号</th>
<th align="left">项目分工</th>
</tr>
</thead>
<tbody><tr>
<td align="left">陈孜卓</td>
<td align="left">苏州大学</td>
<td align="left">计算机科学与技术</td>
<td align="left">二年级</td>
<td align="left"><a href="mailto:3528537606@qq.com">3528537606@qq.com</a></td>
<td align="left">3528537606</td>
<td align="left">构建、训练模型</td>
</tr>
<tr>
<td align="left">王沛月</td>
<td align="left">苏州大学</td>
<td align="left">计算机科学与技术</td>
<td align="left">二年级</td>
<td align="left"><a href="mailto:1138411450@qq.com">1138411450@qq.com</a></td>
<td align="left">1138411450</td>
<td align="left">构建、训练模型</td>
</tr>
<tr>
<td align="left">丁楚瑶</td>
<td align="left">苏州大学</td>
<td align="left">计算机科学与技术</td>
<td align="left">二年级</td>
<td align="left"><a href="mailto:1623030229@qq.com">1623030229@qq.com</a></td>
<td align="left">1623030229</td>
<td align="left">编写爬虫框架</td>
</tr>
<tr>
<td align="left">徐镇宇</td>
<td align="left">苏州大学</td>
<td align="left">国际金融</td>
<td align="left">三年级</td>
<td align="left"><a href="mailto:andrew.xu@foxmail.com">andrew.xu@foxmail.com</a></td>
<td align="left">565143480</td>
<td align="left">编写web界面</td>
</tr>
<tr>
<td align="left">张逸康</td>
<td align="left">苏州大学</td>
<td align="left">计算机科学与技术</td>
<td align="left">二年级</td>
<td align="left"><a href="mailto:zyk0126@126.com">zyk0126@126.com</a></td>
<td align="left">1976497294</td>
<td align="left">收集资料、统筹进度、评估软件</td>
</tr>
</tbody></table>
</li>
<li><p>是否需要使用 Azure 虚拟机资源？</p>
<ul>
<li>是</li>
</ul>
<p>如果需要的话，更倾向于使用 Windows Server 还是 Linux Server ?</p>
<ul>
<li>Windows Server</li>
</ul>
</li>
</ol>
<h2 id="二-项目信息"><a href="#二-项目信息" class="headerlink" title="二. 项目信息"></a>二. 项目信息</h2><ol>
<li><p>项目名称</p>
<ul>
<li>基于深度学习和信息提取的疫情热点分析平台</li>
</ul>
</li>
<li><p>项目概要</p>
<ul>
<li>随着近一段时间复工复产的进行，大家普遍更加关心新冠疫情的发展。然而每天网络上产生的海量新闻数据，加上各种谣言的传播，使得人们需要花费大量的时间来筛选、综合信息，以对近期疫情发展有一个正确全面的认识。我们团队通过深度学习和信息提取的方式，对主流媒体的疫情报道进行分析、综合，以热点话题、热点人物事件关系网的方式将疫情态势展示给用户，使得用户能在短时间内高效地获取疫情新闻资讯，将更多的精力放在工作和事务上。</li>
</ul>
</li>
<li><p>计划书</p>
<ul>
<li><p>项目构思</p>
<ul>
<li><p>项目想法产生的初衷;</p>
<ul>
<li>大家对疫情发展的认识主要来源于疫情新闻和疫情动态上。然而我们发现，即使花费很长的时间去不同的网站上获取新闻、阅读评论，能够获取的重要讯息通常也就只有那么几条；我们大部分的时间被浪费在了阅读重复的信息和鉴别信息的真假之上。因此，在疫情中，如何给大众高效地提供重要、准确的信息是非常重要的。</li>
</ul>
</li>
<li><p>想解决什么样的问题;</p>
<ol>
<li>提供给大众整合过后的信息，促使大众能够高效地对于近期发生的疫情事件，对疫情热点人物有一个全面的、客观的了解。</li>
<li>综合分析不同媒体对同一事件的报道，使得用户能够辨认出错误、片面的信息。</li>
<li>提高信息的整合度，提高用户的新闻应用体验</li>
</ol>
</li>
<li><p>项目的受益群体;</p>
<ul>
<li>关注疫情的群众。</li>
</ul>
</li>
</ul>
</li>
<li><p>实施初步调研</p>
<ul>
<li><p>项目实施中可能存在哪些难点;</p>
<ol>
<li>相关新闻数据的获得</li>
<li>文本的分析，包括新闻事件的关键词提取、聚类，事件主体、人物的识别，新闻情感取向的分析等</li>
<li>数据的整理，包括根据主题进行新闻分类、根据人物和事件构建关系网络等</li>
<li>分析结果的展示</li>
</ol>
<p>对于上述问题，我们的主要策略如下： </p>
<ol>
<li>对新闻数据的获得，我们选择通过爬虫定期对人民网、新华网等主流媒体以及国外媒体的疫情板块进行爬取，获得新闻数据</li>
<li>对新闻文本的分析，我们的处理主要集中在以下几个方面：<ul>
<li>文本关键词提取：使用TextRank对文本的关键词进行提取</li>
<li>事件主体、人物的识别：使用深度学习对文本命名实体进行识别，我们选择使用BiLSTM+CRF模型来构建神经网络，使用开源的语料库来训练模型</li>
<li>文本聚类：基于文本相似度计算对文本进行聚类</li>
<li>文本情感取向分析：使用深度学习对文本的情感取向进行预测，我们选择使用BERT预训练模型来构建神经网络，使用开源的语料库来训练模型</li>
</ul>
</li>
<li>对于数据的整理，我们根据文本关键词对新闻主题进行分类；结合命名实体识别结果和文本聚类结果来构建人物和事件关系网络  </li>
<li>我们使用python语言来获取、分析、整理数据，使用JavaScript生成网页来展示分析结果<br>我们的网页应包括如下几个部分：  <ul>
<li>按热度从高到低的次序向用户展示近期的疫情话题</li>
<li>每个疫情话题中展示不同媒体对相关事件的新闻报道，并标注出各新闻的情感取向</li>
<li>展示一个以近期重点人物和关键事件为中心的疫情关系网络  </li>
</ul>
</li>
</ol>
</li>
<li><p>你会采用什么招数, 特别是独特的招数, 来解决用户的痛苦,  特别是和 AI 相关的手段; </p>
<ul>
<li>用户在阅读海量的新闻时，常会遇到以下两个问题：  </li>
</ul>
<ol>
<li>用户获取的信息是松散的：新闻通常按时间顺序排序，上一篇阅读的新闻事件通常和下一篇阅读的新闻事件没有内在的联系；即使能够获取某一方面的新闻，也需要用户进入到专题板块或者通过搜索得到</li>
<li>用户获取的信息是片面的：不同的新闻媒体，特别是国外的媒体，对于同一个事件报道的侧重点是不同的，导致用户有时很难在第一时间对整个事件有一个全面的了解</li>
</ol>
<ul>
<li>我们使用深度学习技术结合关键词提取、文本聚类的方式，从话题、人物事件两个方面将一段时间内发生的新闻事件进行筛选、分类；同时使用深度学习技术对新闻的情感取向进行标注；使得用户一方面能在较短的时间内了解近期发生的重点事件，另一方面也能对某一个热点话题的内容进行多角度、全方面的了解</li>
</ul>
</li>
<li><p>你会借鉴哪些数据或者工具去帮助你的项目的实施;</p>
<ul>
<li>语言及工具使用：</li>
</ul>
<ol>
<li>python：用于编写数据获取、分析、整理的相关代码，使用包括keras，nltk，jieba等自然语言处理工具</li>
<li>JavaScript：用于生成一个向用户展示数据的网页</li>
</ol>
<ul>
<li>数据使用：</li>
</ul>
<ol>
<li>人民网、新华网等主流媒体以及国外媒体的相关疫情报道数据</li>
<li>BERT预训练模型以及nltk工具内的相关语料库资源</li>
</ol>
</li>
</ul>
</li>
<li><p>项目交付</p>
<ul>
<li><p>项目最终以何种形式呈现;</p>
<ul>
<li>项目最终以可互动的web网页形式呈现</li>
</ul>
</li>
<li><p>通过怎样的数据指标来衡量项目效果;</p>
<ul>
<li>项目的总体效果由各子模型在相应任务上的准确率、召回率与F1-Measure来综合衡量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>sql使用</title>
    <url>/2020/04/11/mysql0/</url>
    <content><![CDATA[<p>mysql的使用大全可以参考<a href="http://c.biancheng.net/view/2433.html" target="_blank" rel="noopener">http://c.biancheng.net/view/2433.html</a></p>
<p>本文根据笔记<a href="http://georgechen.top/2020/02/27/data-base0/" target="_blank" rel="noopener">http://georgechen.top/2020/02/27/data-base0/</a>精简整理,保留常用语句用法</p>
<a id="more"></a>

<h2 id="1-入手"><a href="#1-入手" class="headerlink" title="1. 入手"></a>1. 入手</h2><h3 id="建立用户账户及更改权限"><a href="#建立用户账户及更改权限" class="headerlink" title="建立用户账户及更改权限"></a>建立用户账户及更改权限</h3><p><code>GRANT ALL ON DataBaseA.* TO &#39;root&#39;@&#39;localhost&#39;;</code></p>
<h3 id="创建数据库及表"><a href="#创建数据库及表" class="headerlink" title="创建数据库及表"></a>创建数据库及表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database school;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use school;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>

<p>mysql数据存储位置:</p>
<ul>
<li>这个位置文件的路径在my.ini中datadir中可以找到  </li>
<li>一般情况下,my.ini在mysql安装目录下(例如C:\ProgramData\MySQL\MySQL Server 8.0)</li>
</ul>
<h2 id="2-数据定义"><a href="#2-数据定义" class="headerlink" title="2. 数据定义"></a>2. 数据定义</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>为某人创建某名的模式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</span><br><span class="line">[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;权限定义子句&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>若没有指定模式名,则模式名隐含为用户名</li>
</ul>
<p>删除某模式:<code>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</code><br>删除选项:</p>
<blockquote>
<ul>
<li>CASADE 级联: 删除模式同时将该模式下的所有数据库对象删除</li>
<li>RESTRICT 限制: 仅当该模式中没有任何下属对象时才能执行, 如果这个模式下有表/视图等定义,则拒绝执行语句</li>
</ul>
</blockquote>
<h3 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h3><h4 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="comment">/* 基本表的名称 */</span> </span><br><span class="line">(&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] <span class="comment">/*组成该表的列*/</span> </span><br><span class="line">[,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] </span><br><span class="line">… </span><br><span class="line">[,&lt;表级完整性约束条件&gt; ] );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>&lt;列级完整性约束条件&gt;: 涉及仅单个属性列的完整性约束条件 </p>
</li>
<li><p>&lt;表级完整性约束条件&gt;: 涉及一个或多个属性列的完整性约束条件 </p>
</li>
<li><p>&lt;表名&gt;:每一个基本表需属于某个模式,可以显式地在表名中给出,也可以在搜索路径中设置 </p>
<blockquote>
<p>设置搜索路径(默认模式):<code>SET search_path TO &lt;模式名&gt;,PUBLIC;</code></p>
</blockquote>
</li>
<li><p>&lt;数据类型&gt;: 有如下数据类型</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">含义</th>
<th align="left">数据类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR(n)</td>
<td align="left">n位定长字符串</td>
<td align="left">CHARACTER(n)</td>
<td align="left">同CHAR(n)</td>
</tr>
<tr>
<td align="left">VRCHAR(n)</td>
<td align="left">最大长度为n的变长字符串</td>
<td align="left">VRCHARACTER(n)</td>
<td align="left">同VRCHAR(n)</td>
</tr>
<tr>
<td align="left">CLOB</td>
<td align="left">字符串大对象</td>
<td align="left">BLOB</td>
<td align="left">二进制大对象</td>
</tr>
<tr>
<td align="left">INT</td>
<td align="left">长整数(4字节)</td>
<td align="left">INTEGER</td>
<td align="left">同INT</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">大整数(8字节)</td>
<td align="left">SMALLINT</td>
<td align="left">短整数(2字节)</td>
</tr>
<tr>
<td align="left">DEC(p,d)</td>
<td align="left">精度为d的p位定点数</td>
<td align="left">DECIMAL(p,d),NUMERIC(p,d)</td>
<td align="left">同DEC(p,d)</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">单精度浮点数</td>
<td align="left">DOUBLE PRECISION</td>
<td align="left">双精度浮点数</td>
</tr>
<tr>
<td align="left">FLOAT(n)</td>
<td align="left">精度为n的浮点数</td>
<td align="left">BOOLEAN</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">格式为YYYY-MM-DD的日期</td>
<td align="left">TIME</td>
<td align="left">格式为HH:MM:SS的时间</td>
</tr>
<tr>
<td align="left">TIMESTAP</td>
<td align="left">时间戳类型</td>
<td align="left">INTERVAL</td>
<td align="left">时间间隔类型</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</span><br><span class="line">[<span class="keyword">ADD</span> &lt;表级完整性约束&gt;] <span class="comment">/*完整性约束只能添加表级完整性约束*/</span></span><br><span class="line">[<span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] &lt;列名&gt; [<span class="keyword">CASCADE</span>| RESTRICT] ]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>&lt;完整性约束名&gt;[ RESTRICT | <span class="keyword">CASCADE</span> ] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> &lt;列名&gt;&lt;数据类型&gt; ] ;</span><br></pre></td></tr></table></figure>
<ul>
<li>ADD COLUMN: 增加列</li>
<li>DROP COLUMN: 删除列<blockquote>
<ul>
<li>级联: 删除该列及引用该列的其他对象</li>
<li>限制: 如果该列被其他对象引用,则拒绝删除</li>
</ul>
</blockquote>
</li>
<li>ALTER COLUMN:修改列,也可以用以下两种方法<blockquote>
<ul>
<li><code>MODIFY &lt;列名&gt; &lt;数据类型&gt;</code>:修改列的数据类型</li>
<li><code>CHANGE &lt;列名&gt; &lt;新列名&gt; &lt;新数据类型&gt;</code>:修改列名</li>
</ul>
</blockquote>
</li>
<li>RENAME TO &lt;新表名&gt;:改个新表名</li>
</ul>
<h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;［RESTRICT| <span class="keyword">CASCADE</span>］;</span><br></pre></td></tr></table></figure>
<ul>
<li>级联:在删除基本表的同时，相关的依赖对象一起删除</li>
<li>限制:如果存在依赖该表的对象(该表被其他表引用),则拒绝删除</li>
</ul>
<h3 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h3><p>建立索引目的: 加快查询速度</p>
<ul>
<li>常见索引:顺序索引,B+树索引,散列索引,位图索引</li>
<li>索引由数据库管理员或建表者建立</li>
<li>索引由关系数据库系统自动完成维护</li>
</ul>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] <span class="keyword">INDEX</span> &lt;索引名&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);</span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;表名&gt;：要建索引的基本表的名字  </li>
<li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔  </li>
<li>&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省 值：ASC  </li>
<li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录  </li>
<li>CLUSTER：表示要建立的索引是聚簇索引</li>
</ul>
<h4 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h4><p><code>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索 引名&gt;;</code></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><code>DROP INDEX &lt;索引名&gt;;</code><br>删除索引时，系统会从数据字典中删去有关该索引的描述</p>
<h2 id="3-数据完整性约束"><a href="#3-数据完整性约束" class="headerlink" title="3. 数据完整性约束"></a>3. 数据完整性约束</h2><p>数据库的完整性包括以下两个方面:</p>
<ul>
<li>数据的正确性(实体完整性等)</li>
<li>数据的相容性(参照完整性)</li>
</ul>
<p>在2.中定义和修改表时需要用到数据库完整性约束</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><h4 id="实体完整性定义"><a href="#实体完整性定义" class="headerlink" title="实体完整性定义"></a>实体完整性定义</h4><p>关系模型的实体完整性用主码PRIMARY KEY描述</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;列名&gt; ... PRIMARY KEY /* 列级完整性约束 */</span><br><span class="line">PRIMARY KEY(&lt;列名&gt;[,&lt;列名&gt;,...]) /* 表级完整性约束 */</span><br></pre></td></tr></table></figure>
<ul>
<li>列级完整性约束可以定义单属性构成的码</li>
<li>表级完整性约束可以定义单个或多个属性构成的码</li>
</ul>
<p>违约处理:拒绝插入或更新</p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><h4 id="参照完整性定义"><a href="#参照完整性定义" class="headerlink" title="参照完整性定义"></a>参照完整性定义</h4><ul>
<li>定义表中的外码,以及被参照关系的主码<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列级完整性约束 */</span></span><br><span class="line">&lt;外码列名&gt; ... FOREIGN KEY REFERENCES DEPT(&lt;被参考关系主码&gt;) [ON DELETE|UPDATE CASCADE|NO ACTION|SET-NULL]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表级完整性约束 */</span></span><br><span class="line">FOREIGN KEY(&lt;外码列名&gt;) REFERENCES DEPT(&lt;被参考关系主码&gt;) [ON DELETE|UPDATE CASCADE|NO ACTION|SET-NULL]</span><br></pre></td></tr></table></figure></li>
<li>对于参照表的元组插入或外码值修改,违约即拒绝执行</li>
<li>对于被参照表的元组删除或主码值修改,有三种违约处理方式:<blockquote>
<ul>
<li>拒绝执行:不执行语句</li>
<li>级联操作:将参照表中有关联的元组删除或进行外码修改</li>
<li>设置空值:将参照表中有关联的元组外码置为空值,这可能会导致参照表中的元组违反实体完整性约束</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="用户定义完整性约束"><a href="#用户定义完整性约束" class="headerlink" title="用户定义完整性约束"></a>用户定义完整性约束</h3><h4 id="用户完整性约束定义"><a href="#用户完整性约束定义" class="headerlink" title="用户完整性约束定义"></a>用户完整性约束定义</h4><p>列级完整性约束定义(属性约束条件)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;列名&gt; ... [UNIQUE] [NOT NULL] [CHECK(expr)]</span><br></pre></td></tr></table></figure>
<ul>
<li>NOT NULL:列值非空</li>
<li>UNIQUE:列值唯一(相当于主码)</li>
<li>CHECK(expr):列值满足某表达式</li>
</ul>
<p>表级完整性约束定义(元组约束条件):用于设置不同属性之间的取值的相互约束条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHECK(expr)</span><br></pre></td></tr></table></figure>

<p>违约处理:拒绝执行</p>
<h3 id="完整性约束命名字句"><a href="#完整性约束命名字句" class="headerlink" title="完整性约束命名字句"></a>完整性约束命名字句</h3><h4 id="完整性约束命名子句定义"><a href="#完整性约束命名子句定义" class="headerlink" title="完整性约束命名子句定义"></a>完整性约束命名子句定义</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">CONSTANT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</span><br></pre></td></tr></table></figure>
<p>该子句可以作为列级完整性约束或表级完整性约束使用</p>
<h4 id="完整性约束子句的删除和添加"><a href="#完整性约束子句的删除和添加" class="headerlink" title="完整性约束子句的删除和添加"></a>完整性约束子句的删除和添加</h4><p>用ALTER TABLE对约束条件进行删除和添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTANT</span> &lt;完整性约束条件名&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTANT</span> &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现完整性约束子句的修改时,需要先删除约束,再添加约束,如上所示</li>
</ul>
<h3 id="域中的完整性限制"><a href="#域中的完整性限制" class="headerlink" title="域中的完整性限制"></a>域中的完整性限制</h3><p>对于多个具有联系的表,表中的一些属性可能具有相同的域,可以通过建立域的完整性约束来使不同表中的相同的属性域也相同</p>
<h4 id="域完整性约束定义"><a href="#域完整性约束定义" class="headerlink" title="域完整性约束定义"></a>域完整性约束定义</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义完整性约束 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DOMAIN</span> &lt;完整性约束条件名&gt; &lt;被约束列的值类型&gt; &lt;完整性约束子句&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改完整性约束中的限制条件 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DOMAIN</span> &lt;完整性约束条件名&gt; &lt;完整性约束修改子句&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>完整性约束修改子句包括完整性约束子句的删除和添加,需要指定完整性约束条件名</li>
</ul>
<h4 id="域完整性约束使用"><a href="#域完整性约束使用" class="headerlink" title="域完整性约束使用"></a>域完整性约束使用</h4><p>定义好域的完整性约束后,可以直接使用完整性约束条件名来作为同类型的属性的完整性约束条件</p>
<h2 id="4-数据查询"><a href="#4-数据查询" class="headerlink" title="4. 数据查询"></a>4. 数据查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>语句格式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;] …</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]…|(<span class="keyword">SELECT</span> 语句)</span><br><span class="line">[<span class="keyword">AS</span>]&lt;别名&gt;</span><br><span class="line">[ <span class="keyword">WHERE</span> &lt;条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt; [ <span class="keyword">HAVING</span> &lt;条件表达式&gt; ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [ <span class="keyword">ASC</span>|<span class="keyword">DESC</span> ] ]</span><br></pre></td></tr></table></figure>
<ul>
<li>SELECT:指定要显示的结果属性列,*表示所有列<blockquote>
<ul>
<li>目标列值可以为常量,即使它不在查询对象中</li>
<li>LOWER(&lt;目标列&gt;)可以使目标列值小写输出</li>
<li>目标列值可以用聚集函数表示</li>
<li>可以用别名<code>&lt;目标列表达式&gt; &lt;目标列别名&gt;</code>改变查询结果的列标题</li>
<li>ALL表示不去除重复的行(默认),DISTINCT表示去重</li>
</ul>
</blockquote>
</li>
<li>FROM:指定查询对象</li>
<li>WHERE:查询条件<blockquote>
<p>常用查询条件:</p>
<ul>
<li>基本比较运算符</li>
<li>确定范围: [NOT] BETWEEN .. AND ..</li>
<li>确定集合: [NOT] IN &lt;值表&gt; ; &lt;值表&gt;=(值1,值2,…)</li>
<li>字符匹配: [NOT] LIKE &lt;匹配字符串&gt; [ESCAPE &lt;换码字符&gt;]  <blockquote>
<p>匹配串中’%’表示任意长度通配,’_’表示单字符通配,’&#39;可以将通配符转义(需要ESCAPE’&#39;来表明转义字符)</p>
</blockquote>
</li>
<li>空值:IS [NOT] NULL;其中IS不能用’=’代替</li>
<li>连接运算符:NOT AND OR,优先级从高到低</li>
</ul>
</blockquote>
</li>
<li>GROUP BY:对查询结果按指定列的值分组,列值相等的元素归到一组;通常会在每组中使用聚集函数<blockquote>
<p>常用聚集函数:</p>
<ul>
<li>COUNT([ALL|DISTINCT] &lt;列名&gt;): 列值计数</li>
<li>SUM([ALL|DISTINCT] &lt;列名&gt;): 对数值型的列求总和</li>
<li>AVG([ALL|DISTINCT] &lt;列名&gt;): 对数值型的列求均值</li>
<li>MAX|MIN([ALL|DISTINCT] &lt;列名&gt;): 求列的最大|最小值  </li>
</ul>
<p>没有GROUP BY语句时,聚集函数将作用于整个查询结果,使用分组后函数将分别作用于每个组</p>
</blockquote>
</li>
<li>HAVING:在分组时选择指定条件的组,可以使用聚集函数,不能用WHERE替代</li>
<li>ORDER BY:对查询结果按指定值升序或降序排序,支持以不同优先级设置多个排序标准</li>
</ul>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>SQL中的“连接”是用“连接条件”来表达的。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;表名&gt;.&lt;列名&gt;,...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;,&lt;表<span class="number">2</span>&gt;,...</span><br><span class="line"><span class="keyword">WHERE</span> [&lt;表名<span class="number">1</span>&gt;.]&lt;列名<span class="number">1</span>&gt;  &lt;比较运算符&gt;  [&lt;表名<span class="number">2</span>&gt;.]&lt;列名<span class="number">2</span>&gt;</span><br><span class="line">      <span class="keyword">AND</span> &lt;其他条件&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>WHERE子句中除了连接条件,还可以有选择条件,同时完成选择和连接查询</li>
<li>对于表的自身连接,可以给同一个表取不同的别名来区分,来实现一些复杂的连接条件</li>
<li>左右外连接:<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">LEFT</span>|<span class="keyword">RIGHT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; </span><br><span class="line"><span class="keyword">ON</span> &lt;连接条件&gt;; </span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>FROM中也可以有多个表,进行多表连接</li>
</ul>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>一个SELECT-FROM-WHERE语句称为一个查询块,将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
<h4 id="IN子查询"><a href="#IN子查询" class="headerlink" title="IN子查询"></a>IN子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> &lt;列名(值)&gt; <span class="keyword">IN</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line">        ...</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h4 id="ANY-ALL子查询"><a href="#ANY-ALL子查询" class="headerlink" title="ANY/ALL子查询"></a>ANY/ALL子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> &lt;列名&gt; &lt;比较运算符&gt; <span class="keyword">ANY</span>/<span class="keyword">ALL</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line">        ...</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>当确定内层子查询返回结果是单个值时,可以省略ANY/ALL</li>
<li>ANY/ALL的对象为某个查询结果,表示其中任意一个值或者全部值<blockquote>
<p>有时ANY/ALL谓词表达式可以用子查询中的聚集函数代替,如<code>&lt; ANY (SELECT &lt;列名&gt;)</code>可以用<code>&lt; (SELECT MIN(&lt;列名&gt;))</code>实现</p>
</blockquote>
</li>
</ul>
<h4 id="EXISTS子查询"><a href="#EXISTS子查询" class="headerlink" title="EXISTS子查询"></a>EXISTS子查询</h4><p>EXISTS是相关子查询,它依次取外层查询中表内的各元组,根据它与内层查询相关的属性值处理内层查询,若WHERE子句返回值为真,则取此元组放入结果表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">NOT</span>] <span class="keyword">EXISTS</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> &lt;表<span class="number">2</span>&gt;,...</span><br><span class="line">        <span class="keyword">WHERE</span> &lt;表<span class="number">1</span>&gt;...&lt;表<span class="number">2</span>&gt;...;</span><br><span class="line">    );</span><br><span class="line"><span class="comment">/* 表示查询结果中的每条记录都满足/不满足EXISTS子句 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>EXIST的对象也是某个查询结果，若查询结果非空则返回真<blockquote>
<ul>
<li>由EXISTS引出的子查询中一般都是SELECT *</li>
<li>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换</li>
<li>SQL中的存在,任意,蕴含等谓词都需要用EXISTS手动实现</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h4><p>除法运算需要用EXIST子句实现</p>
<p>原理:</p>
<ol>
<li>计算C(X)=A(X,Y)/B(Y,Z)</li>
<li>根据上式,需要找出所有的c[X],使得对于所有的b[Y],都存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]</li>
<li>SQL中没有全称量词,需要对上式进行转换:找出所有的c[X],使得不存在b[Y],不存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]</li>
<li>对于 ‘不存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]’, 还可以使用集合差运算转化成 ‘全体a[X,Y] - 使得a[X]=c[X],a[Y]=b[Y]的a[X,Y]’</li>
</ol>
<p>3的实现代码如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> X </span><br><span class="line"><span class="keyword">FROM</span> A [<span class="keyword">AS</span>] R <span class="comment">/* 换名防止后面混淆 */</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * </span><br><span class="line">    <span class="keyword">FROM</span> B</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> A</span><br><span class="line">        <span class="keyword">WHERE</span> &lt;X=R.X&gt;</span><br><span class="line">          <span class="keyword">AND</span> &lt;Y=B.Y&gt;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>4的实现代码如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> X </span><br><span class="line"><span class="keyword">FROM</span> A [<span class="keyword">AS</span>] R <span class="comment">/* 换名防止后面混淆 */</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    (<span class="keyword">SELECT</span> *</span><br><span class="line">     <span class="keyword">FROM</span> A</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">EXCEPT</span> <span class="comment">/* 集合做差 */</span></span><br><span class="line">    (<span class="keyword">SELECT</span> X,Y </span><br><span class="line">     <span class="keyword">FROM</span> A,B</span><br><span class="line">     <span class="keyword">WHERE</span> &lt;A.X=R.X&gt;</span><br><span class="line">       <span class="keyword">AND</span> &lt;A.Y=B.Y&gt;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="蕴含逻辑"><a href="#蕴含逻辑" class="headerlink" title="蕴含逻辑"></a>蕴含逻辑</h4><p>蕴含逻辑也需要用EXISTS子句实现</p>
<ol>
<li>给定逻辑:对于任意的a,都有B-&gt;C</li>
<li>化简逻辑:不存在a,使得B或非C</li>
<li>用NOT EXISTS实现上述语句;注意,非C也可以用NOT EXISTS实现</li>
</ol>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>集合查询可以对两个查询结果进行集合运算</p>
<ul>
<li>UNION:并</li>
<li>INTERSECT:交</li>
<li>EXCEPT:差<br>注意:参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同 </li>
</ul>
<h2 id="5-数据更新"><a href="#5-数据更新" class="headerlink" title="5. 数据更新"></a>5. 数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>可以直接插入元组或者插入子查询结果(多个元组)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;[属性列,...]</span><br><span class="line"><span class="keyword">VALUES</span> (属性值,);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;[属性列,...]</span><br><span class="line">&lt;子查询&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有出现的属性列赋空值  </li>
<li>没有定义属性列时默认为原表所有属性</li>
<li>VALUES可以由子查询表示</li>
<li>子查询结果或元组值需要与上面定义的属性列相匹配(子查询结果列的个数和列的类型都要匹配)</li>
<li>除了属性匹配,数据库还会检查所插入元素是否会破坏表的完整性规则</li>
</ul>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">SET</span>  &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>语句将修改指定表中满足WHERE子句条件的元组</li>
<li>SET子句给出&lt;表达式&gt;的值用于取代相应的属性列</li>
<li>注意,如果省略WHERE子句,则会修改表中的所有元组 </li>
<li>执行修改语句时,数据库会检查修改操作是否会破坏表的完整性规则</li>
</ul>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt;</span><br><span class="line">WHERE &lt;条件&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>语句将会删除指定表中满足WHERE子句条件的元组</li>
<li>注意,如果省略WHERE子句,则会删除表中的所有元组</li>
</ul>
<h2 id="6-视图"><a href="#6-视图" class="headerlink" title="6. 视图"></a>6. 视图</h2><h3 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h3><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE  VIEW </span><br><span class="line">    &lt;视图名&gt;  [(&lt;列名&gt;  [,&lt;列名&gt;]…)] </span><br><span class="line">   AS &lt;子查询&gt; </span><br><span class="line">   [WITH  CHECK  OPTION];</span><br></pre></td></tr></table></figure>
<ul>
<li>列名缺省时由子查询中SELECT的列构成<blockquote>
<p>一般出现以下情况,需要指定视图的列名:</p>
<ul>
<li>SELECT的某个列需要聚集函数或列表达式,即出现了一些新的列</li>
<li>多表连接时选出了几个同名列作为视图的字段</li>
<li>需要在视图中为某个列启用新的更合适的名字</li>
</ul>
</blockquote>
</li>
<li>WITH CHECK OPTION 可以保证通过该视图插入的数据符合该视图的定义,即插入成功的数据也会在视图中显示</li>
</ul>
<p>常见视图:</p>
<ul>
<li>行列子集视图:在保留单个基本表主码的情况下,去掉了这个表的某些行和列</li>
<li>基于多个表的视图</li>
<li>基于视图的视图</li>
<li>带表达式的视图:SELECT的某个列为表达式</li>
<li>分组视图:SELECT的某个列为聚集函数</li>
</ul>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><code>DROP  VIEW  &lt;视图名&gt;[CASCADE];</code></p>
<ul>
<li>该语句从数据字典中删除指定的视图定义</li>
<li>如果该视图上还导出了其他视图，需要使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除,否则会拒绝删除</li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</li>
</ul>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>视图查询与上述基本表的查询相同</p>
<p>原理:视图消解法</p>
<ul>
<li>对于数据库系统而言,先得将视图查询转换为对基本表的查询,再进行对基本表的查询</li>
<li>转换时需要进行有效性检查和语句修正</li>
</ul>
<h3 id="更新视图-数据"><a href="#更新视图-数据" class="headerlink" title="更新视图(数据)"></a>更新视图(数据)</h3><p>视图的插入,删除,修改操作与基本表相同</p>
<ul>
<li>一些视图是不可更新的,因为 对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新,如带聚集函数的视图<blockquote>
<p>一般而言,行列子集视图是可以进行更新的  </p>
<p>DB2对视图更新的限制:</p>
<ul>
<li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li>
<li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT 和UPDATE操作，但允许执行DELETE操作。  </li>
<li>若视图的字段来自集函数，则此视图不允许更新。</li>
<li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li>
<li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li>
<li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="7-自主存取控制"><a href="#7-自主存取控制" class="headerlink" title="7. 自主存取控制"></a>7. 自主存取控制</h2><p>通过SQL的GRANT语句和REVOKE语句实现自主存取控制</p>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><h4 id="权限的授予"><a href="#权限的授予" class="headerlink" title="权限的授予"></a>权限的授予</h4><p>给某用户授予对某对象的某操作权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">TO</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>权限有SELECT，INSERT，UPDATE，DELETE，REFERENCES几种; ALL PRIVILEGES表示所有操作权限<blockquote>
<p>至于CREATE,ALTER等权限,是数据库管理员在创建用户时授予的</p>
</blockquote>
</li>
<li>指定了ON的对象,表名这是一种实体权限的授予,而不是系统权限(对任意对象的操作)的授予</li>
<li>TO用户可以时一个或多个具体用户,也可以是全体用户PUBLIC</li>
<li>WITH GRANT OPTION表示授予的权限可以再由该用户向下转授<blockquote>
<p>注意:权限不能循环授予,这样会导致回收权限时遇到无穷递归</p>
</blockquote>
</li>
<li>GRANT语句的发出者可以是数据库管理员,数据库对象创建者或者拥有该权限的用户</li>
</ul>
<h4 id="权限的回收"><a href="#权限的回收" class="headerlink" title="权限的回收"></a>权限的回收</h4><p>收回本授权者对某用户的某对象某操作权限的授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[<span class="keyword">CASCADE</span> | RESTRICT];</span><br></pre></td></tr></table></figure>
<ul>
<li>级联回收: 将用户和他传播的权限全部回收</li>
<li>受限回收: 若用户传播过该权限并没有收回,则拒绝执行回收操作</li>
<li>权限的回收可由管理员或授权者来执行</li>
<li>回收只回收本用户直接或间接对目标用户授予的权限,若该用户还从其他地方获得了相同的权限,则他们仍具有此权限</li>
</ul>
<h3 id="用户-用户的创建"><a href="#用户-用户的创建" class="headerlink" title="用户:用户的创建"></a>用户:用户的创建</h3><p>CREATE USER不是SQL标准,不同数据库对用户创建的实现不一样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">USER</span>  &lt;username&gt;</span><br><span class="line">[<span class="keyword">WITH</span>][DBA|<span class="keyword">RESOURCE</span>|<span class="keyword">CONNECT</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>DBA:可以创建用户,模式,表以及登录数据库执行增删改查等操作</li>
<li>RESOURCE:只能创建表并登录数据库执行增删改查等操作</li>
<li>CONNECT: 能登陆数据库进行增删改查等操作,但必须获得相应权限</li>
</ul>
<h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>角色是权限的集合,能够通过为一组具有相同权限的用户创建一个角色来简化授权的过程</p>
<h4 id="角色的创建"><a href="#角色的创建" class="headerlink" title="角色的创建"></a>角色的创建</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> &lt;角色名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="给角色添加权限"><a href="#给角色添加权限" class="headerlink" title="给角色添加权限"></a>给角色添加权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">TO</span> &lt;角色&gt;[,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure>

<h4 id="回收角色的某权限"><a href="#回收角色的某权限" class="headerlink" title="回收角色的某权限"></a>回收角色的某权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;角色&gt;[,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure>
<ul>
<li>用户可以回收角色的权限，从而修改角色拥有的权限</li>
<li>(不知道对不对)之前通过此角色授予出去的权限也会因为这个操作而被回收</li>
<li>这个REVOKE的发起者是角色的创建者或者拥有该角色ADMIN OPTION的用户</li>
</ul>
<h4 id="把角色授予给某用户或角色"><a href="#把角色授予给某用户或角色" class="headerlink" title="把角色授予给某用户或角色"></a>把角色授予给某用户或角色</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>  &lt;角色<span class="number">1</span>&gt;[,&lt;角色<span class="number">2</span>&gt;]...</span><br><span class="line"><span class="keyword">TO</span>  &lt;角色<span class="number">3</span>&gt;[,&lt;用户<span class="number">1</span>&gt;]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>一个角色的权限是直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限 </li>
<li>把角色授给目标用户后,该用户获得这个角色的所有权限</li>
<li>WITH ADMIN OPTION表示目标角色或用户还可以把这种角色权限授予其他的角色或用户,也有权力更改这个角色的权限</li>
<li>这个GRANT的发起者是角色的创建者或者拥有该角色ADMIN OPTION的用户</li>
</ul>
<h4 id="通过角色收回赋予出去的权限"><a href="#通过角色收回赋予出去的权限" class="headerlink" title="通过角色收回赋予出去的权限"></a>通过角色收回赋予出去的权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;角色<span class="number">1</span>&gt;[,&lt;角色<span class="number">2</span>&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;角色<span class="number">3</span>&gt;[,&lt;用户<span class="number">1</span>&gt;]...</span><br></pre></td></tr></table></figure>
<ul>
<li>目标用户或角色失去了原角色赋予给他的权限</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下C#对cmd的操作</title>
    <url>/2020/03/10/csharp-command/</url>
    <content><![CDATA[<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">"请输入要执行的命令:"</span>);</span><br><span class="line"><span class="keyword">string</span> strInput = Console.ReadLine();</span><br><span class="line">Process p = <span class="keyword">new</span> Process();</span><br><span class="line"><span class="comment">//设置要启动的应用程序</span></span><br><span class="line">p.StartInfo.FileName = <span class="string">"cmd.exe"</span>;</span><br><span class="line"><span class="comment">//是否使用操作系统shell启动</span></span><br><span class="line">p.StartInfo.UseShellExecute = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 接受来自调用程序的输入信息</span></span><br><span class="line">p.StartInfo.RedirectStandardInput = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//输出信息</span></span><br><span class="line">p.StartInfo.RedirectStandardOutput = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 输出错误</span></span><br><span class="line">p.StartInfo.RedirectStandardError = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//不显示程序窗口</span></span><br><span class="line">p.StartInfo.CreateNoWindow = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//启动程序</span></span><br><span class="line">p.Start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//向cmd窗口发送输入信息</span></span><br><span class="line">p.StandardInput.WriteLine(strInput);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.StandardInput.WriteLine(<span class="string">"exit"</span>);</span><br><span class="line">p.StandardInput.AutoFlush = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">string</span> strOuput = p.StandardOutput.ReadToEnd();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取输出信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等待程序执行完退出进程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Console.WriteLine(strOuput);</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>命名管道和进程通讯</title>
    <url>/2020/03/10/FIFO/</url>
    <content><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>参考<a href="https://blog.csdn.net/wh_sjc/article/details/70283843" target="_blank" rel="noopener">https://blog.csdn.net/wh_sjc/article/details/70283843</a><br>IPC（进程间通讯）的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。</p>
<h2 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h2><p>“命名管道”是一种简单的进程间通信（IPC）机制，命名管道可在同一台计算机的不同进程之间或在跨越一个网络的不同计算机的不同进程之间，支持可靠的、单向或双向的数据通信。</p>
<h2 id="python中的命名管道"><a href="#python中的命名管道" class="headerlink" title="python中的命名管道"></a>python中的命名管道</h2><p>参考<a href="https://blog.csdn.net/kongxx/article/details/78037069" target="_blank" rel="noopener">https://blog.csdn.net/kongxx/article/details/78037069</a><br><a href="https://www.programcreek.com/python/example/62752/win32pipe.PIPE_WAIT" target="_blank" rel="noopener">https://www.programcreek.com/python/example/62752/win32pipe.PIPE_WAIT</a><br><a href="https://www.cnblogs.com/achillis/p/10462585.html" target="_blank" rel="noopener">https://www.cnblogs.com/achillis/p/10462585.html</a>  </p>
<p>在 Windows 上的命名管道主要是通过调用 win32 api 的以下方法来实现的</p>
<h3 id="server端"><a href="#server端" class="headerlink" title="server端"></a>server端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32file</span><br><span class="line"><span class="keyword">import</span> win32pipe</span><br><span class="line"></span><br><span class="line">PIPE_NAME = <span class="string">r'\\.\pipe\test_pipe'</span></span><br><span class="line">PIPE_BUFFER_SIZE = <span class="number">65535</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    named_pipe = win32pipe.CreateNamedPipe(PIPE_NAME,</span><br><span class="line">                                           win32pipe.PIPE_ACCESS_DUPLEX,</span><br><span class="line">                                           win32pipe.PIPE_TYPE_MESSAGE | win32pipe.PIPE_WAIT | win32pipe.PIPE_READMODE_MESSAGE,</span><br><span class="line">                                           win32pipe.PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">                                           PIPE_BUFFER_SIZE,</span><br><span class="line">                                           PIPE_BUFFER_SIZE, <span class="number">500</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                win32pipe.ConnectNamedPipe(named_pipe, <span class="literal">None</span>)    <span class="comment">#连接管道</span></span><br><span class="line">                data = win32file.ReadFile(named_pipe, PIPE_BUFFER_SIZE, <span class="literal">None</span>)   <span class="comment">#接收消息</span></span><br><span class="line">                win32file.WriteFile(named_pipe, bytes(<span class="string">"OK"</span>, encoding=<span class="string">'utf-8'</span>))  <span class="comment">#发送消息(二进制)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(data) &lt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                print(<span class="string">'receive msg:'</span>, data)</span><br><span class="line">            <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"exception:"</span>, e)  </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            win32pipe.DisconnectNamedPipe(named_pipe)   <span class="comment">#断开连接</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="client客户端"><a href="#client客户端" class="headerlink" title="client客户端"></a>client客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32pipe, win32file</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">PIPE_NAME = <span class="string">r'\\.\pipe\test_pipe'</span></span><br><span class="line"></span><br><span class="line">file_handle = win32file.CreateFile(PIPE_NAME,</span><br><span class="line">                                   win32file.GENERIC_READ | win32file.GENERIC_WRITE,</span><br><span class="line">                                   win32file.FILE_SHARE_WRITE, <span class="literal">None</span>,</span><br><span class="line">                                   win32file.OPEN_EXISTING, <span class="number">0</span>, <span class="literal">None</span>)    <span class="comment"># 连接管道</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">        msg = str(i)</span><br><span class="line">        print(<span class="string">'send msg:'</span>, msg)</span><br><span class="line">        win32file.WriteFile(file_handle, bytes(msg,encoding=<span class="string">'utf-8'</span>))   <span class="comment"># 发送信息</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        data = win32file.ReadFile(file_handle, <span class="number">65535</span>, <span class="literal">None</span>) <span class="comment"># 接收信息(阻塞)</span></span><br><span class="line">        print(data)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        win32file.CloseHandle(file_handle)  <span class="comment"># 关闭连接</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="C-中的命名管道"><a href="#C-中的命名管道" class="headerlink" title="C#中的命名管道"></a>C#中的命名管道</h2><h3 id="server端-1"><a href="#server端-1" class="headerlink" title="server端"></a>server端</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">NamedPipeServerStream server = <span class="keyword">new</span> NamedPipeServerStream(<span class="string">"test_pipe"</span>, PipeDirection.InOut, <span class="number">100</span>, PipeTransmissionMode.Byte, PipeOptions.None, <span class="number">65535</span>, <span class="number">65535</span>);</span><br><span class="line">server.WaitForConnection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (server.IsConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = server.Read(res, <span class="number">0</span>, <span class="number">65535</span>); <span class="comment">//接收信息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">string</span> s = System.Text.Encoding.UTF8.GetString(res,<span class="number">0</span>,n);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">        n = Encoding.UTF8.GetBytes(s, <span class="number">0</span>, s.Length, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        server.Write(res, <span class="number">0</span>, n);    <span class="comment">//发送信息</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="client端"><a href="#client端" class="headerlink" title="client端"></a>client端</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">NamedPipeClientStream client = <span class="keyword">new</span> NamedPipeClientStream(<span class="string">"test_pipe"</span>);</span><br><span class="line">client.Connect();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (client.IsConnected)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = client.Read(res, <span class="number">0</span>, <span class="number">65535</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> s = System.Text.Encoding.UTF8.GetString(res,<span class="number">0</span>,n);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">    n = Encoding.UTF8.GetBytes(s, <span class="number">0</span>, s.Length, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    client.Write(res, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="python和C-交互代码示例"><a href="#python和C-交互代码示例" class="headerlink" title="python和C#交互代码示例"></a>python和C#交互代码示例</h2><p>python端  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> win32file</span><br><span class="line"><span class="keyword">import</span> win32pipe</span><br><span class="line"></span><br><span class="line">PIPE_NAME = <span class="string">r'\\.\pipe\test_pipe'</span></span><br><span class="line">PIPE_BUFFER_SIZE = <span class="number">65535</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    named_pipe = win32pipe.CreateNamedPipe(PIPE_NAME,</span><br><span class="line">                                           win32pipe.PIPE_ACCESS_DUPLEX,</span><br><span class="line">                                           win32pipe.PIPE_TYPE_MESSAGE | win32pipe.PIPE_WAIT | win32pipe.PIPE_READMODE_MESSAGE,</span><br><span class="line">                                           win32pipe.PIPE_UNLIMITED_INSTANCES,</span><br><span class="line">                                           PIPE_BUFFER_SIZE,</span><br><span class="line">                                           PIPE_BUFFER_SIZE, <span class="number">500</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                win32pipe.ConnectNamedPipe(named_pipe, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">                win32file.WriteFile(named_pipe, bytes(<span class="string">"hello"</span>, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">                data = win32file.ReadFile(named_pipe, PIPE_BUFFER_SIZE, <span class="literal">None</span>)</span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># data = str.encode()</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> len(data) &lt; <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                print(<span class="string">'receive msg:'</span>, data)</span><br><span class="line">            <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">                print(<span class="string">"exception:"</span>, e)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            win32pipe.DisconnectNamedPipe(named_pipe)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>C#端</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">   <span class="keyword">byte</span>[] res = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">65535</span>];</span><br><span class="line"></span><br><span class="line">       NamedPipeClientStream client = <span class="keyword">new</span> NamedPipeClientStream(<span class="string">"test_pipe"</span>);</span><br><span class="line">       client.Connect();</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (client.IsConnected)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> n = client.Read(res, <span class="number">0</span>, <span class="number">65535</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">string</span> s = System.Text.Encoding.UTF8.GetString(res,<span class="number">0</span>,n);</span><br><span class="line"></span><br><span class="line">           Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">           n = Encoding.UTF8.GetBytes(s, <span class="number">0</span>, s.Length, res, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           client.Write(res, <span class="number">0</span>, n);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>python</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>形式语言和自动机初步</title>
    <url>/2020/03/04/formal-language-and-automata/</url>
    <content><![CDATA[<p>参考离散数学(清华大学出版社,第五版)相关内容  </p>
<p>ps: 编辑公式真费时间$\to$_$\to$</p>
<hr>
<p>自动机是描述计算的数学模型,用来识别语言或计算函数. 形式文法也是一种数学模型,用来产生形式语言. 形式语言和自动机理论密切相关,是计算机科学和技术的重要理论基础.  </p>
<p>本文扼要地介绍形式文法的基本概念,有穷自动机和图灵机以及它们识别的语言类,其他不做分析</p>
<a id="more"></a>

<h2 id="形式语言和形式文法"><a href="#形式语言和形式文法" class="headerlink" title="形式语言和形式文法"></a>形式语言和形式文法</h2><p>形式语言的描述最早在1956年由语言学家乔姆斯基建立</p>
<p>在乔姆斯基的分类中,形式文法一共有如下几类:</p>
<ul>
<li>0型文法: 现证明等价于图灵机(下同)</li>
<li>1型文法: 等价于非确定型线性界限自动机</li>
<li>2型文法: 等价于非确定型下推自动机</li>
<li>3型文法: 等价于有穷自动机</li>
</ul>
<p>形式文法,特别是上下文无关文法(2型文法)和正则文法(3型文法)在程序设计语言和编译理论中起着重要的作用</p>
<h3 id="字符串和形式语言"><a href="#字符串和形式语言" class="headerlink" title="字符串和形式语言"></a>字符串和形式语言</h3><p>抽象而言,语言是按照一定规则排列的符号的集合</p>
<p>定义:</p>
<ul>
<li>字母表$\Sigma$: 一个非空的有穷集合</li>
<li>字符串$\omega$: 由$\Sigma$中的符号组成的有穷序列,如$a_ia_j…a_k$; 特别地,$aaa…a$记作$a^n$</li>
<li>$\vert \omega \vert$: 字符串$\omega$的长度, 空串$\epsilon$长度为0  </li>
</ul>
<ul>
<li>形式语言(语言): $\Sigma^*$的任何子集称作字母表$\Sigma$上的形式语言, 其中,$\Sigma^*$是$\Sigma$上字符串的全体  </li>
</ul>
<blockquote>
<p>$\emptyset, \lbrace \epsilon \rbrace, \Sigma^*$都是$\Sigma$上的语言. 注意,前两者是不同的</p>
</blockquote>
<p>在字符串$\omega$中:</p>
<ul>
<li>前缀: 由$\omega$左端若干个连续符号组成的字符串</li>
<li>后缀: 由$\omega$右端若干个连续符号组成的字符串</li>
<li>字串: 由$\omega$任何部位若干个连续符号组成的字符串</li>
<li>连接运算: $\omega_1\omega_2$表示把$\omega_2$接在$\omega_1$的右边, 显然,它是可结合的</li>
</ul>
<h3 id="形式文法"><a href="#形式文法" class="headerlink" title="形式文法"></a>形式文法</h3><p>语言是由一定规则产生出来的,这种规则就是文法</p>
<p>例如,<code>9+5-2</code>这个字符串可由如下文法规则产生:</p>
<blockquote>
<ol>
<li>表达式-&gt;表达式+数字;  </li>
<li>表达式-&gt;表达式-数字;  </li>
<li>表达式-&gt;数字;</li>
<li>数字-&gt;2;  </li>
<li>数字-&gt;5;  </li>
<li>数字-&gt;9;</li>
</ol>
</blockquote>
<p>定义:</p>
<ul>
<li>产生式: 文法中的每一条规则都叫做产生式</li>
<li>终结符: 不能产生其他字符串的符号, 如上述文法中的2,5,9</li>
<li>非终结符: 文法规则中除了终结符之外的其他符号,如<code>表达式</code>,<code>数字</code>,<code>+</code>,<code>-</code></li>
</ul>
<p><code>9+5-2</code>的推理过程:</p>
<ul>
<li>从<code>表达式</code>开始由2,1,3得到<code>数字+数字+数字</code></li>
<li>由4,5,6可以得到<code>9+5-2</code></li>
</ul>
<p>当然,这组规则不仅仅只能推出<code>9+5-2</code>  </p>
<p>注意: 规则所推出的字符串在语义上不一定正确,但在形式上都是合法的</p>
<h4 id="形式文法的定义"><a href="#形式文法的定义" class="headerlink" title="形式文法的定义"></a>形式文法的定义</h4><p>一个形式文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是一个非空有限集合,集合的元素称作变元或<strong>非终结符</strong></li>
<li>$T$是一个非空有限集合,$V\cap T=\emptyset$,集合中的元素称作<strong>终结符</strong></li>
<li>$S\in V$称作<strong>起始符</strong></li>
<li>$P$是一个非空有穷集合,它的元素称作<strong>产生式</strong>或改写规则<br>&emsp; $P$中元素应有这样的形式: a-&gt;b; 其中a,b$\in (V\cup T)^*$, 且a$\ne \epsilon$</li>
</ul>
<h4 id="派生-生成语言"><a href="#派生-生成语言" class="headerlink" title="派生,生成语言"></a>派生,生成语言</h4><p>直接派生:</p>
<ul>
<li>给定文法$G=&lt;V,T,S,P&gt;$,设$x,y \in (V \cup T)^*$. 称<strong>$y$是$x$的直接派生($x\Rightarrow y$)</strong>,当且仅当:  <blockquote>
<p>$\exists u,v \in (V \cup T)^* $ 且 $ \exists$ ‘a-&gt;b’ $\in P$ 使得 $x = uav,y = ubv$ (即把x中的a改写成b后得到y)  </p>
</blockquote>
</li>
</ul>
<p>派生:</p>
<ul>
<li>给定文法$G=&lt;V,T,S,P&gt;$,设$x_1,x_2,…,x_n \in (V \cup T)^*, n \ge 1 且 x_1\Rightarrow x_2 \Rightarrow … \Rightarrow x_n $, 则称<strong>$x_n$是由$x_1$派生出来的($x_1 \dot \Rightarrow x_n$)</strong>  <blockquote>
<p>注意,对$V \cup T$上的所有字符串$\omega$有$\omega \dot \Rightarrow \omega$. 可见$\dot \Rightarrow$是$\Rightarrow$的自反传递闭包  </p>
</blockquote>
</li>
</ul>
<p>生成语言:  </p>
<ul>
<li>设$G=&lt;V,T,S,P&gt;$是一个文法,$L(G)$是文法G<strong>生成的语言</strong>,则$L(G)$满足<br>$$ L(G) = \lbrace \omega \in T^* | S \dot \Rightarrow \omega \rbrace $$   <blockquote>
<p>根据定义,$L(G)$中的字符串满足如下两个条件:</p>
<ol>
<li>字符串由终结符构成</li>
<li>字符串可以由起始符派生出来</li>
</ol>
</blockquote>
</li>
</ul>
<p>文法的等价</p>
<ul>
<li>如果$L(G_1) = L(G_2)$,则称文法$G_1$和$G_2$<strong>等价</strong></li>
</ul>
<h3 id="形式文法分类"><a href="#形式文法分类" class="headerlink" title="形式文法分类"></a>形式文法分类</h3><h4 id="0型文法-无限制文法"><a href="#0型文法-无限制文法" class="headerlink" title="0型文法: 无限制文法"></a>0型文法: 无限制文法</h4><p>0型文法就是一般形式的文法,在形式文法定义的基础上不附加任何条件  </p>
<p>一个0型文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限</li>
</ul>
<p>0型文法又称作短语结构文法或无限制文法,0型文法生成的语言称作0型语言</p>
<h4 id="1型文法-上下文有关文法"><a href="#1型文法-上下文有关文法" class="headerlink" title="1型文法: 上下文有关文法"></a>1型文法: 上下文有关文法</h4><p>1型文法在0型文法上加了一条限制: 对P中每一个产生式a-&gt;b都有$\vert a \vert \ge \vert b \vert$  </p>
<p>一个1型文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: 对P中任意一个产生式a-&gt;b都有$\vert a \vert \ge \vert b \vert$  </p>
</blockquote>
</li>
</ul>
<p>每一个1型文法都等价于这样一个文法(证明略),它的产生式形如<br>$$ uAv \to u \alpha v $$  </p>
<blockquote>
<p>这里$ A \in V, u,v \in (V \cup T)^* ,\alpha \ne \epsilon$  </p>
</blockquote>
<p>也就是说,在这种文法中,替换变元时必须考虑它的上下文,才能把$A$换成$\alpha$  </p>
<p>因此,1型文法又叫做上下文有关文法,若$L-\lbrace \epsilon \rbrace$可由1型文法生成,则L称作1型语言或上下文有关语言(1型文法本身不能生成$\epsilon$)</p>
<h4 id="2型文法-上下文无关文法"><a href="#2型文法-上下文无关文法" class="headerlink" title="2型文法: 上下文无关文法"></a>2型文法: 上下文无关文法</h4><p>2型文法在1型文法的基础上又做了一些限制(令上文中的$u,v = \epsilon$)</p>
<p>一个2型文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: $ A \to \alpha $; 其中$A \in V, \alpha \in (V\cup T)^*$ <em>(0型文法是$A \in (V\cup T)^*$)</em>  </p>
</blockquote>
</li>
</ul>
<p>此时,在这种文法中,替换变元时不需要考虑它的上下文</p>
<p>因此,2型文法又称作上下文无关文法,2型文法生成的语言称作2型语言或上下文无关语言</p>
<h4 id="3型文法-正则文法"><a href="#3型文法-正则文法" class="headerlink" title="3型文法: 正则文法"></a>3型文法: 正则文法</h4><p>3型文法在2型文法的基础上做了更多的限制,其分为右线性文法和左线性文法</p>
<p>一个<strong>右线性文法</strong>是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: $ A \to \alpha B $或$ A \to \alpha $; 其中$A,B \in V, \alpha \in T^*$ <em>(注意符号所属范围)</em></p>
</blockquote>
</li>
</ul>
<p>一个<strong>左线性文法</strong>是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: $ A \to B \alpha $或$ A \to \alpha $; 其中$A,B \in V, \alpha \in T^*$  </p>
</blockquote>
</li>
</ul>
<p>右线性文法和左线性文法统称做3型文法或正则文法,3型文法生成的语言称作3型语言或正则语言  </p>
<p>可以证明的是,每一个右线性文法都存在与之等价的左线性文法,反之亦然; 即每一个正则语言都可以同时用右线性文法和左线性文法生成</p>
<h4 id="几种形式文法生成的语言类之间的关系"><a href="#几种形式文法生成的语言类之间的关系" class="headerlink" title="几种形式文法生成的语言类之间的关系"></a>几种形式文法生成的语言类之间的关系</h4><p>这几种语言类之间存在着真包含关系</p>
<ul>
<li>正则语言是上下文无关语言</li>
<li>上下文无关语言是上下文有关语言</li>
<li>上下文有关语言是0型语言</li>
</ul>
<p>在编译原理中,词法分析可以用正则文法解决,而语法分析使用上下文无关文法</p>
<p>注: 在正则文法和上下文无关文法中,当同一个符号作为多个产生式的左端时,可以用”或”<code>|</code>来合在一起写</p>
<h2 id="图灵机TM"><a href="#图灵机TM" class="headerlink" title="图灵机TM"></a>图灵机TM</h2><p>图灵机是图灵于1936年提出的一种数学模型, 这个模型很好地描述了计算的过程. 大量事实表明, 任何算法都可以用一个图灵机来描述, 这就是Chruch论题.  </p>
<p>图灵机在可计算性理论中起着重要的作用, 可以证明, 图灵机识别的语言是0型语言</p>
<h3 id="图灵机的基本模型"><a href="#图灵机的基本模型" class="headerlink" title="图灵机的基本模型"></a>图灵机的基本模型</h3><p>设想图灵机由一个控制器和一条无穷长的纸带组成,纸带分成了一个一个的小方格，每个方格有不同的颜色。有一个机器头在纸带上移来移去。机器头有一组内部状态，还有一些固定的程序。在每个时刻，机器头都要从当前纸带上读入一个方格信息，然后结合自己的内部状态查找程序表，根据程序输出信息到纸带方格上，并转换自己的内部状态，然后进行移动, 如下图:<br><img src="/2020/03/04/formal-language-and-automata/TM0.jpg" alt="TM"></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>图灵机是一个有序组$M = &lt;Q, \Sigma, \Gamma, \delta, q_0, B, A&gt;$, 其中</p>
<ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\Gamma$是非空有穷的带字母表且$\Sigma \subset \Gamma$</li>
<li>$\delta$为一个$Q \times \Gamma \to \Gamma \times \lbrace L, R \rbrace \times Q$的映射,是动作函数</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$B \in \Gamma - \Sigma$是空白符</li>
<li>$A \subset Q$是接收状态的集合<blockquote>
<p>对于$\delta$, 给定当前状态$q$和当前位置的符号$s$,它能将当前位置的符号改为$s’$、并且给出扫描头移动方向和次态$q’$; 即$\delta (q,s) = (s’, L/R, q’)$</p>
</blockquote>
</li>
</ul>
<p>显然,对于每一步计算,带上只有穷个方格的内容是非空白符,因此,纸带可以表示为$$Ba_1a_2…a_nB$$即两边都有无穷多个空白符的形式  </p>
<p>给定了图灵机M和纸带,为了描述计算中的每一步,这里又有一些定义:</p>
<ul>
<li><p>格局: 计算中某一步时带上的内容、控制器的状态和读写头扫视的带方格称为M的一个格局</p>
<blockquote>
<p>一般地,一个格局总可以表示成$\alpha_1 q \alpha_2$, 其中$\alpha_1, \alpha_2 \in \Gamma, q \in Q$<br>这表示带上的内容为$\alpha_1 \alpha_2$, 当前状态为$q$, 读写头正在扫视$\alpha_2$的第一个字符(若$\alpha_2$是空串则扫视紧挨在右边的空白符)   </p>
<ul>
<li>$q_0\omega$是M的初始格局,$\omega \in \Sigma^*$是输入字符串  </li>
</ul>
</blockquote>
</li>
<li><p>接受格局: $\sigma = \alpha_1 q \alpha_2$中的$q$是接收状态,即$q \in A$</p>
</li>
<li><p>停机格局: $\sigma$时对应的&amp;\delta (q,s)&amp;没有定义,即图灵机不知道接下来一步要干什么  </p>
</li>
<li><p>$\vdash$: 设$\sigma_1, \sigma_2$是两个格局, 如果从$\sigma_1$经过一步到达$sigma_2$,则记作$\sigma_1\vdash\sigma_2$</p>
</li>
<li><p>$\dot \vdash$: 设$\sigma_1, \sigma_2$是两个格局, 如果从$\sigma_1$经过有限步到达$sigma_2$,则记作$\sigma_1\dot\vdash\sigma_2$  </p>
</li>
<li><p>计算: 一个格局序列$\sigma_1,\sigma_2,…,\sigma_n,…$(可以有穷也可以无穷)中每一个$\sigma_{i+1}$都能由$\sigma_i$一步得到,则称这个序列是一个计算</p>
</li>
</ul>
<h3 id="图灵机接受的语言"><a href="#图灵机接受的语言" class="headerlink" title="图灵机接受的语言"></a>图灵机接受的语言</h3><p>任给一个字符串$\omega$,从初始格局开始,图灵机M在字符串上的计算有如下三种可能:</p>
<ul>
<li>停机在接受状态,此时称图灵机M接受字符串$\omega$</li>
<li>婷机在非接受状态,此时图灵机M不接受或拒绝字符串$\omega$</li>
<li>用不停机,此时也称图灵机M不接受或拒绝字符串$\omega$</li>
</ul>
<p>则图灵机M接受的语言L(M)可定义为:<br>$$L(M) = \lbrace \omega | \omega \in \Sigma^* , M接受\omega \rbrace$$</p>
<h3 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h3><p>状态转移图是一个有向图,每一个节点代表一个状态; 初始状态用一个指向该节点的箭头标明, 终结状态用双圈标明; 边上应注明状态转换时的输入/输出</p>
<p>例如:<br><img src="/2020/03/04/formal-language-and-automata/TM1.png" alt="TM"></p>
<ul>
<li>状态转移图有时候也可以用状态转移表表示</li>
</ul>
<h3 id="用图灵机计算函数"><a href="#用图灵机计算函数" class="headerlink" title="用图灵机计算函数"></a>用图灵机计算函数</h3><p>NaN</p>
<h2 id="线性界限自动机LBA"><a href="#线性界限自动机LBA" class="headerlink" title="线性界限自动机LBA"></a>线性界限自动机LBA</h2><p>线性界限自动机(Linear Bounded Automaton)是有限制的图灵机; 它不使用无限纸带，它的纸带有同输入符号数目成正比的空间  </p>
<p>可以证明,LBA 接受上下文有关语言</p>
<h2 id="下推自动机PDA"><a href="#下推自动机PDA" class="headerlink" title="下推自动机PDA"></a>下推自动机PDA</h2><p>下推自动机(Pushdown Automation)可以看成是一个带有附加下推存储器的有穷自动机,下推存储器是一个堆栈,如下:<br><img src="/2020/03/04/formal-language-and-automata/PDA0.png" alt="PDA"></p>
<p>如果把下推自动机扩展，允许一个有限状态自动机存取两个栈，我们得到一个能力更强的自动机，这个自动机与图灵机等价</p>
<h2 id="有穷自动机FA"><a href="#有穷自动机FA" class="headerlink" title="有穷自动机FA"></a>有穷自动机FA</h2><p>有穷自动机(Finity Automation)是具有离散输入和输出系统的一种数学模型,它有有限个内部状态.随着信号的输入,内部状态不断地转移</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>有穷自动机(FA)是一个有序五元组$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$, 其中</p>
<ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times \Sigma \to Q$上的映射,是状态转移函数</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是终结状态集合</li>
</ul>
<p>为了精确描述有穷自动机在输入字符串上的动作,我们推广状态转移函数为$\hat \delta : Q \times \Sigma^* to Q $如下</p>
<blockquote>
<p>对任意的$q \in Q, \omega \in \Sigma^*, a \in \Sigma$都有:<br>$$\hat \delta (q, \epsilon) = q$$  $$\hat \delta (q, \omega a) = \delta (\hat \delta (q, \omega), a)$$<br>即$\hat \delta (q, \omega)$正好是自动机从状态$q$开始扫描完$\omega$所有符号后所处的状态</p>
</blockquote>
<h3 id="有穷自动机接受的语言"><a href="#有穷自动机接受的语言" class="headerlink" title="有穷自动机接受的语言"></a>有穷自动机接受的语言</h3><p>有穷自动机$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$接受的语言$L(M)$为:<br>$$L(M) = \lbrace \omega | \omega \in \Sigma^* , \hat \delta (q_0, \omega) \in F \rbrace$$</p>
<p>由$\delta$定义可知,对于一个确定的状态$q$和输入$a$,输出的次态是唯一的,所以FA在给定字符串上的动作是确定的; 因此上面讲的有穷自动机又叫确定型有穷自动机(DFA)</p>
<h3 id="非确定型有穷自动机NFA"><a href="#非确定型有穷自动机NFA" class="headerlink" title="非确定型有穷自动机NFA"></a>非确定型有穷自动机NFA</h3><p>若在有穷自动机中,FA在输入字符串上的动作是不确定的,那么这种自动机叫做非确定型有穷自动机</p>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>非确定型有穷自动机是一个有序五元组$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$, 其中</p>
<ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times \Sigma \to \rho(Q)$上的映射,$\rho(Q)$表示Q的幂集</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是终结状态集合<br>这样,$\delta (q, a)$就是一个状态集合,它可以含有一个或多个状态,也可以是空集</li>
</ul>
<p>类似地,我们将$\delta$推广成$\hat \delta : Q \times \Sigma^* to \rho(Q)$:</p>
<blockquote>
<p>对任意的$q \in Q, \omega \in \Sigma^*, a \in \Sigma$都有:<br>$$\hat \delta (q, \epsilon) = \lbrace q \rbrace$$  $$\hat \delta (q, \omega a) =\bigcup_{r \in \hat \delta (q, \omega)} \hat \delta (r, a)$$<br>此时$\hat \delta (q, \omega)$表示的是从状态$q$开始扫描完$\omega$所有符号后所有可能的结束状态的集合</p>
</blockquote>
<h4 id="NFA接受的语言"><a href="#NFA接受的语言" class="headerlink" title="NFA接受的语言"></a>NFA接受的语言</h4><p>非确定型有穷自动机$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$接受的语言$L(M)$为:<br>$$L(M) = \lbrace \omega | \omega \in \Sigma^* , \hat \delta (q_0, \omega) \cap F \ne \emptyset \rbrace$$</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li>每一个DFA都可以看成一个特殊的NFA,只要把$\hat \delta (q, \epsilon) = q$看成$\hat \delta (q, \epsilon) = \lbrace q \rbrace$即可  </li>
</ul>
<p>实际上,相比于DFA,非确定性并没有增加NFA的能力,正如下面所述:</p>
<ul>
<li>对每一个非确定型有穷自动机$M$,都存在一个确定型有穷自动机$M’$,使得$L(M) = L(M’)$(证明略)  </li>
</ul>
<p>这种转换方式在此不做介绍</p>
<h3 id="带-epsilon-转移的非确定型有穷自动机"><a href="#带-epsilon-转移的非确定型有穷自动机" class="headerlink" title="带$\epsilon$转移的非确定型有穷自动机"></a>带$\epsilon$转移的非确定型有穷自动机</h3><p>对NFA稍加推广,不仅对$\Sigma$中的每一个符号都可以有状态转移, 而且在不读入任何符号(或者说读入空串$\epsilon$)的情况下,自动机在某些状态下也可以自动转移到另一个状态, 这样的NFA称为带$\epsilon$转移的NFA</p>
<h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>带$\epsilon$转移的非确定型有穷自动机是一个有序五元组$M = &lt;Q, \Sigma, \delta, q_0, F&gt;$, 其中</p>
<ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times (\Sigma \cup \lbrace \epsilon \rbrace) \to \rho(Q)$上的映射,$\rho(Q)$表示Q的幂集</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是终结状态集合</li>
</ul>
<h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><ul>
<li>NFA可以看成是特殊的带$\epsilon$转移的NFA  </li>
</ul>
<p>实际上,带$\epsilon$转移也没有增加NFA的能力:</p>
<ul>
<li>对每一个带$\epsilon$转移的非确定型有穷自动机$M$,都存在一个非确定型有穷自动机$M’$,使得$L(M) = L(M’)$(证明略)  </li>
</ul>
<p>可见,DFA、NFA、带$\epsilon$转移的NFA这三种自动机模型是等价的</p>
<h3 id="有穷自动机和正则文法的等价性"><a href="#有穷自动机和正则文法的等价性" class="headerlink" title="有穷自动机和正则文法的等价性"></a>有穷自动机和正则文法的等价性</h3><ul>
<li>模拟是证明两个计算模型等价的主要方法; 用模型A模拟模型B,就是用模型A实现模型B的计算  </li>
</ul>
<p>可以证明,有穷自动机识别的语言类型恰好是正则语言:</p>
<ul>
<li>对每一个正则语言L,都存在一个带$\epsilon$转移的非确定型有穷自动机$M$使得$L(M) = L$</li>
<li>对每一个带$\epsilon$转移的非确定型有穷自动机$M$,都存在一个右线性文法$G$和左线性文法$G’$使得$L(G) = L(G’)=L(M)$</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown中的公式编辑</title>
    <url>/2020/03/04/markdown-formula-editor/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h3><p>正文(inline)中的LaTeX公式用<code>$...$</code>定义</p>
<p>例如<code>$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$</code></p>
<p>显示为$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$</p>
<h3 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h3><p>单独显示(display)的LaTeX公式用<code>$$...$$</code>定义，此时公式居中并放大显示  </p>
<p>例如<code>$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$</code>   </p>
<p>显示为$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$ </p>
<a id="more"></a>

<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">显示</th>
<th align="center">命令</th>
<th align="center">显示</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\alpha</td>
<td align="center">$\alpha$</td>
<td align="center">A</td>
<td align="center">$A$</td>
</tr>
<tr>
<td align="center">\beta</td>
<td align="center">$\beta$</td>
<td align="center">B</td>
<td align="center">$B$</td>
</tr>
<tr>
<td align="center">\gamma</td>
<td align="center">$\gamma$</td>
<td align="center">\Gamma</td>
<td align="center">$\Gamma$</td>
</tr>
<tr>
<td align="center">\delta</td>
<td align="center">$\delta$</td>
<td align="center">\Delta</td>
<td align="center">$\Delta$</td>
</tr>
<tr>
<td align="center">\epsilon</td>
<td align="center">$\epsilon$</td>
<td align="center">E</td>
<td align="center">$E$</td>
</tr>
<tr>
<td align="center">\zeta</td>
<td align="center">$\zeta$</td>
<td align="center">Z</td>
<td align="center">$Z$</td>
</tr>
<tr>
<td align="center">\eta</td>
<td align="center">$\eta$</td>
<td align="center">H</td>
<td align="center">$H$</td>
</tr>
<tr>
<td align="center">\theta</td>
<td align="center">$\theta$</td>
<td align="center">\Theta</td>
<td align="center">$\Theta$</td>
</tr>
<tr>
<td align="center">\iota</td>
<td align="center">$\iota$</td>
<td align="center">I</td>
<td align="center">$I$</td>
</tr>
<tr>
<td align="center">\kappa</td>
<td align="center">$\kappa$</td>
<td align="center">K</td>
<td align="center">$K$</td>
</tr>
<tr>
<td align="center">\lambda</td>
<td align="center">$\lambda$</td>
<td align="center">\Lambda</td>
<td align="center">$\Lambda$</td>
</tr>
<tr>
<td align="center">\mu</td>
<td align="center">$\mu$</td>
<td align="center">M</td>
<td align="center">$M$</td>
</tr>
<tr>
<td align="center">\nu</td>
<td align="center">$\nu$</td>
<td align="center">N</td>
<td align="center">$N$</td>
</tr>
<tr>
<td align="center">\xi</td>
<td align="center">$\xi$</td>
<td align="center">\Xi</td>
<td align="center">$\Xi$</td>
</tr>
<tr>
<td align="center">\omicron</td>
<td align="center">$\omicron$</td>
<td align="center">O</td>
<td align="center">$O$</td>
</tr>
<tr>
<td align="center">\pi</td>
<td align="center">$\pi$</td>
<td align="center">\Pi</td>
<td align="center">$\Pi$</td>
</tr>
<tr>
<td align="center">\rho</td>
<td align="center">$\rho$</td>
<td align="center">P</td>
<td align="center">$P$</td>
</tr>
<tr>
<td align="center">\sigma</td>
<td align="center">$\sigma$</td>
<td align="center">\Sigma</td>
<td align="center">$\Sigma$</td>
</tr>
<tr>
<td align="center">\tau</td>
<td align="center">$\tau$</td>
<td align="center">T</td>
<td align="center">$T$</td>
</tr>
<tr>
<td align="center">\upsilon</td>
<td align="center">$\upsilon$</td>
<td align="center">Y</td>
<td align="center">$Y$</td>
</tr>
<tr>
<td align="center">\phi</td>
<td align="center">$\phi$</td>
<td align="center">\Phi</td>
<td align="center">$\Phi$</td>
</tr>
<tr>
<td align="center">\chi</td>
<td align="center">$\chi$</td>
<td align="center">X</td>
<td align="center">$X$</td>
</tr>
<tr>
<td align="center">\psi</td>
<td align="center">$\psi$</td>
<td align="center">\Psi</td>
<td align="center">$\Psi$</td>
</tr>
<tr>
<td align="center">\omega</td>
<td align="center">$\omega$</td>
<td align="center">\Omega</td>
<td align="center">$\Omega$</td>
</tr>
</tbody></table>
<h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>上标和下标分别使用<code>^</code>与<code>_</code>，例如<code>$x_i^2$</code>表示的是$x_i^2$  </p>
<p>默认情况下, 上下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>{..}</code> 包裹起来的内容。如果使用<code>$10^10$</code>表示的是$10^10$;而<code>$10^{10}$</code>才是$10^{10}$。同时,大括号还能消除二义性，如<code>x^5^6</code> 将得到一个错误，必须使用大括号来界定^的结合性，如<code>${x^5}^6$</code>:${x^5}^6$或者<code>$x^{5^6}$</code>:$x^{5^6}$。</p>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>使用原始的<code>( )</code>,<code>[ ]</code> 即可，如<code>$(2+3)[4+4]$</code>:$(2+3)[4+4]$<br>使用\left(或\right)使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\left(\frac{x}{y}\right)$</code>:$\left(\frac{x}{y}\right)$</p>
<p>以下转载<a href="https://www.jianshu.com/p/8b6fc36035c0" target="_blank" rel="noopener">https://www.jianshu.com/p/8b6fc36035c0</a></p>
<!DOCTYPE html>
<html lang="en">
<head>
<title></title>
  <meta name="generator" content="hexo-theme-yilia-plus">
<style>
body, html {
    width: 100%;
    height: 100%;
}
*, ::after, ::before {
    -webkit-box-sizing: border-box;
    box-sizing: border-box;
}
article, aside, dialog, figcaption, figure, footer, header, hgroup, main, nav, section {
    display: block;
}
._2rhmJa {
    font-weight: 400;
    line-height: 1.8;
    margin-bottom: 20px;
    padding-right: 50px;
}
._3Z3nHf, .ouvJEz {
    background-color: #fff;
    border-radius: 4px;
    margin-bottom: 10px;
}
.ouvJEz {
    padding: 24px;
}
._gp-ck {
    flex-shrink: 0;
    width: 730px;
    margin-bottom: 24px;
    margin-right: 10px;
}
._3VRLsv {
    box-sizing: content-box;
    padding-left: 16px;
    padding-right: 1000px;
    margin-left: auto;
    margin-right: auto;
}
._3VRLsv {
    justify-content: center;
    align-items: flex-start;
    min-height: calc(-66px + 100vh);
}
._3kbg6I {
    background-color: #f9f9f9;
}
body {
    margin: 0;
    color: rgba(0, 0, 0, 0.65);
    font-size: 14px;
    font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","PingFang SC","Hiragino Sans GB","Microsoft YaHei","Helvetica Neue",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
    line-height: 1.5;
    -webkit-font-feature-settings: "tnum","tnum";
    font-feature-settings: "tnum" 1, "tnum" 1;
}
body {
    line-height: 1.4285;
    color: #404040;
    background-color: #fff;
    font-family: -apple-system,BlinkMacSystemFont,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Segoe UI","PingFang SC","Hiragino Sans GB","Microsoft YaHei","Helvetica Neue",Helvetica,Arial,sans-serif;
    font-feature-settings: "tnum" 1;
    font-variant: tabular-nums;
}
html {
    font-family: sans-serif;
    line-height: 1.15;
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
    -ms-overflow-style: scrollbar;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}
html {
    --antd-wave-shadow-color: #ec7259;
}
p {
    margin-top: 0px;
    margin-bottom: 1em;
}
._2rhmJa p {
    margin-bottom: 20px;
    word-break: break-word;
}
hr {
    -webkit-box-sizing: content-box;
    box-sizing: content-box;
    height: 0px;
    overflow: visible;
}
._2rhmJa hr {
    margin: 0 0 20px;
    border: 0;
    border-top: 1px solid #eee !important;
}
table {
    border-collapse: collapse;
}
._2rhmJa table {
    width: 100%;
    margin-bottom: 20px;
    border-collapse: collapse;
    border: 1px solid #eee;
    border-left: none;
    word-break: break-word;
}
h1, h2, h3, h4, h5, h6 {
    margin-top: 0px;
    margin-bottom: 0.5em;
    color: rgba(0, 0, 0, 0.85);
    font-weight: 500;
}
b, strong {
    font-weight: bolder;
}
b, h1, h2, h3, h4, h5, h6, strong {
    font-weight: 600;
}
h1, h2, h3, h4, h5, h6 {
    color: #404040;
    text-rendering: optimizelegibility;
}
._2rhmJa h1, ._2rhmJa h2, ._2rhmJa h3, ._2rhmJa h4, ._2rhmJa h5, ._2rhmJa h6 {
    margin-bottom: 16px;
}
._2rhmJa h2 {
    font-size: 24px;
}
dl, ol, ul {
    margin-top: 0px;
    margin-bottom: 1em;
}
ol, ul {
    padding-left: 0px;
    margin: 0;
    list-style: none;
}
ol ol, ol ul, ul ol, ul ul {
    margin-bottom: 0px;
}
._2rhmJa ol, ._2rhmJa ul {
    word-break: break-word;
    margin: 0 0 20px 20px;
}
._2rhmJa ul {
    list-style-type: disc;
}
._2Uzcx_ {
    position: relative;
    overflow: hidden;
}
._2rhmJa h3 {
    font-size: 22px;
}
._2rhmJa ol {
    list-style-type: decimal;
}
._2rhmJa table tr:nth-of-type(2n) {
    background-color: hsla(0, 0%, 70%, 0.15);
}
th {
    text-align: inherit;
}
._2rhmJa table td, ._2rhmJa table th {
    padding: 8px;
    border: 1px solid #eee;
    line-height: 20px;
    vertical-align: middle;
}
a {
    color: #ec7259;
    text-decoration: none;
    background-color: transparent;
    outline: none;
    cursor: pointer;
    -webkit-transition: color .3s;
    transition: color .3s;
    -webkit-text-decoration-skip: objects;
}
[role=button], a, area, button, input:not([type=range]), label, select, summary, textarea {
    -ms-touch-action: manipulation;
    touch-action: manipulation;
}
a {
    color: #0681d0;
}
code, kbd, pre, samp {
    font-size: 1em;
    font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
pre {
    margin-top: 0px;
    margin-bottom: 1em;
    overflow: auto;
}
._2rhmJa code {
    padding: 2px 4px;
    border: none;
    vertical-align: middle;
    white-space: pre-wrap;
}
code[class*=language-], pre[class*=language-] {
    color: #ccc;
    background: none;
    font-family: Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;
    font-size: 1em;
    text-align: left;
    white-space: pre;
    word-spacing: normal;
    word-break: normal;
    word-wrap: normal;
    line-height: 1.5;
    -moz-tab-size: 4;
    -o-tab-size: 4;
    tab-size: 4;
    -webkit-hyphens: none;
    -moz-hyphens: none;
    -ms-hyphens: none;
    hyphens: none;
}
pre[class*=language-] {
    padding: 1em;
    margin: .5em 0;
    overflow: auto;
}
:not(pre) > code[class*=language-], pre[class*=language-] {
    background: #2d2d2d;
}
._2rhmJa code, ._2rhmJa pre, ._2rhmJa pre[class*=language-] {
    font-family: Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;
    font-size: 12px;
}
._2rhmJa pre, ._2rhmJa pre[class*=language-] {
    word-wrap: normal;
    word-break: break-all;
    white-space: pre;
    overflow-x: scroll;
    overscroll-behavior-x: contain;
    margin-top: 0px;
    margin-bottom: 20px;
    border-radius: 4px;
    z-index: 0;
    padding: 1em;
    line-height: 1.5;
    color: #ccc;
    background: #2d2d2d;
}
._2rhmJa :not(pre) code {
    color: #c7254e;
    background-color: #f2f2f2;
}
._2rhmJa table th {
    font-weight: bold;
}
._2rhmJa table thead th {
    vertical-align: middle;
    text-align: inherit;
}
img {
    vertical-align: middle;
    border-style: none;
}
._2rhmJa img {
    max-width: 100%;
}
._2rhmJa [mathimg='1'].math-inline {
    display: inline;
    margin: 0 3px;
    vertical-align: middle;
}
._2rhmJa [mathimg='1'].math-block {
    display: block;
    margin: 1em auto;
}
._2rhmJa [mathimg='1'].math-block, ._2rhmJa [mathimg='1'].math-inline {
    max-width: 100%;
}
button, input, optgroup, select, textarea {
    margin: 0;
    color: inherit;
    font-size: inherit;
    font-family: inherit;
    line-height: inherit;
}
button, input {
    overflow: visible;
}
button, select {
    text-transform: none;
}
.VJbwyy {
    position: absolute;
    top: 6px;
    right: 6px;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 32px;
    height: 24px;
    cursor: pointer;
    font-size: 14px;
    padding: 0;
    border: none;
    border-radius: 6px;
    color: #ccc;
    background-color: hsla(0, 0%, 90%, 0.2);
    box-shadow: 0px 2px 0px 0px rgba(0,0,0,0.25);
    opacity: 0;
    visibility: hidden;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    transition: opacity .2s ease-in-out,visibility .2s ease-in-out;
    z-index: 1;
}
[type=reset], [type=submit], button, html [type=button] {
    -webkit-appearance: button;
}
[role=button], button {
    cursor: pointer;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
pre[class*=language-].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}
._2rhmJa pre[class*=language-] code, ._2rhmJa pre code {
    padding: 0;
    background-color: transparent;
    color: inherit;
    white-space: pre;
    vertical-align: unset;
}
pre[class*=language-].line-numbers > code {
    position: relative;
    white-space: inherit;
}
.token.atrule, .token.builtin, .token.important, .token.keyword, .token.selector {
    color: #cc99cd;
}
.token.punctuation {
    color: #ccc;
}
.token.entity, .token.operator, .token.url {
    color: #67cdcc;
}
.token.boolean, .token.function, .token.number {
    color: #f08d49;
}
.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0px;
    font-size: 100%;
    left: -3.8em;
    width: 3em;
    letter-spacing: -1px;
    border-right: 1px solid #999;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
.line-numbers-rows > span {
    pointer-events: none;
    display: block;
    counter-increment: linenumber;
}
.anticon {
    display: inline-block;
    color: inherit;
    font-style: normal;
    line-height: 0;
    text-align: center;
    text-transform: none;
    vertical-align: -0.12em;
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
.anticon > * {
    line-height: 1;
}
svg:not(:root) {
    overflow: hidden;
}
.anticon svg {
    display: inline-block;
}
._2rhmJa ol li, ._2rhmJa ul li {
    line-height: 30px;
}
.token.class-name, .token.constant, .token.property, .token.symbol {
    color: #f8c555;
}
.token.attr-value, .token.char, .token.regex, .token.string, .token.variable {
    color: #7ec699;
}
._2rhmJa ol li ol, ._2rhmJa ol li ul, ._2rhmJa ul li ol, ._2rhmJa ul li ul {
    margin-top: 16px;
}
</style>
</head>
<body><div id="__next"><div class="_21bLU4 _3kbg6I"><div class="_3VRLsv" role="main"><div class="_gp-ck"><section class="ouvJEz"><article class="_2rhmJa">
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">Author</th>
<th style="text-align:left">shaniadolphin</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">e-mail</td>
<td style="text-align:left"><a href="mailto:349948204@qq.com" target="_blank" rel="nofollow">349948204@qq.com</a></td>
</tr>
<tr>
<td style="text-align:center">github</td>
<td style="text-align:left"><a href="https://github.com/shaniadolphin/" target="_blank" rel="nofollow">https://github.com/shaniadolphin/</a></td>
</tr>
</tbody>
</table>
<h3>大括号</h3>
<p>  由于大括号<code>{}</code> 被用于分组，因此需要使用<code>\{</code>和<code>\}</code>表示大括号，也可以使用<code>\lbrace</code> 和<code>\rbrace</code>来表示。如<code>$\{a\*b\}:a\∗b$</code> 或<code>$\lbrace a\*b\rbrace :a\*b$</code> 表示<img class="math-inline" alt="\{a*b\}:a∗b" src="https://math.jianshu.com/math?formula=%5C%7Ba*b%5C%7D%3Aa%E2%88%97b" mathimg="1">。</p>
<h3>尖括号</h3>
<p>  区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<code>$\langle x \rangle$</code> 表示：<img class="math-inline" alt="\langle x \rangle" src="https://math.jianshu.com/math?formula=%5Clangle%20x%20%5Crangle" mathimg="1">。</p>
<h3>上取整</h3>
<p>  使用<code>\lceil</code> 和 <code>\rceil</code> 表示。 如，<code>$\lceil x \rceil$</code>：<img class="math-inline" alt="\lceil x \rceil" src="https://math.jianshu.com/math?formula=%5Clceil%20x%20%5Crceil" mathimg="1">。</p>
<h3>下取整</h3>
<p>  使用<code>\lfloor</code> 和 <code>\rfloor</code> 表示。如，<code>$\lfloor x \rfloor$</code>：<img class="math-inline" alt="\lfloor x \rfloor" src="https://math.jianshu.com/math?formula=%5Clfloor%20x%20%5Crfloor" mathimg="1">。</p>
<h2><strong>求和与积分</strong></h2>
<h3>求和</h3>
<p>  <code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。如:<br>
  <code>$\sum_{r=1}^n$</code>表示：<img class="math-inline" alt="\sum_{r=1}^n" src="https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En" mathimg="1">。<br>
  <code>$$\sum_{r=1}^n$$</code>表示：<img class="math-block" alt="\sum_{r=1}^n" src="https://math.jianshu.com/math?formula=%5Csum_%7Br%3D1%7D%5En" mathimg="1"></p>
<h3>积分</h3>
<p>  <code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<code>$\int_{r=1}^\infty$</code>：<img class="math-inline" alt="\int_{r=1}^\infty" src="https://math.jianshu.com/math?formula=%5Cint_%7Br%3D1%7D%5E%5Cinfty" mathimg="1">。<br>
  多重积分同样使用 <strong>int</strong> ，通过 <strong>i</strong> 的数量表示积分导数：<br>
  <code>$\iint$</code> ：<img class="math-inline" alt="\iint" src="https://math.jianshu.com/math?formula=%5Ciint" mathimg="1"><br>
  <code>$\iiint$</code> ：<img class="math-inline" alt="\iiint" src="https://math.jianshu.com/math?formula=%5Ciiint" mathimg="1"><br>
  <code>$\iiiint$</code> ：<img class="math-inline" alt="\iiiint" src="https://math.jianshu.com/math?formula=%5Ciiiint" mathimg="1"></p>
<h3>连乘</h3>
<p>  <code>$\prod {a+b}$</code>，输出：<img class="math-inline" alt="\prod {a+b}" src="https://math.jianshu.com/math?formula=%5Cprod%20%7Ba%2Bb%7D" mathimg="1">。<br>
  <code>$\prod_{i=1}^{K}$</code>，输出：<img class="math-inline" alt="\prod_{i=1}^{K}" src="https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D" mathimg="1">。<br>
  <code>$$\prod_{i=1}^{K}$$</code>，输出：<img class="math-inline" alt="\prod_{i=1}^{K}" src="https://math.jianshu.com/math?formula=%5Cprod_%7Bi%3D1%7D%5E%7BK%7D" mathimg="1">。</p>
<h3>其他</h3>
<p>  与此类似的符号还有，<br>
  <code>$\prod$</code> ：<img class="math-inline" alt="\prod" src="https://math.jianshu.com/math?formula=%5Cprod" mathimg="1"><br>
  <code>$\bigcup$</code> ：<img class="math-inline" alt="\bigcup" src="https://math.jianshu.com/math?formula=%5Cbigcup" mathimg="1"><br>
  <code>$\bigcap$</code> ：<img class="math-inline" alt="\bigcap" src="https://math.jianshu.com/math?formula=%5Cbigcap" mathimg="1"><br>
  <code>$arg\,\max_{c_k}$</code>：<img class="math-inline" alt="arg\,\max_{c_k}" src="https://math.jianshu.com/math?formula=arg%5C%2C%5Cmax_%7Bc_k%7D" mathimg="1"><br>
  <code>$arg\,\min_{c_k}$</code>：<img class="math-inline" alt="arg\,\min_{c_k}" src="https://math.jianshu.com/math?formula=arg%5C%2C%5Cmin_%7Bc_k%7D" mathimg="1"><br>
  <code>$\mathop {argmin}_{c_k}$</code>：<img class="math-inline" alt="\mathop {argmin}_{c_k}" src="https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmin%7D_%7Bc_k%7D" mathimg="1"><br>
  <code>$\mathop {argmax}_{c_k}$</code>：<img class="math-inline" alt="\mathop {argmax}_{c_k}" src="https://math.jianshu.com/math?formula=%5Cmathop%20%7Bargmax%7D_%7Bc_k%7D" mathimg="1"><br>
  <code>$\max_{c_k}$</code>：<img class="math-inline" alt="\max_{c_k}" src="https://math.jianshu.com/math?formula=%5Cmax_%7Bc_k%7D" mathimg="1"><br>
  <code>$\min_{c_k}$</code>：<img class="math-inline" alt="\min_{c_k}" src="https://math.jianshu.com/math?formula=%5Cmin_%7Bc_k%7D" mathimg="1"></p>
<h2><strong>分式与根式</strong></h2>
<h3>分式</h3>
<ul>
<li>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a</code> ，<code>b</code> ，结果为<img class="math-inline" alt="\frac ab" src="https://math.jianshu.com/math?formula=%5Cfrac%20ab" mathimg="1">。如果你的分子或分母不是单个字符，请使用<code>{..}</code>来分组，比如<code>$\frac {a+c+1}{b+c+2}$</code>表示<img class="math-inline" alt="\frac {a+c+1}{b+c+2}" src="https://math.jianshu.com/math?formula=%5Cfrac%20%7Ba%2Bc%2B1%7D%7Bb%2Bc%2B2%7D" mathimg="1">。</li>
<li>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>{a+1\over b+1}</code>：<img class="math-inline" alt="{a+1\over b+1}" src="https://math.jianshu.com/math?formula=%7Ba%2B1%5Cover%20b%2B1%7D" mathimg="1">
</li>
</ul>
<h3>连分数</h3>
<p>  书写连分数表达式时，请使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>两者效果对比如下：<br>
  <code>\frac</code> 表示如下：</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby"><span class="token variable">$$x</span><span class="token operator">=</span>a_0 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_1 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_2 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_3 <span class="token operator">+</span> \frac <span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_4 <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>$$
<span class="line-numbers-rows" aria-hidden="true"><span></span></span></code></pre></div>
<p>  显示如下：<br>
<img class="math-block" alt="x=a_0 + \frac {1^2}{a_1 + \frac {2^2}{a_2 + \frac {3^2}{a_3 + \frac {4^2}{a_4 + ...}}}}" src="https://math.jianshu.com/math?formula=x%3Da_0%20%2B%20%5Cfrac%20%7B1%5E2%7D%7Ba_1%20%2B%20%5Cfrac%20%7B2%5E2%7D%7Ba_2%20%2B%20%5Cfrac%20%7B3%5E2%7D%7Ba_3%20%2B%20%5Cfrac%20%7B4%5E2%7D%7Ba_4%20%2B%20...%7D%7D%7D%7D" mathimg="1"><br>
  <code>\cfrac</code> 表示如下：</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby"><span class="token variable">$$x</span><span class="token operator">=</span>a_0 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_1 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_2 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_3 <span class="token operator">+</span> \cfrac <span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">{</span>a_4 <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span>$$
<span class="line-numbers-rows" aria-hidden="true"><span></span></span></code></pre></div>
<p>  显示如下：<br>
<img class="math-block" alt="x=a_0 + \cfrac {1^2}{a_1 + \cfrac {2^2}{a_2 + \cfrac {3^2}{a_3 + \cfrac {4^2}{a_4 + ...}}}}" src="https://math.jianshu.com/math?formula=x%3Da_0%20%2B%20%5Ccfrac%20%7B1%5E2%7D%7Ba_1%20%2B%20%5Ccfrac%20%7B2%5E2%7D%7Ba_2%20%2B%20%5Ccfrac%20%7B3%5E2%7D%7Ba_3%20%2B%20%5Ccfrac%20%7B4%5E2%7D%7Ba_4%20%2B%20...%7D%7D%7D%7D" mathimg="1"></p>
<h3>根式</h3>
<p>  根式使用<code>\sqrt</code> 来表示。<br>
  如开4次方：<code>$\sqrt[4]{\frac xy}$</code> ：<img class="math-inline" alt="\sqrt[4]{\frac xy}" src="https://math.jianshu.com/math?formula=%5Csqrt%5B4%5D%7B%5Cfrac%20xy%7D" mathimg="1">。<br>
  开平方：<code>$\sqrt {a+b}$</code>：<img class="math-inline" alt="\sqrt {a+b}" src="https://math.jianshu.com/math?formula=%5Csqrt%20%7Ba%2Bb%7D" mathimg="1">。</p>
<h2><strong>多行表达式</strong></h2>
<h3>分类表达式</h3>
<p>  定义函数的时候经常需要分情况给出表达式，使用<code>\begin{cases}…\end{cases}</code> 。其中：</p>
<ul>
<li>  使用<code>\\</code> 来分类，</li>
<li>  使用<code>&amp;</code> 指示需要对齐的位置，</li>
<li>  使用<code>\</code> +<code>空格</code>表示空格。</li>
</ul>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
f<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
\cfrac n2<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">if</span>\ n\ is\ even\\
<span class="token number">3</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">if</span>\  n\ is\ odd
\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示:<br>
<img class="math-block" alt="f(n) \begin{cases} \cfrac n2, &amp;if\ n\ is\ even\\ 3n + 1, &amp;if\ n\ is\ odd \end{cases}" src="https://math.jianshu.com/math?formula=f(n)%20%5Cbegin%7Bcases%7D%20%5Ccfrac%20n2%2C%20%26if%5C%20n%5C%20is%5C%20even%5C%5C%203n%20%2B%201%2C%20%26if%5C%20n%5C%20is%5C%20odd%20%5Cend%7Bcases%7D" mathimg="1"></p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
<span class="token constant">L</span><span class="token punctuation">(</span><span class="token constant">Y</span><span class="token punctuation">,</span>f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span>
\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> <span class="token operator">=</span> f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>  \\
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> $\neq$ f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示:<br>
<img class="math-block" alt="L(Y,f(X)) = \begin{cases} 0, &amp; \text{Y = f(X)} \\ 1, &amp; \text{Y $\neq$ f(X)} \end{cases}" src="https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D" mathimg="1"><br>
  如果想分类之间的垂直间隔变大，可以使用<code>\\[2ex]</code> 代替<code>\\</code> 来分隔不同的情况。(<code>3ex,4ex</code> 也可以用，<code>1ex</code> 相当于原始距离）。如下所示：</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
<span class="token constant">L</span><span class="token punctuation">(</span><span class="token constant">Y</span><span class="token punctuation">,</span>f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span>
\<span class="token keyword">begin</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
<span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> <span class="token operator">=</span> f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span> \\<span class="token punctuation">[</span><span class="token number">5</span>ex<span class="token punctuation">]</span>
<span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Y</span> $\neq$ f<span class="token punctuation">(</span><span class="token constant">X</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
\<span class="token keyword">end</span><span class="token punctuation">{</span>cases<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="L(Y,f(X)) = \begin{cases} 0, &amp; \text{Y = f(X)} \\[5ex] 1, &amp; \text{Y $\neq$ f(X)} \end{cases}" src="https://math.jianshu.com/math?formula=L(Y%2Cf(X))%20%3D%20%5Cbegin%7Bcases%7D%200%2C%20%26%20%5Ctext%7BY%20%3D%20f(X)%7D%20%5C%5C%5B5ex%5D%201%2C%20%26%20%5Ctext%7BY%20%24%5Cneq%24%20f(X)%7D%20%5Cend%7Bcases%7D" mathimg="1"></p>
<h3>多行表达式</h3>
<p>  有时候需要将一行公式分多行进行显示。</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>\<span class="token keyword">begin</span><span class="token punctuation">{</span>split<span class="token punctuation">}</span> 
a<span class="token operator">&amp;</span><span class="token operator">=</span>b<span class="token operator">+</span>c<span class="token operator">-</span>d \\ 
<span class="token operator">&amp;</span>\quad <span class="token operator">+</span>e<span class="token operator">-</span>f\\ 
<span class="token operator">&amp;</span><span class="token operator">=</span>g<span class="token operator">+</span>h\\ 
<span class="token operator">&amp;</span> <span class="token operator">=</span>i 
\<span class="token keyword">end</span><span class="token punctuation">{</span>split<span class="token punctuation">}</span>\<span class="token keyword">end</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="\begin{equation}\begin{split} a&amp;=b+c-d \\ &amp;\quad +e-f\\ &amp;=g+h\\ &amp; =i \end{split}\end{equation}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%5Cbegin%7Bsplit%7D%20a%26%3Db%2Bc-d%20%5C%5C%20%26%5Cquad%20%2Be-f%5C%5C%20%26%3Dg%2Bh%5C%5C%20%26%20%3Di%20%5Cend%7Bsplit%7D%5Cend%7Bequation%7D" mathimg="1"><br>
  其中<code>begin{equation}</code> 表示开始方程，<code>end{equation}</code> 表示方程结束；<code>begin{split}</code> 表示开始多行公式，<code>end{split}</code> 表示结束；公式中用<code>\\</code> 表示回车到下一行，<code>&amp;</code> 表示对齐的位置。</p>
<h3>方程组</h3>
<p>  使用<code>\begin{array}...\end{array}</code> 与<code>\left \{</code> 与<code>\right.</code> 配合表示方程组:</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\left \<span class="token punctuation">{</span> 
\<span class="token keyword">begin</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token punctuation">}</span>
a_1x<span class="token operator">+</span>b_1y<span class="token operator">+</span>c_1z<span class="token operator">=</span>d_1 \\ 
a_2x<span class="token operator">+</span>b_2y<span class="token operator">+</span>c_2z<span class="token operator">=</span>d_2 \\ 
a_3x<span class="token operator">+</span>b_3y<span class="token operator">+</span>c_3z<span class="token operator">=</span>d_3
\<span class="token keyword">end</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span>
\right<span class="token punctuation">.</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="\left \{ \begin{array}{c} a_1x+b_1y+c_1z=d_1 \\ a_2x+b_2y+c_2z=d_2 \\ a_3x+b_3y+c_3z=d_3 \end{array} \right." src="https://math.jianshu.com/math?formula=%5Cleft%20%5C%7B%20%5Cbegin%7Barray%7D%7Bc%7D%20a_1x%2Bb_1y%2Bc_1z%3Dd_1%20%5C%5C%20a_2x%2Bb_2y%2Bc_2z%3Dd_2%20%5C%5C%20a_3x%2Bb_3y%2Bc_3z%3Dd_3%20%5Cend%7Barray%7D%20%5Cright." mathimg="1"><br>
  注意：通常MathJax通过内部策略自己管理公式内部的空间，因此<code>a…b</code> 与<code>a…….b</code> （<code>.</code>表示空格）都会显示为<code>ab</code> 。可以通过在<code>ab</code> 间加入<code>\</code> ,增加些许间隙，<code>\;</code> 增加较宽的间隙，<code>\quad</code>  与<code>\qquad</code> 会增加更大的间隙。</p>
<h2><strong>特殊函数与符号</strong></h2>
<h3>三角函数</h3>
<p>  <code>\snx$</code> : <img class="math-inline" alt="sinx" src="https://math.jianshu.com/math?formula=sinx" mathimg="1"><br>
  <code>\arctanx</code> : <img class="math-inline" alt="arctanx" src="https://math.jianshu.com/math?formula=arctanx" mathimg="1"></p>
<h3>比较运算符</h3>
<p>  小于(<code>\lt</code> )：<img class="math-inline" alt="\lt" src="https://math.jianshu.com/math?formula=%5Clt" mathimg="1"><br>
  大于(<code>\gt</code> )：<img class="math-inline" alt="\gt" src="https://math.jianshu.com/math?formula=%5Cgt" mathimg="1"><br>
  小于等于(<code>\le</code> )：<img class="math-inline" alt="\le" src="https://math.jianshu.com/math?formula=%5Cle" mathimg="1"><br>
  大于等于(<code>\ge</code> )：<img class="math-inline" alt="\ge" src="https://math.jianshu.com/math?formula=%5Cge" mathimg="1"><br>
  不等于(<code>\ne</code> ) : <img class="math-inline" alt="\ne" src="https://math.jianshu.com/math?formula=%5Cne" mathimg="1"><br>
  可以在这些运算符前面加上<code>\not</code> ，如<code>\not\lt</code> : <img class="math-inline" alt="\not\lt`" src="https://math.jianshu.com/math?formula=%5Cnot%5Clt%60" mathimg="1"></p>
<h3>集合关系与运算</h3>
<p>  并集(<code>\cup</code> ): <img class="math-inline" alt="\cup" src="https://math.jianshu.com/math?formula=%5Ccup" mathimg="1"><br>
  交集(<code>\cap</code> ): <img class="math-inline" alt="\cap" src="https://math.jianshu.com/math?formula=%5Ccap" mathimg="1"><br>
  差集(<code>\setminus</code> ): <img class="math-inline" alt="\setminus" src="https://math.jianshu.com/math?formula=%5Csetminus" mathimg="1"><br>
  子集(<code>\subset</code> ): <img class="math-inline" alt="\subset" src="https://math.jianshu.com/math?formula=%5Csubset" mathimg="1"><br>
  子集(<code>\subseteq</code> ): <img class="math-inline" alt="\subseteq" src="https://math.jianshu.com/math?formula=%5Csubseteq" mathimg="1"><br>
  非子集(<code>\subsetneq</code> ): <img class="math-inline" alt="\subsetneq" src="https://math.jianshu.com/math?formula=%5Csubsetneq" mathimg="1"><br>
  父集(<code>\supset</code> ): <img class="math-inline" alt="\supset" src="https://math.jianshu.com/math?formula=%5Csupset" mathimg="1"><br>
  属于(<code>\in</code> ): <img class="math-inline" alt="\in" src="https://math.jianshu.com/math?formula=%5Cin" mathimg="1"><br>
  不属于(<code>\notin</code> ): <img class="math-inline" alt="\notin" src="https://math.jianshu.com/math?formula=%5Cnotin" mathimg="1"><br>
  空集(<code>\emptyset</code> ): <img class="math-inline" alt="\emptyset" src="https://math.jianshu.com/math?formula=%5Cemptyset" mathimg="1"><br>
  空(<code>\varnothing</code> ): <img class="math-inline" alt="\varnothing" src="https://math.jianshu.com/math?formula=%5Cvarnothing" mathimg="1"></p>
<h3>排列</h3>
<p>  <code>\binom{n+1}{2k}</code> : <img class="math-inline" alt="\binom{n+1}{2k}" src="https://math.jianshu.com/math?formula=%5Cbinom%7Bn%2B1%7D%7B2k%7D" mathimg="1"><br>
  <code>{n+1 \choose 2k}</code> : <img class="math-inline" alt="{n+1 \choose 2k}" src="https://math.jianshu.com/math?formula=%7Bn%2B1%20%5Cchoose%202k%7D" mathimg="1"></p>
<h3>箭头</h3>
<p>  (<code>\to</code> ):<img class="math-inline" alt="\to" src="https://math.jianshu.com/math?formula=%5Cto" mathimg="1"><br>
  (<code>\rightarrow</code> ): <img class="math-inline" alt="\rightarrow" src="https://math.jianshu.com/math?formula=%5Crightarrow" mathimg="1"><br>
  (<code>\leftarrow</code> ): <img class="math-inline" alt="\leftarrow" src="https://math.jianshu.com/math?formula=%5Cleftarrow" mathimg="1"><br>
  (<code>\Rightarrow</code> ): <img class="math-inline" alt="\Rightarrow" src="https://math.jianshu.com/math?formula=%5CRightarrow" mathimg="1"><br>
  (<code>\Leftarrow</code> ): <img class="math-inline" alt="\Leftarrow" src="https://math.jianshu.com/math?formula=%5CLeftarrow" mathimg="1"><br>
  (<code>\mapsto</code> ): <img class="math-inline" alt="\mapsto" src="https://math.jianshu.com/math?formula=%5Cmapsto" mathimg="1"></p>
<h3>逻辑运算符</h3>
<p>  (<code>\land</code> ): <img class="math-inline" alt="\land" src="https://math.jianshu.com/math?formula=%5Cland" mathimg="1"><br>
  (<code>\lor</code> ): <img class="math-inline" alt="\lor" src="https://math.jianshu.com/math?formula=%5Clor" mathimg="1"><br>
  (<code>\lnot</code> ): <img class="math-inline" alt="\lnot" src="https://math.jianshu.com/math?formula=%5Clnot" mathimg="1"><br>
  (<code>\forall</code> ): <img class="math-inline" alt="\forall" src="https://math.jianshu.com/math?formula=%5Cforall" mathimg="1"><br>
  (<code>\exists</code> ): <img class="math-inline" alt="\exists" src="https://math.jianshu.com/math?formula=%5Cexists" mathimg="1"><br>
  (<code>\top</code> ): <img class="math-inline" alt="\top" src="https://math.jianshu.com/math?formula=%5Ctop" mathimg="1"><br>
  (<code>\bot</code> ): <img class="math-inline" alt="\bot" src="https://math.jianshu.com/math?formula=%5Cbot" mathimg="1"><br>
  (<code>\vdash</code> ): <img class="math-inline" alt="\vdash" src="https://math.jianshu.com/math?formula=%5Cvdash" mathimg="1"><br>
  (<code>\vDash</code> ): <img class="math-inline" alt="\vDash" src="https://math.jianshu.com/math?formula=%5CvDash" mathimg="1"></p>
<h3>操作符</h3>
<p>  (<code>\star</code> ): <img class="math-inline" alt="\star" src="https://math.jianshu.com/math?formula=%5Cstar" mathimg="1"><br>
  (<code>\ast</code> ): <img class="math-inline" alt="\ast" src="https://math.jianshu.com/math?formula=%5Cast" mathimg="1"><br>
  (<code>\oplus</code> ): <img class="math-inline" alt="\oplus" src="https://math.jianshu.com/math?formula=%5Coplus" mathimg="1"><br>
  (<code>\circ</code> ): <img class="math-inline" alt="\circ" src="https://math.jianshu.com/math?formula=%5Ccirc" mathimg="1"><br>
  (<code>\bullet</code> ): <img class="math-inline" alt="\bullet" src="https://math.jianshu.com/math?formula=%5Cbullet" mathimg="1"></p>
<h3>等于</h3>
<p>  (<code>\approx</code> ): <img class="math-inline" alt="\approx" src="https://math.jianshu.com/math?formula=%5Capprox" mathimg="1"><br>
  (<code>\sim</code> ): <img class="math-inline" alt="\sim" src="https://math.jianshu.com/math?formula=%5Csim" mathimg="1"><br>
  (<code>\equiv</code> ): <img class="math-inline" alt="\equiv" src="https://math.jianshu.com/math?formula=%5Cequiv" mathimg="1"><br>
  (<code>\prec</code> ): <img class="math-inline" alt="\prec" src="https://math.jianshu.com/math?formula=%5Cprec" mathimg="1"></p>
<h3>范围</h3>
<p>  (<code>\infty</code> ): <img class="math-inline" alt="\infty" src="https://math.jianshu.com/math?formula=%5Cinfty" mathimg="1"><br>
  (<code>\aleph_o</code> ): <img class="math-inline" alt="\aleph_o" src="https://math.jianshu.com/math?formula=%5Caleph_o" mathimg="1"><br>
  (<code>\nabla</code> ): <img class="math-inline" alt="\nabla" src="https://math.jianshu.com/math?formula=%5Cnabla" mathimg="1"><br>
  (<code>\Im</code> ): <img class="math-inline" alt="\Im" src="https://math.jianshu.com/math?formula=%5CIm" mathimg="1"><br>
  (<code>\Re</code> ): <img class="math-inline" alt="\Re" src="https://math.jianshu.com/math?formula=%5CRe" mathimg="1"></p>
<h3>模运算</h3>
<p>  (<code>\pmod</code> ): <img class="math-inline" alt="b \pmod n" src="https://math.jianshu.com/math?formula=b%20%5Cpmod%20n" mathimg="1"><br>
  如<code>a \equiv b \pmod n</code> : <img class="math-inline" alt="a \equiv b \pmod n" src="https://math.jianshu.com/math?formula=a%20%5Cequiv%20b%20%5Cpmod%20n" mathimg="1"></p>
<h3>点</h3>
<p>  (<code>\ldots</code> ): <img class="math-inline" alt="\ldots" src="https://math.jianshu.com/math?formula=%5Cldots" mathimg="1"><br>
  (<code>\cdots</code> ): <img class="math-inline" alt="\cdots" src="https://math.jianshu.com/math?formula=%5Ccdots" mathimg="1"><br>
  (<code>\cdot</code> ): <img class="math-inline" alt="\cdot" src="https://math.jianshu.com/math?formula=%5Ccdot" mathimg="1"><br>
  其区别是点的位置不同，<code>\ldots</code> 位置稍低，<code>\cdots</code> 位置居中。</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>
a_1<span class="token operator">+</span>a_2<span class="token operator">+</span>\ldots<span class="token operator">+</span>a_n \\ 
a_1<span class="token operator">+</span>a_2<span class="token operator">+</span>\cdots<span class="token operator">+</span>a_n
\<span class="token keyword">end</span><span class="token punctuation">{</span>equation<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="\begin{equation} a_1+a_2+\ldots+a_n \\ a_1+a_2+\cdots+a_n \end{equation}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bequation%7D%20a_1%2Ba_2%2B%5Cldots%2Ba_n%20%5C%5C%20a_1%2Ba_2%2B%5Ccdots%2Ba_n%20%5Cend%7Bequation%7D" mathimg="1"></p>
<h2><strong>顶部符号</strong></h2>
<p>  对于单字符，<code>\hat x</code> ：<img class="math-inline" alt="\hat x" src="https://math.jianshu.com/math?formula=%5Chat%20x" mathimg="1"><br>
  多字符可以使用<code>\widehat {xy}</code> ：<img class="math-inline" alt="\widehat {xy}" src="https://math.jianshu.com/math?formula=%5Cwidehat%20%7Bxy%7D" mathimg="1"><br>
  类似的还有:<br>
  (<code>\overline x</code> ): <img class="math-inline" alt="\overline x" src="https://math.jianshu.com/math?formula=%5Coverline%20x" mathimg="1"><br>
  矢量(<code>\vec</code> ): <img class="math-inline" alt="\vec x" src="https://math.jianshu.com/math?formula=%5Cvec%20x" mathimg="1"><br>
  向量(<code>\overrightarrow {xy}</code> ): <img class="math-inline" alt="\overrightarrow {xy}" src="https://math.jianshu.com/math?formula=%5Coverrightarrow%20%7Bxy%7D" mathimg="1"><br>
  (<code>\dot x</code> ): <img class="math-inline" alt="\dot x" src="https://math.jianshu.com/math?formula=%5Cdot%20x" mathimg="1"><br>
  (<code>\ddot x</code> ): <img class="math-inline" alt="\ddot x" src="https://math.jianshu.com/math?formula=%5Cddot%20x" mathimg="1"><br>
  (<code>\dot {\dot x}</code> ): <img class="math-inline" alt="\dot {\dot x}" src="https://math.jianshu.com/math?formula=%5Cdot%20%7B%5Cdot%20x%7D" mathimg="1"></p>
<h2><strong>表格</strong></h2>
<p>  使用<code>\begin{array}{列样式}…\end{array}</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\hline</code> 在本行前加入一条直线。 例如:</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span><span class="token punctuation">{</span>c<span class="token operator">|</span>lcr<span class="token punctuation">}</span>
n <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Left</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Center</span><span class="token punctuation">}</span> <span class="token operator">&amp;</span> \text<span class="token punctuation">{</span><span class="token constant">Right</span><span class="token punctuation">}</span> \\
\hline
<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">0.24</span> <span class="token operator">&amp;</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">125</span> \\
<span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">189</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">8</span> \\
<span class="token number">3</span> <span class="token operator">&amp;</span> <span class="token operator">-</span><span class="token number">20</span> <span class="token operator">&amp;</span> <span class="token number">2000</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token operator">+</span><span class="token number">10</span>i \\
\<span class="token keyword">end</span><span class="token punctuation">{</span>array<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  得到：<br>
<img class="math-block" alt="\begin{array}{c|lcr} n &amp; \text{Left} &amp; \text{Center} &amp; \text{Right} \\ \hline 1 &amp; 0.24 &amp; 1 &amp; 125 \\ 2 &amp; -1 &amp; 189 &amp; -8 \\ 3 &amp; -20 &amp; 2000 &amp; 1+10i \\ \end{array}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Barray%7D%7Bc%7Clcr%7D%20n%20%26%20%5Ctext%7BLeft%7D%20%26%20%5Ctext%7BCenter%7D%20%26%20%5Ctext%7BRight%7D%20%5C%5C%20%5Chline%201%20%26%200.24%20%26%201%20%26%20125%20%5C%5C%202%20%26%20-1%20%26%20189%20%26%20-8%20%5C%5C%203%20%26%20-20%20%26%202000%20%26%201%2B10i%20%5C%5C%20%5Cend%7Barray%7D" mathimg="1"></p>
<h2><strong>矩阵</strong></h2>
<h3>基本内容</h3>
<p>  使用<code>\begin{matrix}…\end{matrix}</code> 这样的形式来表示矩阵，在<code>\begin</code> 与<code>\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\</code> 分隔，列之间使用<code>&amp;</code> 分隔，例如:</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>
<span class="token number">1</span> <span class="token operator">&amp;</span> x <span class="token operator">&amp;</span> x<span class="token operator">^</span><span class="token number">2</span> \\
<span class="token number">1</span> <span class="token operator">&amp;</span> y <span class="token operator">&amp;</span> y<span class="token operator">^</span><span class="token number">2</span> \\
<span class="token number">1</span> <span class="token operator">&amp;</span> z <span class="token operator">&amp;</span> z<span class="token operator">^</span><span class="token number">2</span> \\
\<span class="token keyword">end</span><span class="token punctuation">{</span>matrix<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  得到：<br>
<img class="math-block" alt="\begin{matrix} 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \\ \end{matrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bmatrix%7D%201%20%26%20x%20%26%20x%5E2%20%5C%5C%201%20%26%20y%20%26%20y%5E2%20%5C%5C%201%20%26%20z%20%26%20z%5E2%20%5C%5C%20%5Cend%7Bmatrix%7D" mathimg="1"></p>
<h3>括号</h3>
<p>  如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\left</code> 与<code>\right</code> 配合表示括号符号。也可以使用特殊的<code>matrix</code> 。即替换<code>\begin{matrix}…\end{matrix}</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p>
<ol>
<li>pmatrix<code>$\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}$</code> : <img class="math-inline" alt="\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{pmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bpmatrix%7D" mathimg="1">
</li>
<li>bmatrix<code>$\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}$</code> : <img class="math-inline" alt="\begin{bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{bmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bbmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bbmatrix%7D" mathimg="1">
</li>
<li>Bmatrix<code>$\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}$</code> : <img class="math-inline" alt="\begin{Bmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Bmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7BBmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7BBmatrix%7D" mathimg="1">
</li>
<li>vmatrix<code>$\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}$</code> : <img class="math-inline" alt="\begin{vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{vmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bvmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7Bvmatrix%7D" mathimg="1">
</li>
<li>Vmatrix<code>$\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}$</code> : <img class="math-inline" alt="\begin{Vmatrix}1 &amp; 2 \\ 3 &amp; 4\\ \end{Vmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7BVmatrix%7D1%20%26%202%20%5C%5C%203%20%26%204%5C%5C%20%5Cend%7BVmatrix%7D" mathimg="1">
</li>
</ol>
<h3>元素省略</h3>
<p>  可以使用<code>\cdots</code> ：⋯，<code>\ddots</code>：⋱ ，<code>\vdots</code>：⋮ 来省略矩阵中的元素，如：</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-ruby"><code class="  language-ruby">$$
\<span class="token keyword">begin</span><span class="token punctuation">{</span>pmatrix<span class="token punctuation">}</span>
<span class="token number">1</span><span class="token operator">&amp;</span>a_1<span class="token operator">&amp;</span>a_1<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_1<span class="token operator">^</span>n\\
<span class="token number">1</span><span class="token operator">&amp;</span>a_2<span class="token operator">&amp;</span>a_2<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_2<span class="token operator">^</span>n\\
\vdots<span class="token operator">&amp;</span>\vdots<span class="token operator">&amp;</span>\vdots<span class="token operator">&amp;</span>\ddots<span class="token operator">&amp;</span>\vdots\\
<span class="token number">1</span><span class="token operator">&amp;</span>a_m<span class="token operator">&amp;</span>a_m<span class="token operator">^</span><span class="token number">2</span><span class="token operator">&amp;</span>\cdots<span class="token operator">&amp;</span>a_m<span class="token operator">^</span>n\\
\<span class="token keyword">end</span><span class="token punctuation">{</span>pmatrix<span class="token punctuation">}</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>  表示：<br>
<img class="math-block" alt="\begin{pmatrix} 1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\ 1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n\\ \vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ 1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_m^n\\ \end{pmatrix}" src="https://math.jianshu.com/math?formula=%5Cbegin%7Bpmatrix%7D%201%26a_1%26a_1%5E2%26%5Ccdots%26a_1%5En%5C%5C%201%26a_2%26a_2%5E2%26%5Ccdots%26a_2%5En%5C%5C%20%5Cvdots%26%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C%201%26a_m%26a_m%5E2%26%5Ccdots%26a_m%5En%5C%5C%20%5Cend%7Bpmatrix%7D" mathimg="1"></p>
<h3>增广矩阵</h3>
<p>  增广矩阵需要使用前面的表格中使用到的<code>\begin{array} ... \end{array}</code> 来实现。</p>
<div class="_2Uzcx_"><button class="VJbwyy" aria-label="复制代码" type="button"><i class="anticon anticon-copy" aria-label="icon: copy"><svg xmlns="http://www.w3.org/2000/svg" class="" aria-hidden="true" fill="currentColor" viewbox="64 64 896 896" focusable="false" width="1em" height="1em" data-icon="copy"><path d="M 832 64 H 296 c -4.4 0 -8 3.6 -8 8 v 56 c 0 4.4 3.6 8 8 8 h 496 v 688 c 0 4.4 3.6 8 8 8 h 56 c 4.4 0 8 -3.6 8 -8 V 96 c 0 -17.7 -14.3 -32 -32 -32 Z M 704 192 H 192 c -17.7 0 -32 14.3 -32 32 v 530.7 c 0 8.5 3.4 16.6 9.4 22.6 l 173.3 173.3 c 2.2 2.2 4.7 4 7.4 5.5 v 1.9 h 4.2 c 3.5 1.3 7.2 2 11 2 H 704 c 17.7 0 32 -14.3 32 -32 V 224 c 0 -17.7 -14.3 -32 -32 -32 Z M 350 856.2 L 263.9 770 H 350 v 86.2 Z M 664 888 H 414 V 746 c 0 -22.1 -17.9 -40 -40 -40 H 232 V 264 h 432 v 624 Z"/></svg></i></button><pre class="line-numbers  language-swift"><code class="  language-swift">$$
\<span class="token keyword">left</span><span class="token punctuation">[</span>  \begin<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  <span class="token punctuation">{</span>c c <span class="token operator">|</span> c<span class="token punctuation">}</span> <span class="token operator">%</span>这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示<span class="token number">2</span>、<span class="token number">3</span>列间插入竖线
<span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">2</span> <span class="token operator">&amp;</span> <span class="token number">3</span> \\
\hline <span class="token operator">%</span>插入横线，如果去掉\hline就是增广矩阵
<span class="token number">4</span> <span class="token operator">&amp;</span> <span class="token number">5</span> <span class="token operator">&amp;</span> <span class="token number">6</span>
\end<span class="token punctuation">{</span>array<span class="token punctuation">}</span>  \<span class="token keyword">right</span><span class="token punctuation">]</span>
$$
<span class="line-numbers-rows" aria-hidden="true"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p>显示为：<br>
<img class="math-block" alt="\left[ \begin{array} {c c | c} 1 &amp; 2 &amp; 3 \\ \hline 4 &amp; 5 &amp; 6 \end{array} \right]" src="https://math.jianshu.com/math?formula=%5Cleft%5B%20%5Cbegin%7Barray%7D%20%7Bc%20c%20%7C%20c%7D%201%20%26%202%20%26%203%20%5C%5C%20%5Chline%204%20%26%205%20%26%206%20%5Cend%7Barray%7D%20%5Cright%5D" mathimg="1"></p>
<h2><strong>公式标记与引用</strong></h2>
<p>  使用<code>\tag{yourtag}</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\label{yourlabel}</code> 在<code>\tag</code> 之后，如<code>$$a = x^2 - y^3 \tag{1}\label{1}$$</code> 显示为：<br>
<img class="math-block" alt="a := x^2 - y^3 \tag{1}\label{311}" src="https://math.jianshu.com/math?formula=a%20%3A%3D%20x%5E2%20-%20y%5E3%20%5Ctag%7B1%7D%5Clabel%7B311%7D" mathimg="1"><br>
  如果不需要被引用，只使用<code>\tag{yourtag}</code> ，<code>$$x+y=z\tag{1.1}$$</code>显示为：<br>
<img class="math-block" alt="x+y=z\tag{1.1}" src="https://math.jianshu.com/math?formula=x%2By%3Dz%5Ctag%7B1.1%7D" mathimg="1"><br>
  <code>\tab{yourtab}</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\label{}</code> 设置的内容来引用。为了引用公式，可以使用<code>\eqref{yourlabel}</code> ，如<code>$$a + y^3 \stackrel{\eqref{1}}= x^2$$</code> 显示为：<br>
<img class="math-block" alt="a + y^3 \stackrel{\eqref{1}}= x^2" src="https://math.jianshu.com/math?formula=a%20%2B%20y%5E3%20%5Cstackrel%7B%5Ceqref%7B1%7D%7D%3D%20x%5E2" mathimg="1"></p>
<p>或者使用<code>\ref{yourlabel}</code> 不带括号引用，如<code>$$a + y^3 \stackrel{\ref{111}}= x^2$$</code> 显示为:<br>
<img class="math-block" alt="a + y^3 \stackrel{\ref{1}}= x^2" src="https://math.jianshu.com/math?formula=a%20%2B%20y%5E3%20%5Cstackrel%7B%5Cref%7B1%7D%7D%3D%20x%5E2" mathimg="1"></p>
<h2><strong>字体</strong></h2>
<h3>黑板粗体字</h3>
<p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br>
<code>$\mathbb ABCDEF$</code>：<img class="math-inline" alt="\mathbb ABCDEF" src="https://math.jianshu.com/math?formula=%5Cmathbb%20ABCDEF" mathimg="1"><br>
<code>$\Bbb ABCDEF$</code>：<img class="math-inline" alt="\Bbb ABCDEF" src="https://math.jianshu.com/math?formula=%5CBbb%20ABCDEF" mathimg="1"></p>
<h3>黑体字</h3>
<p><code>$\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img class="math-inline" alt="\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ" src="https://math.jianshu.com/math?formula=%5Cmathbf%20ABCDEFGHIJKLMNOPQRSTUVWXYZ" mathimg="1"><br>
<code>$\mathbf abcdefghijklmnopqrstuvwxyz$</code> :<img class="math-inline" alt="\mathbf abcdefghijklmnopqrstuvwxyz" src="https://math.jianshu.com/math?formula=%5Cmathbf%20abcdefghijklmnopqrstuvwxyz" mathimg="1"></p>
<h3>打印机字体</h3>
<p><code>$\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</code> :<img class="math-inline" alt="\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ" src="https://math.jianshu.com/math?formula=%5Cmathtt%20ABCDEFGHIJKLMNOPQRSTUVWXYZ" mathimg="1"></p>
<h2><strong>参考文档</strong></h2>
<table>
<thead>
<tr>
<th>#</th>
<th>链接地址</th>
<th>文档名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>blog.csdn.net/dabokele/article/details/79577072</code></td>
<td><a href="https://blog.csdn.net/dabokele/article/details/79577072" target="_blank" rel="nofollow">Mathjax公式教程</a></td>
</tr>
<tr>
<td>2</td>
<td><code>blog.csdn.net/ethmery/article/details/50670297</code></td>
<td><a href="https://blog.csdn.net/ethmery/article/details/50670297" target="_blank" rel="nofollow">基本数学公式语法</a></td>
</tr>
<tr>
<td>3</td>
<td><code>blog.csdn.net/lilongsy/article/details/79378620</code></td>
<td><a href="https://blog.csdn.net/lilongsy/article/details/79378620" target="_blank" rel="nofollow">常用数学符号的LaTeX表示方法</a></td>
</tr>
<tr>
<td>4</td>
<td><code>www.mathjax.org</code></td>
<td><a href="https://www.mathjax.org/" target="_blank" rel="nofollow">Beautiful math in all browsers</a></td>
</tr>
</tbody>
</table>
</article></section></div></div></div></div></body>
</html>











]]></content>
      <categories>
        <category>instructions</category>
        <category>notes</category>
      </categories>
      <tags>
        <tag>instructions</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>python多线程、多进程</title>
    <url>/2020/03/04/python-multithreading/</url>
    <content><![CDATA[<p>浅尝辄止,能用就行</p>
<hr>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock() <span class="comment"># 设置一个全局线程锁,某个线程在获得此锁之后其他线程不能再获得</span></span><br><span class="line"></span><br><span class="line">sem = threading.Semaphore(<span class="number">12</span>) <span class="comment"># 设置最大线程数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> sem:</span><br><span class="line">    t = threading.Thread(target=function,args=(a,b,c))  <span class="comment"># 用function(a,b,c)创建一个线程</span></span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)   <span class="comment">#   设置t线程为主线程的守护线程,即主线程结束后会自动杀死子线程(默认为false)</span></span><br><span class="line">    t.start()   <span class="comment"># 启动线程</span></span><br><span class="line">    t.join(<span class="number">60</span>)  <span class="comment"># 线程同步，主线程任务结束之后，进入阻塞状态，一直等待其他的子线程执行结束之后，主线程再终止;如果超时主线程也会终止(默认为无)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#   若在function中执行lock.acquire(),则线程阻塞直到其他线程释放此锁</span></span><br><span class="line"><span class="comment">#   function中执行完lock.acquire()后必须进行lock.release(),否则其他线程将永远无法获得此锁</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>多进程与多线程运用方式相仿</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line">lock = multiprocessing.Lock()   <span class="comment"># 设置一个全局进程锁,某个进程在获得此锁之后其他进程不能再获得</span></span><br><span class="line"></span><br><span class="line">p = multiprocessing.Pool(<span class="number">72</span>)    <span class="comment"># 建立一个进程池,设置最大的进程数量</span></span><br><span class="line"></span><br><span class="line">p.apply_async(func=function,args=(a,))  <span class="comment"># 用function(a)创建一个进程</span></span><br><span class="line"></span><br><span class="line">p.close()   <span class="comment">#   关闭进程池,不再接受新的进程</span></span><br><span class="line">p.join()    <span class="comment">#   主进程阻塞,等待其他进程结束</span></span><br></pre></td></tr></table></figure>

<p>注: windows中多线程的代码应当写道<code>if __name__ == &#39;main&#39;</code>中</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>python spider</title>
    <url>/2020/03/04/python-spider/</url>
    <content><![CDATA[<p>烂尾中…</p>
<hr>
<p>资料主要来源于北理工的<a href="https://www.icourse163.org/learn/BIT-1001870001?tid=1206951268#" target="_blank" rel="noopener">爬虫课程</a><br>有requests库、beautifulsoup库、scrapy框架等</p>
<h2 id="request库"><a href="#request库" class="headerlink" title="request库"></a>request库</h2><p><code>import requests</code></p>
<h3 id="request"><a href="#request" class="headerlink" title="request."></a>request.</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.request()</span><br><span class="line">.get() 获取网页</span><br><span class="line">.head() 获取网页头</span><br><span class="line">.post() 提交post请求</span><br><span class="line">.put() 提交put请求</span><br><span class="line">.patch() 提交局部修改请求</span><br><span class="line">.delete() 提交删除请求</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="关于url"><a href="#关于url" class="headerlink" title="关于url"></a>关于url</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url:http:&#x2F;&#x2F;host[:port][path]</span><br><span class="line">http协议资源操作：</span><br><span class="line">GET 请求获取url位置的资源</span><br><span class="line">HEAD 获取url资源头部信息</span><br><span class="line">POST 请求向资源后附加的新数据</span><br><span class="line">PUT 请求向url位置存储资源，覆盖原有url位置资源</span><br><span class="line">PATCH 请求向资源进行局部更新</span><br><span class="line">DELETE 请求删除资源</span><br></pre></td></tr></table></figure>


<h3 id="request-get-url"><a href="#request-get-url" class="headerlink" title="request.get(url)"></a>request.get(url)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r=requests.get(<span class="string">'http://www.baidu.com'</span>,) <span class="comment">#Response</span></span><br><span class="line"></span><br><span class="line">r.status_code-&gt;200/404</span><br><span class="line">r.text-&gt;string text</span><br><span class="line">r.encodonig-&gt;header enconding</span><br><span class="line">r.apparent_encoding-&gt;text encoding</span><br><span class="line">r.content-&gt;binary text</span><br><span class="line">r.headers</span><br><span class="line"></span><br><span class="line">r.raise_for_status(</span><br><span class="line"></span><br><span class="line">requests.ConnectionError</span><br><span class="line">        HTTPError</span><br><span class="line">        URLRequired</span><br><span class="line">        TooManyRedirects</span><br><span class="line">        ConnectTimeout</span><br><span class="line">        TImeout</span><br></pre></td></tr></table></figure>

<h4 id="请求头部r-head"><a href="#请求头部r-head" class="headerlink" title="请求头部r.head"></a>请求头部r.head</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(r.headers)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'Cache-Control': 'private</span></span><br><span class="line"><span class="string">, no-cache, no-store, proxy-revalidate, no-transform', </span></span><br><span class="line"><span class="string">'Connection': 'keep-alive', 'Content-Encoding': 'gzip', </span></span><br><span class="line"><span class="string">'Content-Type': 'text/html', 'Date': 'Sat, 11 Jan 2020 08:39:34 GMT', </span></span><br><span class="line"><span class="string">'Last-Modified': 'Mon, 23 Jan 2017 13:27:36 GMT', 'Pragma': 'no-cache', </span></span><br><span class="line"><span class="string">'Server': 'bfe/1.0.8.18', 'Set-Cookie': 'BDORZ=27315; max-age=86400; domain=.baidu.com; path=/', </span></span><br><span class="line"><span class="string">'Transfer-Encoding': 'chunked'&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h4 id="在url中附加数据"><a href="#在url中附加数据" class="headerlink" title="在url中附加数据"></a>在url中附加数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>, <span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>,data=payload)</span><br><span class="line">print(r.text)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123; ...</span></span><br><span class="line"><span class="string">  "form": &#123;</span></span><br><span class="line"><span class="string">    "key1": "value1", </span></span><br><span class="line"><span class="string">    "key2": "value2"</span></span><br><span class="line"><span class="string">  &#125;, </span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>,data=<span class="string">'ABC'</span>)</span><br><span class="line">print(r.text)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123; ...</span></span><br><span class="line"><span class="string">  "data": "ABC", </span></span><br><span class="line"><span class="string">  "form": &#123;&#125;, </span></span><br><span class="line"><span class="string">  ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># r = requests.post('http://httpbin.org/post',data=payload)</span></span><br></pre></td></tr></table></figure>

<h2 id="beautifulsoup库"><a href="#beautifulsoup库" class="headerlink" title="beautifulsoup库"></a>beautifulsoup库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>

<h3 id="整理网页格式"><a href="#整理网页格式" class="headerlink" title="整理网页格式"></a>整理网页格式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">"http://python123.io/ws/demo.html"</span>)</span><br><span class="line">demo = r.text   <span class="comment"># print(demo)</span></span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(demo , <span class="string">"html.parser"</span>) <span class="comment"># demo-&gt;open("path.html")</span></span><br><span class="line">print(soup.prettify)</span><br></pre></td></tr></table></figure>

<h3 id="bf类的基本元素"><a href="#bf类的基本元素" class="headerlink" title="bf类的基本元素"></a>bf类的基本元素</h3><ul>
<li>tag: &lt;&gt;…&lt;/&gt; 标签,基本信息组织单元</li>
<li>Name:<tag>.name   标签名字</tag></li>
<li>Attributs:<tag>.attrs 标签属性</tag></li>
<li>NavigableString:<tag>.string  标签内字符串</tag></li>
<li>Comment:特殊注释:&lt;!content&gt;为注释   </li>
</ul>
<p><img src="/2020/03/04/python-spider/tag0.png" alt="tag"> </p>
<h3 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h3><p>HTML基本结构:树形结构</p>
<p><img src="/2020/03/04/python-spider/tag1.png" alt="tag"> </p>
<p>节点查找与遍历:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.title)</span><br><span class="line">print(soup.a) #返回第一个a标签</span><br><span class="line">print(soup.a.parent.name)</span><br><span class="line">print(soup.a.attrs)</span><br><span class="line">print(soup.a.string)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">&lt;tag&gt;.contents  儿子节点列表</span><br><span class="line">&lt;tag&gt;.children  儿子节点迭代器</span><br><span class="line">&lt;tag&gt;.descendent    子孙节点列表</span><br><span class="line"></span><br><span class="line">&lt;tag&gt;.parent 父亲节点</span><br><span class="line">&lt;tag&gt;.parents 父辈节点迭代器</span><br><span class="line"></span><br><span class="line">&lt;tag&gt;.next_sibling(s) 同一父节点下才构成兄弟关系</span><br><span class="line">&lt;tag&gt;.previous_sibling(s)</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soup.find_all(<span class="string">'a'</span>))</span><br><span class="line">print(soup.find_all(re.compile(<span class="string">'b'</span>))) <span class="comment"># 返回以b开头的标签</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&lt;&gt;.find_all(name,attrs,recursive,string,**kwargs)</span></span><br><span class="line"><span class="string">            名字  属性  是否搜索子孙 字符串检索</span></span><br><span class="line"><span class="string">tag.find_all(True)-&gt;所有标签</span></span><br><span class="line"><span class="string">tag.find_all(id='link')-&gt;attrs</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">soup()=soup.find_all</span></span><br><span class="line"><span class="string">&lt;tag&gt;()=&lt;tag&gt;.find_all()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.fing()</span></span><br><span class="line"><span class="string">.find_parents()</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h2 id="scrapy框架"><a href="#scrapy框架" class="headerlink" title="scrapy框架"></a>scrapy框架</h2><p>cmd命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install scapy</span><br><span class="line">scapy startproject &lt;name&gt; [<span class="built_in">dir</span>] //创建工程</span><br><span class="line">scrapy genspider [options] &lt;name&gt; &lt;domain&gt;  //创建爬虫</span><br><span class="line">scrapy crawl &lt;spider&gt;</span><br></pre></td></tr></table></figure>

<p>太乱了,写不下去了…</p>
<p>关于scrapy,可以参考<a href="https://www.jianshu.com/p/cecb29c04cd2" target="_blank" rel="noopener">https://www.jianshu.com/p/cecb29c04cd2</a></p>
<hr>
<p>等我哪天有兴趣了再回来整理整理这篇博文</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>毛概相关</title>
    <url>/2020/03/03/mao-theory/</url>
    <content><![CDATA[<p>水课，佛系更新</p>
<hr>
<h2 id="第一章问题"><a href="#第一章问题" class="headerlink" title="第一章问题"></a>第一章问题</h2><ul>
<li>如何理解毛泽东思想活的灵魂</li>
</ul>
<ol>
<li>思想路线: 坚持实事求是，一切从实际出发，理论联系实际，坚持在实践中检验和发展真理</li>
<li>根本工作路线: 群众路线;一切为了群众,一切依靠群众,从群众中来,到群众中去,把党的主张变为群众的自觉行动</li>
<li>根本政治原则: 独立自主;坚持独立思考,走自己的路;坚定不移地维护民族独立,捍卫国家主权,把立足点放在依靠自己力量的基础之上;同时积极争取外援,开展国际经济文化交流,学习外国一切对我们有益的先进事物</li>
</ol>
<a id="more"></a>]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>毛概</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理与设计(基础篇)</title>
    <url>/2020/02/27/data-base0/</url>
    <content><![CDATA[<p><del>未完结,持续更新</del> 完结</p>
<hr>
<p>任课教师: 赵朋朋<a href="http://web.suda.edu.cn/ppzhao/" target="_blank" rel="noopener">http://web.suda.edu.cn/ppzhao/</a></p>
<p>网课资源: 慕课中国人民大学数据库系统概论<a href="https://www.icourse163.org/course/RUC-488001" target="_blank" rel="noopener">https://www.icourse163.org/course/RUC-488001</a></p>
<p>参考教材: 高等教育出版社《数据库系统概论(第5版)》</p>
<p>课程主要讲述关系型数据库的原理, 不着重于具体数据库的使用</p>
<p>简明的数据库使用笔记可参考<a href="http://georgechen.top/2020/04/11/mysql0/" target="_blank" rel="noopener">http://georgechen.top/2020/04/11/mysql0/</a></p>
<p>后续见数据库原理与设计(高级篇)<a href="http://georgechen.top/2020/04/16/data-base1/" target="_blank" rel="noopener">http://georgechen.top/2020/04/16/data-base1/</a></p>
<a id="more"></a>

<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1 数据库系统概述"></a>1.1 数据库系统概述</h2><h3 id="数据库中的基本概念"><a href="#数据库中的基本概念" class="headerlink" title="数据库中的基本概念"></a>数据库中的基本概念</h3><ul>
<li>数据(data): 是数据库中存储的基本对象; 是描述事物的符号记录,包括数字、文字等不同种类 </li>
</ul>
<blockquote>
<p>数据是有语义的:相同的数据形式可能有不同的含义,数据与语义是不可分的<br>数据是有结构的:记录是计算机存储数据的一种格式或方法</p>
</blockquote>
<ul>
<li>数据库(database): 是长期存储在计算机内,有组织,可共享的大量数据的集合</li>
</ul>
<blockquote>
<p>数据库能够收集并抽取应用的数据将其保存,用后续处理<br>数据库的基本特征:  </p>
<ol>
<li>数据按一定的数据模型组织,描述和存储</li>
<li>可为各种用户共享,冗余度较小,易扩展</li>
<li>数据独立性较高</li>
</ol>
</blockquote>
<ul>
<li>数据库管理系统(DBMS): 是位于用户应用与操作系统之间的一层数据管理软件,是一个大型复杂的软件系统</li>
</ul>
<blockquote>
<p>用途: 能科学地组织和存储数据,高效的获取和维护数据<br>功能: </p>
<ol>
<li>数据定义功能:提供数据定义语言,定义数据库中的数据对象</li>
<li>数据组织存储和管理功能</li>
<li>数据操纵功能:提供数据操纵语言,实现对数据库增删改查</li>
<li>数据库的事务和并发管理和运行管理功能:保证数据安全完整,故障恢复</li>
<li>数据库建立和维护功能:提供实用程序和工具</li>
<li>其它功能:通信,数据转换等</li>
</ol>
</blockquote>
<ul>
<li>数据库系统(DBS): 在计算机系统中引入数据库后的系统构成, 也可简称为数据库</li>
</ul>
<blockquote>
<p>数据库系统构成: 数据库, 数据库管理系统(及其应用开发工具), 应用程序, 数据库管理员(DBA)</p>
</blockquote>
<h3 id="数据库管理技术"><a href="#数据库管理技术" class="headerlink" title="数据库管理技术"></a>数据库管理技术</h3><p>数据管理: 对数据进行分类,组织,编码,存储,检索和维护<br>数据管理是数据处理和数据分析的中心问题</p>
<p>发展: 人工管理-&gt;文件系统管理-&gt;数据库系统管理<br><img src="/2020/02/27/data-base0/diff0.png" alt="diff"></p>
<ul>
<li>人工管理阶段, 应用程序和数据集是一一对应的</li>
<li>文件系统阶段, 存取方法是共享的, 但应用程序和数据集是一一对应的</li>
<li>数据库系统阶段, 多个应用程序通过同一个数据库管理系统对同一个数据库进行操作</li>
</ul>
<h3 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h3><ul>
<li>数据结构化</li>
<li>数据的共享性高,冗余度低且易扩充</li>
<li>数据独立性高:有物理独立性和逻辑独立性</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ul>
<h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2  数据模型"></a>1.2  数据模型</h2><p>数据模型是对现实世界数据特征的抽象,是对现实世界的模拟</p>
<p>数据模型应满足三方面要求</p>
<ul>
<li>能比较真实地模拟现实世界</li>
<li>容易为人所理解</li>
<li>便于在计算机上实现  </li>
</ul>
<p>数据模型是数据库系统的核心和基础 </p>
<h3 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h3><p>数据模型分为两类(两个不同层次):  </p>
<ul>
<li>概念模型，也称信息模型 : 它是按用户的观点来对数据和信息建模，用于数据库设计  </li>
<li>逻辑模型和物理模型 <blockquote>
<ul>
<li>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等</li>
<li>逻辑模型是按计算机系统的观点对数据建模，用于DBMS实现</li>
<li>物理模型是对数据最底层的抽象, 是描述数据在系统内（磁盘上）的表示方式和存取方法</li>
</ul>
</blockquote>
</li>
</ul>
<p>现实世界中客观对象的抽象过程:<br><img src="/2020/02/27/data-base0/proc0.png" alt="proc"></p>
<h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><ul>
<li>概念模型用于信息世界的建模 </li>
<li>是现实世界到机器世界的一个中间层次</li>
<li>是数据库设计的有力工具</li>
<li>数据库设计人员和用户之间进行交流的语言 </li>
</ul>
<p>概念模型的特点:  </p>
<ul>
<li>较强的语义表达能力</li>
<li>简单、清晰、易于用户理解 </li>
</ul>
<p>信息世界中的基本概念: </p>
<ul>
<li>实体（Entity）: 客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。</li>
<li>属性（Attribute）: 实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。</li>
<li>码（Key）: 唯一标识实体的属性集称为码。</li>
<li>实体型（Entity Type）: 用实体名及其属性名集合来抽象和刻画同类实体称为实体型(对象)</li>
<li>实体集（Entity Set）: 同一类型实体的集合称为实体集 </li>
<li>联系（Relationship）: 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。<blockquote>
<ul>
<li>实体内部的联系: 是指组成实体的各属性之间的联系 </li>
<li>实体之间的联系: 通常是指不同实体集之间的联系, 实体之间的联系有一对一（1:1）、一对多（1:n）和多对多（m:n）等多种类型 </li>
</ul>
</blockquote>
</li>
</ul>
<p>实体-联系方法（Entity-Relationship Approach）是概念模型的一种表示方法:</p>
<ul>
<li>用E-R图来描述现实世界的概念模型 </li>
<li>E-R方法也称为E-R模型<br><img src="/2020/02/27/data-base0/rela0.png" alt="relation">  </li>
</ul>
<p>(具体方法在数据库设计中会讲到)</p>
<h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><p>数据模型是严格定义的一组概念的集合</p>
<ul>
<li>它精确地描述了系统的静态特性、动态特性和完整性约束条件 (Integrity Constraints)。</li>
</ul>
<p>数据模型由三部分组成</p>
<ul>
<li>数据结构–描述系统的静态特性 </li>
<li>数据操作–描述系统的动态特性 </li>
<li>完整性约束条件</li>
</ul>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p>数据结构是刻画数据模型性质的重要方面  </p>
<blockquote>
<ul>
<li>一般用数据结构的类型来命名数据模型,如: 层次结构-层次模型、网状结构–网状模型、关系结构—关系模型 </li>
</ul>
</blockquote>
</li>
<li><p>数据结构是用来描述数据库的组成对象–对象的类型、内容、性质</p>
</li>
<li><p>数据结构可以用来描述对象之间的联系 </p>
</li>
</ul>
<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>数据操作是对数据库中各种对象的实例允许执行的操作的集合，包括操作的类型及有关的操作规则</p>
<p>操作的类型: 增删改查</p>
<p>数据操作语言: </p>
<ul>
<li>数据操作语言需要定义数据操作的确切含义、符号、优先级别</li>
<li>数据操作语言需要实现查询语言(Query Language)和更新语言(Insert、Delete、Update) </li>
</ul>
<h4 id="数据完整性约束条件"><a href="#数据完整性约束条件" class="headerlink" title="数据完整性约束条件"></a>数据完整性约束条件</h4><p>数据完整性约束条件是一组完整性规则的集合</p>
<ul>
<li>完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则</li>
<li>完整性规则可以限定符合数据模型的数据库状态以及状态的变化，以保证数 据的正确、有效和相容。</li>
</ul>
<p>数据模型对完整性约束条件的定义:</p>
<ul>
<li>反映和规定必须遵守的基本的通用的完整性约束条件</li>
<li>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</li>
</ul>
<h3 id="常用的数据模型"><a href="#常用的数据模型" class="headerlink" title="常用的数据模型"></a>常用的数据模型</h3><ul>
<li>格式化模型: 层次模型,网状模型 </li>
<li>关系模型</li>
<li>对象模型: 面向对象数据模型,对象关系数据模型</li>
<li>半结构化数据模型:XML,HTML</li>
<li>非结构化数据模型,图模型,…</li>
</ul>
<h4 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h4><p>层次模型用树形结构来表示各类实体以及实体间的联系</p>
<p>表示方法：</p>
<ul>
<li>实体型：用纪录类描述，每个节点表示一个记录类型</li>
<li>属性：用字段描述，每个记录类型可包含若干个字段</li>
<li>联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系</li>
</ul>
<p>特点:</p>
<ul>
<li>结点的双亲是唯一的</li>
<li>只能直接处理一对多的实体联系</li>
<li>任何记录值只有按其路径查看</li>
<li>没有一个子女记录值能够脱离双亲记录值而独立存在 </li>
</ul>
<p>优缺点:</p>
<ul>
<li>(优点)层次模型的数据结构比较简单清晰</li>
<li>查询效率高，性能优于关系模型，不低于网状模型</li>
<li>层次数据模型提供了良好的完整性支持</li>
<li>(缺点)结点之间的多对多联系表示不自然</li>
<li>对插入和删除操作的限制多，应用程序的编写比较复杂</li>
<li>查询子女结点必须通过双亲结点</li>
<li>层次数据库的命令（语言）趋于程序化  </li>
</ul>
<h4 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h4><p>网状数据库系统采用网状结构来表示各类实体以及实体间的联系(有向图)</p>
<p>网状模型表示方法和层次模型相同</p>
<p>特点:</p>
<ul>
<li>允许多个结点没有双亲结点</li>
<li>允许一个结点有多个双亲结点</li>
<li>允许两个结点之间有多种联系</li>
<li>要为每个联系命名并指出与该联系有关的双亲记录和子女记录 </li>
</ul>
<p>优缺点:</p>
<ul>
<li>(优点)能够更为直接地描述现实世界，如一个结点可以有多个双亲</li>
<li>具有良好的性能，存取效率较高</li>
<li>(缺点)结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握</li>
<li>DDL、DML语言复杂，用户不容易使用</li>
<li>记录之间联系是通过存取路径实现的，应用程序必须选择存取路径，加重了程序员的负担</li>
</ul>
<h4 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h4><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表,如下<br><img src="/2020/02/27/data-base0/table0.png" alt="relation">  </p>
<p>其中:</p>
<ul>
<li>关系: 一个关系对应通常来说的一张表</li>
<li>元组: 表中的一行即为一个元组</li>
<li>属性: 表中的一列即为一个属性, 每一个属性都会有一个属性名</li>
<li>主码(key): 也称码键, 是可以唯一确定一个元组的属性组</li>
<li>域(domain): 是一组具有相同数据类型的值的集合, 是属性的取值范围</li>
<li>分量: 元组中的一个属性值</li>
<li>关系模式: 对关系的描述</li>
</ul>
<p>注意: 关系模型中的关系必须是规范化的, 关系中的每一个分量必须是不可分的数据项, 即不允许表中套表(这个表应该是个纯粹的二维数组)</p>
<p>优点:</p>
<ul>
<li>建立在严格的数学概念的基础上</li>
<li>概念单一<blockquote>
<ul>
<li>实体和各类联系都用关系来表示 </li>
<li>对数据的检索结果也是关系 </li>
</ul>
</blockquote>
</li>
<li>关系模型的存取路径对用户透明(用户感受不到路径)<blockquote>
<ul>
<li>具有更高的数据独立性，更好的安全保密性 </li>
<li>简化了程序员的工作和数据库开发建立的工作 </li>
</ul>
</blockquote>
</li>
</ul>
<p>缺点:</p>
<ul>
<li>存取路径对用户透明，查询效率往往不如格式化数据模型</li>
<li>为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度</li>
</ul>
<h2 id="1-3-数据库系统的结构"><a href="#1-3-数据库系统的结构" class="headerlink" title="1.3 数据库系统的结构"></a>1.3 数据库系统的结构</h2><p>从数据库应用开发人员角度看：</p>
<ul>
<li>数据库系统采用三级模式结构，是数据库系统内部的系统结构</li>
</ul>
<p>从数据库最终用户角度看，数据库系统的结构有：</p>
<ul>
<li>单用户结构</li>
<li>主从式结构</li>
<li>分布式结构</li>
<li>客户-服务器</li>
<li>浏览器-应用服务器／数据库服务器等</li>
</ul>
<h3 id="关于模式的一些概念"><a href="#关于模式的一些概念" class="headerlink" title="关于模式的一些概念"></a>关于模式的一些概念</h3><p>模式:</p>
<ul>
<li>是对数据库逻辑结构和特征的描述</li>
<li>是型的描述,不涉及具体值</li>
<li>模式是相对稳定的</li>
</ul>
<p>实例</p>
<ul>
<li>数据库某一时刻的状态: 模式的一个具体值</li>
<li>同一个模式可以有很多实例</li>
<li>实例随数据库中的数据的更新而变动</li>
</ul>
<h3 id="三级模式结构"><a href="#三级模式结构" class="headerlink" title="三级模式结构"></a>三级模式结构</h3><p><img src="/2020/02/27/data-base0/pattern0.png" alt="pattern"></p>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>模式(逻辑模式)</p>
<ul>
<li>是数据库中全体数据的逻辑结构和特征描述 </li>
<li>是所有用户的公共数据视图<blockquote>
<p>一般,某个应用的数据库有一个模式  </p>
</blockquote>
</li>
</ul>
<p>模式是数据库系统模式结构的中心:</p>
<ul>
<li>与数据的物理存储细节和硬件环境无关</li>
<li>与具体的应用程序、开发工具及高级程序设计语言无关 </li>
</ul>
<p>定义模式</p>
<ul>
<li>DDL定义数据的逻辑结构，以某种数据模型为基础</li>
<li>数据记录由哪些数据项构成，数据项的名字、类型、取值范围等</li>
<li>定义数据之间的联系</li>
<li>定义与数据有关的安全性、完整性要求</li>
</ul>
<h4 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h4><p>外模式（也称子模式或用户模式）</p>
<ul>
<li>数据库用户使用的局部数据的逻辑结构和特征的描述</li>
<li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 </li>
</ul>
<p>外模式与模式的关系</p>
<ul>
<li>外模式通常是模式的子集、一个模式可以有多个外模式</li>
<li>反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</li>
<li>对模式中某一数据，在不同的外模式中 结构、类型、长度、保密级别等都可以不同 </li>
</ul>
<p>外模式与应用的关系</p>
<ul>
<li>一个外模式可以为 多个应用系统所使用，一个应用程序只能使用一个外模式 </li>
</ul>
<p>外模式的用途</p>
<ul>
<li>每个用户只能看见和访问所对应的外模式中的数据，简化用户视图</li>
<li>保证数据库安全性的一个有力措施</li>
</ul>
<h4 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h4><p>内模式（也称存储模式）</p>
<ul>
<li><p>是数据物理结构和存储方式的描述</p>
</li>
<li><p>是数据在数据库内部的表示方式</p>
<blockquote>
<ul>
<li>记录的存储方式 （例如，顺序存储，堆存储，Cluste按hash方法存储等）</li>
<li>索引的组织方式（B+树，Bitmap，Hash）</li>
<li>数据是否压缩存储</li>
<li>数据是否加密</li>
<li>数据存储记录结构的规定—如定长/变长，记录是否可以跨页存放等 </li>
</ul>
</blockquote>
</li>
<li><p>一个数据库只有一个内模式</p>
</li>
</ul>
<h3 id="二级映像"><a href="#二级映像" class="headerlink" title="二级映像"></a>二级映像</h3><p>三级模式实际上是对数据的三个抽象级别</p>
<p>数据库管理系统内部提供了二级映像</p>
<ul>
<li>外模式/模式映像</li>
<li>模式/内模式映像</li>
</ul>
<h4 id="外模式-模式映像"><a href="#外模式-模式映像" class="headerlink" title="外模式/模式映像"></a>外模式/模式映像</h4><p>对每一个外模式,有一个外模式/模式映像</p>
<ul>
<li>它定义了外模式与模式之间的对应关系</li>
<li>映像定义通常包含在各外模式的描述中</li>
</ul>
<p>这种映像可以保证数据(和程序)的逻辑独立性</p>
<ul>
<li>当模式改变时，数据库管理员对外模式／模式映像作相应改变，使外模式保持不变</li>
<li>应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据 与程序的逻辑独立性，简称数据的逻辑独立性 </li>
</ul>
<h4 id="模式-内模式映像"><a href="#模式-内模式映像" class="headerlink" title="模式/内模式映像"></a>模式/内模式映像</h4><p>模式/内模式映像定义了全局数据逻辑结构与存储结构之间的对应关系(如，说明某个逻辑记录对应何种存储结构)</p>
<p>数据库中模式/内模式映像是唯一的,该映像定义通常包含在模式的描述中</p>
<p>这种映像能保证数据的物理独立性</p>
<ul>
<li>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员 修改模式／内模式映象，使模式保持不变。</li>
<li>模式不变，则应用程序不变。保证了数据与程序的物理独立性，简称数据的 物理独立性。</li>
</ul>
<h4 id="二级映像的功能与数据独立性"><a href="#二级映像的功能与数据独立性" class="headerlink" title="二级映像的功能与数据独立性"></a>二级映像的功能与数据独立性</h4><ul>
<li><p>保证了应用程序的稳定性</p>
<blockquote>
<ul>
<li>除非应用需求本身发生变化，否则应用程序一般不需要修改。</li>
</ul>
</blockquote>
</li>
<li><p>从程序为中心——发展为 以数据为中心</p>
<blockquote>
<ul>
<li>具有了数据与程序之间的独立性，使得数据的定义和描述可以从应用 程序中分离出去</li>
</ul>
</blockquote>
</li>
<li><p>数据的存取由数据库管理系统管理</p>
<blockquote>
<ul>
<li>简化了应用程序的编制</li>
<li>大大减少了应用程序的维护和修改  </li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="1-4-数据库系统的组成"><a href="#1-4-数据库系统的组成" class="headerlink" title="1.4 数据库系统的组成"></a>1.4 数据库系统的组成</h2><ul>
<li>数据库</li>
<li>数据库管理系统（及其开发工具）</li>
<li>应用程序</li>
<li>数据库管理员 </li>
</ul>
<h3 id="硬件平台及数据库"><a href="#硬件平台及数据库" class="headerlink" title="硬件平台及数据库"></a>硬件平台及数据库</h3><p>数据库对硬件资源的要求:</p>
<ul>
<li>足够大的内存</li>
<li>足够大的磁盘(阵列)等外部设备</li>
<li>较高的通讯能力</li>
</ul>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><ul>
<li>数据库管理系统</li>
<li>支持数据库管理系统运行的操作系统</li>
<li>与数据库接口的高级语言及其编译系统</li>
<li>以数据库管理系统为核心的应用开发工具</li>
<li>为特定应用环境开发的数据库应用系统</li>
</ul>
<h3 id="人员"><a href="#人员" class="headerlink" title="人员"></a>人员</h3><p>不同的人员涉及不同的数据抽象级别，具有不同的数据视图:</p>
<ul>
<li>用户:应用程序客户端</li>
<li>应用程序员:外模式</li>
<li>数据库管理员,系统分析员:数据库,内模式,模式,外模式</li>
</ul>
<h1 id="二、关系数据库"><a href="#二、关系数据库" class="headerlink" title="二、关系数据库"></a>二、关系数据库</h1><h2 id="2-1-关系模型"><a href="#2-1-关系模型" class="headerlink" title="2.1 关系模型"></a>2.1 关系模型</h2><h3 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h3><p>关系数据结构是单一的数据结构-关系</p>
<p>关系数据结构示意图如下:<br><img src="/2020/02/27/data-base0/relation0.png" alt="rela"></p>
<h4 id="域和笛卡尔积空间"><a href="#域和笛卡尔积空间" class="headerlink" title="域和笛卡尔积空间"></a>域和笛卡尔积空间</h4><ul>
<li><p>域:域是一组具有相同数据类型的值的集合,是属性的取值范围</p>
</li>
<li><p>域的笛卡尔积空间是一组域的笛卡尔积,是属性值组合的集合</p>
</li>
<li><p>笛卡尔积的基数是参与笛卡尔积中元素的个数</p>
</li>
<li><p>笛卡尔积可以表示为一张二维表,行对应集合中的每个元素,列对应每个属性的域</p>
</li>
</ul>
<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p>关系是在笛卡尔积上的子集  </p>
<p>关系中的元素可以用元组表示,在二维表中由一行表示</p>
<ul>
<li>属性: 关系中不同列称为属性,每个属性有一个名字; n目关系有n个属性</li>
<li>码: 码是能唯一标识一个元组的属性(组)<blockquote>
<ul>
<li>候选码:关系中能唯一地标识一个元组的最小属性组，则称该属性组为候选码 </li>
<li>全码:关系模式的所有属性都是这个关系模式的候选码时,这个属性组称为全码（All-key）</li>
<li>主码:若一个关系有多个候选码，则选定其中一个为主码（Primary key）</li>
<li>主属性:候选码的诸属性称为主属性（Prime attribute）不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）  </li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h4><p>关系模式是对关系的描述<br>关系模式主要有元组集合的结构和完整性约束条件两方面构成</p>
<p>关系模式可以由一个五元组R(U,D,DOM,F)表示,其中:</p>
<ul>
<li>R:关系名</li>
<li>U:属性名集合</li>
<li>D:各属性的域的集合</li>
<li>DOM:属性向域的映像集合(映射关系,指明哪个属性的域是哪个)</li>
<li>F:属性间数据依赖的关系集合</li>
</ul>
<h3 id="关系完整性约束"><a href="#关系完整性约束" class="headerlink" title="关系完整性约束"></a>关系完整性约束</h3><ul>
<li><p>实体完整性和参照完整性: 关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持</p>
</li>
<li><p>用户定义的完整性: 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 </p>
</li>
</ul>
<p>关系完整性约束能够使得一些不符合条件的元组不能进入数据库</p>
<h4 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h4><ul>
<li>关系的主属性不能取空值(码不能为空)</li>
</ul>
<p>说明: </p>
<ul>
<li>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</li>
<li>现实世界中的实体是可区分的，即它们具有某种唯一性标识。</li>
<li>关系模型中以主码作为唯一性标识。</li>
<li>主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性</li>
</ul>
<h4 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h4><ul>
<li>关系中的某些属性的取值需要参考另外一个关系中的相关数据</li>
</ul>
<p>在关系模型中实体及实体间的联系都是用关系来描述的,自然存在着关系与关系间的引用,而这种引用应当是有意义的 </p>
<p>若关系R中的属性F的取值需要参考关系S中的主码K,则:</p>
<ul>
<li>F为R的外码/外键,此时F不能是R的码</li>
<li>R为参照关系</li>
<li>S为被参照关系或目标关系</li>
<li>外码F只能为空或者是关系S中某个存在的元组的K属性(有意义)</li>
<li>R和S可以是同一个关系</li>
</ul>
<h4 id="用户定义完整性"><a href="#用户定义完整性" class="headerlink" title="用户定义完整性"></a>用户定义完整性</h4><p>其他一些用户定义的完整性规则,可以是列级完整性约束也可以是表级完整性约束</p>
<h2 id="2-2-关系代数"><a href="#2-2-关系代数" class="headerlink" title="2.2 关系代数"></a>2.2 关系代数</h2><p>关系数据库语言分类：</p>
<ul>
<li>关系代数语言: 用对关系的运算来表达查询要求</li>
<li>关系演算语言：用谓词来表达查询要求</li>
<li>具有关系代数和关系演算双重特点的语言(SQL)</li>
</ul>
<p>关系代数是一种抽象的查询语言，它用对关系的运算来表达查询,其以集合运算为数学基础</p>
<ul>
<li>关系代数运算对象是关系</li>
<li>关系代数运算结果是关系</li>
<li>关系代数运算符分为集合运算符和专门关系的运算符</li>
</ul>
<h3 id="传统集合操作"><a href="#传统集合操作" class="headerlink" title="传统集合操作"></a>传统集合操作</h3><p>一些记号的定义:</p>
<ul>
<li><p>$R(A_1,A_2,…,A_n)$表示n目的关系模式,$A_i$表示属性</p>
</li>
<li><p>$R$为符合上述关系模式的一个关系</p>
</li>
<li><p>$t\in R$是R中的一个元组</p>
</li>
<li><p>$t[A_i]$表示元组$t$中属性$A_i$的值</p>
</li>
<li><p>$A=\lbrace A_i,A_j,…,A_k \rbrace$表示属性列或属性组</p>
</li>
<li><p>$t[A]$可以表示$t$在上述属性组中诸分量的集合</p>
</li>
<li><p>$\overline A$表示$A$在全体属性中的补集</p>
</li>
<li><p>$\widehat {t_rt_s}$表示关系R和关系S中两个元组的连接</p>
</li>
<li><p>$Z_x$是象集,表示R中属性组$X$上值为$x$的所有元组在属性组$Z$上分量的集合,称为$x$在$R$中的象集</p>
</li>
</ul>
<h4 id="关系的并"><a href="#关系的并" class="headerlink" title="关系的并"></a>关系的并</h4><p>关系的并就是集合的并,运算要求如下:</p>
<ul>
<li>关系R和S目数相同,相应的属性属于同一个域</li>
<li>R并S仍为n目关系,R$\cup$S是R和S上所有元组的集合</li>
<li>并完之后要去重</li>
</ul>
<h4 id="关系的差"><a href="#关系的差" class="headerlink" title="关系的差"></a>关系的差</h4><p>关系的差就是集合的差,运算要求如下:</p>
<ul>
<li>关系R和S目数相同,相应的属性属于同一个域</li>
<li>R并S仍为n目关系,R-S是属于R而不属于S的所有元组的集合</li>
</ul>
<h4 id="关系的交"><a href="#关系的交" class="headerlink" title="关系的交"></a>关系的交</h4><p>要求同上,运算结果是在R和S中都存在的元组的集合</p>
<h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>关系的笛卡尔积中,$R\times S = \lbrace \widehat {t_rt_s} | t_r \in R \land t_s \in S \rbrace$</p>
<ul>
<li>行:运算后为$n_R+n_S$目关系</li>
<li>列:运算后有$k_R*k_S$个元组</li>
</ul>
<h3 id="关系特有操作"><a href="#关系特有操作" class="headerlink" title="关系特有操作"></a>关系特有操作</h3><h4 id="选择-sigma"><a href="#选择-sigma" class="headerlink" title="选择$\sigma$"></a>选择$\sigma$</h4><ul>
<li>选择运算又称为限制</li>
<li>是在关系R中选择符合条件的元组组成集合</li>
<li>条件是一个取值为真或假的逻辑表达式</li>
</ul>
<h4 id="投影-pi"><a href="#投影-pi" class="headerlink" title="投影$\pi$"></a>投影$\pi$</h4><ul>
<li>从关系R中选择出若干属性列组成新的关系</li>
<li>投影后形成的新的关系目数会减少</li>
<li>需要去重</li>
</ul>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接是从两个关系的笛卡尔积中选择属性满足一定条件A$\theta$B的元组组成的关系</p>
<p>此时,参与连接的两个关系有一些度数相等且可以进行比较的属性组A和B</p>
<ul>
<li><p>等值连接: 两个元组能连接的条件是对应属性组的值相等,即$\theta$为’=’</p>
</li>
<li><p>自然连接: 一种特殊的等值连接,两个进行比较的属性组必须相同,且运算结束后这些重复的属性组将会被去掉,这是一种对行和列都进行操作的运算</p>
</li>
<li><p>两个关系R和S在做自然连接时，被舍弃的元组称为悬浮元组</p>
</li>
<li><p>外连接: 将悬浮元组也保留在结果关系中,附加的属性置为空</p>
<blockquote>
<ul>
<li>左外连接:只保留左边关系R中的悬浮元组,悬浮元组中多出来的S分量全置为空</li>
<li>右外连接:只保留右边关系S中的悬浮元组,多出来的R分量全置为空</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h4><ul>
<li>给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组;Y一般为R和S中都有的属性组</li>
<li>R/S的结果是R上的一个投影P(X)的子集</li>
<li>R/S中的元组在X上分量值x的象集Yx包含S在Y上投影的集合<blockquote>
<ul>
<li>如果R是选课记录,S是全体课程,R/S就表示选了所有课程的学生</li>
</ul>
</blockquote>
</li>
<li>属性组Z没有参与到R/S的运算中</li>
</ul>
<h2 id="2-3-关系演算"><a href="#2-3-关系演算" class="headerlink" title="2.3 关系演算"></a>2.3 关系演算</h2><p>关系演算是以谓词演算为数学基础</p>
<p>按谓词变元不同,可分为元组关系演算(ALPHA语言)和域关系演算(QBE语言)</p>
<h3 id="元组关系演算ALPHA"><a href="#元组关系演算ALPHA" class="headerlink" title="元组关系演算ALPHA"></a>元组关系演算ALPHA</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><p><code>GET [(定额)] &lt;工作空间&gt; (&lt;操作对象&gt;) [:条件] [DOWN|UP 排序方式]</code></p>
<ul>
<li>以相应排序方式返回符合条件的操作对象</li>
<li>如果有定额则只返回前n个结果</li>
</ul>
<h4 id="用元组变量进行检索"><a href="#用元组变量进行检索" class="headerlink" title="用元组变量进行检索"></a>用元组变量进行检索</h4><p>元组变量是可以在某一关系上任意取值的变量</p>
<ul>
<li>可以用元组变量来代替较长的关系名</li>
<li>如果条件中使用量词,其后只能接元组变量</li>
</ul>
<p>元组关系演算是以元组变量作为谓词变元的基本对象的关系演算</p>
<p>定义方式:<code>RANGE &lt;关系名&gt; &lt;变量名&gt;</code></p>
<h4 id="用存在量词的检索"><a href="#用存在量词的检索" class="headerlink" title="用存在量词的检索"></a>用存在量词的检索</h4><ul>
<li>使用量词时先得定义在关系上的元组变量</li>
</ul>
<p>条件语句格式: $\exists$ &lt;元组变量&gt; (&lt;关于元组变量和目标元组的表达式&gt;)</p>
<p>对于需要判断的目标元组,只要存在一个元组变量的取值使得后面的表达式成立,这个目标元组就能够被选择</p>
<h4 id="用全称量词检索"><a href="#用全称量词检索" class="headerlink" title="用全称量词检索"></a>用全称量词检索</h4><ul>
<li>使用量词时先得定义在关系上的元组变量</li>
</ul>
<p>条件语句格式: $\forall$ &lt;元组变量&gt; (&lt;关于元组变量和目标元组的表达式&gt;)</p>
<p>对于需要判断的目标元组,无论元组变量取什么值后面的表达式都成立,则这个目标元组能够被选择</p>
<h4 id="用蕴含的检索"><a href="#用蕴含的检索" class="headerlink" title="用蕴含的检索"></a>用蕴含的检索</h4><p>在上述表达式中,可以使用蕴含条件</p>
<p>表达式格式:A$\to$B</p>
<p>当A成立时B一定成立,表达式为真</p>
<h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><p>常用聚集函数(内部函数):</p>
<ul>
<li>COUNT: 对元组计数(计数时会自动排除重复值)</li>
<li>TOTAL: 求值的总和</li>
<li>MAX: 求最大值</li>
<li>MIN: 求最小值</li>
<li>AVG: 求平均值</li>
</ul>
<h3 id="域关系演算QBE"><a href="#域关系演算QBE" class="headerlink" title="域关系演算QBE"></a>域关系演算QBE</h3><p>域关系演算是以元组变量的分量即域变量作为谓词变元的基本对象的关系演算</p>
<h1 id="三、关系数据库标准语言SQL"><a href="#三、关系数据库标准语言SQL" class="headerlink" title="三、关系数据库标准语言SQL"></a>三、关系数据库标准语言SQL</h1><p>SQL: 结构化查询语言,Structured Query Language</p>
<p>目前,没有一个数据库系统能够支持SQL标准的所有概念和特性</p>
<h2 id="3-1-SQL概述"><a href="#3-1-SQL概述" class="headerlink" title="3.1 SQL概述"></a>3.1 SQL概述</h2><p>SQL（Structured Query Language）结构化查询语言是关系数据库的标准语言</p>
<h3 id="SQL特点"><a href="#SQL特点" class="headerlink" title="SQL特点"></a>SQL特点</h3><p>综合统一: </p>
<ul>
<li>集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。 </li>
<li>可以独立完成数据库生命周期中的全部活动  </li>
</ul>
<p>高度非过程化:</p>
<ul>
<li>非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径。</li>
<li>SQL只要提出“做什么”，无须了解存取路径。</li>
<li>存取路径的选择以及SQL的操作过程由系统自动完成。</li>
</ul>
<p>面向集合的操作方式: </p>
<ul>
<li>非关系数据模型采用面向记录的操作方式，操作对象是一条记录</li>
<li>SQL采用集合操作方式</li>
<li>操作对象、查找结果可以是元组的集合</li>
<li>一次插入、删除、更新操作的对象可以是元组的集合</li>
</ul>
<p>以同一种语法结构提供多种使用方式: </p>
<ul>
<li>SQL是独立的语言,能够独立地用于联机交互的使用方式</li>
<li>SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用</li>
</ul>
<p>语言简洁，易学易用: </p>
<ul>
<li>SQL功能极强，完成核心功能只用了9个动词。<blockquote>
<ul>
<li>数据定义:CREATE,DROP,ALTER</li>
<li>数据操纵:INSERT,UPDATE,DELETE</li>
<li>数据查询:SELECT</li>
<li>权限控制:GRANT,REVOKE</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="SQL基本概念"><a href="#SQL基本概念" class="headerlink" title="SQL基本概念"></a>SQL基本概念</h3><p>数据库三级模式在SQL数据库中的体现:<br><img src="/2020/02/27/data-base0/sql0.png" alt="sql"></p>
<ul>
<li><p>基本表(模式)</p>
<blockquote>
<ul>
<li>本身独立存在的表</li>
<li>SQL中一个关系就对应一个基本表</li>
<li>一个（或多个）基本表对应一个存储文件</li>
<li>一个表可以带若干索引</li>
</ul>
</blockquote>
</li>
<li><p>存储文件(内模式)</p>
<blockquote>
<ul>
<li>存储文件以逻辑结构的方式组成了关系数据库的内模式</li>
<li>而物理存储结构对用户是隐蔽的(透明)</li>
</ul>
</blockquote>
</li>
<li><p>视图(外模式)</p>
<blockquote>
<ul>
<li>视图是由一个或几个基本表导出的表,是一个虚表</li>
<li>视图不存储数据,数据库中只存放视图的定义</li>
<li>视图上可以再定义视图</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="3-2-数据定义"><a href="#3-2-数据定义" class="headerlink" title="3.2 数据定义"></a>3.2 数据定义</h2><p>数据定义是定义各种数据库的对象</p>
<blockquote>
<p>数据定义包括模式(SCHEMA)定义,表(TABLE)定义,视图(VIEW)定义,索引(INDEX)定义  </p>
<ul>
<li>这里的模式通常指基本表的结构</li>
<li>一个数据库中可以建立多个模式</li>
<li>一个模式下可以建立多个表,视图,索引等数据库对象</li>
</ul>
</blockquote>
<p>上述对象的定义存储在数据库系统的数据字典中</p>
<ul>
<li>数据字典: 数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有对象的定义等一些信息<blockquote>
<ul>
<li>除了模式,表,视图,索引的定义(包括完整性约束)外, 数据字典还会存储各类用户对数据库的操作权限和统计信息等</li>
<li>关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>为某人创建某名的模式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;</span><br><span class="line">[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;权限定义子句&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>若没有指定模式名,则模式名隐含为用户名</li>
</ul>
<p>删除某模式:<code>DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;</code><br>删除选项:</p>
<blockquote>
<ul>
<li>CASADE 级联: 删除模式同时将该模式下的所有数据库对象删除</li>
<li>RESTRICT 限制: 仅当该模式中没有任何下属对象时才能执行, 如果这个模式下有表/视图等定义,则拒绝执行语句</li>
</ul>
</blockquote>
<h3 id="基本表的定义"><a href="#基本表的定义" class="headerlink" title="基本表的定义"></a>基本表的定义</h3><h4 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="comment">/* 基本表的名称 */</span> </span><br><span class="line">(&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] <span class="comment">/*组成该表的列*/</span> </span><br><span class="line">[,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ] </span><br><span class="line">… </span><br><span class="line">[,&lt;表级完整性约束条件&gt; ] );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>&lt;列级完整性约束条件&gt;: 涉及仅单个属性列的完整性约束条件 </p>
</li>
<li><p>&lt;表级完整性约束条件&gt;: 涉及一个或多个属性列的完整性约束条件 </p>
</li>
<li><p>&lt;表名&gt;:每一个基本表需属于某个模式,可以显式地在表名中给出,也可以在搜索路径中设置 </p>
<blockquote>
<p>设置搜索路径(默认模式):<code>SET search_path TO &lt;模式名&gt;,PUBLIC;</code></p>
</blockquote>
</li>
<li><p>&lt;数据类型&gt;: 有如下数据类型</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">含义</th>
<th align="left">数据类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR(n)</td>
<td align="left">n位定长字符串</td>
<td align="left">CHARACTER(n)</td>
<td align="left">同CHAR(n)</td>
</tr>
<tr>
<td align="left">VRCHAR(n)</td>
<td align="left">最大长度为n的变长字符串</td>
<td align="left">VRCHARACTER(n)</td>
<td align="left">同VRCHAR(n)</td>
</tr>
<tr>
<td align="left">CLOB</td>
<td align="left">字符串大对象</td>
<td align="left">BLOB</td>
<td align="left">二进制大对象</td>
</tr>
<tr>
<td align="left">INT</td>
<td align="left">长整数(4字节)</td>
<td align="left">INTEGER</td>
<td align="left">同INT</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">大整数(8字节)</td>
<td align="left">SMALLINT</td>
<td align="left">短整数(2字节)</td>
</tr>
<tr>
<td align="left">DEC(p,d)</td>
<td align="left">精度为d的p位定点数</td>
<td align="left">DECIMAL(p,d),NUMERIC(p,d)</td>
<td align="left">同DEC(p,d)</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">单精度浮点数</td>
<td align="left">DOUBLE PRECISION</td>
<td align="left">双精度浮点数</td>
</tr>
<tr>
<td align="left">FLOAT(n)</td>
<td align="left">精度为n的浮点数</td>
<td align="left">BOOLEAN</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">格式为YYYY-MM-DD的日期</td>
<td align="left">TIME</td>
<td align="left">格式为HH:MM:SS的时间</td>
</tr>
<tr>
<td align="left">TIMESTAP</td>
<td align="left">时间戳类型</td>
<td align="left">INTERVAL</td>
<td align="left">时间间隔类型</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="修改基本表"><a href="#修改基本表" class="headerlink" title="修改基本表"></a>修改基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]</span><br><span class="line">[<span class="keyword">ADD</span> &lt;表级完整性约束&gt;] <span class="comment">/*完整性约束只能添加表级完整性约束*/</span></span><br><span class="line">[<span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] &lt;列名&gt; [<span class="keyword">CASCADE</span>| RESTRICT] ]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>&lt;完整性约束名&gt;[ RESTRICT | <span class="keyword">CASCADE</span> ] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> &lt;列名&gt;&lt;数据类型&gt; ] ;</span><br></pre></td></tr></table></figure>
<ul>
<li>ADD COLUMN: 增加列</li>
<li>DROP COLUMN: 删除列<blockquote>
<ul>
<li>级联: 删除该列及引用该列的其他对象</li>
<li>限制: 如果该列被其他对象引用,则拒绝删除</li>
</ul>
</blockquote>
</li>
<li>ALTER COLUMN:修改列,也可以用以下两种方法<blockquote>
<ul>
<li><code>MODIFY &lt;列名&gt; &lt;数据类型&gt;</code>:修改列的数据类型</li>
<li><code>CHANGE &lt;列名&gt; &lt;新列名&gt; &lt;新数据类型&gt;</code>:修改列名</li>
</ul>
</blockquote>
</li>
<li>RENAME TO &lt;新表名&gt;:改个新表名</li>
</ul>
<h4 id="删除基本表"><a href="#删除基本表" class="headerlink" title="删除基本表"></a>删除基本表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;［RESTRICT| <span class="keyword">CASCADE</span>］;</span><br></pre></td></tr></table></figure>
<ul>
<li>级联:在删除基本表的同时，相关的依赖对象一起删除</li>
<li>限制:如果存在依赖该表的对象(该表被其他表引用),则拒绝删除</li>
</ul>
<h3 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h3><p>建立索引目的: 加快查询速度</p>
<ul>
<li>常见索引:顺序索引,B+树索引,散列索引,位图索引</li>
<li>索引由数据库管理员或建表者建立</li>
<li>索引由关系数据库系统自动完成维护</li>
</ul>
<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] <span class="keyword">INDEX</span> &lt;索引名&gt;</span><br><span class="line"><span class="keyword">ON</span> &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);</span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;表名&gt;：要建索引的基本表的名字  </li>
<li>索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔  </li>
<li>&lt;次序&gt;：指定索引值的排列次序，升序：ASC，降序：DESC。缺省 值：ASC  </li>
<li>UNIQUE：此索引的每一个索引值只对应唯一的数据记录  </li>
<li>CLUSTER：表示要建立的索引是聚簇索引</li>
</ul>
<h4 id="修改索引"><a href="#修改索引" class="headerlink" title="修改索引"></a>修改索引</h4><p><code>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索 引名&gt;;</code></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><code>DROP INDEX &lt;索引名&gt;;</code><br>删除索引时，系统会从数据字典中删去有关该索引的描述</p>
<h2 id="3-3-数据查询"><a href="#3-3-数据查询" class="headerlink" title="3.3 数据查询"></a>3.3 数据查询</h2><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><p>语句格式:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;] …</span><br><span class="line"><span class="keyword">FROM</span> &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]…|(<span class="keyword">SELECT</span> 语句)</span><br><span class="line">[<span class="keyword">AS</span>]&lt;别名&gt;</span><br><span class="line">[ <span class="keyword">WHERE</span> &lt;条件表达式&gt; ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名<span class="number">1</span>&gt; [ <span class="keyword">HAVING</span> &lt;条件表达式&gt; ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名<span class="number">2</span>&gt; [ <span class="keyword">ASC</span>|<span class="keyword">DESC</span> ] ]</span><br></pre></td></tr></table></figure>
<ul>
<li>SELECT:指定要显示的结果属性列,*表示所有列<blockquote>
<ul>
<li>目标列值可以为常量,即使它不在查询对象中</li>
<li>LOWER(&lt;目标列&gt;)可以使目标列值小写输出</li>
<li>目标列值可以用聚集函数表示</li>
<li>可以用别名<code>&lt;目标列表达式&gt; &lt;目标列别名&gt;</code>改变查询结果的列标题</li>
<li>ALL表示不去除重复的行(默认),DISTINCT表示去重</li>
</ul>
</blockquote>
</li>
<li>FROM:指定查询对象</li>
<li>WHERE:查询条件<blockquote>
<p>常用查询条件:</p>
<ul>
<li>基本比较运算符</li>
<li>确定范围: [NOT] BETWEEN .. AND ..</li>
<li>确定集合: [NOT] IN &lt;值表&gt; ; &lt;值表&gt;=(值1,值2,…)</li>
<li>字符匹配: [NOT] LIKE &lt;匹配字符串&gt; [ESCAPE &lt;换码字符&gt;]  <blockquote>
<p>匹配串中’%’表示任意长度通配,’_’表示单字符通配,’&#39;可以将通配符转义(需要ESCAPE’&#39;来表明转义字符)</p>
</blockquote>
</li>
<li>空值:IS [NOT] NULL;其中IS不能用’=’代替</li>
<li>连接运算符:NOT AND OR,优先级从高到低</li>
</ul>
</blockquote>
</li>
<li>GROUP BY:对查询结果按指定列的值分组,列值相等的元素归到一组;通常会在每组中使用聚集函数<blockquote>
<p>常用聚集函数:</p>
<ul>
<li>COUNT([ALL|DISTINCT] &lt;列名&gt;): 列值计数</li>
<li>SUM([ALL|DISTINCT] &lt;列名&gt;): 对数值型的列求总和</li>
<li>AVG([ALL|DISTINCT] &lt;列名&gt;): 对数值型的列求均值</li>
<li>MAX|MIN([ALL|DISTINCT] &lt;列名&gt;): 求列的最大|最小值  </li>
</ul>
<p>没有GROUP BY语句时,聚集函数将作用于整个查询结果,使用分组后函数将分别作用于每个组</p>
</blockquote>
</li>
<li>HAVING:在分组时选择指定条件的组,可以使用聚集函数,不能用WHERE替代</li>
<li>ORDER BY:对查询结果按指定值升序或降序排序,支持以不同优先级设置多个排序标准</li>
</ul>
<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>不像关系代数中“连接”是用一个特殊符号来表达的，在SQL中“连接”是用“连接条件”来表达的。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;表名&gt;.&lt;列名&gt;,...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;,&lt;表<span class="number">2</span>&gt;,...</span><br><span class="line"><span class="keyword">WHERE</span> [&lt;表名<span class="number">1</span>&gt;.]&lt;列名<span class="number">1</span>&gt;  &lt;比较运算符&gt;  [&lt;表名<span class="number">2</span>&gt;.]&lt;列名<span class="number">2</span>&gt;</span><br><span class="line">      <span class="keyword">AND</span> &lt;其他条件&gt;;</span><br></pre></td></tr></table></figure>

<ul>
<li>WHERE子句中除了连接条件,还可以有选择条件,同时完成选择和连接查询</li>
<li>对于表的自身连接,可以给同一个表取不同的别名来区分,来实现一些复杂的连接条件</li>
<li>左右外连接:<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt; <span class="keyword">LEFT</span>|<span class="keyword">RIGHT</span> <span class="keyword">OUT</span> <span class="keyword">JOIN</span> &lt;表<span class="number">2</span>&gt; </span><br><span class="line"><span class="keyword">ON</span> &lt;连接条件&gt;; </span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>FROM中也可以有多个表,进行多表连接</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>循环嵌套法:</p>
<blockquote>
<p>每从表1中取出一个元组,扫描一遍表2,将表2中符合条件的元组与前面的元组拼接起来,重复直到表1中的元组都处理完毕</p>
</blockquote>
<p>排序合并法:(常用于等值连接)</p>
<blockquote>
<p>按连接属性对表1和2进行排序,然后设置两个指针分别从两个表头开始从前向后扫;如果扫描的两个指针可以连接,则拼接后两个指针同时向后移,否在值较小的指针向后移动(归并算法);重复直到某个指针走到了表尾</p>
</blockquote>
<p>索引连接:</p>
<blockquote>
<p>对表2按连接字段建立索引,对于表1中的每个元组,按索引结果进行连接(循环嵌套法的一个变种)</p>
</blockquote>
<h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>一个SELECT-FROM-WHERE语句称为一个查询块,将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询</p>
<ul>
<li>上层的查询块称为外层查询或父查询</li>
<li>下层查询块称为内层查询或子查询</li>
<li>SQL语言允许多层嵌套查询</li>
<li>子查询不能使用ORDER BY子句</li>
</ul>
<p>嵌套查询类型:</p>
<ul>
<li><p>不相关子查询:子查询的查询条件不依赖于父查询,如IN,ANY/ALL子查询 </p>
<blockquote>
<p>原理:由里向外逐层处理</p>
</blockquote>
</li>
<li><p>相关子查询:子查询的查询条件依赖于父查询,如EXISTS子查询</p>
<blockquote>
<p>原理:依次取外层查询中表内的各元组,根据它与内层查询相关的属性值处理内层查询,若WHERE子句返回值为真,则取此元组放入结果表中</p>
</blockquote>
</li>
</ul>
<h4 id="IN子查询"><a href="#IN子查询" class="headerlink" title="IN子查询"></a>IN子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> &lt;列名(值)&gt; <span class="keyword">IN</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line">        ...</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h4 id="ANY-ALL子查询"><a href="#ANY-ALL子查询" class="headerlink" title="ANY/ALL子查询"></a>ANY/ALL子查询</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> &lt;列名&gt; &lt;比较运算符&gt; <span class="keyword">ANY</span>/<span class="keyword">ALL</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> &lt;列名&gt;</span><br><span class="line">        ...</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<ul>
<li>当确定内层子查询返回结果是单个值时,可以省略ANY/ALL</li>
<li>ANY/ALL的对象为某个查询结果,表示其中任意一个值或者全部值<blockquote>
<p>有时ANY/ALL谓词表达式可以用子查询中的聚集函数代替,如<code>&lt;ANY (SELECT &lt;列名&gt;)</code>可以用<code>&lt; (SELECT MIN(&lt;列名&gt;))</code>实现</p>
</blockquote>
</li>
</ul>
<h4 id="EXISTS子查询"><a href="#EXISTS子查询" class="headerlink" title="EXISTS子查询"></a>EXISTS子查询</h4><p>EXISTS是相关子查询,它依次取外层查询中表内的各元组,根据它与内层查询相关的属性值处理内层查询,若WHERE子句返回值为真,则取此元组放入结果表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> &lt;表<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="keyword">NOT</span>] <span class="keyword">EXISTS</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> &lt;表<span class="number">2</span>&gt;,...</span><br><span class="line">        <span class="keyword">WHERE</span> &lt;表<span class="number">1</span>&gt;...&lt;表<span class="number">2</span>&gt;...;</span><br><span class="line">    );</span><br><span class="line"><span class="comment">/* 表示查询结果中的每条记录都满足/不满足EXISTS子句 */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>EXIST的对象也是某个查询结果，若查询结果非空则返回真<blockquote>
<ul>
<li>由EXISTS引出的子查询中一般都是SELECT *</li>
<li>所有带IN谓词、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS谓词的子查询等价替换</li>
<li>SQL中的存在,任意,蕴含等谓词都需要用EXISTS手动实现</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h4><p>除法运算需要用EXIST子句实现</p>
<p>原理:</p>
<ol>
<li>计算C(X)=A(X,Y)/B(Y,Z)</li>
<li>根据上式,需要找出所有的c[X],使得对于所有的b[Y],都存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]</li>
<li>SQL中没有全称量词,需要对上式进行转换:找出所有的c[X],使得不存在b[Y],不存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]</li>
<li>对于 ‘不存在a[X,Y]使得a[X]=c[X],a[Y]=b[Y]’, 还可以使用集合差运算转化成 ‘全体a[X,Y] - 使得a[X]=c[X],a[Y]=b[Y]的a[X,Y]’</li>
</ol>
<p>3的实现代码如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> X </span><br><span class="line"><span class="keyword">FROM</span> A [<span class="keyword">AS</span>] R <span class="comment">/* 换名防止后面混淆 */</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    <span class="keyword">SELECT</span> * </span><br><span class="line">    <span class="keyword">FROM</span> B</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">        <span class="keyword">SELECT</span> *</span><br><span class="line">        <span class="keyword">FROM</span> A</span><br><span class="line">        <span class="keyword">WHERE</span> &lt;X=R.X&gt;</span><br><span class="line">          <span class="keyword">AND</span> &lt;Y=B.Y&gt;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>4的实现代码如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> X </span><br><span class="line"><span class="keyword">FROM</span> A [<span class="keyword">AS</span>] R <span class="comment">/* 换名防止后面混淆 */</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line">    (<span class="keyword">SELECT</span> *</span><br><span class="line">     <span class="keyword">FROM</span> A</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">EXCEPT</span> <span class="comment">/* 集合做差 */</span></span><br><span class="line">    (<span class="keyword">SELECT</span> X,Y </span><br><span class="line">     <span class="keyword">FROM</span> A,B</span><br><span class="line">     <span class="keyword">WHERE</span> &lt;A.X=R.X&gt;</span><br><span class="line">       <span class="keyword">AND</span> &lt;A.Y=B.Y&gt;</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="蕴含逻辑"><a href="#蕴含逻辑" class="headerlink" title="蕴含逻辑"></a>蕴含逻辑</h4><p>蕴含逻辑也需要用EXISTS子句实现</p>
<ol>
<li>给定逻辑:对于任意的a,都有B-&gt;C</li>
<li>化简逻辑:不存在a,使得B或非C</li>
<li>用NOT EXISTS实现上述语句;注意,非C也可以用NOT EXISTS实现</li>
</ol>
<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>集合查询可以对两个查询结果进行集合运算</p>
<ul>
<li>UNION:并</li>
<li>INTERSECT:交</li>
<li>EXCEPT:差<br>注意:参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同 </li>
</ul>
<h2 id="3-4-数据更新"><a href="#3-4-数据更新" class="headerlink" title="3.4 数据更新"></a>3.4 数据更新</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>可以直接插入元组或者插入子查询结果(多个元组)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;[属性列,...]</span><br><span class="line"><span class="keyword">VALUES</span> (属性值,);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;[属性列,...]</span><br><span class="line">&lt;子查询&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>没有出现的属性列赋空值  </li>
<li>没有定义属性列时默认为原表所有属性</li>
<li>VALUES可以由子查询表示</li>
<li>子查询结果或元组值需要与上面定义的属性列相匹配(子查询结果列的个数和列的类型都要匹配)</li>
<li>除了属性匹配,数据库还会检查所插入元素是否会破坏表的完整性规则</li>
</ul>
<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span>  &lt;表名&gt;</span><br><span class="line"><span class="keyword">SET</span>  &lt;列名&gt;=&lt;表达式&gt;[,&lt;列名&gt;=&lt;表达式&gt;]…</span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件&gt;];</span><br></pre></td></tr></table></figure>
<ul>
<li>语句将修改指定表中满足WHERE子句条件的元组</li>
<li>SET子句给出&lt;表达式&gt;的值用于取代相应的属性列</li>
<li>注意,如果省略WHERE子句,则会修改表中的所有元组 </li>
<li>执行修改语句时,数据库会检查修改操作是否会破坏表的完整性规则</li>
</ul>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt;</span><br><span class="line">WHERE &lt;条件&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>语句将会删除指定表中满足WHERE子句条件的元组</li>
<li>注意,如果省略WHERE子句,则会删除表中的所有元组</li>
</ul>
<h2 id="3-5-空值处理"><a href="#3-5-空值处理" class="headerlink" title="3.5 空值处理"></a>3.5 空值处理</h2><p>空值一般可以表示不存在(无意义)的值,未知值,不便于显示的值</p>
<p>空值一般用NULL表示,在关系运算中,需要对它进行特殊处理</p>
<ul>
<li>IS [NOT] NULL用来判断值是否为空</li>
<li>空值与其他值进行算术运算的结果为空值</li>
<li>空值与其他值(包括另一个空值)进行比较运算的结果为UNKNOWN</li>
<li>UNKNOWN将传统的二值（TRUE，FALSE）逻辑扩展成了三值逻辑</li>
<li>一般情况下UNKNOWN会被当成FALSE看待</li>
</ul>
<h2 id="3-6-视图"><a href="#3-6-视图" class="headerlink" title="3.6 视图"></a>3.6 视图</h2><ul>
<li>视图是一种虚拟的表,是从基本表中导出的表</li>
<li>视图只有定义,不存放数据</li>
<li>基本表中的数据发生变化，从视图中查询出的数据也随之改变</li>
</ul>
<h3 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h3><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE  VIEW </span><br><span class="line">    &lt;视图名&gt;  [(&lt;列名&gt;  [,&lt;列名&gt;]…)] </span><br><span class="line">   AS &lt;子查询&gt; </span><br><span class="line">   [WITH  CHECK  OPTION];</span><br></pre></td></tr></table></figure>
<ul>
<li>列名缺省时由子查询中SELECT的列构成<blockquote>
<p>一般出现以下情况,需要指定视图的列名:</p>
<ul>
<li>SELECT的某个列需要聚集函数或列表达式,即出现了一些新的列</li>
<li>多表连接时选出了几个同名列作为视图的字段</li>
<li>需要在视图中为某个列启用新的更合适的名字</li>
</ul>
</blockquote>
</li>
<li>WITH CHECK OPTION 可以保证通过该视图插入的数据符合该视图的定义,即插入成功的数据也会在视图中显示</li>
</ul>
<p>常见视图:</p>
<ul>
<li>行列子集视图:在保留单个基本表主码的情况下,去掉了这个表的某些行和列</li>
<li>基于多个表的视图</li>
<li>基于视图的视图</li>
<li>带表达式的视图:SELECT的某个列为表达式</li>
<li>分组视图:SELECT的某个列为聚集函数</li>
</ul>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><p><code>DROP  VIEW  &lt;视图名&gt;[CASCADE];</code></p>
<ul>
<li>该语句从数据字典中删除指定的视图定义</li>
<li>如果该视图上还导出了其他视图，需要使用CASCADE级联删除语句，把该视图和由它导出的所有视图一起删除,否则会拒绝删除</li>
<li>删除基表时，由该基表导出的所有视图定义都必须显式地使用DROP VIEW语句删除</li>
</ul>
<h3 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h3><p>视图查询与上述基本表的查询相同</p>
<p>原理:视图消解法</p>
<ul>
<li>对于数据库系统而言,先得将视图查询转换为对基本表的查询,再进行对基本表的查询</li>
<li>转换时需要进行有效性检查和语句修正</li>
</ul>
<h3 id="更新视图-数据"><a href="#更新视图-数据" class="headerlink" title="更新视图(数据)"></a>更新视图(数据)</h3><p>视图的插入,删除,修改操作与基本表相同</p>
<ul>
<li>一些视图是不可更新的,因为 对这些视图的更新不能唯一地有意义地转换成对相应基本表的更新,如带聚集函数的视图<blockquote>
<p>一般而言,行列子集视图是可以进行更新的  </p>
<p>DB2对视图更新的限制:</p>
<ul>
<li>若视图是由两个以上基本表导出的，则此视图不允许更新。</li>
<li>若视图的字段来自字段表达式或常数，则不允许对此视图执行INSERT 和UPDATE操作，但允许执行DELETE操作。  </li>
<li>若视图的字段来自集函数，则此视图不允许更新。</li>
<li>若视图定义中含有GROUP BY子句，则此视图不允许更新。</li>
<li>若视图定义中含有DISTINCT短语，则此视图不允许更新。</li>
<li>若视图定义中有嵌套查询，并且内层查询的FROM子句中涉及的表也是导出该视图的基本表，则此视图不允许更新</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="视图作用"><a href="#视图作用" class="headerlink" title="视图作用"></a>视图作用</h3><ul>
<li>视图能够简化用户的操作</li>
<li>视图使用户能以多种角度看待同一数据</li>
<li>视图对重构数据库提供了一定程度的逻辑独立性</li>
<li>视图能够对机密数据提供安全保护</li>
<li>适当的利用视图可以更清晰的表达查询</li>
</ul>
<h1 id="四、数据库安全性"><a href="#四、数据库安全性" class="headerlink" title="四、数据库安全性"></a>四、数据库安全性</h1><p>数据库的一大特点就是数据可以共享,而这必然带来安全性问题,这种数据的共享不能是无条件的共享</p>
<ul>
<li>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏</li>
<li>系统的安全保护措施是否有效是数据库系统主要的性能指标之一</li>
</ul>
<h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><h3 id="数据库不安全因素"><a href="#数据库不安全因素" class="headerlink" title="数据库不安全因素"></a>数据库不安全因素</h3><p>不安全的因素和主要对策</p>
<ul>
<li>非授权用户对数据库的恶意存取和破坏:用户身份鉴别,存取控制和视图技术</li>
<li>数据库中重要或敏感数据被泄露:强制存取控制,数据存储加密和传输加密</li>
<li>安全环境的脆弱性:建立可信计算机系统的标准</li>
</ul>
<h3 id="安全标准简介"><a href="#安全标准简介" class="headerlink" title="安全标准简介"></a>安全标准简介</h3><ul>
<li>TCSEC标准-&gt;CC标准</li>
</ul>
<p>TCSEC/TDI标准从四个方面来考虑程序的安全性: 安全策略,责任,保证和文档</p>
<p>TCSEC/TDI安全级别划分(由低到高):  </p>
<ul>
<li>D 最小保护: 一切不符合更高安全等级的系统,例如DOS</li>
<li>C1 自主安全保护: 能够实现对用户和数据的分离，进行自主存取控制（ DAC），保护或限制用户权限的传播; 现有商业系统稍作改进即可满足 </li>
<li>C2 受控的存取保护: 提供受控的存取保护，将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离; 如Windows2000</li>
<li>B1 标记安全保护: 对系统的数据加以标记，对标记的主体和客体实施强制存取控制（MAC）、审计等安全机制; 是安全或可信的产品</li>
<li>B2 结构化保护: 建立形式化的安全策略模型并对系统内的所有主体和 客体实施DAC和MAC </li>
<li>B3 安全域: 该级的TCB必须满足访问监控器的要求，审计跟踪能 力更强，并提供系统恢复过程 </li>
<li>A1 验证设计: 验证设计，即提供B3级保护的同时给出系统的形式化 设计说明和验证以确信各安全保护真正实现。</li>
</ul>
<p>CC评估保证级(EAL)划分:</p>
<ul>
<li>EAL1:功能测试（functionally tested）</li>
<li>EAL2:结构测试（structurally tested）,相当于C1</li>
<li>EAL3:系统地测试和检查（methodically tested and checked）,相当于C2 </li>
<li>EAL4:系统地设计、测试和复查（methodically designed， tested， and reviewed）,相当于B1 </li>
<li>EAL5:半形式化设计和测试（semiformally designed and tested）,相当于B2 </li>
<li>EAL6:半形式化验证的设计和测试（semiformally verified design and tested）,相当于B3 </li>
<li>EAL7:形式化验证的设计和测试（formally verified design and tested）,相当于A1 </li>
</ul>
<h2 id="4-2-数据库安全性控制"><a href="#4-2-数据库安全性控制" class="headerlink" title="4.2 数据库安全性控制"></a>4.2 数据库安全性控制</h2><p>计算机系统中,安全措施是一级一级层层设置的:<br>用户标识和鉴别(用户)&lt;-&gt;数据库安全保护(DBMS)&lt;-&gt;操作系统安全保护(OS)&lt;-&gt;数据密码存储(DB)</p>
<p>数据库安全控制常用方法</p>
<ul>
<li>用户身份鉴别</li>
<li>存取控制</li>
<li>视图</li>
<li>审计</li>
<li>数据加密</li>
</ul>
<p><img src="/2020/02/27/data-base0/sec0.png" alt="security"></p>
<h3 id="用户身份鉴别"><a href="#用户身份鉴别" class="headerlink" title="用户身份鉴别"></a>用户身份鉴别</h3><p>用户身份鉴别是系统提供的最外层安全保护措施</p>
<ul>
<li>用户标识：由用户名和用户标识号组成（用户标识号在系统整个生命周期内唯一） </li>
<li>身份鉴别方法:静态口令识别,动态口令识别,智能卡识别,生物特征鉴别</li>
</ul>
<h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><ul>
<li>定义用户对数据对象的操作权限,并将权限登记到数据字典中,称为安全规则或授权规则</li>
<li>对每个用户发出的存取数据库的请求,DBMS都会查找数据字典进行合法权限检查</li>
</ul>
<p>用户权限定义和合法权检查机制一起组成了DBMS的存取控制子系统 </p>
<h3 id="自主存取控制DAC"><a href="#自主存取控制DAC" class="headerlink" title="自主存取控制DAC"></a>自主存取控制DAC</h3><h4 id="自主存取控制方法概述"><a href="#自主存取控制方法概述" class="headerlink" title="自主存取控制方法概述"></a>自主存取控制方法概述</h4><ul>
<li>用户对不同的数据对象有不同的存取权限</li>
<li>不同的用户对同一对象也有不同的权限</li>
<li>用户还可将其拥有的存取权限转授给其他用户</li>
</ul>
<p>通过SQL的GRANT语句和REVOKE语句实现</p>
<h4 id="权限的授予"><a href="#权限的授予" class="headerlink" title="权限的授予"></a>权限的授予</h4><p>给某用户授予对某对象的某操作权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">TO</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>权限有SELECT，INSERT，UPDATE，DELETE，REFERENCES几种; ALL PRIVILEGES表示所有操作权限<blockquote>
<p>至于CREATE,ALTER等权限,是数据库管理员在创建用户时授予的</p>
</blockquote>
</li>
<li>指定了ON的对象,表名这是一种实体权限的授予,而不是系统权限(对任意对象的操作)的授予</li>
<li>TO用户可以时一个或多个具体用户,也可以是全体用户PUBLIC</li>
<li>WITH GRANT OPTION表示授予的权限可以再由该用户向下转授<blockquote>
<p>注意:权限不能循环授予,这样会导致回收权限时遇到无穷递归</p>
</blockquote>
</li>
<li>GRANT语句的发出者可以是数据库管理员,数据库对象创建者或者拥有该权限的用户</li>
</ul>
<h4 id="权限的回收"><a href="#权限的回收" class="headerlink" title="权限的回收"></a>权限的回收</h4><p>收回本授权者对某用户的某对象某操作权限的授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;用户&gt;[,&lt;用户&gt;]...</span><br><span class="line">[<span class="keyword">CASCADE</span> | RESTRICT];</span><br></pre></td></tr></table></figure>
<ul>
<li>级联回收: 将用户和他传播的权限全部回收</li>
<li>受限回收: 若用户传播过该权限并没有收回,则拒绝执行回收操作</li>
<li>权限的回收可由管理员或授权者来执行</li>
<li>回收只回收本用户直接或间接对目标用户授予的权限,若该用户还从其他地方获得了相同的权限,则他们仍具有此权限</li>
</ul>
<h4 id="用户的创建"><a href="#用户的创建" class="headerlink" title="用户的创建"></a>用户的创建</h4><p>CREATE USER不是SQL标准,不同数据库对用户创建的实现不一样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">USER</span>  &lt;username&gt;</span><br><span class="line">[<span class="keyword">WITH</span>][DBA|<span class="keyword">RESOURCE</span>|<span class="keyword">CONNECT</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>DBA:可以创建用户,模式,表以及登录数据库执行增删改查等操作</li>
<li>RESOURCE:只能创建表并登录数据库执行增删改查等操作</li>
<li>CONNECT: 能登陆数据库进行增删改查等操作,但必须获得相应权限</li>
</ul>
<h3 id="数据库中的角色"><a href="#数据库中的角色" class="headerlink" title="数据库中的角色"></a>数据库中的角色</h3><p>角色是权限的集合,能够通过为一组具有相同权限的用户创建一个角色来简化授权的过程</p>
<h4 id="创建角色"><a href="#创建角色" class="headerlink" title="创建角色"></a>创建角色</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> &lt;角色名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="给角色添加权限"><a href="#给角色添加权限" class="headerlink" title="给角色添加权限"></a>给角色添加权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">TO</span> &lt;角色&gt;[,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure>

<h4 id="回收角色的某权限"><a href="#回收角色的某权限" class="headerlink" title="回收角色的某权限"></a>回收角色的某权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限&gt;[,&lt;权限&gt;]...</span><br><span class="line"><span class="keyword">ON</span> &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;角色&gt;[,&lt;角色&gt;]...</span><br></pre></td></tr></table></figure>
<ul>
<li>用户可以回收角色的权限，从而修改角色拥有的权限</li>
<li>(不知道对不对)之前通过此角色授予出去的权限也会因为这个操作而被回收</li>
<li>这个REVOKE的发起者是角色的创建者或者拥有该角色ADMIN OPTION的用户</li>
</ul>
<h4 id="把角色授予给某用户或角色"><a href="#把角色授予给某用户或角色" class="headerlink" title="把角色授予给某用户或角色"></a>把角色授予给某用户或角色</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span>  &lt;角色<span class="number">1</span>&gt;[,&lt;角色<span class="number">2</span>&gt;]...</span><br><span class="line"><span class="keyword">TO</span>  &lt;角色<span class="number">3</span>&gt;[,&lt;用户<span class="number">1</span>&gt;]...</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>一个角色的权限是直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限 </li>
<li>把角色授给目标用户后,该用户获得这个角色的所有权限</li>
<li>WITH ADMIN OPTION表示目标角色或用户还可以把这种角色权限授予其他的角色或用户,也有权力更改这个角色的权限</li>
<li>这个GRANT的发起者是角色的创建者或者拥有该角色ADMIN OPTION的用户</li>
</ul>
<h4 id="通过角色收回赋予出去的权限"><a href="#通过角色收回赋予出去的权限" class="headerlink" title="通过角色收回赋予出去的权限"></a>通过角色收回赋予出去的权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;角色<span class="number">1</span>&gt;[,&lt;角色<span class="number">2</span>&gt;]...</span><br><span class="line"><span class="keyword">FROM</span> &lt;角色<span class="number">3</span>&gt;[,&lt;用户<span class="number">1</span>&gt;]...</span><br></pre></td></tr></table></figure>
<ul>
<li>目标用户或角色失去了原角色赋予给他的权限</li>
</ul>
<h3 id="强制存取控制MAC"><a href="#强制存取控制MAC" class="headerlink" title="强制存取控制MAC"></a>强制存取控制MAC</h3><p>自主存取控制可能存在数据的“无意泄露”,因为自主存取控制仅仅通过对数据的存取权限来进行安全控制,而数据本身并无安全性标记 </p>
<ul>
<li>强制存取控制（MAC）保证更高程度的安全性,用户不能直接感知或进行控制</li>
<li>强制存取控制适用于对数据有严格而固定密级分类的部门 </li>
</ul>
<h4 id="强制存取控制方法概述"><a href="#强制存取控制方法概述" class="headerlink" title="强制存取控制方法概述"></a>强制存取控制方法概述</h4><p>在强制存取控制中，数据库管理系统所管理的全部实体被分为两大类:</p>
<ul>
<li>主体:系统中的活动实体,即用户</li>
<li>客体:系统中受主体操纵的被动实体,如文件、基本表、索引、视图等</li>
</ul>
<p>DBMS对每个主体和客体的实例指派了一个敏感度标记(从高到低):</p>
<ul>
<li>绝密: Top Secret, TS</li>
<li>机密: Secret, S</li>
<li>可信: Confidential, C</li>
<li>公开: Public, P</li>
</ul>
<blockquote>
<ul>
<li>对主体的敏感度标记称为许可证(Clearance Level)</li>
<li>对客体的敏感度标记称为密级(Classification Leve)</li>
</ul>
</blockquote>
<h4 id="强制存取控制读写规则"><a href="#强制存取控制读写规则" class="headerlink" title="强制存取控制读写规则"></a>强制存取控制读写规则</h4><ul>
<li>仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体<blockquote>
<ul>
<li>可以防止主体看到一些敏感性较高的数据</li>
</ul>
</blockquote>
</li>
<li>仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体 <blockquote>
<ul>
<li>可以防止主体将高敏感性的数据向下透露(写)给低敏感性数据</li>
<li>主体可以更改密级比它高的数据,但写完之后它自己不能读取到</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="DAC-MAC安全检查"><a href="#DAC-MAC安全检查" class="headerlink" title="DAC+MAC安全检查"></a>DAC+MAC安全检查</h3><p>实现强制存取控制MAC时要首先实现自主存取控制DAC,因为较高安全性级别提 供的安全保护要包含较低级别的所有保护  </p>
<p>自主存取控制与强制存取控制共同构成数据库管理系统的安全机制</p>
<p>检查过程: SQL语法分析、语义检查-&gt;DAC检查-&gt;MAC检查-&gt;继续语义检查</p>
<h2 id="4-3-视图机制"><a href="#4-3-视图机制" class="headerlink" title="4.3 视图机制"></a>4.3 视图机制</h2><p>把要保密的数据对无权存取这些数据的用户通过视图隐藏起来，对数据提供一定程度的安全保护</p>
<p>例如,允许用户对表的部分进行查询的权限,用GRANT语句就无法实现,需要用视图进行操作</p>
<p>视图的相关操作可参见上面的3.6</p>
<h2 id="4-4-审计"><a href="#4-4-审计" class="headerlink" title="4.4 审计"></a>4.4 审计</h2><ul>
<li>用户身份鉴别,自主存取控制,强制存取控制,视图,数据加密是预防性措施</li>
<li>审计是监控措施<br>C2以上安全级别的DBMS必须具有审计功能 </li>
</ul>
<h3 id="审计相关概述"><a href="#审计相关概述" class="headerlink" title="审计相关概述"></a>审计相关概述</h3><p>审计就是启用一个专用的审计日志（Audit Log）,将用户对数据库的所有操作记录在上面   </p>
<p>审计员利用审计日志监控数据库中的各种行为,发现非法存取,发现潜在威胁  </p>
<p>可以被审计的事件:</p>
<ul>
<li>服务器事件: 记录数据库服务器发生的相关事件</li>
<li>系统权限: 记录对系统拥有的结构或模式对象进行的操作</li>
<li>语句事件: 记录SQL(或者其他数据库)语言发生的事件</li>
<li>模式对象事件: 记录对特定模式对象上进行的SELECT或DML操作</li>
</ul>
<p>审计日志管理:</p>
<ul>
<li>基本功能: 提供多种审计查阅方式</li>
<li>在初始化时设定多套审计规则</li>
<li>提供审计分析和报表功能</li>
<li>审计日志文件管理: 包括防止误删、加密、完整性保护、查阅和转储权限的管理</li>
<li>提供查询审计设置及审计记录信息的专门视图</li>
</ul>
<h3 id="审计功能的设置"><a href="#审计功能的设置" class="headerlink" title="审计功能的设置"></a>审计功能的设置</h3><p>由于审计很费时间和空间,可以选择使用或不使用审计功能</p>
<ul>
<li>系统级审计只能由数据库管理员设置,监测成功或失败的登录要求、监测授权和收回操作以及其他数据库级权限下的操作</li>
<li>用户级审计是任何用户可设置的审计,主要是用户针对自己创建的数据库表和视图进行审计</li>
</ul>
<p>审计功能用AUDIT和NOAUDIT设置和取消</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用户级审计定义 */</span></span><br><span class="line">AUDIT &lt;操作名&gt;</span><br><span class="line">ON &lt;表名&gt;; /* 可以对某表结构或数据的修改操作进行审计 */</span><br><span class="line"></span><br><span class="line">NOAUDIT &lt;操作名&gt;</span><br><span class="line">ON &lt;表名&gt;; /* 取消审计 */</span><br></pre></td></tr></table></figure>

<h2 id="4-5-数据加密"><a href="#4-5-数据加密" class="headerlink" title="4.5 数据加密"></a>4.5 数据加密</h2><p>数据加密是一种预防性措施,是防止数据库中数据在存储和传输中失密的有效手段</p>
<p>有存储加密和传输加密两种</p>
<h3 id="存储加密"><a href="#存储加密" class="headerlink" title="存储加密"></a>存储加密</h3><p>透明存储加密:性能较好，安全完备性较高</p>
<ul>
<li>内核级加密保护方式，对用户完全透明</li>
<li>将数据在写到磁盘时对数据进行加密，授权用户读取数据时再对其进行解密</li>
<li>数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可</li>
</ul>
<p>非透明存储加密:</p>
<ul>
<li>通过多个加密函数实现的加密</li>
</ul>
<h3 id="传输加密"><a href="#传输加密" class="headerlink" title="传输加密"></a>传输加密</h3><p>链路加密:</p>
<ul>
<li>传输信息由报头和报文两部分组成;报头是路由选择信息,报文是要传送的数据信息</li>
<li>报文和报头均加密</li>
</ul>
<p>端到端加密:</p>
<ul>
<li>在发送端加密，接收端解密</li>
<li>只加密报文不加密报头</li>
<li>所需密码设备数量相对较少，容易被非法监听者发现并从中获取敏感信息</li>
</ul>
<p>数据库系统可信传输示意图:<br><img src="/2020/02/27/data-base0/trust0.png" alt="trust"></p>
<h2 id="4-6-其他安全性保护"><a href="#4-6-其他安全性保护" class="headerlink" title="4.6 其他安全性保护"></a>4.6 其他安全性保护</h2><h3 id="推理控制"><a href="#推理控制" class="headerlink" title="推理控制"></a>推理控制</h3><p>强制存取控制不能解决通过公开信息推理出机密信息的问题</p>
<p>常用策略:基于函数依赖的推理控制,基于敏感关联的推理控制</p>
<h3 id="隐蔽信道"><a href="#隐蔽信道" class="headerlink" title="隐蔽信道"></a>隐蔽信道</h3><p>强制存取控制不能解决高安全等级用户利用数据库特性,按事先约定的方式主动向低安全等级用户透露信息的问题</p>
<p>隐蔽信道用于解决类似这种问题:例如,绝密用户向数据库插入了一条绝密数据,而此时一个公开用户向数据库插入相同数据时被拒绝,绝密用户便通过这种隐蔽的方式向公开用户透露了这条信息的存在</p>
<h1 id="五、数据库完整性"><a href="#五、数据库完整性" class="headerlink" title="五、数据库完整性"></a>五、数据库完整性</h1><p>数据库安全性防范的是非法操作,而数据库完整性防范的是非法数据 </p>
<p>数据库的完整性包括以下两个方面:</p>
<ul>
<li>数据的正确性(实体完整性等)</li>
<li>数据的相容性(参照完整性)</li>
</ul>
<p>数据库提供的机制:</p>
<ul>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查机制 </li>
<li>违约处理 </li>
</ul>
<h2 id="5-1-实体完整性"><a href="#5-1-实体完整性" class="headerlink" title="5.1 实体完整性"></a>5.1 实体完整性</h2><p>关系的主属性(码)唯一且不能为空,详细定义见2.1关系完整性约束</p>
<h3 id="实体完整性定义"><a href="#实体完整性定义" class="headerlink" title="实体完整性定义"></a>实体完整性定义</h3><p>关系模型的实体完整性用主码PRIMARY KEY描述</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;列名&gt; ... PRIMARY KEY /* 列级完整性约束 */</span><br><span class="line">PRIMARY KEY(&lt;列名&gt;[,&lt;列名&gt;,...]) /* 表级完整性约束 */</span><br></pre></td></tr></table></figure>
<ul>
<li>列级完整性约束可以定义单属性构成的码</li>
<li>表级完整性约束可以定义单个或多个属性构成的码</li>
</ul>
<h3 id="实体完整性检查和违约处理"><a href="#实体完整性检查和违约处理" class="headerlink" title="实体完整性检查和违约处理"></a>实体完整性检查和违约处理</h3><p>实体完整性检查发生在插入或对主码列进行更新操作时</p>
<p>检查方法:</p>
<ul>
<li>全表扫描(费时)</li>
<li>建立索引搜索(这个一般由RDBMS核心自动完成,可以是B+索引树)</li>
</ul>
<p>违约处理:拒绝插入或更新</p>
<h2 id="5-2-参照完整性"><a href="#5-2-参照完整性" class="headerlink" title="5.2 参照完整性"></a>5.2 参照完整性</h2><p>保证外码取值符合参照完整性约束,详细定义见2.1关系完整性约束</p>
<h3 id="参照完整性定义"><a href="#参照完整性定义" class="headerlink" title="参照完整性定义"></a>参照完整性定义</h3><ul>
<li>定义表中的外码,以及被参照关系的主码<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列级完整性约束 */</span></span><br><span class="line">&lt;外码列名&gt; ... FOREIGN KEY REFERENCES DEPT(&lt;被参考关系主码&gt;) [ON DELETE|UPDATE CASCADE|NO ACTION|SET-NULL]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表级完整性约束 */</span></span><br><span class="line">FOREIGN KEY(&lt;外码列名&gt;) REFERENCES DEPT(&lt;被参考关系主码&gt;) [ON DELETE|UPDATE CASCADE|NO ACTION|SET-NULL]</span><br></pre></td></tr></table></figure></li>
<li>违约选项:见下文违约处理</li>
</ul>
<h3 id="参照完整性检查"><a href="#参照完整性检查" class="headerlink" title="参照完整性检查"></a>参照完整性检查</h3><p>参照完整性检查发生在对被参照表或参照表进行增删改操作时</p>
<h3 id="违约处理"><a href="#违约处理" class="headerlink" title="违约处理"></a>违约处理</h3><p>对于参照表的元组插入或外码值修改,违约即拒绝执行</p>
<p>对于被参照表的元组删除或主码值修改,有三种违约处理方式:</p>
<ul>
<li>拒绝执行:不执行语句</li>
<li>级联操作:将参照表中有关联的元组删除或进行外码修改</li>
<li>设置空值:将参照表中有关联的元组外码置为空值,这可能会导致参照表中的元组违反实体完整性约束</li>
</ul>
<h2 id="5-3-用户定义完整性约束"><a href="#5-3-用户定义完整性约束" class="headerlink" title="5.3 用户定义完整性约束"></a>5.3 用户定义完整性约束</h2><p>针对某一具体应用的数据必须满足的语义要求,需要用户定义完整性约束</p>
<h3 id="用户完整性约束定义"><a href="#用户完整性约束定义" class="headerlink" title="用户完整性约束定义"></a>用户完整性约束定义</h3><p>列级完整性约束定义(属性约束条件)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;列名&gt; ... [UNIQUE] [NOT NULL] [CHECK(expr)]</span><br></pre></td></tr></table></figure>
<ul>
<li>NOT NULL:列值非空</li>
<li>UNIQUE:列值唯一(相当于主码)</li>
<li>CHECK(expr):列值满足某表达式</li>
</ul>
<p>表级完整性约束定义(元组约束条件):用于设置不同属性之间的取值的相互约束条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHECK(expr)</span><br></pre></td></tr></table></figure>

<h3 id="用户定义完整性约束检查和违约处理"><a href="#用户定义完整性约束检查和违约处理" class="headerlink" title="用户定义完整性约束检查和违约处理"></a>用户定义完整性约束检查和违约处理</h3><p>用户定义约束条件检查发生在插入元组或修改属性的值时</p>
<p>违约即拒绝执行</p>
<h2 id="5-4-完整性约束命名字句"><a href="#5-4-完整性约束命名字句" class="headerlink" title="5.4 完整性约束命名字句"></a>5.4 完整性约束命名字句</h2><p>为完整性约束条件起个名字,方便后面对它进行修改和删除,否则无法操作</p>
<h3 id="完整性约束命名子句定义"><a href="#完整性约束命名子句定义" class="headerlink" title="完整性约束命名子句定义"></a>完整性约束命名子句定义</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">CONSTANT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;</span><br></pre></td></tr></table></figure>
<p>该子句可以作为列级完整性约束或表级完整性约束使用</p>
<h3 id="完整性约束子句的删除和添加"><a href="#完整性约束子句的删除和添加" class="headerlink" title="完整性约束子句的删除和添加"></a>完整性约束子句的删除和添加</h3><p>用ALTER TABLE对约束条件进行删除和添加</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTANT</span> &lt;完整性约束条件名&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 添加 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt;</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTANT</span> &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>实现完整性约束子句的修改时,需要先删除约束,再添加约束,如上所示</li>
</ul>
<h2 id="5-5-域中的完整性限制"><a href="#5-5-域中的完整性限制" class="headerlink" title="5.5 域中的完整性限制"></a>5.5 域中的完整性限制</h2><p>对于多个具有联系的表,表中的一些属性可能具有相同的域,可以通过建立域的完整性约束来使不同表中的相同的属性域也相同</p>
<h3 id="域完整性约束定义"><a href="#域完整性约束定义" class="headerlink" title="域完整性约束定义"></a>域完整性约束定义</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义完整性约束 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DOMAIN</span> &lt;完整性约束条件名&gt; &lt;被约束列的值类型&gt; &lt;完整性约束子句&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改完整性约束中的限制条件 */</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DOMAIN</span> &lt;完整性约束条件名&gt; &lt;完整性约束修改子句&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>完整性约束修改子句包括完整性约束子句的删除和添加,需要指定完整性约束条件名</li>
</ul>
<h3 id="域完整性约束使用"><a href="#域完整性约束使用" class="headerlink" title="域完整性约束使用"></a>域完整性约束使用</h3><p>定义好域的完整性约束后,可以直接使用完整性约束条件名来作为同类型的属性的完整性约束条件</p>
<h2 id="5-6-断言"><a href="#5-6-断言" class="headerlink" title="5.6 断言"></a>5.6 断言</h2><p>SQL中更一般的约束可以用断言来指定</p>
<ul>
<li>涉及多个表或聚集操作比较复杂的完整性约束</li>
<li>断言创建以后,任何对断言中所涉及的关系的操作都会触发检查</li>
<li>断言不为真则拒绝执行</li>
</ul>
<p>断言创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ASSERTION</span> &lt;断言名&gt; &lt;<span class="keyword">CHECK</span>子句&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>CHECK子句和WHERE子句的表达类似</li>
</ul>
<p>断言删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">ASSERTION</span> &lt;断言名&gt;</span><br></pre></td></tr></table></figure>

<h2 id="5-7-触发器"><a href="#5-7-触发器" class="headerlink" title="5.7 触发器"></a>5.7 触发器</h2><ul>
<li>触发器是用户定义在关系表上的一类由事件驱动的特殊过程</li>
<li>任何用户对表的增删改操作均由服务器自动激活相应的触发器</li>
<li>触发器可以实施更为复杂的检查和操作(前面的完整性约束检查都是自动触发),具有更精细和更强大的数据控制能力</li>
</ul>
<p>触发器又叫做事件-条件-动作规则</p>
<h3 id="定义触发器"><a href="#定义触发器" class="headerlink" title="定义触发器"></a>定义触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt;</span><br><span class="line">&#123;<span class="keyword">BEFORE</span>|<span class="keyword">AFTER</span>&#125; &lt;触发事件&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br><span class="line">[<span class="keyword">REFERENCING</span> </span><br><span class="line">    <span class="keyword">NEW</span>|<span class="keyword">OLD</span> <span class="keyword">ROW</span> <span class="keyword">AS</span> &lt;变量&gt;,</span><br><span class="line">    <span class="keyword">NEW</span>|<span class="keyword">OLD</span> <span class="keyword">ROW</span> <span class="keyword">AS</span> &lt;变量&gt;,...]</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123;<span class="keyword">ROW</span>|<span class="keyword">STATEMENT</span>&#125;</span><br><span class="line">[<span class="keyword">WHEN</span> &lt;触发条件&gt;] &lt;触发动作体&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>触发器只能由表的拥有者创建</li>
<li>触发器只能定义在基本表上</li>
<li>&lt;触发器名&gt;可以包含或不包含模式名,同一模式下触发器名必须是唯一的</li>
<li>&lt;触发事件&gt;可以是对&lt;表名&gt;的INSERT,DELETE或UPDATE [OF &lt;触发列,…&gt;],触发器可在上述操作之后或者之前执行</li>
<li>RECEFRENCING子句用于指出所引用的变量,在后面的行级触发器中可以用到</li>
<li>FOR EACH子句可以定义触发器的类型:行级触发器或语句级触发器<blockquote>
<ul>
<li>行级触发器在对每一个元组进行相应的更改时激活(会多次激活触发器)</li>
<li>语句级触发器在语句执行时进行激活(以所更改的行为对象一次性进行操作)</li>
</ul>
</blockquote>
</li>
<li>定义WHEN后,只有触发器在激活后满足&lt;触发条件&gt;,触发动作体才会执行</li>
<li>&lt;触发动作体&gt;可以是一个匿名的SQL过程块,也可以是对已创建存储过程的调用;<blockquote>
<ul>
<li>行级触发器中用户可以在触发动作体中使用NEW和OLD引用实践之后的新之和事件之前的旧值</li>
<li>如果触发器动作体执行失败,则激活触发器的事件会被拒绝执行</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="触发器的激活"><a href="#触发器的激活" class="headerlink" title="触发器的激活"></a>触发器的激活</h3><p>一个表上可以定义多个触发器,遵循如下顺序执行</p>
<ul>
<li>执行表上的BEFORE触发器</li>
<li>执行SQL语句</li>
<li>执行表上的AFTER触发器<blockquote>
<p>有多个BEFORE或AFTER触发器时,一般上时间上先定义的触发器先执行</p>
</blockquote>
</li>
</ul>
<h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> &lt;触发器名&gt; <span class="keyword">ON</span> &lt;表名&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>只有具有相应权限的用户才能删除相应的触发器</li>
</ul>
<hr>
<p>后续见数据库原理与设计(高级篇)<a href="http://georgechen.top/2020/04/16/data-base1/" target="_blank" rel="noopener">http://georgechen.top/2020/04/16/data-base1/</a></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>featured-chinese-culture</title>
    <url>/2020/02/26/featured-chinese-culture/</url>
    <content><![CDATA[<p>英语课，佛系更新</p>
<hr>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>中国园林文化与艺术</title>
    <url>/2020/02/25/chinese-garden/</url>
    <content><![CDATA[<p>选修课，佛系更新</p>
<hr>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucence相关</title>
    <url>/2020/02/24/Lucence0/</url>
    <content><![CDATA[<p><del>未完结,不定期更新</del>  完结</p>
<hr>
<p>Lucence是一个由Java实现的,支持纯文本文件索引和搜索的高效、可扩展、开源的的全文检索框架</p>
<p>因自己需要用到lucence.net相关知识, 学习时参阅了不少资料, 将一些要点记录在此, 以供参考</p>
<a id="more"></a>

<h2 id="总论"><a href="#总论" class="headerlink" title="总论"></a>总论</h2><p>参考:<br><a href="https://www.cnblogs.com/forfuture1978/archive/2010/06/13/1757479.html" target="_blank" rel="noopener">https://www.cnblogs.com/forfuture1978/archive/2010/06/13/1757479.html</a><br><a href="https://blog.csdn.net/PZ_eng/article/details/91977083" target="_blank" rel="noopener">https://blog.csdn.net/PZ_eng/article/details/91977083</a>  </p>
<p><a href="http://lucene.apache.org/" target="_blank" rel="noopener">http://lucene.apache.org/</a>  </p>
<h3 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h3><h4 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a>数据的分类</h4><p>生活中数据总体分为如下几种:</p>
<ul>
<li>结构化数据: 具有固定格式或有限长度的数据(数据库,元数据)</li>
<li>非结构化数据: 不定长或无固定格式数据(word文档)</li>
<li>半结构化数据: 可根据需要当成结构化数据处理,也可以抽取纯文本按非结构化数据处理  </li>
</ul>
<p>其中,非结构化数据又叫全文数据</p>
<h4 id="全文数据搜索的主要方法"><a href="#全文数据搜索的主要方法" class="headerlink" title="全文数据搜索的主要方法"></a>全文数据搜索的主要方法</h4><ul>
<li>顺序扫描法: 直接,方便,较慢</li>
<li>索引法: 将非结构化数据中一部分信息提取出来重新组织,使其有一定结构后再搜索  </li>
</ul>
<p>索引构成了全文检索的基本思路<br>这种先建立索引,再对索引进行搜索的过程就叫做全文检索</p>
<p>全文检索大体分为两个过程: 索引创建,搜索索引</p>
<h4 id="全文检索需要关注的问题"><a href="#全文检索需要关注的问题" class="headerlink" title="全文检索需要关注的问题"></a>全文检索需要关注的问题</h4><p>因此,全文检索需要关注下面三个问题:  </p>
<ol>
<li>索引里面应该存什么(index)</li>
<li>如何创建索引(indexing)</li>
<li>如何对索引进行搜索(search)</li>
</ol>
<h3 id="索引里面应该存什么–倒排索引"><a href="#索引里面应该存什么–倒排索引" class="headerlink" title="索引里面应该存什么–倒排索引"></a>索引里面应该存什么–倒排索引</h3><p>倒排索引一般形式如下:</p>
<blockquote>
<p>token1-&gt;doc1 doc2 doc3 …<br>token2-&gt;doc3 doc5 doc6 …</p>
</blockquote>
<p>其中:</p>
<ul>
<li>token所在的地方称为词典</li>
<li>每个token指向一个文档链表,此链表称为倒排表</li>
</ul>
<p>通过这种索引方式,加上对链表的一系列操作,可以大大加速全文搜索的速度</p>
<h3 id="索引创建一般过程"><a href="#索引创建一般过程" class="headerlink" title="索引创建一般过程"></a>索引创建一般过程</h3><p>创建索引一般分为如下几步:</p>
<ol>
<li>整理要索引的Document</li>
<li>将Document传给Tokenizer,得到Token(分词)</li>
<li>将Token传给Linguistic Processor进行预处理,得到Term(转变大小写,词性,单复数)</li>
<li>将Term传给Indexer进行倒排索引</li>
</ol>
<h3 id="搜索一般过程"><a href="#搜索一般过程" class="headerlink" title="搜索一般过程"></a>搜索一般过程</h3><p>对索引进行搜索一般分为如下几步:</p>
<ol>
<li>用户输入query</li>
<li>对query进行词法,语法分析以及语言处理,得到语法树</li>
<li>搜索索引,得到符合语法树的文档</li>
<li>根据得到的文档和query的相关性对结果进行排序</li>
</ol>
<h3 id="Lucence"><a href="#Lucence" class="headerlink" title="Lucence"></a>Lucence</h3><p>Lucence是一个由Java实现的,支持纯文本文件的索引和搜索的高效、可扩展的全文检索框架</p>
<h4 id="Lucence和外界的交互"><a href="#Lucence和外界的交互" class="headerlink" title="Lucence和外界的交互"></a>Lucence和外界的交互</h4><p><img src="/2020/02/24/Lucence0/Lucence0.png" alt="Lucence"></p>
<h4 id="Lucence内部结构"><a href="#Lucence内部结构" class="headerlink" title="Lucence内部结构"></a>Lucence内部结构</h4><p><img src="/2020/02/24/Lucence0/Lucence1.png" alt="Lucence"></p>
<p>其中:</p>
<ul>
<li>被索引的文档用Document对象表示  </li>
<li>IndexWriter通过函数addDocument将文档添加到索引中 ,实现创建索引的过程  </li>
<li>Lucene的索引是应用倒排索引  </li>
<li>当用户有请求时,Query代表用户的查询语句  </li>
<li>IndexSearcher通过函数search搜索Lucene Index  </li>
<li>IndexSearcher计算term weight和score并且将结果返回给用户</li>
<li>返回给用户的文档集合用TopDocsCollector表示  </li>
</ul>
<h4 id="Lucence索引过程"><a href="#Lucence索引过程" class="headerlink" title="Lucence索引过程"></a>Lucence索引过程</h4><ol>
<li>创建一个IndexWriter用来写索引文件,它有几个参数,INDEX_DIR 就是索引文件所存放的位置,Analyzer便是用来对文档进行词法分析和语言处理的 </li>
<li>创建一个 Document 代表我们要索引的文档 </li>
<li>将不同的Field加入到文档中;我们知道,一篇文档有多种信息,如题目,作者,修改时间,内容等;不同类型的信息用不同的Field来表示  </li>
<li>IndexWriter调用函数addDocument将索引写到索引文件夹中 　</li>
</ol>
<h4 id="Lucence搜索过程"><a href="#Lucence搜索过程" class="headerlink" title="Lucence搜索过程"></a>Lucence搜索过程</h4><ol>
<li>IndexReader将磁盘上的索引信息读入到内存</li>
<li>创建IndexSearcher准备进行搜索  </li>
<li>创建Analyer用来对查询语句进行词法分析和语言处理 </li>
<li>创建QueryParser用来对查询语句进行语法分析 </li>
<li>QueryParser调用parser进行语法分析,形成查询语法树,放到Query中  </li>
<li>IndexSearcher调用search对查询语法树Query进行搜索,得到结果TopScoreDocCollector</li>
</ol>
<h4 id="Lucence的包结构"><a href="#Lucence的包结构" class="headerlink" title="Lucence的包结构"></a>Lucence的包结构</h4><p><img src="/2020/02/24/Lucence0/Lucence2.png" alt="Lucence"></p>
<p>其中:</p>
<ul>
<li>Lucene的analysis模块主要负责词法分析及语言处理而形成Term  </li>
<li>Lucene的index模块主要负责索引的创建,里面有里面有IndexWriter</li>
<li>Lucene的store模块主要负责索引的读写</li>
<li>Lucene的QueryParser主要负责语法分析</li>
<li>Lucene的search模块主要负责对索引的搜索</li>
<li>Lucene的similarity模块主要负责对相关性打分的实现  </li>
</ul>
<h2 id="Lucence-net"><a href="#Lucence-net" class="headerlink" title="Lucence.net"></a>Lucence.net</h2><p>参考:<br><a href="http://lucenenet.apache.org/" target="_blank" rel="noopener">http://lucenenet.apache.org/</a><br><a href="https://www.cnblogs.com/xiaoyaodijun/p/4140507.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoyaodijun/p/4140507.html</a><br><a href="https://blog.csdn.net/xuezhongsong/article/details/4388241" target="_blank" rel="noopener">https://blog.csdn.net/xuezhongsong/article/details/4388241</a></p>
<h3 id="lucence-net中主要的几个类"><a href="#lucence-net中主要的几个类" class="headerlink" title="lucence.net中主要的几个类"></a>lucence.net中主要的几个类</h3><h4 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h4><p>Document用于描述一个文档,由多个Field(相当于属性)组成</p>
<p>常用方法: </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Document</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Document</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">puclib <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">IFieldable field</span>)</span>;  <span class="comment">//  添加字段/属性field</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Field <span class="title">GetField</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>; <span class="comment">//  获得第一个名为name的field,无则返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Get</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>; <span class="comment">// 获得第一个名为name的field 中的文本内容</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Field[] <span class="title">GetFields</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>;  <span class="comment">//获得所有名为name的field,无则返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">string</span>[] <span class="title">GetValues</span>(<span class="params"><span class="keyword">string</span> name</span>)</span>; <span class="comment">//  获得所有名为name的field 中的文本内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><p>Field用于描述一个文档的某个属性,一般由名字和属性值构成</p>
<p>常用方法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Field</span> : <span class="title">AbstractField</span>, <span class="title">IFieldable</span>&#123;</span><br><span class="line">    <span class="comment">//  inherited</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; &#125; <span class="comment">//  名字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> StringValue &#123; <span class="keyword">get</span>; &#125; <span class="comment">//  属性值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Field</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">string</span> <span class="keyword">value</span>, Store store, Index index</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="keyword">string</span> <span class="keyword">value</span></span>)</span>; <span class="comment">//更改属性值   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于构造函数中的参数的说明:</p>
<ul>
<li><p>name: 字段名称</p>
</li>
<li><p>value: 字段内容,也就是属性值</p>
</li>
<li><p>store: 存储类型</p>
<blockquote>
<p>Field.Store有三个属性：  </p>
<ul>
<li>Field.Store.YES: 索引文件本来只存储索引数据,此设计将原文内容直接也存储在索引文件中,如文档的标题</li>
<li>Field.Store.NO：原文不存储在索引文件中，搜索结果命中后，再根据其他附加属性如文件的Path，数据库的主键等，重新连接打开原文，适合原文内容较大的情况。</li>
<li>Field.Store.COMPRESS 压缩存储  </li>
</ul>
</blockquote>
</li>
<li><p>index: 索引类型</p>
<blockquote>
<p>Field.Index有四个属性：</p>
<ul>
<li>Field.Index.TOKENIZED：分词索引</li>
<li>Field.Index.UN_TOKENIZED：进行索引，但不对其进行分词，如作者名，日期等，Rod Johnson本身为一单词，不再需要分词。</li>
<li>Field.Index.NO 和 Field.Index.NO_NORMS: 不进行索引，存放不能被搜索的内容如文档的一些附加属性如文档类型, URL等  </li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h4><p>在一个文档被索引之前，首先需要对文档内容进行分词处理，这部分工作就是由 Analyzer 来做的。Analyzer 类是一个抽象类，它有多个实现。针对不同的语言和应用需要选择适合的 Analyzer。Analyzer 把分词后的内容交给 IndexWriter 来建立索引。</p>
<p>一般用法(不太会用,先这么写着吧):</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">StandardAnalyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT);</span><br></pre></td></tr></table></figure>

<h4 id="IndexWriter"><a href="#IndexWriter" class="headerlink" title="IndexWriter"></a>IndexWriter</h4><p>IndexWriter 是 Lucene 用来创建索引的一个核心的类，他的作用是把一个个的 Document 对象加到索引中来。建立索引必须从它开始。而且，从它的构造函数开始</p>
<p>一般用法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"> IndexWriter writer = <span class="keyword">new</span> IndexWriter(<span class="keyword">string</span> idxDir,Analyzer analyzer,<span class="keyword">bool</span> isNewCreate,MaxFieldLength IndexWriter.MaxFieldLength.LIMITED);</span><br><span class="line"> </span><br><span class="line"> writer.AddDocument(doc);<span class="comment">//向索引文件中写数据 </span></span><br><span class="line">writer.Optimize();<span class="comment">// 索引优化，一般执行此步骤时，所消耗的内存是写入索引所需内存的2倍，在执行索引生成操作的时候本身就对内存有比较大的消耗，最好在索引创建完成之后，执行此步骤。 </span></span><br><span class="line">writer.Commit();<span class="comment">//数据提交 </span></span><br><span class="line">writer.Rollback();<span class="comment">//数据回滚 </span></span><br><span class="line">writer.Close();<span class="comment">//关闭流索引写入器，此步骤才真正将数据写入到索引文件中。</span></span><br></pre></td></tr></table></figure>

<h4 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h4><p>这个类代表了 Lucene 的索引的存储的位置，这是一个抽象类，它目前有两个实现，第一个是 FSDirectory，它表示一个存储在文件系统中的索引的位置。第二个是 RAMDirectory，它表示一个存储在内存当中的索引的位置</p>
<p>一般用法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> indexDir = <span class="string">"idx"</span>;</span><br><span class="line">DirectoryInfo dir = <span class="keyword">new</span> DirectoryInfo(indexDir);</span><br><span class="line"></span><br><span class="line">Lucene.Net.Store.Directory idxDir = <span class="keyword">new</span> SimpleFSDirectory(dir, <span class="keyword">new</span> SimpleFSLockFactory());  <span class="comment">//  创建上面的indexwriter需要用到</span></span><br></pre></td></tr></table></figure>

<h3 id="Lucence-net中的索引建立"><a href="#Lucence-net中的索引建立" class="headerlink" title="Lucence.net中的索引建立"></a>Lucence.net中的索引建立</h3><p>总结一下建立索引的一般过程</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  前期准备    */</span></span><br><span class="line"><span class="keyword">var</span> indexDir = <span class="string">"idx"</span>;   <span class="comment">//  索引目录</span></span><br><span class="line"><span class="keyword">var</span> isNewCreate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">DirectoryInfo dir = <span class="keyword">new</span> DirectoryInfo(indexDir);</span><br><span class="line">Lucene.Net.Store.Directory idxDir = <span class="keyword">new</span> SimpleFSDirectory(dir, <span class="keyword">new</span> SimpleFSLockFactory());</span><br><span class="line"></span><br><span class="line">StandardAnalyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT);</span><br><span class="line"></span><br><span class="line">IndexWriter writer = <span class="keyword">new</span> IndexWriter(idxDir, analyzer, isNewCreate, IndexWriter.MaxFieldLength.LIMITED);</span><br><span class="line"><span class="comment">// writer.MergeFactor(50); 多少个合并一次【优化缓存】 </span></span><br><span class="line"><span class="comment">// writer.MaxMergeDocs(5000); 一个segment最多有多少个document【优化索引存储的segment文件】 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  写索引   */</span></span><br><span class="line">Document doc = <span class="keyword">new</span> Document();</span><br><span class="line">Field field = <span class="keyword">new</span> Field(<span class="string">"name"</span>, <span class="string">"content"</span>, Field.Store.YES, Field.Index.ANALYZED);</span><br><span class="line">doc.Add(field);</span><br><span class="line">writer.AddDocument(doc);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  关文件   */</span></span><br><span class="line">writer.Optimize();</span><br><span class="line">writer.Commit(); </span><br><span class="line">writer.Rollback(); </span><br><span class="line">writer.Close();</span><br></pre></td></tr></table></figure>

<h3 id="Lucence-net中的索引搜索"><a href="#Lucence-net中的索引搜索" class="headerlink" title="Lucence.net中的索引搜索"></a>Lucence.net中的索引搜索</h3><p>下面是我自己写的一个索引搜索的流程模板</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> indexDir = <span class="string">"idx"</span>;   <span class="comment">//  指定索引的目录</span></span><br><span class="line">IndexSearcher searcher = <span class="keyword">new</span> IndexSearcher(LuceneConnection.GetIndexDirectory(indexDir));<span class="comment">// 建立搜索引擎; readOnly 为boolean值</span></span><br><span class="line"></span><br><span class="line">StandardAnalyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT);   <span class="comment">//  分词器用于分析query,此分词器应当与建立索引的分词器保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MultiFieldQueryParser parser = new MultiFieldQueryParser(Version.LUCENE_CURRENT, new string[] &#123; title, content &#125;, analyzer); 多字段搜索   </span></span><br><span class="line"><span class="keyword">var</span> q = <span class="keyword">new</span> QueryParser(Version.LUCENE_CURRENT, <span class="string">"name"</span>, <span class="keyword">new</span> StandardAnalyzer(Version.LUCENE_CURRENT)).Parse(<span class="string">"content"</span>);   <span class="comment">//  单字段搜索,字段是name搜索词是content   </span></span><br><span class="line"></span><br><span class="line">SortField sfield = <span class="keyword">new</span> SortField(<span class="literal">null</span>, SortField.SCORE, <span class="literal">true</span>);</span><br><span class="line">Sort sort = <span class="keyword">new</span> Sort(sfield);    <span class="comment">//  指定一个排序方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hits = searcher.Search(q, <span class="literal">null</span>, searcher.MaxDoc, sort); <span class="comment">//  搜索,返回前searcher.MaxDoc个Docs组成的TopFieldDocs</span></span><br><span class="line"><span class="comment">//TopFieldDocs docs = searcher.Search(q,null, searcher.MaxDoc, sort);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  下面是通过搜索结果获取Doc的一般方法  */</span></span><br><span class="line">ScoreDoc[] scoreDocs = hits.ScoreDocs;<span class="comment">//权值对象 包含document下标信息，能确定searcher中的document的下标。 </span></span><br><span class="line"><span class="keyword">int</span> docCount = scoreDocs.Length;<span class="comment">// 结果个数统计  </span></span><br><span class="line">Document doc = searcher.Doc(scoreDocs[docCount - <span class="number">1</span>].Doc); <span class="comment">// 通过document下标值，获取document对象 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  输出结果</span></span><br><span class="line">Console.WriteLine(<span class="string">"字段&#123;2&#125;搜索到:&#123;0&#125; 字段&#123;3&#125;搜索到:&#123;1&#125;"</span>, doc.Get(<span class="string">"name"</span>), doc.Get(<span class="string">"content"</span>), <span class="string">"name"</span>, <span class="string">"hello"</span>);</span><br><span class="line">searcher.Close();</span><br></pre></td></tr></table></figure>

<hr>
<p>说实话,本人没有对搜索引擎有过系统的学习,文中有些地方也是根据自己的理解来写的; 如果各位发现有写得不妥之处，欢迎指正！</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>learning</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理相关知识</title>
    <url>/2020/02/24/compilers0/</url>
    <content><![CDATA[<p>未完结,持续更新</p>
<hr>
<p>课程内容:</p>
<ul>
<li>编译器构造的一般原理和基本实现方法</li>
<li>理论知识: 形式语言和自动机理论,语法制导的定义和属性方法,程序分析原理</li>
<li>强调形式描述技术和自动生成技术</li>
<li>强调对编译原理和技术的宏观理解,不把注意力分散到枝节算法,不偏向于任何源语言或目标机器</li>
</ul>
<a id="more"></a>

<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><h2 id="1-1-编译原理概述"><a href="#1-1-编译原理概述" class="headerlink" title="1.1 编译原理概述"></a>1.1 编译原理概述</h2><p>语言处理器: 由编译器,解释器,汇编器,连接器,加载器,调试器及程序概要提取工具等所构成的集成软件开发环境  </p>
<ul>
<li>机器语言和汇编语言: 第一和第二代程序设计语言  </li>
<li>高级语言: 能够自动进行内存管理,类型一致性检查等功能的程序设计语言   </li>
</ul>
<p>翻译器: 能完成一种语言到另一种语言变换的软件</p>
<p>翻译器的不同形式:</p>
<ul>
<li>编译器(c,c++): 从源程序通过编译器得到目标程序,从输入通过目标程序得到输出(效率高,平台相关)</li>
<li>解释器(Python,JavaScript): 从源程序和输入经过解释器直接得到输出 (平台无关)  </li>
<li>区别: 编译器通过翻译来生成目标程序,解释器直接生成源程序指定的运算*</li>
<li>混和编译器(Java,C#): 源程序通过翻译器得到中间程序,中间程序和输入经过虚拟机得到输出(效率稍高,平台无关,但每个平台都要装虚拟机)</li>
</ul>
<p>语言处理系统: 预处理器,编译器,汇编器,连接器\加载器  </p>
<p>主要流程: 源程序-&gt;修改后的源程序-&gt;目标汇编程序-&gt;可重定位的机器代码-(库文件,可重定位目标文件)&gt;可执行目标程序</p>
<h2 id="1-2-编译器基本结构"><a href="#1-2-编译器基本结构" class="headerlink" title="1.2 编译器基本结构"></a>1.2 编译器基本结构</h2><p>编译器: 将源程序编译为目标可执行程序的系统<br>特点: 目标语言比源语言低级</p>
<p>编译器结构:</p>
<ul>
<li>分析部分,前端: 源程序-&gt;中间表示</li>
<li>综合部分,后端: 中间表示-&gt;目标程序</li>
</ul>
<p>前端,只依赖于源语言: 词法分析-&gt;语法分析-&gt;语义分析-&gt;中间代码生成</p>
<ul>
<li>词法分析: 识别词法单元,如变量、数字等</li>
<li>语法分析: 识别语句,得到语法树</li>
<li>语义分析: 识别语义的合理性,得到语义分析结果</li>
<li>中间代码生成: 得到中间表示</li>
</ul>
<p>后端,独立于源语言;和中间语言与目标机器有关: -&gt;代码优化-&gt;代码生成</p>
<ul>
<li>代码优化: 得到中间表示</li>
<li>代码生成: 得到可执行程序</li>
</ul>
<p>同一前端和不同后端组合可以得到同一源语言在不同机器上的编译器<br>不同前端和同一后端组合可以得到同一机器上的几个编译器</p>
<p>总体过程可以如下表示:<br><img src="/2020/02/24/compilers0/proc0.png" alt="progress"><br>编译的几个阶段常用一趟/遍（pass）扫描来实现，一趟/遍扫描 包括读一个输入文件和写一个输出文件。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>逐个扫描构成源程序的字符,把它们组成词法单元(token)流</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">position</span> = rate * <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>词法单元:</p>
<ul>
<li>标识符: position,rate</li>
<li>运算符: *</li>
<li>赋值符: =</li>
<li>数字: 60</li>
</ul>
<p>词法分析结果: *&lt;id,1&gt; &lt;=&gt; &lt;id,2&gt; &lt;*&gt; &lt;60&gt;*  </p>
<p>词法分析也可以叫做线性分析或扫描</p>
<h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>把词法单元流依照语言的语法结构按层次分组,来形式化成语法短语</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">position</span> = rate * <span class="number">60</span></span><br></pre></td></tr></table></figure>
<p>构建语法树:<br><img src="/2020/02/24/compilers0/ga0.png" alt="grammer analysis"></p>
<p>表达式、语句等程序层次结构通常由递归的规则表示</p>
<h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>检查程序语义的正确性,保证程序各个部分能有意义地结合在一起,为后面代码生成阶段手机类型信息  </p>
<p>语义分析包括:</p>
<ul>
<li>类型转换</li>
<li>类型检查</li>
<li>语法制导翻译</li>
</ul>
<p>语义分析结果:<br><img src="/2020/02/24/compilers0/ga1.png" alt="grammer analysis"></p>
<h3 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h3><p>生成一个位于高级编程语言和机器语言(目标程序)之间的中间代码  </p>
<p>一般有后缀表示,抽象语法树,三地址码表示法:<br><img src="/2020/02/24/compilers0/ga2.png" alt="grammer analysis"><br><em>三地址码表示中只有三个变量</em></p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>改进代码,以产生执行较快的机器代码:<br><img src="/2020/02/24/compilers0/ga3.png" alt="grammer analysis"></p>
<h3 id="目标程序生成"><a href="#目标程序生成" class="headerlink" title="目标程序生成"></a>目标程序生成</h3><p>生成可以重定位的机器代码或汇编码:<br><img src="/2020/02/24/compilers0/ga4.png" alt="grammer analysis">  </p>
<ul>
<li>为源程序所用的每个变量选择存储单元，并且把中间代码翻译成等价的机器指令序列。</li>
<li>关键问题是寄存器分配</li>
</ul>
<h3 id="关于符号表管理"><a href="#关于符号表管理" class="headerlink" title="关于符号表管理"></a>关于符号表管理</h3><p>编译器的一项重要工作是记录源程序中使用的标识符，并收集每个标识符的各种属性  </p>
<ul>
<li>这些属性提供标识符的存储分配、类型和作用域信息  </li>
<li>如果是过程标识符，还有参数的个数和类型、参数传递方式和返回值类型  </li>
</ul>
<p>符号表是为每个标识符保存一个记录的数据结构，记录的域是标识符的属性   </p>
<ul>
<li>该数据结构允许我们迅速地找到一个标识符的记录，在此记录中存储和读取数据 </li>
</ul>
<p>管理符号表:</p>
<ul>
<li>词法分析器发现源程序的标识符时，把该标识符填入符号表;但是,词法分析期间不能确定一个标识符的属性</li>
<li>其余的阶段把标识符的信息填入符号表，然后以不同的方式使用这些信息</li>
</ul>
<p><img src="/2020/02/24/compilers0/ga5.png" alt="grammer analysis"></p>
<h3 id="关于出错管理"><a href="#关于出错管理" class="headerlink" title="关于出错管理"></a>关于出错管理</h3><p>每个阶段都可能发现源程序的错误。发现错误后，该阶段必须处理此错误，使得编译可以继续进行，以便进一步发现源程序的其他错误。</p>
<ul>
<li>词法分析：当前被扫描的字符串不能形成语言的词法记号。</li>
<li>语法分析：记号流违反语言的语法规则。</li>
<li>语义分析：编译器试图找出语法正确但对所含的操作来说是无意义的结构，如相加的两个标识符，其一是数组名，另一个是过程名。</li>
</ul>
<h1 id="二、一个简单的语法制导翻译器"><a href="#二、一个简单的语法制导翻译器" class="headerlink" title="二、一个简单的语法制导翻译器"></a>二、一个简单的语法制导翻译器</h1><p>语法制导翻译器:</p>
<ul>
<li>词法分析</li>
<li>语法分析(上下文无关文法)</li>
<li>中间代码生成(语法制导翻译)</li>
</ul>
<p>前端模型如下:<br><img src="/2020/02/24/compilers0/ga5.png" alt="grammer analysis"></p>
<h2 id="2-1-词法分析概述"><a href="#2-1-词法分析概述" class="headerlink" title="2.1 词法分析概述"></a>2.1 词法分析概述</h2><p>源程序–(词法分析器)-&gt;词法单元序列</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>词法分析基本步骤:</p>
<ul>
<li>剔除空白和注释</li>
<li>识别和计算常量</li>
<li>识别关键字和标识符  </li>
</ul>
<p>创建一个符合语法的状态机,并优化,编程实现它</p>
<p>下面代码可以不用细看,后面会细讲  </p>
<h3 id="剔除空白和注释"><a href="#剔除空白和注释" class="headerlink" title="剔除空白和注释"></a>剔除空白和注释</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; peek = next input character) &#123;    <span class="comment">// peek为预读字符</span></span><br><span class="line">       <span class="keyword">if</span>( peek is a blank or a tab ) <span class="keyword">do</span> nothing;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>( peek is a newline) </span><br><span class="line">              line = line + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剔除空行和空白,直到扫描到下一个有效词法单元</p>
<h3 id="识别和计算常量"><a href="#识别和计算常量" class="headerlink" title="识别和计算常量"></a>识别和计算常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( peek holds a digit) &#123;</span><br><span class="line">       v = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">               v = v * <span class="number">10</span> + integer value of digit peek;</span><br><span class="line">               peek = next  input  character</span><br><span class="line">        &#125;<span class="keyword">while</span> ( peek holds a digit);</span><br><span class="line">        <span class="keyword">return</span> token (num, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="识别关键字和标识符"><a href="#识别关键字和标识符" class="headerlink" title="识别关键字和标识符"></a>识别关键字和标识符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( peek 存放了一个字母) &#123;</span><br><span class="line">     将字母或数位读入一个缓冲区b;</span><br><span class="line">      s = b 中的字符形成的字符串;</span><br><span class="line">      w = words.get(s) 返回的词法单元；</span><br><span class="line">      <span class="keyword">if</span> ( w 不是 <span class="keyword">null</span>) <span class="keyword">return</span> w;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">             将键-值对(s, &lt;id, s&gt;)加入到words;</span><br><span class="line">              <span class="keyword">return</span> 词法单元&lt;id, s&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Token <span class="title">scan</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">       跳过空白符；</span><br><span class="line">       处理数字；</span><br><span class="line">       处理保留字和标识符；</span><br><span class="line">       <span class="comment">/*如果运行到这里，就将预读字符peek作为一个词法单元*/</span></span><br><span class="line">       Token t = <span class="keyword">new</span> Token (peek);</span><br><span class="line">        peek = 空白符 <span class="comment">/*按照预读的规则进行初始化,参见龙书p48*/</span>；</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="词法分析建立的类"><a href="#词法分析建立的类" class="headerlink" title="词法分析建立的类"></a>词法分析建立的类</h3><p>各个对象关系如下:<br><img src="/2020/02/24/compilers0/proc1.png" alt="relatives"></p>
<h2 id="2-2-语法分析概述"><a href="#2-2-语法分析概述" class="headerlink" title="2.2 语法分析概述"></a>2.2 语法分析概述</h2><p>语法分析是决定如何使用一个文法生成一个终结符号串的过程</p>
<p>举例如下:<br><img src="/2020/02/24/compilers0/proc3.png" alt="analysis">  </p>
<p>步骤:</p>
<ul>
<li>根据语法构建文法</li>
<li>根据文法构建预测分析表(LL文法,LR文法)</li>
</ul>
<h3 id="上下文无关文法-CFG"><a href="#上下文无关文法-CFG" class="headerlink" title="上下文无关文法 CFG"></a>上下文无关文法 CFG</h3><p>上下文无关文法(Context Free Grammar)由一个四元组G构成<br><img src="/2020/02/24/compilers0/gra0.png" alt="grammer"></p>
<p>在这里，有<br><img src="/2020/02/24/compilers0/gra1.png" alt="grammer"></p>
<p>例如，由+，-号分隔的数位序列可以由如下语法表示  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终结符号集合 &#123;0,1,2,3,4,5,6,7,8,9,+,-&#125; (叶子节点)</span></span><br><span class="line"><span class="comment">// 非终结符号集合 &#123;list,digit&#125;</span></span><br><span class="line"><span class="comment">// 产生式集合:&#123;</span></span><br><span class="line">    list-&gt;list+digit</span><br><span class="line">    list-&gt;list-digit</span><br><span class="line">    list-&gt;digit</span><br><span class="line">    digit-&gt;<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 开始符号 list</span></span><br></pre></td></tr></table></figure>
<h3 id="预测分析表"><a href="#预测分析表" class="headerlink" title="预测分析表"></a>预测分析表</h3><p>NaN</p>
<h3 id="语法分析树"><a href="#语法分析树" class="headerlink" title="语法分析树"></a>语法分析树</h3><p>语法分析树用图形的方式展现从文法的开始符号推出相应符号串的过程  </p>
<p>从定义上看,给定一个上下文无关文法,该文法的一棵语法分析树(parse tree)是具有如下性质的树:</p>
<ol>
<li>根节点的标号为文法的开始符号</li>
<li>每个叶子节点的标号为一个终结符号或空串(e)</li>
<li>每个内部节点的标号为一个非终结符号</li>
<li>如果非终结符号A是某个内部节点的标号,并且它的子节点的标号从左到右分别为X1,X2…Xn,那么必然存在产生式A-&gt;X1,X2…Xn, 其中X1…Xn既可以是终结符号也可以是非终结符号</li>
</ol>
<p>例如:<br><img src="/2020/02/24/compilers0/tree0.png" alt="tree"></p>
<h3 id="左递归问题的消除"><a href="#左递归问题的消除" class="headerlink" title="左递归问题的消除"></a>左递归问题的消除</h3><p>原始公式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A -&gt; A x | y</span><br></pre></td></tr></table></figure>
<p>这种公式在考虑FRONT(A)时会遇到无穷递归的问题</p>
<p>改进公式:将左递归化为循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A -&gt; x R</span><br><span class="line">R -&gt; y R | e(空白符)</span><br></pre></td></tr></table></figure>

<p>效果如下:<br><img src="/2020/02/24/compilers0/recu0.png" alt="recursive"></p>
<h2 id="2-3-语法制导翻译"><a href="#2-3-语法制导翻译" class="headerlink" title="2.3 语法制导翻译"></a>2.3 语法制导翻译</h2><p>语法制导翻译的两种方式:</p>
<ul>
<li>语法制导定义</li>
<li>语法制导翻译方案</li>
</ul>
<h3 id="语法制导定义"><a href="#语法制导定义" class="headerlink" title="语法制导定义"></a>语法制导定义</h3><ul>
<li>每一个产生式和一组语义规则相关联</li>
<li>每个文法符号(非终结符)和一个属性集合相关联</li>
</ul>
<p>此时,产生式和语义规则是分离的,如下:<br><img src="/2020/02/24/compilers0/trans0.png" alt="trans"><br>语法制导定义类似于一种属性文法</p>
<h3 id="语法制导翻译方案"><a href="#语法制导翻译方案" class="headerlink" title="语法制导翻译方案"></a>语法制导翻译方案</h3><ul>
<li>将程序片段附加到一个文法的各个产生式上的表示</li>
<li>被嵌入到产生式体中的程序片段成为语义动作,语义动作用花括号括起来</li>
</ul>
<p>此时,语义是嵌入到产生式中的,如下:<br><img src="/2020/02/24/compilers0/trans1.png" alt="trans"></p>
<h1 id="三、词法分析"><a href="#三、词法分析" class="headerlink" title="三、词法分析"></a>三、词法分析</h1><p><img src="/2020/02/24/compilers0/lex0.png" alt="lex"></p>
<ul>
<li>词法记号：由记号名和属性值构成的二元组，属性值不是必须项，记号名是语法分析的输入符号。(这个模式的名字)</li>
<li>模式：一个记号的模式描述属于该记号的词法单元的形式。和一个给定模式匹配的字（字符串）的集合成为该模式的语言。(一个词法单元可能具有的形式)</li>
<li>词法单元：是源程序中匹配一个记号模式的字符序列，由词法分析器识别为该记号的一个实例。(一个具体的词法单元)</li>
</ul>
<p>常见的词法分析生成器:lex,flex,jlex,ply等  </p>
<h2 id="3-1-串和语言的定义"><a href="#3-1-串和语言的定义" class="headerlink" title="3.1 串和语言的定义"></a>3.1 串和语言的定义</h2><ul>
<li>字母表：符号的有限集合</li>
<li>串：符号的有穷序列,空串为$\epsilon$</li>
<li>语言：字母表上的一个串集,可以只包含空串或是空集</li>
<li>句子：属于语言的串</li>
</ul>
<p>串的运算:<br><img src="/2020/02/24/compilers0/lex1.png" alt="lex"></p>
<h2 id="3-2-正则表达式"><a href="#3-2-正则表达式" class="headerlink" title="3.2 正则表达式"></a>3.2 正则表达式</h2><h3 id="正则表达式的递归定义"><a href="#正则表达式的递归定义" class="headerlink" title="正则表达式的递归定义"></a>正则表达式的递归定义</h3><p><img src="/2020/02/24/compilers0/re0.png" alt="re"></p>
<h3 id="正则表达式的一些公理"><a href="#正则表达式的一些公理" class="headerlink" title="正则表达式的一些公理"></a>正则表达式的一些公理</h3><p><img src="/2020/02/24/compilers0/re1.png" alt="re"></p>
<h3 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h3><p><img src="/2020/02/24/compilers0/re2.png" alt="re"></p>
<h3 id="正则表达式的扩展"><a href="#正则表达式的扩展" class="headerlink" title="正则表达式的扩展"></a>正则表达式的扩展</h3><p>为了方便书写,对一些常用的正则表达式做如下定义<br><img src="/2020/02/24/compilers0/re3.png" alt="re"><br><img src="/2020/02/24/compilers0/re4.png" alt="re">  </p>
<p>一些数量方面的运算符也做了扩展<br><img src="/2020/02/24/compilers0/re5.png" alt="re"><br><img src="/2020/02/24/compilers0/re6.png" alt="re"></p>
<h3 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h3><p>状态转换图描述词法分析器被语法分析器调用时，词法分析器为返回下一个记号所做的动作</p>
<p>绘制状态转换图是构造词法分析器的第一步</p>
<ul>
<li>圆圈表示状态，开始状态由一条没有出发节点、标号为“开始”的边指明</li>
<li>双层圆圈表示接受状态，表示已识别一个记号</li>
<li>有向边表示从一个状态到另一状态</li>
<li>每条边的标号包含一个或多个符号，若离开状态s的某边上标号为other，则它表示离开s的其他边所指示的字符以外的任意字符</li>
<li>*表示输入指针必须回退的转态</li>
</ul>
<p><img src="/2020/02/24/compilers0/status0.png" alt="status"></p>
<h2 id="3-3-有限状态自动机"><a href="#3-3-有限状态自动机" class="headerlink" title="3.3 有限状态自动机"></a>3.3 有限状态自动机</h2><h3 id="不确定的有限状态自动机NFA"><a href="#不确定的有限状态自动机NFA" class="headerlink" title="不确定的有限状态自动机NFA"></a>不确定的有限状态自动机NFA</h3><ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times (\Sigma \cup \lbrace \epsilon \rbrace) \to \rho(Q)$上的映射,$\rho(Q)$表示Q的幂集</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是接受状态集合  <blockquote>
<p>此时,这个自动机在确定的状态接收到了一个确定的符号后,其下一个状态时不确定的</p>
</blockquote>
</li>
</ul>
<h3 id="确定的有限状态自动机DFA"><a href="#确定的有限状态自动机DFA" class="headerlink" title="确定的有限状态自动机DFA"></a>确定的有限状态自动机DFA</h3><ul>
<li>$Q$是非空有穷的状态集合</li>
<li>$\Sigma$是非空有穷的输入字母表</li>
<li>$\delta$为一个$Q \times \Sigma \to Q$上的映射,是状态转移函数</li>
<li>$q_0 \in Q$是初始状态</li>
<li>$F \subseteq Q$是接受状态集合<blockquote>
<ul>
<li>一个符号标记离开同一状态只有一条边</li>
<li>任何状态下都没有ε转换</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="3-4-基于MYT算法从正则表达式到NFA"><a href="#3-4-基于MYT算法从正则表达式到NFA" class="headerlink" title="3.4 基于MYT算法从正则表达式到NFA"></a>3.4 基于MYT算法从正则表达式到NFA</h2><p>正则表达式-(MYT算法)&gt;NFA-(子集构造算法)&gt;DFA-(hopcorft最小化算法)&gt;词法分析器代码</p>
<h3 id="MYT算法"><a href="#MYT算法" class="headerlink" title="MYT算法"></a>MYT算法</h3><p>基本思路: 对正则表达式的结构做归纳  </p>
<ul>
<li>一些基本元素如下构造<br><img src="/2020/02/24/compilers0/construct0.png" alt="cons"><br><img src="/2020/02/24/compilers0/construct1.png" alt="cons"><br><img src="/2020/02/24/compilers0/construct2.png" alt="cons"><br><img src="/2020/02/24/compilers0/construct3.png" alt="cons">  </li>
</ul>
<p>正则表达式的分解和构造:<br><img src="/2020/02/24/compilers0/construct4.png" alt="cons"></p>
<h3 id="从NFA到DFA的转换-子集构造算法"><a href="#从NFA到DFA的转换-子集构造算法" class="headerlink" title="从NFA到DFA的转换(子集构造算法)"></a>从NFA到DFA的转换(子集构造算法)</h3><ul>
<li>找出字母表</li>
<li>分析转换过程(注意$\epsilon$状态可以进行多次输入/滑行),得到DFA<blockquote>
<ol>
<li>以初始状态为中心,将它接受$\epsilon$所能滑行到的状态和这个状态设为一个新状态</li>
<li>扫描字母表,将新状态接受相同字母所能到达的所有状态设合并为一个状态</li>
<li>以2.中所得到的状态为中心执行操作1.,直到没有新状态产生  </li>
</ol>
</blockquote>
</li>
</ul>
<p>一些概念:<br><img src="/2020/02/24/compilers0/construct5.png" alt="cons">  </p>
<p>子集构造算法不一定得到最简的DFA</p>
<h3 id="DFA的化简"><a href="#DFA的化简" class="headerlink" title="DFA的化简"></a>DFA的化简</h3><p>目标: 使得DFA的状态最少</p>
<ul>
<li>找出字母表</li>
<li>分析DFA转换过程,得到最简DFA</li>
<li>主要思想:对状态进行最小划分</li>
<li>化简条件:化简前DFA的函数应是全函数(对每一个状态s和输入a都有对应输出状态)<blockquote>
<ol start="0">
<li>如果DFA不是全函数,需要引入非终结的死状态E<blockquote>
<ul>
<li>所有未定义的输出状态全部转到死状态E</li>
<li>死状态接受E的所有输入都转换到本身</li>
</ul>
</blockquote>
</li>
<li>构造状态集合的初始划分$\Pi$={接收状态,非接收状态}</li>
<li>对$\Pi$中每个子集G,对G进行如下划分:<blockquote>
<p>把G划分为若干子集，G的两个状态s和t在同一子集中，当且仅当对任意输入符号a，s和t的a转换都到π的同一子集中</p>
</blockquote>
</li>
<li>重复2.直到$\Pi$不再改变</li>
<li>去除死状态,得到最简的状态集合:<blockquote>
<ul>
<li>删除死状态和所有和这个状态连接的边,所有边都改成无定义</li>
<li>从开始状态不可达到的状态也删除</li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="3-5-直接从正则表达式到DFA"><a href="#3-5-直接从正则表达式到DFA" class="headerlink" title="3.5 直接从正则表达式到DFA"></a>3.5 直接从正则表达式到DFA</h2><p>NaN</p>
<h1 id="四、语法分析"><a href="#四、语法分析" class="headerlink" title="四、语法分析"></a>四、语法分析</h1><p>语法分析器读取词法分析器提供的记号流，检查它是否能由源语言的文法产生，输出分析树的某种表示。</p>
<p><img src="/2020/02/24/compilers0/token0.png" alt="token"></p>
<p>语法分析器类型:</p>
<ul>
<li>通用语法分析（Cocke-Younger-Kasami算法，Earley算法）:效率低</li>
<li>自顶向下语法分析: 从语法分析树的根节点开始向叶子节点构造语法分析树</li>
<li>自底向上语法分析: 从叶子结点开始，逐渐向根节点方向构造语法分析树</li>
</ul>
<h2 id="4-1-上下文无关文法CFG"><a href="#4-1-上下文无关文法CFG" class="headerlink" title="4.1 上下文无关文法CFG"></a>4.1 上下文无关文法CFG</h2><p>正则文法属于一种上下文无关文法,但它不能描述诸如括号匹配或嵌套结构这样的语言</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>上下文无关文法是一个有序四元组$G=&lt;V,T,S,P&gt;$, 其中:</p>
<ul>
<li>$V$是非终结符集合,非空有限</li>
<li>$T$是终结符集合,非空有限,$V\cap T=\emptyset$</li>
<li>$S\in V$是<strong>起始符</strong></li>
<li>$P$是产生式集合,非空有限<blockquote>
<p>$P$中元素应有这样的形式: $ A \to \alpha $; 其中$A \in V, \alpha \in (V\cup T)^*$ <em>(0型文法是$A \in (V\cup T)^*$)</em> </p>
</blockquote>
</li>
</ul>
<p>上下文无关文法是一个产生式文法</p>
<p>约定:</p>
<ul>
<li>终结符号一般用小写字母abc,标点符号,运算符,数字,黑体单词表示</li>
<li>非终结符一般用大写字母ABC(起始符一般为S),小写斜体单词表示</li>
<li>XYZ可以表示文法符号(终结符或非终结符)</li>
<li>$uvw$等表示终结符号(可以为空)串</li>
<li>$\alpha \beta \gamma$等表示(可以为空)的文法符号串</li>
<li>一般一组产生式中第一个产生式的头就是开始符号</li>
</ul>
<h3 id="文法的推导-派生"><a href="#文法的推导-派生" class="headerlink" title="文法的推导(派生)"></a>文法的推导(派生)</h3><p>直接推导:</p>
<ul>
<li>给定文法$G=&lt;V,T,S,P&gt;$,设$x,y \in (V \cup T)^*$. 称<strong>$y$是$x$的直接推导($x\Rightarrow y$)</strong>,当且仅当:  <blockquote>
<p>$\exists u,v \in (V \cup T)^* $ 且 $ \exists$ ‘a-&gt;b’ $\in P$ 使得 $x = uav,y = ubv$ (即把x中的a改写成b后得到y)  </p>
</blockquote>
</li>
</ul>
<p>推导:</p>
<ul>
<li>给定文法$G=&lt;V,T,S,P&gt;$,设$x_1,x_2,…,x_n \in (V \cup T)^*, n \ge 1 且 x_1\Rightarrow x_2 \Rightarrow … \Rightarrow x_n $, 则称<strong>$x_n$是由$x_1$(经过$n-1$步)推导出来的($x_1 \dot \Rightarrow x_n$)</strong>  <blockquote>
<p>注意,对$V \cup T$上的所有字符串$\omega$有$\omega \dot \Rightarrow \omega$. 可见$\dot \Rightarrow$是$\Rightarrow$的自反传递闭包 </p>
<ul>
<li>推导具有自反性和传递性</li>
</ul>
</blockquote>
</li>
</ul>
<p>句型:</p>
<ul>
<li>从文法的开始符号推到含有非终结符的符号串$\alpha$,则$\alpha$是</li>
</ul>
<p>生成语言:  </p>
<ul>
<li>设$G=&lt;V,T,S,P&gt;$是一个文法,$L(G)$是文法G<strong>生成的语言</strong>,则$L(G)$满足<br>$$ L(G) = \lbrace \omega \in T^* | S \dot \Rightarrow \omega \rbrace $$   <blockquote>
<p>根据定义,$L(G)$中的字符串满足如下两个条件:</p>
<ol>
<li>字符串由终结符构成</li>
<li>字符串可以由起始符派生出来</li>
</ol>
</blockquote>
</li>
</ul>
<p>文法的等价</p>
<ul>
<li>如果$L(G_1) = L(G_2)$,则称文法$G_1$和$G_2$<strong>等价</strong></li>
</ul>
<hr>
<p><em>待更新…</em></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成相关知识</title>
    <url>/2020/02/24/computer-composition0/</url>
    <content><![CDATA[<p>未完结,持续更新</p>
<hr>
<p>网课资源: (智慧树)长春师范大学计算机组成</p>
<p>参考教材: 清华大学出版社《计算机组成与结构(第5版)》</p>
<p>课程内容:</p>
<ul>
<li>讨论单机系统范围内计算机各部件和系统的组成原理以及内部工作机制</li>
</ul>
<p>课程目标:</p>
<ul>
<li>计算机个大部件的组成原理</li>
<li>计算机各大部件的逻辑实现</li>
<li>计算机各大部件的设计方法</li>
<li>计算机各大部件互联构成整体系统的技术</li>
<li>(为后继课程的学习打好基础)</li>
</ul>
<p>课程地位: 承上启下</p>
<ul>
<li>先导课程: 计算机导论,数字逻辑</li>
<li>后继课程: 微机原理,接口技术,计算机系统结构</li>
</ul>
<p>重点难点:</p>
<ul>
<li>掌握五大基本部件的原理及实现</li>
<li>掌握各部件互联构成整机系统的知识(整机概念的建立)</li>
</ul>
<p>课程要求:</p>
<ul>
<li>重点掌握: 多层次的存储器,中央处理器</li>
<li>掌握: 运算方法和运算器,指令系统,总线系统</li>
<li>理解: 外存与io设备</li>
<li>了解: 计算机系统概论,输入输出系统</li>
</ul>
<a id="more"></a>

<h1 id="一、计算机系统概论"><a href="#一、计算机系统概论" class="headerlink" title="一、计算机系统概论"></a>一、计算机系统概论</h1><p>计算机的定义,分类.发展史</p>
<h2 id="1-1-计算机发展简史"><a href="#1-1-计算机发展简史" class="headerlink" title="1.1 计算机发展简史"></a>1.1 计算机发展简史</h2><p>计算机: 能够连续自动进行数值和逻辑运算的机器</p>
<p>分类:</p>
<ul>
<li>原理角度: 数字计算机,模拟计算机</li>
<li>性能指标: 巨型机,大型机,小型机,微型机</li>
<li>用途角度: 专用机,通用机</li>
</ul>
<p>计算机发展阶段:</p>
<ul>
<li>1946-1957: 电子管时代,ENIAC(1946)</li>
<li>1958-1964: 晶体管时代,整体性能大幅度提高,TRADIC(增加浮点运算)</li>
<li>1965-1971: 中小规模集成电路,进入文字处理和图形图像处理</li>
<li>1972-: 大和超大规模集成电路,出现微处理器</li>
</ul>
<h2 id="1-2-计算机硬件"><a href="#1-2-计算机硬件" class="headerlink" title="1.2 计算机硬件"></a>1.2 计算机硬件</h2><p>硬件系统的组成: 冯诺依曼结构,以存储器为中心</p>
<p>特点:</p>
<ul>
<li>计算机(硬件)应由运算器,存储器,控制器,输入设备,输出设备组成</li>
<li>计算机内部采用二进制来表示指令和数据</li>
<li>将编好的程序和原始数据实现存入存储器中然后再启动计算机工作</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/compo0.jpg" alt="composition">  </p>
<ul>
<li>运算器: 数据的加工处理  </li>
<li>控制器: 指令控制,操作控制,时序控制  </li>
<li>存储器: 存放数据和程序  </li>
<li>输入设备: 将外部数据送给计算机并转换成计算机能够识别的形式  </li>
<li>输出设备: 将计算机处理结果送出给外界并转换成外界能够识别的形式<blockquote>
<ul>
<li>运算器,控制器一般为cpu  </li>
<li>存储器一般由主存(内存)和辅存组成  </li>
<li>cpu和主存一般构成主机</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<p>以运算器为核心构造时,输入设备的数据得通过运算器才能进入存储器中;因此以存储器为核心的构造可以提高计算机系统运行的效率</p>
</blockquote>
<p>个计算结构时以总线连接起来的: 总线上有地址,数据,控制三种信号线,结构如下:<br><img src="/2020/02/24/computer-composition0/bus0.jpg" alt="bus"></p>
<h2 id="1-3-计算机软件"><a href="#1-3-计算机软件" class="headerlink" title="1.3 计算机软件"></a>1.3 计算机软件</h2><p>软件和硬件之间存在着逻辑等价关系</p>
<p>语言: 计算机语言经历了由机器语言-&gt;汇编语言-&gt;高级语言的发展过程</p>
<p>计算机系统的多级层次结构(由低到高):</p>
<ul>
<li>硬件(机器语言级)-&gt;操作系统级-&gt;中间件/平台级-&gt;应用程序级(高级语言)</li>
</ul>
<h1 id="二、计算机中常用的组合逻辑电路"><a href="#二、计算机中常用的组合逻辑电路" class="headerlink" title="二、计算机中常用的组合逻辑电路"></a>二、计算机中常用的组合逻辑电路</h1><h2 id="2-1-计算机种常用的组合逻辑电路"><a href="#2-1-计算机种常用的组合逻辑电路" class="headerlink" title="2.1 计算机种常用的组合逻辑电路"></a>2.1 计算机种常用的组合逻辑电路</h2><h3 id="三态门"><a href="#三态门" class="headerlink" title="三态门"></a>三态门</h3><p>三态: 0,1,高阻态Z<br><img src="/2020/02/24/computer-composition0/compo1.jpg" alt="composition"></p>
<p>三态门通常用于驱动总线,当控制端G=1时,数据线A和总线接通,G=0时,该数据线和总线断开</p>
<blockquote>
<p>当总线传输数据时,应当只有一个三态门是正常工作的</p>
</blockquote>
<h3 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h3><p>异或门是计算单元中常用的逻辑电路<br><img src="/2020/02/24/computer-composition0/compo2.jpg" alt="composition"></p>
<p>常见异或门应用:</p>
<ul>
<li>数码比较器 </li>
<li>原码/反码输出电路  </li>
<li>奇偶检测电路</li>
</ul>
<h3 id="加法器"><a href="#加法器" class="headerlink" title="加法器"></a>加法器</h3><p>加法器是计算机的基本运算部件之一</p>
<p>半加器不考虑前一位的进位输入:<br><img src="/2020/02/24/computer-composition0/compo3.jpg" alt="composition"></p>
<p>全加器考虑前一位的进位输入:<br><img src="/2020/02/24/computer-composition0/compo4.jpg" alt="composition"></p>
<h4 id="串行进位加法器"><a href="#串行进位加法器" class="headerlink" title="串行进位加法器"></a>串行进位加法器</h4><p>将多个全加器串联,可以得到多位的加法器,但后一位的计算需要等前一位计算完成后才能开始,导致加法效率较低  </p>
<h4 id="超前进位加法器"><a href="#超前进位加法器" class="headerlink" title="超前进位加法器"></a>超前进位加法器</h4><p>超前进位产生电路通过迭代各位进位的产生式,得到直接产生各位进位的表达式来实现的;后一位的进位无需等待前一位的进位就可以产生,高效但需要使用更多的组合逻辑单元</p>
<p>原理如下:</p>
<ol>
<li>考虑第每一位进位ci的产生条件:<br>$X_i,Y_i$均为1,或$X_i,Y_i$有一个为1且$C_{i-1}$为1,即<br>$C_i=X_iY_i+(X_i+Y_i)C_{i-1}$</li>
<li>由$C_1=X_1Y_1+(X_1+Y_1)C_0$不停对$C_i$进行迭代化简,得到:<br>$$C_i=X_iY_i+\sum_{n=i-1}^1(X_nY_n\prod_{k=i}^{n}(X_k+Y_k))+C_0\prod_{k=i}^{1}(X_k+Y_k)$$<br>如:$C_4=X_4Y_4+(X_4+Y_4)X_3Y_3+(X_4+Y_4)(X_3+Y_3)X_2Y_2+…+..C_0$</li>
<li>定义进位传递函数$P_i=X_i+Y_i$,表明$X_i,Y_i$有一个为1时,将前一位进位传给下一位,达到一种进位传递的效果<br>定义进位产生函数$G_i=X_iY_i$,表明$X_i,Y_i$都为1时,无论$P_i$如何必定向高位产生进位<br>如,此时$C_3=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0$</li>
<li>将各进位改成与非式,画出电路图,如下<br><img src="/2020/02/24/computer-composition0/compo5.jpg" alt="composition"></li>
</ol>
<h4 id="ALU算数逻辑单元"><a href="#ALU算数逻辑单元" class="headerlink" title="ALU算数逻辑单元"></a>ALU算数逻辑单元</h4><p>考虑到超前进位电路的复杂程度是随着位数呈指数增加,一般可以将4位超前进位电路封装成算数逻辑单元,然后再通过组间的串行或超前进位组成16位的ALU</p>
<p>16位快速ALU:组间快速进位<br><img src="/2020/02/24/computer-composition0/compo6.jpg" alt="composition"></p>
<ul>
<li>$G_n=(片内)G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1G_0$</li>
<li>$P_n=(片内)P_3P_2P_1P_0$</li>
<li>$C_11=G_{N_2}+P_{N_2}G_{N_1}+P_{N_2}P_{N_1}G_{N_0}+P_{N_2}P_{N_1}P_{N_0}C_n$,依次类推</li>
</ul>
<p>相比于组间串行进位,最高位进位需要等待前三次进位;16位快速ALU只需要等待一次片内的进位即可;ALU在保证一定运行速度间的同时使得电路规模没有过大</p>
<h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p>由n个输入,最多$2^n$个输出组合而成的逻辑电路,包含:</p>
<ul>
<li>$\overline E$:使能端,一般低有效</li>
<li>$A,B,C(A_1,A_2,A_3)…$:输入端,高有效</li>
<li>$Y_1,Y_2,…,Y_8,…$:输出端,一般低有效</li>
</ul>
<p>通常将使能端连接另一个译码器的输出(CS:芯片选择功能),可以将译码器的译码范围进行扩展</p>
<h3 id="数据选择器"><a href="#数据选择器" class="headerlink" title="数据选择器"></a>数据选择器</h3><p>由$2^n$个输入,n个输出组合而成的逻辑电路,包含:</p>
<ul>
<li>$\overline G_1,\overline G_2$(双数据选择器):使能信号,由一个三态门控制,一般低有效</li>
<li>$S_0,S_1$:通道选择端,高有效</li>
<li>$D_0,D_1,D_2,D_3,…,D_7$(双4选1):通道输入端</li>
<li>$Y_1,Y_2$:输出端,输出所选择通道的电位</li>
</ul>
<p>在保证$\overline G_1,\overline G_2$反相的情况下,可以连接$Y_1,Y_2$来扩展选择通道数</p>
<h2 id="2-2-时序逻辑电路"><a href="#2-2-时序逻辑电路" class="headerlink" title="2.2 时序逻辑电路"></a>2.2 时序逻辑电路</h2><p>如果逻辑电路的输出状态不但和当时的输入状态有关，而且还与电路在此以前的输入状态有关，称这种电路为时序逻辑电路。</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><h4 id="电位触发器"><a href="#电位触发器" class="headerlink" title="电位触发器"></a>电位触发器</h4><p><img src="/2020/02/24/computer-composition0/compo7.jpg" alt="composition"></p>
<p>普通触发器存在触发不能被同步的问题</p>
<h4 id="边沿D触发器"><a href="#边沿D触发器" class="headerlink" title="边沿D触发器"></a>边沿D触发器</h4><p>每当经过一个时钟周期时(CP上升沿或下降沿):<br>$Q^n=D$</p>
<p>边沿触发器存在空翻问题</p>
<h4 id="主从JK触发器"><a href="#主从JK触发器" class="headerlink" title="主从JK触发器"></a>主从JK触发器</h4><p>$Q^n=J \overline Q + \overline K Q$</p>
<h3 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h3><p><img src="/2020/02/24/computer-composition0/compo8.jpg" alt="composition"></p>
<p>每当经过一个时钟周期时,移位寄存器向最低位读取数据,将最高位数据输出,并进行移位</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>每当经过一个时钟周期,将计数加1,计数满则清零并输出进位信息</p>
<ul>
<li>$\overline R_D$:异步清零信号,一般低有效</li>
<li>$L$:同步置数信号,高有效</li>
<li>$Q_1,Q_2,…$:同步置数端</li>
<li>$P,T$:计数使能信号,均高有效,否则为保持状态</li>
<li>$CK$:时钟信号</li>
<li>$RC$:进位信号</li>
</ul>
<h2 id="2-3-阵列逻辑电路"><a href="#2-3-阵列逻辑电路" class="headerlink" title="2.3 阵列逻辑电路"></a>2.3 阵列逻辑电路</h2><p>阵列逻辑电路表明逻辑元件以阵列的形式在硅芯片上排列</p>
<h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p>存储器:</p>
<ul>
<li>字:放置信息的单元,由多个位组成</li>
<li>位:一个二进制信息</li>
<li>地址(码):存储器中每个字的编号,用于寻找存入存储器的字</li>
</ul>
<p>ROM主要由地址译码器和存储单元体构成,通过在每个位置设置或不设置三极管、二极管、熔丝等元件来表示存入的二进制信息<br><img src="/2020/02/24/computer-composition0/rom0.jpg" alt="rom"><br><img src="/2020/02/24/computer-composition0/rom1.jpg" alt="rom"><br>由上图可以看出,ROM存储的是一种主析取范式的表达式</p>
<p>ROM主要有如下两个缺陷:</p>
<ul>
<li>ROM实际存储的字数常少于它所能提供的字数,造成存储单元的闲置和芯片面积的浪费</li>
<li>ROM中的地址和字之间有一一对应的关系,在存储大量重复内容时不能灵活节省空间</li>
</ul>
<h3 id="可编程序逻辑阵列PLA"><a href="#可编程序逻辑阵列PLA" class="headerlink" title="可编程序逻辑阵列PLA"></a>可编程序逻辑阵列PLA</h3><ul>
<li>相比于ROM,PLA能用较少的存储单元存储大量的信息</li>
<li>ROM存储的是一种主析取范式的表达式,而PLA可以存储最简的与或式,因此可以节省一些存储资源的消耗<br><img src="/2020/02/24/computer-composition0/rom2.jpg" alt="rom"> </li>
</ul>
<h3 id="可编程序阵列逻辑PAL"><a href="#可编程序阵列逻辑PAL" class="headerlink" title="可编程序阵列逻辑PAL"></a>可编程序阵列逻辑PAL</h3><ul>
<li>PAL中的与阵列是可编程的,但或阵列不可编程;而在PAL中,两者都可以编程,还有一些PAL中带有记忆元件或反馈电路</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/pal0.jpg" alt="pal"></p>
<h3 id="通用阵列逻辑GAL"><a href="#通用阵列逻辑GAL" class="headerlink" title="通用阵列逻辑GAL"></a>通用阵列逻辑GAL</h3><ul>
<li>ROM,PLA,PAL是一次性编程的,编程后不能修改</li>
<li>GAL是一种可用电擦除的,可重复编程的高速PLD(可编程逻辑电路)</li>
<li>可重复擦写100次以上,数据可保存20年以上,数秒内即可完成擦除和编程的过程</li>
</ul>
<h3 id="门阵列GA-宏单元阵列MCA，标准单元阵列SCA"><a href="#门阵列GA-宏单元阵列MCA，标准单元阵列SCA" class="headerlink" title="门阵列GA,宏单元阵列MCA，标准单元阵列SCA"></a>门阵列GA,宏单元阵列MCA，标准单元阵列SCA</h3><ul>
<li>这些芯片是用来实现批量较大的专用集成电路的</li>
<li>这三种芯片内部的单元都是以阵列形式排列的</li>
</ul>
<h4 id="门阵列"><a href="#门阵列" class="headerlink" title="门阵列"></a>门阵列</h4><p>门阵列设计利用预先制造好的“母片”来进行布图设计;母片上通常以一定的间距成行成列的排列着基本单元电路。</p>
<ul>
<li>这样可以降低设计成本,缩短设计周期:因为母片已完成了整个集成电路制造工艺的大部分流程,剩下只要进行布线连接,就可以实现各种逻辑需求</li>
<li>门阵列器件是一种半用户器件或半定制器件</li>
</ul>
<h4 id="宏单元阵列"><a href="#宏单元阵列" class="headerlink" title="宏单元阵列"></a>宏单元阵列</h4><p>宏单元阵列是一种对门阵列的改进,逻辑功能更强,布图密度更高,制造周期更短</p>
<h4 id="标准单元阵列"><a href="#标准单元阵列" class="headerlink" title="标准单元阵列"></a>标准单元阵列</h4><p>标准单元以预先设计好的功能单元(如门,触发器,加法器等)为基础进行设计生产</p>
<ul>
<li>不同于门阵列那样事先生产半成品芯片;在标准单元阵列中,所有单元都是根据用户逻辑图的需要安排在芯片上。</li>
<li>标准单元阵列是定制器件而非半定制器件,但布局布线更易于实现</li>
</ul>
<h3 id="现场可编程序门阵列FPGA"><a href="#现场可编程序门阵列FPGA" class="headerlink" title="现场可编程序门阵列FPGA"></a>现场可编程序门阵列FPGA</h3><ul>
<li>FPGA由大规模集成电路构成，门电路数达到几万个到几百万个</li>
<li>它主要由四个部分组成：<blockquote>
<ul>
<li>可编程序逻辑宏单元(CLB)</li>
<li>可编程序输入输出宏单元(IOB)</li>
<li>互连资源</li>
<li>重构逻辑的程序存储器: 可以允许多次逻辑的修改,适合在在产品试验或生产批蜇不大时使用</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="三、运算方法和运算部件"><a href="#三、运算方法和运算部件" class="headerlink" title="三、运算方法和运算部件"></a>三、运算方法和运算部件</h1><h2 id="3-1-数值型数据的表示方法和转换"><a href="#3-1-数值型数据的表示方法和转换" class="headerlink" title="3.1 数值型数据的表示方法和转换"></a>3.1 数值型数据的表示方法和转换</h2><ul>
<li>数制: $ (D_m…D_0.D_{-1} .. D_{-k})i $ 是一个i进制数,可以表示成 $ \sum_{n=-k}^mD_n*i^n $,其中i称为基数或底</li>
</ul>
<h3 id="不同数制之间的数据转换"><a href="#不同数制之间的数据转换" class="headerlink" title="不同数制之间的数据转换"></a>不同数制之间的数据转换</h3><h4 id="二进制-八进制-和十六进制转换"><a href="#二进制-八进制-和十六进制转换" class="headerlink" title="二进制,八进制,和十六进制转换"></a>二进制,八进制,和十六进制转换</h4><ul>
<li>二进制转八进制: 从小数点向两边三位成一组转换</li>
<li>二进制转十六进制: 从小数点向两边四位成一组转换</li>
</ul>
<h4 id="二进制-十进制的转换"><a href="#二进制-十进制的转换" class="headerlink" title="二进制,十进制的转换"></a>二进制,十进制的转换</h4><ul>
<li>二进制转十进制用公式$ \sum_{n=-k}^mD_n*2^n $</li>
<li>十进制转二进制用除2取余法(整数部分)和乘2取整法(小数部分)</li>
</ul>
<h3 id="十进制数的编码与运算"><a href="#十进制数的编码与运算" class="headerlink" title="十进制数的编码与运算"></a>十进制数的编码与运算</h3><h4 id="有权码"><a href="#有权码" class="headerlink" title="有权码"></a>有权码</h4><p>如8421,5421,2421BCD编码</p>
<ul>
<li>注意,这种编码是对十进制的每一位进行编码运算,而不是对整个十进制数的运算</li>
</ul>
<h4 id="无权码"><a href="#无权码" class="headerlink" title="无权码"></a>无权码</h4><p>如余3码,格雷码(循环码)</p>
<h2 id="3-2-带符号的二进制数在计算机中的表示方法及加减运算"><a href="#3-2-带符号的二进制数在计算机中的表示方法及加减运算" class="headerlink" title="3.2 带符号的二进制数在计算机中的表示方法及加减运算"></a>3.2 带符号的二进制数在计算机中的表示方法及加减运算</h2><ul>
<li>计算机中表示的带符号的二进制数称为机器数</li>
<li>机器数有原码,补码,反码三种表示方式</li>
<li>这里,假设机器数的真值为[-1,1]的小数,小数部分为数值,整数部分为符号<blockquote>
<p>如:1.0100=10100</p>
</blockquote>
</li>
</ul>
<h3 id="原码-反码-补码及其加减运算"><a href="#原码-反码-补码及其加减运算" class="headerlink" title="原码,反码,补码及其加减运算"></a>原码,反码,补码及其加减运算</h3><h4 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h4><ul>
<li>原码最高位是符号位,0表示正数,1表示负数</li>
<li>其他位是数值位,以绝对值的方式给出</li>
<li>数值0有+0和-0两种原码表示,即0.0000和1.0000</li>
</ul>
<p>原码的加减法需要判断正负号,比较麻烦</p>
<h4 id="反码表示"><a href="#反码表示" class="headerlink" title="反码表示"></a>反码表示</h4><p>正数不变;负数反码在原码的基础上,符号位不变,其他位取反</p>
<ul>
<li>反码的反码是原码</li>
<li>运算时，当最高位有进位而丢掉进位时,要在最低位加1(循环进位)。</li>
</ul>
<h4 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h4><p>正数不变;负数补码在反码的基础上,数值加1</p>
<ul>
<li>数值0的补码形式是唯一的,为0.0000</li>
<li>补码的补码是原码</li>
</ul>
<p>补码在运算中有如下性质:</p>
<ul>
<li>符号位与数值位一样参与运算</li>
<li>补码运算的结果仍为补码</li>
<li>[X]补+[Y]补=[X+Y]补</li>
<li>[X]补-[Y]补=[X]补+[-Y]补</li>
<li>注意,Y与-Y正负号不同,求补码的策略也不同</li>
<li>补码运算时最高位产生的进位直接舍去即可</li>
</ul>
<h3 id="加减运算的溢出处理"><a href="#加减运算的溢出处理" class="headerlink" title="加减运算的溢出处理"></a>加减运算的溢出处理</h3><p>溢出:运算结果超出机器数所能表示的范围</p>
<ul>
<li>异号相加或同号相减结果是不会溢出的,只考虑同号相加或异号相减的情况</li>
<li>注意,最高位是否产生进位和运算结果是否溢出没有关系</li>
</ul>
<p>溢出判断有如下几种方法:</p>
<ul>
<li>同号两数相加,结果符号与两加数不相同,则溢出<blockquote>
<p>$\overline f_A \overline f_B f_S + f_A f_B \overline f_S = 1,其中,f_A f_B f_S$分别为两运算数的符号和结果的符号</p>
</blockquote>
</li>
<li>最高位进位和符号位进位不相同,则溢出<ul>
<li>即,运算正确的情况下,最高位(符号位的前一位)的进位一定要导致符号位进<blockquote>
<p>$C \overline C_f +\overline  C C_f = 1; 其中C,C_f$分别是最高位的进位和符号位的进位</p>
</blockquote>
</li>
</ul>
</li>
<li>采用双符号位运算,正数符号为00,负数为11,此时当结果的两个符号位不同时,溢出<blockquote>
<p>$\overline f_{S2} f_{S1} + f_{S2} \overline f_{S1} = 1,其中f_{S2},f_{S1}$分别是两位符号位</p>
</blockquote>
</li>
</ul>
<h3 id="定点数和浮点数"><a href="#定点数和浮点数" class="headerlink" title="定点数和浮点数"></a>定点数和浮点数</h3><p>在计算机中的数据有定点数和浮点数两种表示方式</p>
<h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><p>定点数指小数点固定在某个位置上的数据,前面加减法中讨论的为定点数</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数指小数点位置可以浮动的数据,可以用$N = M*R^E$表示</p>
<ul>
<li>N为浮点数,M为尾数,E为阶码,R为阶的基数;一般情况下一个计算机中的R都是相同的,无需存储</li>
</ul>
<p>浮点数在计算机中一般以这样的形式显示:$M_S$–$E$–$M$</p>
<ul>
<li>$M_S$: 尾数的符号位(一般为一位),设置在最高位</li>
<li>$E$: 阶码,有n+1位,一般为整数,第一位为符号位</li>
<li>$M$: 尾数,有m位,和前面的$M_S$一同组成一个定点小数<blockquote>
<ul>
<li>规格化尾数:当R=2(二进制数)且尾数不为0时,其绝对值应大于或等于十进制的0.5(即最高位应当为1);对非规格化浮点数,需要将尾数左移或右移,并改变阶码使其满足规格化要求  <blockquote>
<p>如:0.0011 —&gt; (0.11)*2^(0010)</p>
</blockquote>
</li>
<li>机器零值:表示比机器数能表示的最小数还要小的值</li>
</ul>
</blockquote>
</li>
</ul>
<p>浮点数国际标准: IEEE 754</p>
<ul>
<li>单精度浮点数(32位):阶码8位,尾数24位(含一位符号位)</li>
<li>双精度浮点数(64位):阶码11位,尾数53位(含一位符号位)</li>
<li>浮点数基数为2,阶码采用增码(移码),尾数采用原码</li>
<li>而在多数通用机中，浮点数的尾数用原码或补码表示，阶码用补码或移码表示。</li>
<li>注意,由于规格化后的原码最高位恒为1,存储时自动省略,需要在计算时自己加上去<blockquote>
<ul>
<li>移码:在补码基础上,将符号位取反;在阶码上的移码只执行加减运算,且需要对结果进行修正</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="数值范围和精度"><a href="#数值范围和精度" class="headerlink" title="数值范围和精度"></a>数值范围和精度</h3><p>数值范围指机器所能表示的一个数的最大值和最小值;精度是指一个数的有效位数</p>
<ul>
<li>32位定点小数(补码):$-1$(1000…)~$1-2^{-31}$(0111…)</li>
<li>32位定点整数(补码):$-2^{31}$(1000…)~$2^{31}-1$(0111…)</li>
<li>32位单精度浮点数:$-2^{127}$~$(1-2^{-23})*2^{127}$,精度为24位</li>
</ul>
<h2 id="3-3-二进制乘法运算"><a href="#3-3-二进制乘法运算" class="headerlink" title="3.3 二进制乘法运算"></a>3.3 二进制乘法运算</h2><h3 id="定点数一位乘法"><a href="#定点数一位乘法" class="headerlink" title="定点数一位乘法"></a>定点数一位乘法</h3><h4 id="定点原码一位乘"><a href="#定点原码一位乘" class="headerlink" title="定点原码一位乘"></a>定点原码一位乘</h4><p>人工算法:<br><img src="/2020/02/24/computer-composition0/multi0.jpg" alt="multipy"></p>
<p>机器算法:<br><img src="/2020/02/24/computer-composition0/multi1.jpg" alt="multipy"></p>
<ul>
<li>在机器中,有3个寄存器ABC,分别存放部分积,被乘数和乘数的绝对值,其中部分积和被乘数都以双符号位表示;具体过程如下:</li>
</ul>
<ol>
<li>初始化:A寄存器清零,被乘数X放在B中,n位乘数Y放在C中,Cd初始值设为n(用于判断C是否被乘完)</li>
<li>判断C的最低为是否为1,是则将A+B赋给A</li>
<li>将{A,C}向右移一位(A高位补符号位),此时A的最低位进入C的最高位,C的最低位丢失</li>
<li>Cd减1,若减1后Cd仍不为0,转2.继续进行循环</li>
<li>计算A的最高符号位,其为被乘数和乘数符号位的异或</li>
<li>得出结果,此时结果的高位在A中,低位在C中</li>
</ol>
<p>示意图如下,其中被乘数X=0.1101,乘数Y=0.1011<br><img src="/2020/02/24/computer-composition0/multi2.jpg" alt="multipy"><br>得到X*Y=0.10001111</p>
<h4 id="定点补码一位乘"><a href="#定点补码一位乘" class="headerlink" title="定点补码一位乘"></a>定点补码一位乘</h4><p>由于计算机中机器数常以补码形式存在,可以直接使用补码相乘</p>
<p>补码相乘规则如下:</p>
<blockquote>
<p>设被乘数$[X]_补=X_0.X_1X_2…X_n$,乘数$[Y]_补=Y_0.Y_1Y_2…Y_n$,则有:<br>$$ [X*Y]_补=[X]_补*(0.Y_1Y_2…Y_n)-[X]_补*Y_0 $$<br>可见,如果$Y$为负数,需要补充进行$-[X]_补$操作</p>
</blockquote>
<p>布斯补码乘法规则如下:</p>
<blockquote>
<p>考虑相邻的两位$Y_{i+1}$和$Y_i$(乘数的最后一位和倒数第二位),将定点原码一位乘中的2.3.策略改成如下</p>
<ul>
<li>最后两位为00或11,{A,C}右移一位</li>
<li>最后两位为01,将部分积A增加$[X]_补$,{A,C}右移一位</li>
<li>最后两位为10,将部分积A增加$[-X]_补$,{A,C}右移一位</li>
<li>最后一步运算结束后不需要移位<br>计算时,乘数末位需要添加附加位$Y_{n+1}=0$</li>
</ul>
</blockquote>
<p>示意图如下,其中被乘数X=-0.1101,乘数Y=0.1011,即[X]补=11.0011,[Y]补=0.1011,[-X]补=00.1101:<br><img src="/2020/02/24/computer-composition0/multi3.jpg" alt="multipy"> </p>
<h3 id="定点数二位乘"><a href="#定点数二位乘" class="headerlink" title="定点数二位乘"></a>定点数二位乘</h3><p>相比于定点一位乘法,定点数二位乘按乘数每两位的取值情况，一次求出对应于该两位的部分积。此时，只要增加少拭逻辑电路，就可使乘法速度提高一倍。 </p>
<h3 id="阵列乘法器"><a href="#阵列乘法器" class="headerlink" title="阵列乘法器"></a>阵列乘法器</h3><p>为了进一步提高乘法运算速度，可采用类似于人了计算的方法，用一个阵列乘法器完成乘法运算</p>
<h2 id="3-4-二进制除法运算"><a href="#3-4-二进制除法运算" class="headerlink" title="3.4 二进制除法运算"></a>3.4 二进制除法运算</h2><h3 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><p>人工算法:<br><img src="/2020/02/24/computer-composition0/div0.jpg" alt="div"> </p>
<p>机器算法:(要求被除数小于除数,即除法结果应小于1)</p>
<ul>
<li>使用3个寄存器ABC,存放余数(被除数),除数和商的绝对值,商的符号独立计算</li>
</ul>
<ol>
<li>初始化:被除数X放在A中,n位除数Y放在B中,C寄存器清零,计数器i=n+1,若X&gt;Y,则溢出</li>
<li>将A减去B;若余数大于等于0,则商C中的最低位上1,否则上0并恢复余数</li>
<li>i减1,若减1后i仍不为0,将A,C左移一位,重复2.过程</li>
<li>计算C的最高符号位,其为被除数和除数符号位的异或</li>
<li>得出结果,此时商在C中,余数在A中</li>
</ol>
<p>示意图如下,其中被除数X=0.1011,Y=0.1101,即[Y]补=00.1101, [-Y]补=11.0011:<br><img src="/2020/02/24/computer-composition0/div1.jpg" alt="div"><br>得到结果X/Y=0.1101,余数位0.0111</p>
<h4 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h4><p>加减交替法省略了恢复余数的操作,将恢复余数法中的2.策略改成如下</p>
<blockquote>
<ul>
<li>若A&gt;0,则将A减去B;结果余数A&gt;0,则商C中的最低位上1,否则上0(此时下一步就会执行减法操作)</li>
<li>若A&lt;0,则将A加上B;若余数A&gt;0,则商C中的最低位上1,否则上0<br>此时若最后一次上商为0,在计算余数时,依然需要为最后一步恢复余数</li>
</ul>
</blockquote>
<p>示意图如下,其中被除数X=0.1011,Y=0.1101,即[-Y]补=11.0011:<br><img src="/2020/02/24/computer-composition0/div2.jpg" alt="div">  </p>
<ul>
<li>实际上在上述除法运算策略中,被除数的位数可以是除数的两倍,初始化时其高位放在A中,低位在C中,在左移操作时将C中的高位移入A中的低位</li>
</ul>
<h3 id="提高除法运算速度的方法"><a href="#提高除法运算速度的方法" class="headerlink" title="提高除法运算速度的方法"></a>提高除法运算速度的方法</h3><ul>
<li>跳0跳1除法</li>
<li>除法运算通过乘法操作来实现</li>
</ul>
<h2 id="3-5-浮点数的运算方法"><a href="#3-5-浮点数的运算方法" class="headerlink" title="3.5 浮点数的运算方法"></a>3.5 浮点数的运算方法</h2><h3 id="浮点数的加减法运算"><a href="#浮点数的加减法运算" class="headerlink" title="浮点数的加减法运算"></a>浮点数的加减法运算</h3><p>考虑两个浮点数$X = M_X*2^E_X, Y = X = M_Y*2^E_Y$的运算</p>
<p>浮点数加减法运算需要如下五个过程:</p>
<ol>
<li>对阶操作,使得两个浮点数阶码相等(注意阶码是移码)<blockquote>
<ul>
<li>小阶向大阶对齐,将阶码小的数位数右移$\Delta$E位,使其阶码变成E(一般对于补码尾数,符号位参加移位,高位补符号位;但对于原码尾数对阶,符号位不参加移位,高位补0),右移所丢失的位可以保留下来以供舍入操作</li>
</ul>
</blockquote>
</li>
<li>尾数加减,即通常的尾数加减(两个符号位)</li>
<li>(补码)结果规格化操作<blockquote>
<ul>
<li>右规: 运算结果两个符号位的值不同,即运算尾数向上溢出,需要将尾数结果右移一位(高位补符号位),阶码E+1</li>
<li>左规: 运算结果最高数值位与符号位相同(补码),应将尾数连续左移直到最高位数值与符号位不同,并减去相应阶码</li>
</ul>
</blockquote>
</li>
<li>舍入操作: 用于右规和对阶操作时低位舍去的处理<blockquote>
<ul>
<li>截断法: 直接丢掉低位</li>
<li>置1法: 舍去后最低位直接置1</li>
<li>0舍1入法: 若舍去的最高位为1,则它前面的最低为加1,这是常用方法</li>
</ul>
</blockquote>
</li>
<li>检查阶码是否溢出: 在规格化和舍入时阶码可能发生溢出情况<blockquote>
<ul>
<li>阶码向下溢出: 运算结果为机器零</li>
<li>阶码向上溢出: 置溢出标记</li>
</ul>
</blockquote>
</li>
</ol>
<p>具体流程图如下:<br><img src="/2020/02/24/computer-composition0/float0.jpg" alt="float"></p>
<h3 id="浮点数的乘除法运算"><a href="#浮点数的乘除法运算" class="headerlink" title="浮点数的乘除法运算"></a>浮点数的乘除法运算</h3><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><ol>
<li>检测操作数是否为0，若其中有一个操作数为0，则置结果为0；</li>
<li>阶码相加，阶符相同的加可能会溢出，若溢出，则作溢出处理；(阶码一般是移码)</li>
<li>尾数相乘；</li>
<li>尾数乘积规格化,只有左规.</li>
<li>舍入</li>
<li>截断处理:无条件地丢掉正常尾数最低位之后的全部数值</li>
<li>舍入处理:运算过程中保留右移中移出的若干高位的值,然而再按某种规则用这些位上的值修正尾数</li>
<li>判溢出</li>
</ol>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>浮点数除法运算与乘法运算类似,也分求商的阶码、尾数相除、规格化、舍入和判溢这几个步骤</p>
<h2 id="3-6-运算部件"><a href="#3-6-运算部件" class="headerlink" title="3.6 运算部件"></a>3.6 运算部件</h2><h3 id="定点运算部件"><a href="#定点运算部件" class="headerlink" title="定点运算部件"></a>定点运算部件</h3><p>定点运算部件由算术逻辑运算部件ALU、多个寄存器、移位电路、计数器、门电路组成</p>
<ul>
<li>一般定点运算部件中有3个寄存器A、B、C,在不同运算中作用如下:<blockquote>
<ul>
<li>加法:A为被加数-&gt;运算结果,B为加数</li>
<li>减法:A为被减数-&gt;运算结果,B为减数</li>
<li>乘法:A为部分积-&gt;乘积高位,B为被乘数,C为乘数-&gt;乘积低位</li>
<li>除法:A为被除数-&gt;余数,B为除数,C为商</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="浮点运算部件"><a href="#浮点运算部件" class="headerlink" title="浮点运算部件"></a>浮点运算部件</h3><p>浮点运算部件通常由阶码运算部件和尾数运算部件组成</p>
<ul>
<li>阶码部分仅执行加减运算</li>
<li>尾数部分执行加减乘除运算</li>
</ul>
<h2 id="3-7-数据校验码"><a href="#3-7-数据校验码" class="headerlink" title="3.7 数据校验码"></a>3.7 数据校验码</h2><p>通过在数据为中加入一些冗余位,从而达到在数据传输过程中能自动发现错误和校正错误</p>
<ul>
<li>码距: 任意两个合法码之间至少由几个二进制位不同; 较大的码距能使得一个合法码变成另一个合法码的概率较小, 但会增加存储的代价</li>
</ul>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>方法: 在数据(开头)补充一个校验位,使得补充校验位后的数据编码中1值的个数为奇数(奇校验)或偶数(偶校验)</p>
<p><img src="/2020/02/24/computer-composition0/check0.jpg" alt="check"></p>
<ul>
<li>奇偶校验码只能发现一位或奇数个位的出错</li>
<li>奇偶校验码只能发现错误,不能校正错误</li>
<li>就校验码常用于存储器读写检查，或ASCII字符传送过程中的检查。</li>
</ul>
<h3 id="海明校验码"><a href="#海明校验码" class="headerlink" title="海明校验码"></a>海明校验码</h3><p>方法: 在数据中加入多个校验位,将数据中的每一个二进制位分配在几个校验组中;当某一位出错时,就会导致多个校验组的数值发生变化,通过综合分析这些变化来发现出错的位置,为纠错提供依据</p>
<p>一位纠错海明码:</p>
<ul>
<li>设有r位校验位，则共有0到2^r-1个共2^r个组合。若用0表示无差错，则剩余2^r-1个值表示有差错，并指出错在第几位。由于差错可能发生在k个数据位中或r个校验位中，因此有: 2^r–1 &gt;= r+k<blockquote>
<ul>
<li>例如,5-11位数据可用4位校验位来校验</li>
</ul>
</blockquote>
</li>
<li>校验位的分布(下标从1开始):<blockquote>
<ul>
<li>将原数据按位从前向后标号,遇到第$2^{i-1}$个位时,插入第i个校验位$P_i$,得到海明码的数据排列</li>
</ul>
</blockquote>
</li>
<li>校验位的计算<blockquote>
<ul>
<li>按照上述的数据排列给每一位一个二进制编号(从1开始),则对于第i个校验位,它需要校验的是所有二进制编号中第i位为1的数<br>如,第二位校验码$P_2$就需要校验第2(010),3(011),6(110),7(111)位;注意,此时校验码本身也在这些校验位中</li>
<li>用上述方法按校验位进行分组,校验位计算是进行偶校验计算,它等于同组的其他数据的异或</li>
</ul>
</blockquote>
</li>
<li>还可以加入一个总校验位$P_{i+1}$,它等于前面所有位的异或,这时的校验码不仅能纠正一位错,还能发现两位错</li>
</ul>
<p>此时,原数据中每一位都至少由两位校验码校验,码距为4<br>检验方法: 对上述分组中的每一组进行异或检验(包括总校验位),所有检验结果都为0则无措,若有些组为1则可根据检验结果推理出哪一位出错(或者是两位错)</p>
<h3 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h3><p>CRC编码以模2运算为基础,可以发现并纠正多位错误</p>
<h1 id="四、主存储器"><a href="#四、主存储器" class="headerlink" title="四、主存储器"></a>四、主存储器</h1><p>主存储器(主存或内存)在现代计算机中处于中心地位</p>
<ul>
<li>计算机执行的程序和数据均放在存储器中</li>
<li>计算机系 统中输入输出设备数量增多,数据传送速度加快</li>
<li>共享存储器的多处理机的出现 </li>
</ul>
<h2 id="4-1-主存储器分类-技术指标和基本操作"><a href="#4-1-主存储器分类-技术指标和基本操作" class="headerlink" title="4.1 主存储器分类,技术指标和基本操作"></a>4.1 主存储器分类,技术指标和基本操作</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>随机存储器RAM<blockquote>
<ul>
<li>又称读写存储器,通过指令可以随机对各个存储单元进行访问的存储器;一般访问所需时间与存储单元的地址无关,但停电会造成信息丢失</li>
</ul>
</blockquote>
</li>
<li>非易失性存储器<blockquote>
<ul>
<li>停电仍能保持其内容</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h3><ul>
<li>容量<blockquote>
<ul>
<li>计算机可寻址的最小单位是一个存储字;一个存储字所包括的二进制位数称为字长</li>
<li>由于现代计算机中一个字节为8位,因此一个字的字长通常为8的倍数</li>
<li>以字节为单位来表示主存储器存储单元的总数就是主存储器的容量</li>
<li>指令中地址码的位数决定了主存储器可以直接寻址的最大空间,如32位微型机提供32位物理地址,支持对4G物理存储空间的访问</li>
</ul>
</blockquote>
</li>
<li>存取时间<blockquote>
<ul>
<li>存储器的存取时间又称存储器访问时间,是指启动一次存储器操作(读/写)到完成该操作所经历的时间<br>存储周期</li>
<li>存储周期指连续启动两次独立的存储器操作(例如连续两次读操作)所需间隔的最小时间</li>
<li>通常,存储周期略长于存取时间</li>
</ul>
</blockquote>
</li>
</ul>
<p>主存储器的速度和容址两项指标随着存储器件的发展得到了极大的提高。但是，具有 合适价格的主存储器能提供信息的速度总是跟不上CPU的处理指令和数据的速度。</p>
<h3 id="主存储器的基本操作"><a href="#主存储器的基本操作" class="headerlink" title="主存储器的基本操作"></a>主存储器的基本操作</h3><p>主存储器和CPU的连接是由总线支持的:<br><img src="/2020/02/24/computer-composition0/rw0.jpg" alt="rw"></p>
<ul>
<li>AR位地址寄存器</li>
<li>DR为数码寄存器</li>
</ul>
<h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p>读操作是将存储器的数据读取到CPU中:</p>
<ol>
<li>CPU把信息字的地址送到AR,经地址总线送往主存储器</li>
<li>CPU发读(Read)命令</li>
<li>CPU等待主存储器的Ready回答信号，Ready为 1，表示信息已读出经数据总线,送入DR</li>
</ol>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>写操作是将CPU中的数据写入存储器中</p>
<ol>
<li>CPU把信息字的地址送到AR，经地址总线送往主存储器,并将信息字送往DR</li>
<li>CPU发写(Write)命令</li>
<li>CPU等待主存储器的Ready回答信号，Ready为 1，表示信息已从DR经数据总线写入主存储器</li>
</ol>
<h2 id="4-2-读-写存储器-的发展"><a href="#4-2-读-写存储器-的发展" class="headerlink" title="4.2 读/写存储器(的发展)"></a>4.2 读/写存储器(的发展)</h2><h3 id="静态存储器SRAM"><a href="#静态存储器SRAM" class="headerlink" title="静态存储器SRAM"></a>静态存储器SRAM</h3><p>静态存储器利用触发器保存信息,只要不断电,信息就不会丢失</p>
<ul>
<li>集成度低,功耗较大</li>
</ul>
<h3 id="动态存储器DRAM"><a href="#动态存储器DRAM" class="headerlink" title="动态存储器DRAM"></a>动态存储器DRAM</h3><p>动态存储器利用MOS管存储电荷来保存信息,需要不断给电容充电使信息保存</p>
<ul>
<li>使用单管存储单元,通过电容充电来保存信息</li>
<li>再生: DRAM需要在电容的电荷漏掉之间进行充电,又称刷新,一般周期小于2ms</li>
<li>集成度高,功耗小,速度快;但读出是破坏性的,读出后需要立即对单元进行重写</li>
<li>单元读出信号很小,要求有高灵敏度的读出放大器</li>
<li>主要用于大容量存储器<blockquote>
<ul>
<li>相比SRAM,DRAM每片存储容量约是前者4倍,造价约为前者1/4,功率约为前者1/6</li>
</ul>
</blockquote>
</li>
</ul>
<p>DRAM发展:</p>
<ul>
<li>FPM快页式内存</li>
<li>EDO DRAM</li>
<li>同步DRAM(SDRAM):将RAM与CPU以相同的时钟频率进行控制,使RAM和CPU外频同步,取消等待时间</li>
<li>DDR SDRAM:双数据传送速率的SDRAM,在时钟的上升沿和下降沿都能读出数据(预取2位)</li>
<li>DDR 2:预读取能力为4位,降低电压和功耗,等效传输频率翻倍</li>
<li>DDR 3:预读取能力为8位</li>
</ul>
<h2 id="4-3-非易失性半导体存储器"><a href="#4-3-非易失性半导体存储器" class="headerlink" title="4.3 非易失性半导体存储器"></a>4.3 非易失性半导体存储器</h2><p>非易失性半导体存储器在停电时所存储的内容也不会丢失</p>
<ul>
<li><p>只读存储器ROM: 掩模式ROM由芯片制造商在制造时写入内容,以后只能读而不能再写入,前面叙述过它的存储原理</p>
</li>
<li><p>可编程序的只读存储器PROM: 一次性写入的存储器;如熔丝式PROM，刚出厂的产品熔丝是全部接通的，使用前，用户根据需要断开某些单元的熔丝(写入)。</p>
</li>
<li><p>可擦除可编程序的只读存储器EPROM: 能多次修改数据的ROM;产品出厂时,所有存储单元都不导通,当浮置栅注入电子后,存储单元将通导;当芯片用紫外线照射后,浮置栅上的电子将逸散,即整体擦除</p>
</li>
<li><p>可电擦可编程序只读存储器E2PROM: 编程原理和EPROM同,但读写操作可按每个位或每字节进行(类似于SRAM),但每字节的写入周期要几毫秒,寿命为10万次。</p>
</li>
<li><p>快擦读写存储器Flash Memory: 用电擦除,但只能整体擦除或分区擦除; 可做成内存卡应用于各种电子产品</p>
</li>
</ul>
<h2 id="4-4-存储器的组成与控制"><a href="#4-4-存储器的组成与控制" class="headerlink" title="4.4 存储器的组成与控制"></a>4.4 存储器的组成与控制</h2><h3 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h3><p>一个存储器的芯片容量是有限的,要达到所需要的存储字数和存储字长,需要在字向和位向进行扩充; 这里展示静态存储器的位扩展和字扩展</p>
<p>静态存储芯片表示:</p>
<ul>
<li>芯片容量: 由字数*字长表示</li>
<li>地址线: 用于寻址,地址线的位数可由字数表示;如16K表示地址线有14条($16K=2^{14}$,其中1K的地址线是10条</li>
<li>数据线: 用于向芯片写入/读出数据,数据线的位数可由字长表示;如字长为4的芯片数据线有4条</li>
<li>使能(片选)端: 用于控制芯片是否能进行读写操作,一般低有效</li>
<li>读写控制端: 用于切换芯片的读/写操作,一般高位读取低位写入</li>
</ul>
<h4 id="位扩展-扩充数据线字长"><a href="#位扩展-扩充数据线字长" class="headerlink" title="位扩展(扩充数据线字长)"></a>位扩展(扩充数据线字长)</h4><ul>
<li>地址线,使能线(片选$\overline {CS}$),读写控制端$R/ \overline W$并联</li>
<li>数据线串联,分高低位分别引出<br>两片16K*4扩展成一片16K*8<br><img src="/2020/02/24/computer-composition0/sram0.jpg" alt="sram"></li>
</ul>
<h4 id="字扩展-扩充地址线字数"><a href="#字扩展-扩充地址线字数" class="headerlink" title="字扩展(扩充地址线字数)"></a>字扩展(扩充地址线字数)</h4><ul>
<li>地址线,读写控制线,使能线并联</li>
<li>片选连接译码器,用于区分各芯片的地址范围,地址高位通过译码器控制使能端来访问不同的芯片<br>四片16K*8扩展成一片64K*8<br><img src="/2020/02/24/computer-composition0/sram1.jpg" alt="sram"></li>
</ul>
<h4 id="字位扩展"><a href="#字位扩展" class="headerlink" title="字位扩展"></a>字位扩展</h4><p>同时对字向和位向进行扩展</p>
<ul>
<li>片内成组进行位扩展,然后组间进行字扩展</li>
<li>需要用MN/LK个芯片将L*K的存储器扩展成M*N的存储器<br><img src="/2020/02/24/computer-composition0/sram2.jpg" alt="sram"></li>
</ul>
<h3 id="存储控制"><a href="#存储控制" class="headerlink" title="存储控制"></a>存储控制</h3><p>在存储器中，往往需要增设附加电路。这些附加电路包括地址多路转换线路、地址选 通、刷新逻辑，以及读／写控制逻辑等。</p>
<ul>
<li>在大容量存储芯片中,为了减少芯片的地址线引出端的数目,将地址码分两次送到存储器芯片中,使得芯片地址线引出端减少一半</li>
<li>刷新逻辑: 通过定时刷新(读出)保证DRAM中的信息不丢失<blockquote>
<ul>
<li>刷新周期: 从上一次对整个存储器刷新结束到下一次刷新结束为止需要的时间,一般为2ms</li>
<li>分布式刷新:  在2ms内分散地将存储器的每一行刷新</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="存储校验线路"><a href="#存储校验线路" class="headerlink" title="存储校验线路"></a>存储校验线路</h3><ul>
<li>早期计算机多采用奇偶校验电路,只能发现一位错且不能纠正</li>
<li>由于大规模集成电路的发展，主存储器的位数可以做得更多，使多数计算机的存储器有纠正错误代码的功能(ECC)</li>
<li>一般采用的海明码校验线路可以纠正一位错</li>
</ul>
<h2 id="4-5-多体交叉存储器"><a href="#4-5-多体交叉存储器" class="headerlink" title="4.5 多体交叉存储器"></a>4.5 多体交叉存储器</h2><p>计算机中的大容量主存可由多个存储体构成,每个存储体都有自己的读写线路、地址寄存器和数据寄存器,称这种存储体为存储模块</p>
<ul>
<li>为了提高每个模块的使用率和总体的读取效率,对每个模块进行低位交叉编址,连续的地址分布在相邻的模块中<blockquote>
<p>M个交叉模块的使用率在$\sqrt M$和$M$之间</p>
</blockquote>
</li>
</ul>
<h1 id="五、存储系统"><a href="#五、存储系统" class="headerlink" title="五、存储系统"></a>五、存储系统</h1><p>(本章为原书第七章)</p>
<h2 id="5-1-存储系统的层次结构"><a href="#5-1-存储系统的层次结构" class="headerlink" title="5.1 存储系统的层次结构"></a>5.1 存储系统的层次结构</h2><h3 id="存储器类型"><a href="#存储器类型" class="headerlink" title="存储器类型"></a>存储器类型</h3><ul>
<li>主存储器:<blockquote>
<ul>
<li>一般为半导体存储器</li>
<li>存放当前正在执行的程序和数据</li>
<li>主存储器可以随机访问任一单元</li>
</ul>
</blockquote>
</li>
<li>辅助存储器(外存储器)<blockquote>
<ul>
<li>一般为磁盘,磁带,光盘等</li>
<li>存放当前不在运行的大量程序和数据</li>
<li>辅助存储器一般为串行访问存储器,需要顺序地按位进行访问,访问指定信息所需时间与信息所在位置有关   </li>
</ul>
<p>串行存储器:</p>
<ul>
<li>顺序存取存储器(磁带等): 磁带上的信息以顺序的方式存储在带上，读／写时要待磁带移动到合适位置后才能顺序读／写，需要耗费较多时间</li>
<li>直接存取存储器(磁盘等): 它对信息的存取包括移动磁头到信息所在区域(磁道)和从磁道的合适位置进行顺序读写;它比磁带快得多</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h3><p>操作系统和硬件结合,把主存和辅存统一在一起,形成了一个存储层次</p>
<ul>
<li>整体上看,其速度接近于主存</li>
<li>整体上看,其容量接近于辅存  </li>
<li>主存-辅存层次满足了存储器的大容量和低成本的需求<br>这种系统的发展和完善形成了现在广泛使用的虚拟存储系统</li>
</ul>
<p>cache-主存层次</p>
<ul>
<li>在速度方面,计算机的主存和CPU存在一个数量级的差距</li>
<li>高速缓冲存储器cache在速度上能满足CPU的要求</li>
<li>从CPU的角度看,cache-主存层次的速度接近于cache,容量与每位价格接近于主存</li>
<li>这个层次完全由硬件实现</li>
</ul>
<p>计算机的存储层次解决了速度与成本之间的矛盾</p>
<p>现代计算机同时采用上述两种存储层次,构成cache-主存-辅存三级存储层次</p>
<h2 id="5-2-高速缓冲存储器"><a href="#5-2-高速缓冲存储器" class="headerlink" title="5.2 高速缓冲存储器"></a>5.2 高速缓冲存储器</h2><h3 id="cache存在的合理性"><a href="#cache存在的合理性" class="headerlink" title="cache存在的合理性"></a>cache存在的合理性</h3><ul>
<li>程序访问的局部性原理: 在一个较短的时间间隔内,程序访问的地址往往集中在一个很小的范围内<blockquote>
<ul>
<li>程序指令地址本身就是连续分布的,且循环程序段和子程序段经常被反复执行</li>
<li>程序数据分布虽然不一定是集中的,但短时间内对数组的存储和访问以及对工作单元的选择也需要使用到局部范围的存储器地址</li>
</ul>
</blockquote>
</li>
</ul>
<p>根据局部性原理,在主存和CPU之间设置一个高速而容量相对较小的存储器,将当前执行的程序和数据存放在这个存储器中;当程序运行时,不需要再从主存储器中取指令和数据,访问cache即可</p>
<h3 id="cache的结构"><a href="#cache的结构" class="headerlink" title="cache的结构"></a>cache的结构</h3><p>cache一般由SRAM组成,它的工作速度数倍于主存,全部功能由硬件实现,并且对程序员是透明的</p>
<p>其基本结构如下:<br><img src="/2020/02/24/computer-composition0/cache0.jpg" alt="cache">  </p>
<ul>
<li>将n位的主存地址分块,前m位为主存块号,后b位为块内地址;将cache也分成同样大小的多个块,前c位为cache块号,后b位为块内地址(块内字节数与主存相同)</li>
<li>cache内每一个块外加一个标记地址,指明它是主存哪一块的副本,这个标记地址应该为m-c位</li>
<li>注意,cache的块号和它的标记地址不同</li>
</ul>
<p>当CPU发出读请求时,将主存地址m位(或m中的一部分)与cache某块的标记相比较,当结果相等时,说明需要的数据已经在cache中,直接访问cache即可,在CPU与cache之间,通常一次传送一个字块;当比较结果不相等时,说明需要的数据尚未调入cache,那么就要把该数据所在的整个字块从主存中调进来</p>
<ul>
<li>命中: CPU所要访问的信息在cache中,否则为不命中</li>
<li>命中率: CPU所要访问的信息在cache中的比率</li>
<li>失效率: 所要访问的信息不在cache中的比率</li>
</ul>
<p>具有cache的存储器的平均存取时间的计算:</p>
<ul>
<li>设cache本身的存取时间(周期)为tc,命中率为h,主存的存取时间为tm,则:<blockquote>
<p>平均存取时间t = h*tc+(1-h)(tc+tm) 或者估算为 h*tc+(1-h)tm</p>
</blockquote>
</li>
</ul>
<p>cache写策略:如何保证cache中的副本在更改后与主存一致</p>
<ul>
<li>标志交换或写回法: 暂时只修改cache中数据,待该字块被替换出去时写入主存</li>
<li>通过式写法或写通法: 每次修改cache的同时也修改主存</li>
<li>若被修改的单元根本不在cache中,也可以直接对主存进行写操作</li>
</ul>
<h3 id="cache映像"><a href="#cache映像" class="headerlink" title="cache映像"></a>cache映像</h3><h4 id="地址映射-映像-的概念"><a href="#地址映射-映像-的概念" class="headerlink" title="地址映射(映像)的概念"></a>地址映射(映像)的概念</h4><p>为了将信息存放到cache中,需要某种函数将主存的地址映射到cache中;执行程序时,需要通过地址变换将主存地址变换成cache地址,这种变换基于地址映像来实现</p>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><ul>
<li>特点: 主存中第$2^i+k$块只能映射到cache中第k块,其中,i&gt;c(c为cache字块地址位数)<blockquote>
<p>即: $cache字块号 = 主存字块号 mod 2^c$</p>
</blockquote>
</li>
</ul>
<p>从实现上,只需要将m位的主存分成t位主存字块标记和c位cache字块标记;cache中只需要t位进行标记,将其与t位主存字块标记对比即可判断是否命中</p>
<p><img src="/2020/02/24/computer-composition0/cache1.jpg" alt="cache"></p>
<p>由于cache块号与主存块号的部分相关连,因此标记只需要t位;实现简单,cache块的定位迅速(主存的块只能映射到一个cache块中),但不够灵活</p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><ul>
<li>特点: 主存中的每一块可以映射到cache中的任意一块<blockquote>
<p>cache中的标记需要m位,在定位cache块时需要将m位主存块号和所有的cache标记比对一次,才能判断是否”命中”</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/cache2.jpg" alt="cache"></p>
<p>这种方式最灵活,cache命中率最高,但成本也最高,开销大速度慢</p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><ul>
<li>特点: 是直接映射和全相联映射的一个折衷,主存中的每一块可以映射到cache中的$2^{c-r}$块<blockquote>
<ul>
<li>主存和cache分成r组,取主存块地址和cache块地址的后r位</li>
<li>组间为直接映射,组内为全相联映射</li>
</ul>
</blockquote>
</li>
</ul>
<p><img src="/2020/02/24/computer-composition0/cache3.jpg" alt="cache"></p>
<p>上图中cache每一组(行)内都有多个全相联的块</p>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><p>新的主存字块需要调入cache而原可用位置已被占满时,就需要用替换算法来更新cache内容</p>
<h4 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h4><ul>
<li>按调入cache的先后顺序来决定需要被替换出去的cache块;最先被调入cache的块最先被替换成新的块<blockquote>
<ul>
<li>这种算法考虑了局部访问性原理</li>
<li>这种算法实现容易,开销小</li>
<li>但有些时候会使得命中率下降</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h4><ul>
<li>将近期长久未被访问过的块替换出去<blockquote>
<ul>
<li>这种算法按调用频繁程度来决定淘汰顺序,并没有考虑局部访问性原理,比较合理</li>
<li>这种算法的cache命中率较高</li>
<li>这种算法实现开销比FIFO稍大</li>
</ul>
</blockquote>
</li>
</ul>
<p>LRU+FIFO实现: 每次命中新块,都将它移动到队头;若未命中,则将队尾元素替换成新块,然后将它移动到队头</p>
<h4 id="cache地址的监听"><a href="#cache地址的监听" class="headerlink" title="cache地址的监听"></a>cache地址的监听</h4><p>在外部设备对存储器进行修改时,需要保证cache与主存对应快的内容一致,需要对地址进行监听</p>
<p>做法: 若某一IO设备直接对存储器而非cache写入数据时,将对应地址的cache(若有的话)标记有效的位清0,当CPU再次访问该cache时将产生不命中信号;保证CPU所取数据的正确性</p>
<h3 id="多层次cache"><a href="#多层次cache" class="headerlink" title="多层次cache"></a>多层次cache</h3><h4 id="指令cache和数据cache"><a href="#指令cache和数据cache" class="headerlink" title="指令cache和数据cache"></a>指令cache和数据cache</h4><p>将指令和数据放在同一cache中通常会使得存取数据操作和取指令操作发生冲突,延迟了指令的读取</p>
<p>哈佛结构: 将指令cache和数据cache独立分开来</p>
<h4 id="多层次cache-1"><a href="#多层次cache-1" class="headerlink" title="多层次cache"></a>多层次cache</h4><p>集成度高的芯片可用设计出高速的片内cache,与大容量的片外cache配合使用</p>
<p>一般一级cache和二级cache设计在片内,高性能处理器均已采用三级cache方案</p>
<h2 id="5-3-虚拟存储器"><a href="#5-3-虚拟存储器" class="headerlink" title="5.3 虚拟存储器"></a>5.3 虚拟存储器</h2><p>虚拟存储器指的是主存-辅存层次,程序员可以按虚存空间编址</p>
<p>几个单位: 段,页,段页</p>
<h3 id="段式管理"><a href="#段式管理" class="headerlink" title="段式管理"></a>段式管理</h3><p>段: 利用程序模块化性质,按照程序逻辑结构划分出的多个相对的独立部分</p>
<ul>
<li>如: 过程,子过程,数据表,阵列等</li>
<li>这些逻辑部分可以互相调用或者被外部程序调用,形成段间连接,产生规模较大的程序</li>
<li>一般用段表指明段在主存中的位置: 段号,段起点,装入位(表示段是否已经装入主存),段长等(段表本身也是由一个段存储)</li>
</ul>
<p>段式管理: 主存按段进行分配</p>
<ul>
<li>优点: 逻辑独立性好,与程序的自然分界相对应,易于编译、管理、修改和保护,也易于多道程序共享</li>
<li>缺点: 会在段间留下许多空余的零碎存储空间,造成存储资源的浪费</li>
</ul>
<h3 id="页式管理"><a href="#页式管理" class="headerlink" title="页式管理"></a>页式管理</h3><p>页面: 主存的物理空间被划分位等长的固定区域,称为页面</p>
<p>页式管理: 主存按页进行管理,信息传送单位是定长的页</p>
<ul>
<li>优点: 新页调入主存十分容易,,只要有空白页即可; 可能造成浪费的地方是程序最后一页的零头,它比段式管理系统的空间浪费要小得很多</li>
<li>缺点: 由于页不是逻辑上独立的实体,在处理、保护和共享都不及段式来得方便</li>
</ul>
<p>段页式管理: 将程序按模块分段,段内再分页; 出入主存仍以页为信息传送单位, 用段表和页表(每段一个页表)进行两级管理</p>
<p>####页式虚拟存储器</p>
<ul>
<li>逻辑页: 在页式虚拟存储器中,把虚拟空间分成页,称为虚页或逻辑页</li>
<li>物理页: 主存空间分成和虚存同样大小的页,称为实页或物理页</li>
<li>虚存地址: 虚拟地址由高低两个字段组成,高字段为逻辑页号,低字段为页内地址</li>
<li>实存地址: 主存实地址由高低两个字段组成, 高字段为物理页号,低字段为页内地址</li>
</ul>
<p>虚存地址到主存实地址的变换是由页表来实现的<br><img src="/2020/02/24/computer-composition0/page0.jpg" alt="page"></p>
<ul>
<li>对应每个虚页号有一个页表条目,该条目要包含虚页对应主存的物理页号</li>
<li>其他属性包含装入(有效)位,修改位(表示页面内容是否被修改),替换控制位(指出需要替换的页)和其他保护位等<blockquote>
<p>页表本身也在主存中,如果一次访问不命中,那么进行替换、修改再访问,需要和主存进行多次通讯,效率较低</p>
</blockquote>
</li>
</ul>
<p>快表TLB: 将频繁访问的页表信息存放在一个快速存储器中<br><img src="/2020/02/24/computer-composition0/TLB0.jpg" alt="tlb"></p>
<ul>
<li>首先按虚页号同时查询快表慢表</li>
<li>快表查到即访问,查不到即花费一个周期去主存中的慢表找</li>
<li>找到后用替换算法将该页号调入快表</li>
</ul>
<p>页式虚拟存储器优点:</p>
<ul>
<li>主存储器利用率较高</li>
<li>页表相对简单</li>
<li>地址变换速度较快</li>
<li>对磁盘管理比较容易</li>
</ul>
<p>缺点:</p>
<ul>
<li>程序模块化性能不好</li>
<li>页表很长,需要占用大量的存储空间</li>
</ul>
<p>内页表: 虚地址到主存物理地址的变换表<br>外页表: 虚地址和具体辅存地址之间的变换表</p>
<h3 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h3><p>在段页式管理的基础上,产生段页式虚拟存储器</p>
<ul>
<li>多道程序: 如果有多个用户在机器上运行,称为多道程序<blockquote>
<ul>
<li>每一道(每个用户)需要一个基号(用户标志号)</li>
<li>这个地址需要指明该道程序的段表起点(存放在基址寄存器中)</li>
</ul>
</blockquote>
</li>
<li>虚拟地址: 包括基号D,段号S,页号P,页内地址D</li>
</ul>
<p>段页式虚拟存储器地址变换过程见课本第174 175页<br><img src="/2020/02/24/computer-composition0/para0.jpg" alt="para"><br>查询过程:</p>
<ul>
<li>程序段起点+段号-&gt;页表起点</li>
<li>页表起点+页号+页内偏移量-&gt;实存地址</li>
</ul>
<h3 id="虚拟存储器工作过程"><a href="#虚拟存储器工作过程" class="headerlink" title="虚拟存储器工作过程"></a>虚拟存储器工作过程</h3><p><img src="/2020/02/24/computer-composition0/storage0.jpg" alt="storage"></p>
<h3 id="存储管理部件MMU"><a href="#存储管理部件MMU" class="headerlink" title="存储管理部件MMU"></a>存储管理部件MMU</h3><p>虚拟存储系统的特点:</p>
<ul>
<li>允许用户程序用比主存空间大得多的空间来访问主存</li>
<li>每次访存都要进行虚实地址的变换<br>整个虚拟存储器的管理是由存储管理部件MMU和操作系统共同完成的</li>
</ul>
<h2 id="5-4-相连存储器"><a href="#5-4-相连存储器" class="headerlink" title="5.4 相连存储器"></a>5.4 相连存储器</h2><p>在cache和虚拟存储器中,需要用到按内容寻址的相连存储器(页表查询等)</p>
<ul>
<li>相连存储器按照所存数据字的全部内容或部分内容进行查找(检索)访问<br><img src="/2020/02/24/computer-composition0/CR0.jpg" alt></li>
<li>CR是比较数寄存器</li>
<li>MR是屏蔽数寄存器,无需进行匹配的位置为0,置1的位为关键字段</li>
<li>WSR为字选择寄存器,对应位为0的字不参与查找(可以用这个进行二次或多次查找;将上一次的SRR放入WSR即可)</li>
<li>SRR为查找结果寄存器,满足要求的相应位为1</li>
<li>相联存储器能够进行比较操作(相等比较,大小比较,求最值)看,比较操作是并行的,时间复杂度为常数</li>
</ul>
<h2 id="5-5-存储保护"><a href="#5-5-存储保护" class="headerlink" title="5.5 存储保护"></a>5.5 存储保护</h2><p>多个用户对主存进行共享,需要防止由于一个用户程序出错导致其他用户程序和系统软件被破坏,也要防止一个用户程序不合法地访问其他的主存区域</p>
<h3 id="存储区域保护"><a href="#存储区域保护" class="headerlink" title="存储区域保护"></a>存储区域保护</h3><ul>
<li>在主存系统中由系统软件经特权指令设置上下界寄存器为每个程序划定存储区域,禁止越界访问</li>
</ul>
<p>虚拟存储系统中:</p>
<ul>
<li>页表保护: 每个程序都有自己的页表和段表,对它们进行保护; 除非地址变换出错,否则程序只能影响分配给它的几个主存页面</li>
<li>键保护: 为主存的每一页配一个由操作系统赋予的存储键,给相应的每个用户分配一个访问键,这个访问键赋予每道程序; 当访问键与存储键相符合时,这一页的数据才能被允许操作</li>
<li>环保护: 按系统程序和用户程序的重要性对整个系统正常运行的影响程度进行分层(环); 环号大小表示保护级别,环号越大等级越低; 某环内的程序只能转到环号大于等于它本身的页中去</li>
</ul>
<h3 id="访问方式保护"><a href="#访问方式保护" class="headerlink" title="访问方式保护"></a>访问方式保护</h3><p>对主存信息进行读R,写W和执行E(指将数据作为指令使用)保护</p>
<h3 id="管理状态和用户状态"><a href="#管理状态和用户状态" class="headerlink" title="管理状态和用户状态"></a>管理状态和用户状态</h3><p>大多数计算机在执行程序时把工作状态分成两种</p>
<ul>
<li>管理状态：执行操作系统或管理程序时所处的状态</li>
<li>用户状态：执行用户程序时所处的状态<br>为了防止因程序员编程出错而影响整个系统的工作，在机器中设置了一些特权指令(规定特权指令只有操作系统等系统程序才能使用，如在用户程序中出现特权指令)，则在执行到该指令时立即中止程序的执行并发出中断。</li>
</ul>
<h1 id="六、指令系统"><a href="#六、指令系统" class="headerlink" title="六、指令系统"></a>六、指令系统</h1><p>(原书第五章)</p>
<h2 id="指令系统的发展"><a href="#指令系统的发展" class="headerlink" title="指令系统的发展"></a>指令系统的发展</h2><ul>
<li>指令: 计算机执行某种操作的命令 </li>
</ul>
<hr>
<p><em>待更新…</em></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/02/24/java0/</url>
    <content><![CDATA[<p>未完结,持续更新</p>
<hr>
<h2 id="Java常识"><a href="#Java常识" class="headerlink" title="Java常识"></a>Java常识</h2><p>Java: 一次编译，处处运行</p>
<h3 id="Java特点"><a href="#Java特点" class="headerlink" title="Java特点"></a>Java特点</h3><p>c++ - -</p>
<ul>
<li>无直接指针操作</li>
<li>自动内存管理</li>
<li>数据类型长度固定</li>
<li>不用头文件</li>
<li>不包含结构和联合</li>
<li>不支持宏</li>
<li>不用多重继承(接口实现)</li>
<li>无类外全局变量</li>
<li>无goto</li>
</ul>
<p>Java三种核心机制</p>
<ul>
<li>Java虚拟机</li>
<li>代码安全性监测</li>
<li>垃圾回收机制</li>
</ul>
<p><em>Java程序都是运行在虚拟机之上的,与平台无关</em></p>
<ul>
<li>JRE(java运行环境)=JVM+API</li>
<li>JDK(Java开发工具包)=JRE+Tools</li>
</ul>
<a id="more"></a>

<h3 id="Java面向对象程序设计"><a href="#Java面向对象程序设计" class="headerlink" title="Java面向对象程序设计"></a>Java面向对象程序设计</h3><p>类</p>
<ul>
<li>属性: 变量,字段</li>
<li>行为: 函数,方法</li>
</ul>
<p>类与对象的关系</p>
<ul>
<li>类是对象的抽象</li>
<li>对象是类的实例</li>
</ul>
<p>面向对象三大特性</p>
<ul>
<li>封装: 模块化,信息隐蔽</li>
<li>继承: 父类子类间共享数据,更好地抽象和分类,增强代码重用性和可维护性</li>
<li>多态: 方法重载</li>
</ul>
<h3 id="简单Java程序"><a href="#简单Java程序" class="headerlink" title="简单Java程序"></a>简单Java程序</h3><p>Java程序类型:</p>
<ul>
<li>Application: 独立程序,需要执行器(虚拟机)来运行</li>
<li>Applect: 非独立程序,嵌入在HTML网页中运行</li>
</ul>
<p>应用程序要点(helloword)</p>
<ul>
<li>class是主体</li>
<li>public类名与文件名同名</li>
<li>main()的写法是固定的: public static void main()</li>
<li>System.out.print及println及printf</li>
</ul>
<p>Applet程序(helloword)</p>
<ul>
<li>import表示导入</li>
<li>extends JApplet表示继承</li>
<li>有paint()方法,表示如何绘制</li>
<li>没有main()方法</li>
</ul>
<p>Java程序基本构成</p>
<ul>
<li>package语句(0或1句)</li>
<li>import语句(0或多句)</li>
<li>类定义(1或多个,但只能有一个public类,与文件同名)</li>
</ul>
<h3 id="Java程序开发过程"><a href="#Java程序开发过程" class="headerlink" title="Java程序开发过程"></a>Java程序开发过程</h3><p>编辑,编译与运行</p>
<ul>
<li>编辑: 编辑器编辑,文件名要与public class类名一致</li>
<li>程序编译: 转换程序为字节码,扩展名.class  javac name.java</li>
<li>程序运行: 执行.class中的文件    java name</li>
</ul>
<p>JDK安装目录</p>
<blockquote>
<p>Bin 存放工具文件<br>Jre 存放与Java运行环境相关的文件<br>Demo 存放示例文件<br>Include 存放与C相关的头文件<br>Lib 存放程序库<br>DB 数据库相关</p>
</blockquote>
<h3 id="Java的几个工具"><a href="#Java的几个工具" class="headerlink" title="Java的几个工具"></a>Java的几个工具</h3><p>主要工具</p>
<ul>
<li>javac 编译</li>
<li>java 运行(控制台及图形界面程序)</li>
<li>javaw 运行图形界面程序</li>
<li>appletViewer 运行applet程序</li>
</ul>
<p>另外常用工具</p>
<ul>
<li>jar 打包工具</li>
<li>javadoc 生成文档</li>
<li>javap 查看类信息及反汇编</li>
</ul>
<h3 id="Java的输入和输出"><a href="#Java的输入和输出" class="headerlink" title="Java的输入和输出"></a>Java的输入和输出</h3><h4 id="文本界面-使用Scanner类"><a href="#文本界面-使用Scanner类" class="headerlink" title="文本界面: 使用Scanner类"></a>文本界面: 使用Scanner类</h4><p>使用java.util.Scanner类</p>
<ul>
<li>Scanner.nextInt()</li>
<li>Scanner.nextDouble()</li>
<li>Scanner.next 得到下一个单词<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScannerTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = scanner.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="使用in及out"><a href="#使用in及out" class="headerlink" title="使用in及out"></a>使用in及out</h4><p>使用java.io包</p>
<ul>
<li>System.in.read()</li>
<li>System.out.print()<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">''</span>;</span><br><span class="line">System.out.print(<span class="string">'Hello'</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    c = (<span class="keyword">char</span>)System.in.read();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOExceprion e)&#123;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="图形界面输入输出"><a href="#图形界面输入输出" class="headerlink" title="图形界面输入输出"></a>图形界面输入输出</h4><p>添加按钮,监听事件…</p>
<h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><p>NaN</p>
<h4 id="eclips"><a href="#eclips" class="headerlink" title="eclips"></a>eclips</h4><p>java里的程序应当都以工程的形式存在</p>
<ul>
<li>新建一个工程，起一个名字(文件夹的名字)</li>
<li>在src文件夹中建立package包(一般小写字母)</li>
<li>在package里面建立类(首字母大写)</li>
<li>写主函数…</li>
<li>右击包文件 run as application</li>
</ul>
<h2 id="Java数据运算-流程控制和数组"><a href="#Java数据运算-流程控制和数组" class="headerlink" title="Java数据运算,流程控制和数组"></a>Java数据运算,流程控制和数组</h2><p>数据类型决定数据的存储方式和运算方式</p>
<p>主要有两类数据类型:</p>
<ul>
<li>基本数据类型(实体直接存储在栈里)</li>
<li>引用数据类型(实体存储在堆里)<blockquote>
<p>赋值时,基本类型复制的是值,引用类型复制的是引用</p>
</blockquote>
</li>
</ul>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>整数型(byte,short,int,long(3.14L))</li>
<li>浮点数型</li>
<li>逻辑型</li>
<li>字符型</li>
</ul>
<h3 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h3><ul>
<li>短路与:&amp;&amp; 短路或||</li>
<li>注意: ^不是乘方,是位运算异或</li>
<li>赋值的强制类型转换</li>
<li>字符串连接运算符:+ 可以将非字符串类型转换成字符串类型并连接</li>
</ul>
<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><p><em>类似C++</em></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><em>类似C++</em></p>
<h2 id="Java的类"><a href="#Java的类" class="headerlink" title="Java的类"></a>Java的类</h2><h3 id="字段和方法"><a href="#字段和方法" class="headerlink" title="字段和方法"></a>字段和方法</h3><ul>
<li>字段是类的属性</li>
<li>方法时类内部的函数</li>
</ul>
<p>Java的对象时通过引用来表示的，没有指针</p>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载是指多个方法有相同的名字，但编译的时候能识别出来</p>
<ul>
<li>同通过方法重载可以实现多态</li>
</ul>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>类中this可以解决局部变量与域同名的问题，也可以用来调用另一个构造方法:<code>this(args**)</code></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>java一个类只能有一个直接父类</p>
<ul>
<li>子类继承父类的状态和行为</li>
<li>子类可以修改父类的状态或重载父类的行为</li>
<li>子类可以添加新的状态和行为<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c1</span> <span class="keyword">extends</span> <span class="title">c2</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在UML图中,继承用箭头表示</li>
</ul>
<h3 id="方法覆盖"><a href="#方法覆盖" class="headerlink" title="方法覆盖"></a>方法覆盖</h3><p>方法覆盖可以用<code>@override</code>标注</p>
<h3 id="super的使用"><a href="#super的使用" class="headerlink" title="super的使用"></a>super的使用</h3><ul>
<li>使用super在同名的情况下可以在类内访问父类的方法</li>
<li>super可以在子类的构造函数中调用父类的构造函数<code>super(args**)</code></li>
</ul>
<h3 id="父类对象和子类对象转换"><a href="#父类对象和子类对象转换" class="headerlink" title="父类对象和子类对象转换"></a>父类对象和子类对象转换</h3><p>子类对象可以赋值给父类对象,反之不行</p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包和子包的定义,实际上时为了解决名字空间,名字冲突的问题</p>
<ul>
<li>同一个包中的类,默认情况下可以互相访问</li>
</ul>
<h4 id="package语句和import导入语句"><a href="#package语句和import导入语句" class="headerlink" title="package语句和import导入语句"></a>package语句和import导入语句</h4><p>package可以封装包,import可以导入包</p>
<h3 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h3><p>访问修饰符和C++类似C</p>
<ul>
<li>默认情况是一种包内可访问性</li>
</ul>
<p>非访问控制符:</p>
<ul>
<li>static静态类,静态成员</li>
<li>final最终的类,成员,方法</li>
<li>abstract抽象类,抽象成员</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>定义接口<code>interface i1</code></p>
<ul>
<li>接口所有方法都自动是public abstract<br>实现接口implements</li>
<li>实现接口可以解决多继承问题</li>
<li>实现接口与类的继承无关</li>
</ul>
<h2 id="Java内的一些机制"><a href="#Java内的一些机制" class="headerlink" title="Java内的一些机制"></a>Java内的一些机制</h2><h3 id="变量及其传递"><a href="#变量及其传递" class="headerlink" title="变量及其传递"></a>变量及其传递</h3><p>变量分为基本类型和引用类型</p>
<p>变量也可以分为字段变量和局部变量</p>
<ul>
<li>字段变量在堆中存储，局部变量在栈中存储</li>
<li>字段变量可以自动赋初始值，局部变量要显式赋值</li>
<li>相对于字段变量，局部变量不能被访问控制符或static修饰，但可以被final修饰</li>
<li>Java参数传递是值传递(引用变量传递的是引用值)</li>
</ul>
<h3 id="多态和虚方法调用"><a href="#多态和虚方法调用" class="headerlink" title="多态和虚方法调用"></a>多态和虚方法调用</h3><ul>
<li>编译时的多态: 重载</li>
<li>运行时的多态: 覆盖,动态绑定(虚方法调用)<blockquote>
<ul>
<li>所有的非final方法都会进行动态绑定</li>
</ul>
</blockquote>
</li>
</ul>
<p>上溯造型: 将派生类当作基本类处理</p>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><ul>
<li>Java中,普通的方法是虚方法</li>
<li>static,private方法不是虚方法调用(编译后的指令是不同的)</li>
</ul>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>对象都有构造方法,包括抽象类</p>
<ul>
<li>实例初始化: 在类中直接写{}</li>
<li>静态初始化: 在类中写static {}</li>
</ul>
<h3 id="构造方法执行过程"><a href="#构造方法执行过程" class="headerlink" title="构造方法执行过程"></a>构造方法执行过程</h3><ul>
<li>调用本类或父类构造方法直到objct类</li>
<li>按照声明顺序执行字段的初始化赋值</li>
<li>执行构造方法中的语句</li>
</ul>
<h3 id="对象清除与对象回收"><a href="#对象清除与对象回收" class="headerlink" title="对象清除与对象回收"></a>对象清除与对象回收</h3><p>Java中对象销毁是自动的,不需要进行delete</p>
<p>System.gc()可以建议系统进行垃圾回收</p>
<p>Java中没有析构方法,但子类可以重写finalize()方法</p>
<h3 id="内部类和匿名类"><a href="#内部类和匿名类" class="headerlink" title="内部类和匿名类"></a>内部类和匿名类</h3><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>在类内定义class即为内部类</p>
<h3 id="java异常处理"><a href="#java异常处理" class="headerlink" title="java异常处理"></a>java异常处理</h3><p>Java中用try-catch捕获并处理异常，用throw来抛出异常</p>
<hr>
<p><em>待更新…</em></p>
]]></content>
      <categories>
        <category>notes</category>
        <category>学位课程</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>python作图</title>
    <url>/2020/02/12/python-plot1/</url>
    <content><![CDATA[<p>一些参考网站:<br><a href="https://zhuanlan.zhihu.com/p/39077155" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/39077155</a><br><a href="https://zhuanlan.zhihu.com/p/49035741" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49035741</a><br><a href="https://zhuanlan.zhihu.com/p/27401041" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27401041</a><br><a href="https://zhuanlan.zhihu.com/p/37360133" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37360133</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUzODYwMDAzNA==&amp;mid=2247488701&amp;idx=4&amp;sn=73c8ca23d8eced3590ab285f9f43d99b&amp;chksm=fad463b0cda3eaa6f9be051e3c1e0c1a7ddc8922c5c6bf1dfa75f2db84affb88fa248760b781&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1581401241375&amp;sharer_shareid=ab6f5905c1aa5f4891f8d87e4501862b#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzUzODYwMDAzNA==&amp;mid=2247488701&amp;idx=4&amp;sn=73c8ca23d8eced3590ab285f9f43d99b&amp;chksm=fad463b0cda3eaa6f9be051e3c1e0c1a7ddc8922c5c6bf1dfa75f2db84affb88fa248760b781&amp;mpshare=1&amp;scene=23&amp;srcid=&amp;sharer_sharetime=1581401241375&amp;sharer_shareid=ab6f5905c1aa5f4891f8d87e4501862b#rd</a>  </p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab常用语法</title>
    <url>/2020/02/09/matlab/</url>
    <content><![CDATA[<p>仅作随笔用,不完善不严谨</p>
<h3 id="变量-符号-数组-矩阵"><a href="#变量-符号-数组-矩阵" class="headerlink" title="变量 符号 数组 矩阵"></a>变量 符号 数组 矩阵</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&lt;var&gt; = &lt;expression&gt;</span><br></pre></td></tr></table></figure>

<p>预定义变量   </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pi</span>  <span class="comment">% 圆周率</span></span><br><span class="line"><span class="built_in">inf</span> <span class="comment">% 又Inf,无穷大</span></span><br><span class="line"><span class="built_in">nan</span> <span class="comment">% 又NaN,不定值</span></span><br><span class="line"><span class="built_in">eps</span> <span class="comment">% 浮点数运算相对精度,无穷小</span></span><br><span class="line"><span class="built_in">i</span>   <span class="comment">% 又j,虚部单位</span></span><br><span class="line"><span class="built_in">ans</span> <span class="comment">% 上一次运算结果</span></span><br></pre></td></tr></table></figure>

<p>变量存储 读取 清除  </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">save [filename.mat] [var1] [var2] ...</span><br><span class="line">load &lt;filename.mat&gt; [var1] [var2] ...</span><br><span class="line">clear [var1] [var2]</span><br></pre></td></tr></table></figure>

<p>相关命令</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">who <span class="comment">% 显示工作空间中的所有变量  </span></span><br><span class="line">whos    <span class="comment">% 查看工作空间中变量的详细属性 </span></span><br><span class="line"><span class="built_in">realmin</span> <span class="comment">% 最小可用正实数</span></span><br><span class="line"><span class="built_in">realmax</span> <span class="comment">% 最大可用正实数</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="符号-符号表达式"><a href="#符号-符号表达式" class="headerlink" title="符号 符号表达式"></a>符号 符号表达式</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">syms [symbol1] &lt;symbol2&gt; &lt;symbol3&gt; ...  <span class="comment">% 创建多个符号变量, 相当于symbol1 = sym('symbol'); symbol2 = sym('symbol2'); ...</span></span><br><span class="line">[symbol] = sym([symbol/value/symbolexpression])  <span class="comment">% 用符号/数值/表达式来创建符号变量/常量/表达式</span></span><br></pre></td></tr></table></figure>

<p>相关函数  </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">findsym(expression [, N])   <span class="comment">% 查找符号表达式中的[离x最近的N个]符号变量</span></span><br><span class="line">subs(expression, symbol1, symbol2)  <span class="comment">% 在表达式中用s2替换s1</span></span><br></pre></td></tr></table></figure>

<h4 id="数组-矩阵"><a href="#数组-矩阵" class="headerlink" title="数组 矩阵"></a>数组 矩阵</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[matrix] = [row1 ; row2 ; ... ]</span><br><span class="line">[row] = [sym1 sym2 ...] <span class="comment">% row = start: step: end</span></span><br><span class="line">[matrix](n) = value <span class="comment">% 元素赋值</span></span><br><span class="line">[matrix] = [matrix ; matrix2]   <span class="comment">% 矩阵列拼接</span></span><br><span class="line">[matrix] = [matrix matrix2] <span class="comment">% 矩阵行拼接</span></span><br></pre></td></tr></table></figure>

<p>相关操作</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">A(i1 : step : i2, j1 : step : j2)   <span class="comment">% 矩阵切片</span></span><br><span class="line">.* ./ .^    <span class="comment">% 点乘点除点幂乘</span></span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sin</span>、<span class="built_in">cos</span>、<span class="built_in">tan</span>、<span class="built_in">cot</span>、<span class="built_in">sec</span>、<span class="built_in">csc</span>、…</span><br><span class="line"><span class="built_in">asin</span>、<span class="built_in">acos</span>、<span class="built_in">atan</span>、<span class="built_in">acot</span>、<span class="built_in">asec</span>、<span class="built_in">acsc</span>、…</span><br><span class="line"><span class="built_in">exp</span>、<span class="built_in">log</span>、<span class="built_in">log2</span>、<span class="built_in">log10</span>、<span class="built_in">sqrt</span></span><br><span class="line"><span class="built_in">abs</span>、<span class="built_in">conj</span>、<span class="built_in">real</span>、<span class="built_in">imag</span></span><br><span class="line">rank、det、inv、eig、lu、qr、svd</span><br><span class="line"><span class="built_in">diag</span>、<span class="built_in">triu</span>、<span class="built_in">tril</span>、expm</span><br></pre></td></tr></table></figure>

<p>相关命令  </p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">findsym(expr)   <span class="comment">% 按字母顺序列出符号表达式 expr 中的所有符号变量</span></span><br><span class="line">findsym(expr, N)    <span class="comment">% 按顺序列出 expr 中离 x 最近的 N 个符号变量</span></span><br><span class="line">nargin  <span class="comment">% 所用函数的输入变量数目</span></span><br><span class="line">nargout <span class="comment">% 所用函数的输出变量数目</span></span><br></pre></td></tr></table></figure>

<p>####　运算函数</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">factor</span>(f)   <span class="comment">% 因式分解或质因数分解</span></span><br><span class="line">expand(f)   <span class="comment">% 函数展开</span></span><br><span class="line">taylor(f,x,a)   <span class="comment">% f关于符号x在a处进行5项泰勒展开</span></span><br><span class="line">collect(f,v)    <span class="comment">% f对(默认变量)v进行合并同类项</span></span><br><span class="line">simplify(f) <span class="comment">% 对f化简函数</span></span><br><span class="line">numden(f)   <span class="comment">% 函数化简 -&gt; [N,D] N为分子,D为分母</span></span><br><span class="line">horner(f)   <span class="comment">% 多项式转嵌套多项式 x(...x(x+i)+j)+k</span></span><br></pre></td></tr></table></figure>

<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">limit(fun,x,x0 [, <span class="string">'left'</span>/<span class="string">'right'</span>])  <span class="comment">% 在fun中对符号x在x0处求极限</span></span><br><span class="line">int(f [, v, a, b])  <span class="comment">% 在f中对(默认)变量[v][在区间(a,b)上]的(不)定积分</span></span><br><span class="line">symsum(f, v, a, b)  <span class="comment">% 在v=a,a+1....b上对f(v)进行求和</span></span><br><span class="line">solve(f,v)  <span class="comment">% 求方程(组)关于指定自变量的解</span></span><br><span class="line">y=dsolve(eq1, eq2, ..., cond1, cond2, ..., v)   <span class="comment">% 微分方程eq1,eq2...在cond1,cond2...为初值条件下自变量v的解 -&gt; 输出解y,若无显式函数,则输出[x,y]</span></span><br><span class="line">finverse(f,v)   <span class="comment">% f关于(默认变量)v的反函数</span></span><br></pre></td></tr></table></figure>

<h4 id="多项式函数"><a href="#多项式函数" class="headerlink" title="多项式函数"></a>多项式函数</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p = [a1, a2, a3, a4 ...]    <span class="comment">% 多项式降幂系数的行向量表示</span></span><br><span class="line">r = roots(p)    <span class="comment">% 求出多项式为0的根</span></span><br><span class="line">p = poly(r) <span class="comment">% 通过多项式为0的根求出多项式</span></span><br><span class="line">c = conv(a,b)   <span class="comment">% 多项式相乘</span></span><br><span class="line">[q, r] = deconv(c, b)   <span class="comment">% 多项式相除</span></span><br><span class="line">d = polyder(a)  <span class="comment">% 微分多项式</span></span><br><span class="line">n = polyval(a, <span class="number">2</span>)   <span class="comment">% 多项式函数求值</span></span><br><span class="line">p = polyfit(x,y,n)  <span class="comment">% 在x, y样本点向量下求出一个n阶多项式的拟合p</span></span><br><span class="line">[a,Jm] = lsqcurvefit(Fun,a0,x,y)    <span class="comment">% 最小二乘曲线拟合,Fun为原函数，x,y 为原始输入数据,a0为最优化初值，a为最小二乘系数，Jm为目标</span></span><br><span class="line">yi = interp1(x, y, xi, <span class="string">'method'</span>)    <span class="comment">% 一维插值计算</span></span><br><span class="line">zi = interp2(x，y，z，xi，yi，<span class="string">'method'</span>)  <span class="comment">% 二维插值计算</span></span><br></pre></td></tr></table></figure>

<h4 id="作图函数"><a href="#作图函数" class="headerlink" title="作图函数"></a>作图函数</h4><p>参考<a href="https://www.cnblogs.com/ileanj1998/p/9060664.html" target="_blank" rel="noopener">https://www.cnblogs.com/ileanj1998/p/9060664.html</a></p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>(x,y)   <span class="comment">% x 为向量, y为x的函数或者同长度向量</span></span><br><span class="line">xlabel(<span class="string">'x'</span>) ylabel(<span class="string">'y'</span>) <span class="comment">% 坐标轴信息]</span></span><br></pre></td></tr></table></figure>

<h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><ul>
<li>若不想在屏幕上输出结果，可以在语句最后加分号  </li>
<li>如果语句很长，可用续行符 “…”（三个点）续行,续行符的前面最好留一个空格</li>
<li>Matlab 的命令记忆功能：上下箭头键  </li>
<li>命令补全功能： Tab 键   </li>
<li>用 Esc 键 删除命令行</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>learning</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>From Flour to Rolls</title>
    <url>/2020/02/08/making-rolls/</url>
    <content><![CDATA[<p><em>这是一次从面粉到面花卷过程</em>  </p>
<hr>
<a id="more"></a>

<ol>
<li>一斤玉米面、一斤荞麦面、一斤白面、一包奶粉一勺糖，混合均匀  </li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour1.jpg" alt="alt">  </p>
<ol start="2">
<li>35度以下,将干酵母放入水中,混合搅拌均匀  </li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour2.jpg" alt="alt">  </p>
<p><em>一斤面粉放2g干酵母</em>  </p>
<p><img src="/2020/02/08/making-rolls/flour3.jpg" alt="alt"></p>
<p><em>倒入水中混合</em>  </p>
<ol start="3">
<li>将水和面粉混合  </li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour4.jpg" alt="alt"> </p>
<ol start="4">
<li>搅匀  </li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour5.jpg" alt="alt">  </p>
<p><img src="/2020/02/08/making-rolls/flour6.jpg" alt="alt"> </p>
<p><em>最后的样子</em></p>
<ol start="5">
<li>将面放在温暖的地方静置一会</li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour7.jpg" alt="alt">  </p>
<p><img src="/2020/02/08/making-rolls/flour8.jpg" alt="alt">  </p>
<p><em>等待发面中…</em></p>
<ol start="6">
<li>稍微加亿点处理……  </li>
</ol>
<p><em>这儿没有图</em></p>
<ol start="7">
<li>结束</li>
</ol>
<p><img src="/2020/02/08/making-rolls/flour9.jpg" alt="alt">  </p>
<p><em>结束!成品如上</em></p>
<hr>
<p>至于这个花卷最后嘛…<br>嗯,有点丑,但能吃</p>
<!--本来其实是想写一篇关于如何在hexo上发图片的博客,但是感觉没啥意思...  
如果是真的想知道如何在markdown中插入图片,可以看这儿<https://www.jianshu.com/p/81ce308e894c>  
这一篇就当是我拿来练练手发发图片的吧  
还是吃太饱了... --> 
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
        <tag>playing</tag>
      </tags>
  </entry>
  <entry>
    <title>使用termux在安卓系统下搭建hexo-github博客编写环境</title>
    <url>/2020/02/07/android-hexo-setting/</url>
    <content><![CDATA[<p>在hexo已经部署到github的情况下，本文将记录如何把自己的移动设备(安卓手机、平板)变成可以编辑并上传博客的平台。  </p>
<p>关于如何在github上搭建hexo，详见<a href="https://zhuanlan.zhihu.com/p/44213627" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44213627</a><br>注意：使用多终端更新博客之前，请确保自己的博客系统在github上面同时有编译前、后两个分支，多终端更新方法可参考<a href="https://keyanbu.club/2020/02/05/guide/" target="_blank" rel="noopener">https://keyanbu.club/2020/02/05/guide/</a></p>
<p>本博文使用matepad pro在安卓环境下编写完成。  </p>
<a id="more"></a>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于安卓系统下没有直接支持git及hexo的软件，我们使用termux来虚拟出一个linux环境，在终端中安装git及相关包，使用vim或安卓的相关文本编辑器(我用的920编辑器)来编写博文，用termux终端同步博客。  </p>
<p>相关问题：</p>
<ul>
<li>使用termux的pkg安装nodejs时可能会出现与npm版本不兼容的情况，安装nodejs-lts可解决。</li>
<li>使用在使用hexo generate生成博客时可能会出现网页排版错误，尚未解决。  </li>
</ul>
<p>以下所有操作都相对小白，懂的可以直接略过  </p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>除了安装termux之外，其他操作几乎和电脑上是一样的</p>
<ul>
<li>安装termux</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自己去网上找安装包安装，这里不说了</span></span><br><span class="line"><span class="comment"># 安装好之后进入termux，应该是一个显示如下的终端</span></span><br><span class="line"></span><br><span class="line">Welcome to Termux!</span><br><span class="line"></span><br><span class="line">Wiki:            https://wiki.termux.com</span><br><span class="line">Community forum: https://termux.com/community</span><br><span class="line">Gitter chat:     https://gitter.im/termux/termux</span><br><span class="line">IRC channel:     <span class="comment">#termux on freenode</span></span><br><span class="line"></span><br><span class="line">Working with packages:</span><br><span class="line"></span><br><span class="line"> * Search packages:   pkg search &lt;query&gt;</span><br><span class="line"> * Install a package: pkg install &lt;package&gt;</span><br><span class="line"> * Upgrade packages:  pkg upgrade</span><br><span class="line"></span><br><span class="line">Subscribing to additional repositories:</span><br><span class="line"></span><br><span class="line"> * Root:     pkg install root-repo</span><br><span class="line"> * Unstable: pkg install unstable-repo</span><br><span class="line"> * X11:      pkg install x11-repo</span><br><span class="line"></span><br><span class="line">Report issues at https://termux.com/issues</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<ul>
<li>安装git</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pkg install git</span><br></pre></td></tr></table></figure>

<ul>
<li>设置git全局邮箱和用户名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"yourname"</span></span><br><span class="line">$ git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>设置ssh key  </li>
</ul>
<p>这里得先安openssh  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pkg install openssh</span><br></pre></td></tr></table></figure>
<p>然后生成ssh key  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br><span class="line"><span class="comment"># 然后一路默认回车即可</span></span><br></pre></td></tr></table></figure>
<p>这里注意，生成的ssh_key路径是在隐藏目录home/.ssh下的，需要进入˜/.ssh用vim打开id_rsa.pub复制公钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时是默认home路径</span></span><br><span class="line">$ <span class="built_in">cd</span> .ssh    <span class="comment"># 切换到.ssh目录</span></span><br><span class="line">$ vim id_rsa.pub</span><br><span class="line"><span class="comment"># 此时进入vim编辑器，屏幕上显示内容应该和如下类似</span></span><br><span class="line"></span><br><span class="line">ssh-rsa AAAADAQABAAABgQC8uwcEZdQna+zv/HTa2W4I</span><br><span class="line">AvqiNyKxgVdi07ce8hRTpb/lejdVK5rux7jOkWM00Pl73</span><br><span class="line">7qTKXAgWkgVckflinjfd6bxgOEA0ZUYRcFjuMYNccOdWO</span><br><span class="line">XDfmX0w4GYaKhGG5RMsWxVsNSfoskjYpCs1fiSTvM49Y6</span><br><span class="line">FWsEzyXaQ46VWedZJKqEhVPoAtZOEmNOi0krsqymzfjZj</span><br><span class="line">7/iVzuZiFP/zN5itPJXHvYMTA0OzDiPo3qHGHW8yvUpPd</span><br><span class="line">mSY65mXUk1odGmUMBo3/VoOW9ki9t0G6BTqK4lW4qijII</span><br><span class="line">lhrVocrs6APlyAuyPbi5cCtrwQxJSd6J+h8d9t9qdZD/E</span><br><span class="line">DUUdh63jdk07vmlv/+qUza15SZaAptfmFFbKOES8b7qfk</span><br><span class="line">iUXvCr+kCH36lz+rTbF75cW1aU3dJ1/WWj3jgumVyqeMU</span><br><span class="line">bE/OiF3ZBQA7mmz93Jho+Wis5mG07QjI3f18d+ZG0xonf</span><br><span class="line">wg+sjQf3fIujCPq99PcKlM= georgechen1827@gmail.</span><br><span class="line">com</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">id_rsa.pub                1,1            All</span><br></pre></td></tr></table></figure>
<p>复制从ssh到.com的内容，粘贴到你的github-&gt;settings-&gt;SSH and GPG keys-&gt;New SSH key-&gt;Key中(Title随便取个名就行),Add SSH key即可<br>然后回到终端，退出vim并且测试一下是否可以通过git连上github</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关于退出vim，只要输入':q'回车就行</span></span><br><span class="line">$ ssh -T git@github.com    <span class="comment"># 测试是否能够连上github，第一次可能需要连接确认</span></span><br></pre></td></tr></table></figure>
<p>顺便说一句，这个终端中所有的目录和文件都是termux应用的内部数据，从外部(如安卓手机上的文件管理器)一般是访问不到的(比如这个id_rsa.pub就无法从外部来访问)，如果你所操作的文件是在外部存储中；或者想将文件保存在外部存储中，需要给予termux访问存储设备的权限，具体操作下一节会讲到。  </p>
<ul>
<li>安装nodejs</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pkg install nodejs-lts</span><br><span class="line"><span class="comment"># 如果这里 pkg install nodejs 可能会出现npm与nodejs版本不兼容问题，具体原因未知</span></span><br><span class="line"><span class="comment"># 如果termux没有安装npm，需要pkg install npm</span></span><br><span class="line"><span class="comment"># 通过node -v和npm -v可以查看相应的版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装hexo</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<ul>
<li>git自己的博客源文件</li>
</ul>
<p>先cd到你想存放博客的某个文件夹下(如果可以的话，我建议将这个文件夹设在一个能被其他应用访问到的地方，具体操作见下一节)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:yourname/yourname.github.io.git</span><br><span class="line"><span class="comment"># clone你的博客源文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成部署编写…</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> yourname.github.io</span><br><span class="line">$ npm install</span><br><span class="line">$ npm install hexo-deployer-git --save</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>然后就可以开始写博客啦！</p>
<h3 id="关于termux访问外部存储"><a href="#关于termux访问外部存储" class="headerlink" title="关于termux访问外部存储"></a>关于termux访问外部存储</h3><p>上面讲过，termux终端中所有的目录和文件都是作为应用的内部数据存在的，从外部一般访问不到(当然理论上是能访问到的，只是我水平有限)，如果你将博客源文件放在了home目录中，那就意味着你只能用termux中的vim编辑器写博文了，这既不方便也不优雅。  </p>
<p>在此，我的建议是，将你的博客文件存到外部存储(一个容易被你手机/平板的文件管理器访问到的)中，然后做一个文件夹的软链接到你的home目录下，这样即能够使用你手机/平板上其他的app来编辑博文，又方便你在终端中用命令同步文件(软链接可以省去输入难以记住的路径信息)。  </p>
<p>具体操作如下:  </p>
<ul>
<li>开放存储访问权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install termux-tools <span class="comment"># 这是termux自带的管理工具</span></span><br><span class="line">$ termux-setup-storage <span class="comment"># 设置存储访问权限</span></span><br><span class="line"><span class="comment"># 这个时候手机应该会跳出一个权限确认弹窗，点击确定</span></span><br></pre></td></tr></table></figure>

<ul>
<li>链接一个合适的文件夹到home目录下  </li>
</ul>
<p>开放存储访问权限之后，你可以在home目录下发现一个新目录storage，如下:  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># home目录下</span></span><br><span class="line">$ dir</span><br><span class="line">storage</span><br><span class="line">$ <span class="built_in">cd</span> storage <span class="comment"># storage目录里面是一些常用文件夹</span></span><br><span class="line">$ dir</span><br><span class="line">dcim       movies  pictures</span><br><span class="line">downloads  music   shared</span><br><span class="line">$ <span class="built_in">cd</span> shared <span class="comment"># shared文件夹里面就是你安卓设备能访问到的根目录(不严谨地说)</span></span><br><span class="line">$ dir</span><br><span class="line">ANRSnap        Alarms         </span><br><span class="line">Android        BaiduMapAuto   </span><br><span class="line">DCIM           Documents      </span><br><span class="line">Download       Fonts          </span><br><span class="line">Foxit          GDTDOWNLOAD    </span><br><span class="line">Huawei         HuaweiSystem   </span><br><span class="line">Movies         Music          </span><br><span class="line">Notifications  Pictures</span><br></pre></td></tr></table></figure>

<p>我个人是这样做的:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># shared目录下</span></span><br><span class="line">$ mkdir github <span class="comment"># 创建一个github文件夹，以后里面也可以clone其他项目</span></span><br><span class="line">$ <span class="built_in">cd</span> ˜ <span class="comment"># 回到home目录</span></span><br><span class="line">$ ln -s ˜/storage/shared/github github <span class="comment"># 将刚刚创建的文件夹链接到home目录下，方便以后访问</span></span><br><span class="line">$ <span class="built_in">cd</span> github</span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:yourname/yourname.github.io.git <span class="comment"># 做clone，具体不细讲，上一节有</span></span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ ln -s ˜/github/yourname.github.io hexo <span class="comment"># 链接博客目录</span></span><br><span class="line">$ ln -s ˜/hexo/<span class="built_in">source</span>/_posts <span class="comment"># 链接博客文章</span></span><br><span class="line"><span class="comment"># 这样，你的home目录下面应该有博客文章、github、博客三个快速访问链接</span></span><br><span class="line">$ ls</span><br><span class="line">blog  github  hexo  storage</span><br></pre></td></tr></table></figure>

<hr>
<p>到此所有的操作就结束了，如果各位发现我有写得不妥之处，欢迎指正！</p>
]]></content>
      <categories>
        <category>instructions</category>
      </categories>
      <tags>
        <tag>instructions</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>c# notes</title>
    <url>/2020/02/06/csharp-learing/</url>
    <content><![CDATA[<p>未完结,不定期更新</p>
<hr>
<p>源:<a href="https://www.runoob.com/csharp/csharp-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-tutorial.html</a></p>
<h2 id="c-入门"><a href="#c-入门" class="headerlink" title="c#入门"></a>c#入门</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>特性:</p>
<blockquote>
<p>现代的、通用的编程语言<br>面向对象<br>面向组件<br>容易学习<br>结构化语言<br>它产生高效率的程序<br>它可以在多种计算机平台上编译<br>.Net 框架的一部分  </p>
</blockquote>
<p>重要功能:</p>
<blockquote>
<p>布尔条件（Boolean Conditions）<br>自动垃圾回收（Automatic Garbage Collection）<br>标准库（Standard Library）<br>组件版本（Assembly Versioning）<br>属性（Properties）和事件（Events）<br>委托（Delegates）和事件管理（Events Management）<br>易于使用的泛型（Generics）<br>索引器（Indexers）<br>条件编译（Conditional Compilation）<br>简单的多线程（Multithreading）<br>LINQ 和 Lambda 表达式<br>集成 Windows  </p>
</blockquote>
<p>.net框架:<br>.Net 框架是一个创新的平台，能帮您编写出下面类型的应用程序：</p>
<blockquote>
<p>Windows 应用程序<br>Web 应用程序<br>Web 服务  </p>
</blockquote>
<p>.Net 框架应用程序是多平台的应用程序。框架的设计方式使它适用于下列各种语言：C#、C++、Visual Basic、Jscript、COBOL 等等。所有这些语言可以访问框架，彼此之间也可以互相交互。</p>
<blockquote>
<p>.Net 框架由一个巨大的代码库组成，用于 C# 等客户端语言。下面列出一些 .Net 框架的组件：<br>公共语言运行库（Common Language Runtime - CLR）<br>.Net 框架类库（.Net Framework Class Library）<br>公共语言规范（Common Language Specification）<br>通用类型系统（Common Type System）<br>元数据（Metadata）和组件（Assemblies）<br>Windows 窗体（Windows Forms）<br>ASP.Net 和 ASP.Net AJAX<br>ADO.Net<br>Windows 工作流基础（Windows Workflow Foundation - WF）<br>Windows 显示基础（Windows Presentation Foundation）<br>Windows 通信基础（Windows Communication Foundation - WCF）<br>LINQ    </p>
</blockquote>
<a id="more"></a>

<h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;   <span class="comment">//使用名字空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorldApplication</span> <span class="comment">//一个名字空间</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="comment">//一个类</span></span><br><span class="line">   &#123;    <span class="comment">//类方法、类属性</span></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)   <span class="comment">//main方法</span></span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">         <span class="comment">/* 我的第一个 C# 程序*/</span></span><br><span class="line">         Console.WriteLine(<span class="string">"Hello World"</span>);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li>程序的第一行 using System; - using 关键字用于在程序中包含 System 命名空间。 一个程序一般有多个 using 语句。</li>
<li>下一行是 namespace 声明。一个 namespace 里包含了一系列的类。HelloWorldApplication 命名空间包含了类 HelloWorld。</li>
<li>下一行是 class 声明。类 HelloWorld 包含了程序使用的数据和方法声明。类一般包含多个方法。方法定义了类的行为。在这里，HelloWorld 类只有一个 Main 方法。</li>
<li>下一行定义了 Main 方法，是所有 C# 程序的 入口点。Main 方法说明当执行时 类将做什么动作。</li>
<li>下一行 /<em>…</em>/ 将会被编译器忽略，且它会在程序中添加额外的 注释。</li>
<li>Main 方法通过语句 Console.WriteLine(“Hello World”); 指定了它的行为。 </li>
<li>WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法。该语句会在屏幕上显示消息 “Hello, World!”。</li>
<li>最后一行 Console.ReadKey(); 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。  </li>
</ul>
<p>以下几点值得注意：</p>
<ul>
<li>C# 是大小写敏感的。</li>
<li>所有的语句和表达式必须以分号（;）结尾。</li>
<li>程序的执行从 Main 方法开始。</li>
<li>与 Java 不同的是，文件名可以不同于类的名称</li>
</ul>
<h3 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h3><h4 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h4><p>&lt;data_type&gt;?或Nullable&lt;data_type&gt;表示一个可空类型,其除了可以被data_type范围内的对象赋值之外还可以被赋值为null  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>? i = <span class="number">3</span> </span><br><span class="line">等同于</span><br><span class="line">Nullable&lt;<span class="keyword">int</span>&gt; i = <span class="keyword">new</span> Nullable&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">//默认值0</span></span><br><span class="line"><span class="keyword">int</span>? i; <span class="comment">//默认值null</span></span><br></pre></td></tr></table></figure>

<p>‘??’运算:Null合并运算符  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NullablesAtShow</span></span><br><span class="line">   &#123;</span><br><span class="line">         </span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">double</span>? num1 = <span class="literal">null</span>;</span><br><span class="line">         <span class="keyword">double</span>? num2 = <span class="number">3.14157</span>;</span><br><span class="line">         <span class="keyword">double</span> num3;</span><br><span class="line">         num3 = num1 ?? <span class="number">5.34</span>;      <span class="comment">// num1 如果为空值则返回 5.34</span></span><br><span class="line">         Console.WriteLine(<span class="string">"num3 的值： &#123;0&#125;"</span>, num3);</span><br><span class="line">         num3 = num2 ?? <span class="number">5.34</span>;</span><br><span class="line">         Console.WriteLine(<span class="string">"num3 的值： &#123;0&#125;"</span>, num3);</span><br><span class="line">         Console.ReadLine();</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>数据类型<a href="https://www.runoob.com/csharp/csharp-data-types.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-data-types.html</a><br>类型转换<a href="https://www.runoob.com/csharp/csharp-type-conversion.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-type-conversion.html</a><br>变量<a href="https://www.runoob.com/csharp/csharp-variables.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-variables.html</a><br>常量<a href="https://www.runoob.com/csharp/csharp-constants.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-constants.html</a><br>运算符<a href="https://www.runoob.com/csharp/csharp-operators.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-operators.html</a><br>数组<a href="https://www.runoob.com/csharp/csharp-array.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-array.html</a><br>字符串<a href="https://www.runoob.com/csharp/csharp-string.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-string.html</a><br>枚举<a href="https://www.runoob.com/csharp/csharp-enum.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-enum.html</a>   </p>
<p>名字空间<a href="https://www.runoob.com/csharp/csharp-namespace.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-namespace.html</a><br>预处理命令<a href="https://www.runoob.com/csharp/csharp-preprocessor-directives.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-preprocessor-directives.html</a><br>正则表达式<a href="https://www.runoob.com/csharp/csharp-regular-expressions.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-regular-expressions.html</a><br>异常处理<a href="https://www.runoob.com/csharp/csharp-exception-handling.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-exception-handling.html</a><br>文件操作<a href="https://www.runoob.com/csharp/csharp-file-io.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-file-io.html</a>  </p>
<h3 id="判断循环"><a href="#判断循环" class="headerlink" title="判断循环"></a>判断循环</h3><p>判断:  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">jiecheng</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">jiecheng</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Jc</span>(<span class="params"><span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> num &gt; <span class="number">0</span> ? num *Jc(num - <span class="number">1</span>):<span class="number">1</span>;  <span class="comment">//如果num&gt;0则返回num *Jc(num - 1)，否则返回1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">excutejiecheng</span></span><br><span class="line">  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            jiecheng n = <span class="keyword">new</span> jiecheng();</span><br><span class="line">            <span class="keyword">int</span> result = n.Jc(Convert.ToInt16(Console.ReadLine()));</span><br><span class="line">            Console.WriteLine(<span class="string">"result is &#123;0&#125;"</span>,result);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环:  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Loops</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (; ; )</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"Hey! I am Trapped"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//成员变量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> length;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">GetArea</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"长度： &#123;0&#125;"</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">"宽度： &#123;0&#125;"</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">"面积： &#123;0&#125;"</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// Rectangle 结束</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">            r.length = <span class="number">4.5</span>;</span><br><span class="line">            r.width = <span class="number">3.5</span>;</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装<a href="https://www.runoob.com/csharp/csharp-encapsulation.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-encapsulation.html</a><br>方法<a href="https://www.runoob.com/csharp/csharp-methods.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-methods.html</a><br>结构体<a href="https://www.runoob.com/csharp/csharp-struct.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-struct.html</a><br>类<a href="https://www.runoob.com/csharp/csharp-class.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-class.html</a><br>继承<a href="https://www.runoob.com/csharp/csharp-inheritance.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-inheritance.html</a><br>多态<a href="https://www.runoob.com/csharp/csharp-polymorphism.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-polymorphism.html</a><br>重载运算符<a href="https://www.runoob.com/csharp/csharp-operator-overloading.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-operator-overloading.html</a><br>接口<a href="https://www.runoob.com/csharp/csharp-interface.html" target="_blank" rel="noopener">https://www.runoob.com/csharp/csharp-interface.html</a></p>
<h2 id="关于NuGet"><a href="#关于NuGet" class="headerlink" title="关于NuGet"></a>关于NuGet</h2><p>参考<a href="https://www.cnblogs.com/nizhenghua/p/6422078.html" target="_blank" rel="noopener">https://www.cnblogs.com/nizhenghua/p/6422078.html</a><br>NuGet（读作New Get）是用于微软.NET开发平台的软件包管理器，是一个Visual Studio的扩展。在使用Visual Studio开发基于.NET Framework的应用时，NuGet能够令你在项目中添加、移除和更新引用的工作变得更加快捷方便。  </p>
<p>可以在VS中打开安装相应的包, 相当于pip之于python、npm之于nodejs</p>
<h2 id="WPF应用程序-程序和界面分离"><a href="#WPF应用程序-程序和界面分离" class="headerlink" title="WPF应用程序,程序和界面分离"></a>WPF应用程序,程序和界面分离</h2><p>参考<a href="https://www.cnblogs.com/zpfbuaa/p/5380352.html" target="_blank" rel="noopener">https://www.cnblogs.com/zpfbuaa/p/5380352.html</a></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>learning</tag>
      </tags>
  </entry>
  <entry>
    <title>About the Blog</title>
    <url>/2020/02/06/about-the-blog/</url>
    <content><![CDATA[<h3 id="搭建参考"><a href="#搭建参考" class="headerlink" title="搭建参考"></a>搭建参考</h3><p>搭建：<a href="https://zhuanlan.zhihu.com/p/44213627" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44213627</a><br>主题使用：<a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank" rel="noopener">https://github.com/Shen-Yu/hexo-theme-ayer</a><br>分类设置：<a href="https://www.zhihu.com/question/29017171" target="_blank" rel="noopener">https://www.zhihu.com/question/29017171</a></p>
<a id="more"></a>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地运行博客</span></span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo server </span><br><span class="line"></span><br><span class="line"><span class="comment"># 部署博客到github</span></span><br><span class="line">$ hexo clean    <span class="comment"># 可不加</span></span><br><span class="line">$ hexo generate <span class="comment"># hexo g</span></span><br><span class="line">$ hexo deploy   <span class="comment"># hexo d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新hexo分支</span></span><br><span class="line">$ git pull origin hexo  <span class="comment"># 同步博客</span></span><br><span class="line">$ git add .     <span class="comment"># .github.io目录下</span></span><br><span class="line">$ git commit -m <span class="string">"update hexo branch"</span> <span class="comment"># 带解释地提交</span></span><br><span class="line">$ git push      <span class="comment"># 默认分支为hexo, -f 进行强制覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建博文</span></span><br><span class="line">$ hexo new [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建菜单页</span></span><br><span class="line">$ hexo new page &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建草稿</span></span><br><span class="line">$ hexo new draft &lt;title&gt;</span><br><span class="line">$ hexo server --draft   <span class="comment"># 预览草稿</span></span><br><span class="line">$ hexo publish draft newpage    <span class="comment"># 发布草稿</span></span><br></pre></td></tr></table></figure>

<h3 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h3><p><a href="https://www.jianshu.com/p/ebe52d2d468f" target="_blank" rel="noopener">https://www.jianshu.com/p/ebe52d2d468f</a><br><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a></p>
]]></content>
      <categories>
        <category>instructions</category>
      </categories>
      <tags>
        <tag>instructions</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2000/02/28/hello-world/</url>
    <content><![CDATA[<p>欢迎来访！<br>本人初建博客，水平有限，请大家多谅解。</p>
<p><em>以下为原博文</em></p>
<hr>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
</search>
