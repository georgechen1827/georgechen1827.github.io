---
title: 数据库原理与设计
categories: [notes,学位课程]
tags: [数据库,learning]
date: 2020-02-27 13:24:32
---

未完结,持续更新

---

任课教师: 赵朋朋<http://web.suda.edu.cn/ppzhao/>

课程主要讲述关系型数据库的原理, 不着重于具体数据库的使用

<!--more-->

# 一、绪论

## 1.1 数据库系统概述

### 数据库中的基本概念
  
* 数据(data): 是数据库中存储的基本对象; 是描述事物的符号记录,包括数字、文字等不同种类 
 
> 数据是有语义的:相同的数据形式可能有不同的含义,数据与语义是不可分的
> 数据是有结构的:记录是计算机存储数据的一种格式或方法

* 数据库(database): 是长期存储在计算机内,有组织,可共享的大量数据的集合

> 数据库能够收集并抽取应用的数据将其保存,用后续处理  
> 数据库的基本特征:  
> 1. 数据按一定的数据模型组织,描述和存储
> 2. 可为各种用户共享,冗余度较小,易扩展
> 3. 数据独立性较高

* 数据库管理系统(DBMS): 是位于用户应用与操作系统之间的一层数据管理软件,是一个大型复杂的软件系统

> 用途: 能科学地组织和存储数据,高效的获取和维护数据  
> 功能: 
>1. 数据定义功能:提供数据定义语言,定义数据库中的数据对象
>2. 数据组织存储和管理功能
>3. 数据操纵功能:提供数据操纵语言,实现对数据库增删改查
>4. 数据库的事务和并发管理和运行管理功能:保证数据安全完整,故障恢复
>5. 数据库建立和维护功能:提供实用程序和工具
>6. 其它功能:通信,数据转换等

* 数据库系统(DBS): 在计算机系统中引入数据库后的系统构成, 也可简称为数据库

> 数据库系统构成: 数据库, 数据库管理系统(及其应用开发工具), 应用程序, 数据库管理员(DBA)

### 数据库管理技术

数据管理: 对数据进行分类,组织,编码,存储,检索和维护  
数据管理是数据处理和数据分析的中心问题

发展: 人工管理->文件系统管理->数据库系统管理  
![diff](diff0.png)

* 人工管理阶段, 应用程序和数据集是一一对应的
* 文件系统阶段, 存取方法是共享的, 但应用程序和数据集是一一对应的
* 数据库系统阶段, 多个应用程序通过同一个数据库管理系统对同一个数据库进行操作

### 数据库系统的特点

* 数据结构化
* 数据的共享性高,冗余度低且易扩充
* 数据独立性高:有物理独立性和逻辑独立性
* 数据由数据库管理系统统一管理和控制

## 1.2  数据模型
数据模型是对现实世界数据特征的抽象,是对现实世界的模拟

数据模型应满足三方面要求
* 能比较真实地模拟现实世界
* 容易为人所理解
* 便于在计算机上实现  

数据模型是数据库系统的核心和基础 

### 两类数据模型
数据模型分为两类(两个不同层次):  
* 概念模型，也称信息模型 : 它是按用户的观点来对数据和信息建模，用于数据库设计  
* 逻辑模型和物理模型 
>* 逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型等
>* 逻辑模型是按计算机系统的观点对数据建模，用于DBMS实现
>* 物理模型是对数据最底层的抽象, 是描述数据在系统内（磁盘上）的表示方式和存取方法

现实世界中客观对象的抽象过程:   
![proc](proc0.png)

### 概念模型  
* 概念模型用于信息世界的建模 
* 是现实世界到机器世界的一个中间层次
* 是数据库设计的有力工具
* 数据库设计人员和用户之间进行交流的语言 

概念模型的特点:  
* 较强的语义表达能力
* 简单、清晰、易于用户理解 

信息世界中的基本概念: 
* 实体（Entity）: 客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。
* 属性（Attribute）: 实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。
* 码（Key）: 唯一标识实体的属性集称为码。
* 实体型（Entity Type）: 用实体名及其属性名集合来抽象和刻画同类实体称为实体型(对象)
* 实体集（Entity Set）: 同一类型实体的集合称为实体集 
* 联系（Relationship）: 现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。
>* 实体内部的联系: 是指组成实体的各属性之间的联系 
>* 实体之间的联系: 通常是指不同实体集之间的联系, 实体之间的联系有一对一（1:1）、一对多（1:n）和多对多（m:n）等多种类型 

实体-联系方法（Entity-Relationship Approach）是概念模型的一种表示方法:
* 用E-R图来描述现实世界的概念模型 
* E-R方法也称为E-R模型  
![relation](rela0.png)  

(具体方法在数据库设计中会讲到)

### 数据模型的组成要素

数据模型是严格定义的一组概念的集合
* 它精确地描述了系统的静态特性、动态特性和完整性约束条件 (Integrity Constraints)。

数据模型由三部分组成
* 数据结构--描述系统的静态特性 
* 数据操作--描述系统的动态特性 
* 完整性约束条件

#### 数据结构
* 数据结构是刻画数据模型性质的重要方面  
>* 一般用数据结构的类型来命名数据模型,如: 层次结构-层次模型、网状结构--网状模型、关系结构—关系模型 

* 数据结构是用来描述数据库的组成对象--对象的类型、内容、性质
* 数据结构可以用来描述对象之间的联系 

#### 数据操作
数据操作是对数据库中各种对象的实例允许执行的操作的集合，包括操作的类型及有关的操作规则

操作的类型: 增删改查

数据操作语言: 
* 数据操作语言需要定义数据操作的确切含义、符号、优先级别
* 数据操作语言需要实现查询语言(Query Language)和更新语言(Insert、Delete、Update) 

#### 数据完整性约束条件
数据完整性约束条件是一组完整性规则的集合
* 完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则
* 完整性规则可以限定符合数据模型的数据库状态以及状态的变化，以保证数 据的正确、有效和相容。

数据模型对完整性约束条件的定义:
* 反映和规定必须遵守的基本的通用的完整性约束条件
* 提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。

### 常用的数据模型

* 格式化模型: 层次模型,网状模型 
* 关系模型
* 对象模型: 面向对象数据模型,对象关系数据模型
* 半结构化数据模型:XML,HTML
* 非结构化数据模型,图模型,...

#### 层次模型
层次模型用树形结构来表示各类实体以及实体间的联系

表示方法：
* 实体型：用纪录类描述，每个节点表示一个记录类型
* 属性：用字段描述，每个记录类型可包含若干个字段
* 联系：用结点之间的连线表示记录类型（实体）之间的一对多的父子联系

特点:
* 结点的双亲是唯一的
* 只能直接处理一对多的实体联系
* 任何记录值只有按其路径查看
* 没有一个子女记录值能够脱离双亲记录值而独立存在 

优缺点:
* (优点)层次模型的数据结构比较简单清晰
* 查询效率高，性能优于关系模型，不低于网状模型
* 层次数据模型提供了良好的完整性支持
* (缺点)结点之间的多对多联系表示不自然
* 对插入和删除操作的限制多，应用程序的编写比较复杂
* 查询子女结点必须通过双亲结点
* 层次数据库的命令（语言）趋于程序化  

#### 网状模型
网状数据库系统采用网状结构来表示各类实体以及实体间的联系(有向图)

网状模型表示方法和层次模型相同

特点:
* 允许多个结点没有双亲结点
* 允许一个结点有多个双亲结点
* 允许两个结点之间有多种联系
* 要为每个联系命名并指出与该联系有关的双亲记录和子女记录 

优缺点:
* (优点)能够更为直接地描述现实世界，如一个结点可以有多个双亲
* 具有良好的性能，存取效率较高
* (缺点)结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握
* DDL、DML语言复杂，用户不容易使用
* 记录之间联系是通过存取路径实现的，应用程序必须选择存取路径，加重了程序员的负担

#### 关系模型
在用户观点下，关系模型中数据的逻辑结构是一张二维表,如下  
![relation](table0.png)  

其中:
* 关系: 一个关系对应通常来说的一张表
* 元组: 表中的一行即为一个元组
* 属性: 表中的一列即为一个属性, 每一个属性都会有一个属性名
* 主码(key): 也称码键, 是可以唯一确定一个元组的属性组
* 域(domain): 是一组具有相同数据类型的值的集合, 是属性的取值范围
* 分量: 元组中的一个属性值
* 关系模式: 对关系的描述

注意: 关系模型中的关系必须是规范化的, 关系中的每一个分量必须是不可分的数据项, 即不允许表中套表(这个表应该是个纯粹的二维数组)

优点:
* 建立在严格的数学概念的基础上
* 概念单一
>* 实体和各类联系都用关系来表示 
>* 对数据的检索结果也是关系 
* 关系模型的存取路径对用户透明(用户感受不到路径)
>* 具有更高的数据独立性，更好的安全保密性 
>* 简化了程序员的工作和数据库开发建立的工作 

缺点:
* 存取路径对用户透明，查询效率往往不如格式化数据模型
* 为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度

## 1.3 数据库系统的结构

从数据库应用开发人员角度看：
* 数据库系统采用三级模式结构，是数据库系统内部的系统结构

从数据库最终用户角度看，数据库系统的结构有：
* 单用户结构
* 主从式结构
* 分布式结构
* 客户-服务器
* 浏览器-应用服务器／数据库服务器等

### 关于模式的一些概念
模式:
* 是对数据库逻辑结构和特征的描述
* 是型的描述,不涉及具体值
* 模式是相对稳定的

实例
* 数据库某一时刻的状态: 模式的一个具体值
* 同一个模式可以有很多实例
* 实例随数据库中的数据的更新而变动

### 三级模式结构
![pattern](pattern0.png)

#### 模式
模式(逻辑模式)
* 是数据库中全体数据的逻辑结构和特征描述 
* 是所有用户的公共数据视图
> 一般,某个应用的数据库有一个模式  

模式是数据库系统模式结构的中心:
* 与数据的物理存储细节和硬件环境无关
* 与具体的应用程序、开发工具及高级程序设计语言无关 

定义模式
* DDL定义数据的逻辑结构，以某种数据模型为基础
* 数据记录由哪些数据项构成，数据项的名字、类型、取值范围等
* 定义数据之间的联系
* 定义与数据有关的安全性、完整性要求

#### 外模式
外模式（也称子模式或用户模式）
* 数据库用户使用的局部数据的逻辑结构和特征的描述
* 数据库用户的数据视图，是与某一应用有关的数据的逻辑表示 

外模式与模式的关系
* 外模式通常是模式的子集、一个模式可以有多个外模式
* 反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求
* 对模式中某一数据，在不同的外模式中 结构、类型、长度、保密级别等都可以不同 

外模式与应用的关系
* 一个外模式可以为 多个应用系统所使用，一个应用程序只能使用一个外模式 

外模式的用途
* 每个用户只能看见和访问所对应的外模式中的数据，简化用户视图
* 保证数据库安全性的一个有力措施

#### 内模式
内模式（也称存储模式）
* 是数据物理结构和存储方式的描述
* 是数据在数据库内部的表示方式
>* 记录的存储方式 （例如，顺序存储，堆存储，Cluste按hash方法存储等）
>* 索引的组织方式（B+树，Bitmap，Hash）
>* 数据是否压缩存储
>* 数据是否加密
>* 数据存储记录结构的规定—如定长/变长，记录是否可以跨页存放等 

* 一个数据库只有一个内模式

### 二级映像
三级模式实际上是对数据的三个抽象级别

数据库管理系统内部提供了二级映像
* 外模式/模式映像
* 模式/内模式映像

#### 外模式/模式映像
对每一个外模式,有一个外模式/模式映像
* 它定义了外模式与模式之间的对应关系
* 映像定义通常包含在各外模式的描述中

这种映像可以保证数据(和程序)的逻辑独立性
* 当模式改变时，数据库管理员对外模式／模式映像作相应改变，使外模式保持不变
* 应用程序是依据数据的外模式编写的，应用程序不必修改，保证了数据 与程序的逻辑独立性，简称数据的逻辑独立性 

#### 模式/内模式映像
模式/内模式映像定义了全局数据逻辑结构与存储结构之间的对应关系(如，说明某个逻辑记录对应何种存储结构)

数据库中模式/内模式映像是唯一的,该映像定义通常包含在模式的描述中

这种映像能保证数据的物理独立性
* 当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员 修改模式／内模式映象，使模式保持不变。
* 模式不变，则应用程序不变。保证了数据与程序的物理独立性，简称数据的 物理独立性。

#### 二级映像的功能与数据独立性
* 保证了应用程序的稳定性
>* 除非应用需求本身发生变化，否则应用程序一般不需要修改。

* 从程序为中心——发展为 以数据为中心
>* 具有了数据与程序之间的独立性，使得数据的定义和描述可以从应用 程序中分离出去

* 数据的存取由数据库管理系统管理
>* 简化了应用程序的编制
>* 大大减少了应用程序的维护和修改  

## 1.4 数据库系统的组成
* 数据库
* 数据库管理系统（及其开发工具）
* 应用程序
* 数据库管理员 

### 硬件平台及数据库
数据库对硬件资源的要求:
* 足够大的内存
* 足够大的磁盘(阵列)等外部设备
* 较高的通讯能力

### 软件
* 数据库管理系统
* 支持数据库管理系统运行的操作系统
* 与数据库接口的高级语言及其编译系统
* 以数据库管理系统为核心的应用开发工具
* 为特定应用环境开发的数据库应用系统

### 人员 
不同的人员涉及不同的数据抽象级别，具有不同的数据视图:
* 用户:应用程序客户端
* 应用程序员:外模式
* 数据库管理员,系统分析员:数据库,内模式,模式,外模式

# 二、关系数据库

## 2.1 关系模型

### 关系数据结构
关系数据结构是单一的数据结构-关系

关系数据结构示意图如下:  
![rela](relation0.png)

#### 域和笛卡尔积空间
* 域:域是一组具有相同数据类型的值的集合,是属性的取值范围

* 域的笛卡尔积空间是一组域的笛卡尔积,是属性值组合的集合

* 笛卡尔积的基数是参与笛卡尔积中元素的个数

* 笛卡尔积可以表示为一张二维表,行对应集合中的每个元素,列对应每个属性的域


#### 关系
关系是在笛卡尔积上的子集  
  
关系中的元素可以用元组表示,在二维表中由一行表示

* 属性: 关系中不同列称为属性,每个属性有一个名字; n目关系有n个属性
* 码: 码是能唯一标识一个元组的属性(组)
>* 候选码:关系中能唯一地标识一个元组的最小属性组，则称该属性组为候选码 
>* 全码:关系模式的所有属性都是这个关系模式的候选码时,这个属性组称为全码（All-key）
>* 主码:若一个关系有多个候选码，则选定其中一个为主码（Primary key）
>* 主属性:候选码的诸属性称为主属性（Prime attribute）不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）  

#### 关系模式
关系模式是对关系的描述  
关系模式主要有元组集合的结构和完整性约束条件两方面构成

关系模式可以由一个五元组R(U,D,DOM,F)表示,其中:
* R:关系名
* U:属性名集合
* D:各属性的域的集合
* DOM:属性向域的映像集合(映射关系,指明哪个属性的域是哪个)
* F:属性间数据依赖的关系集合

### 关系完整性约束
* 实体完整性和参照完整性: 关系模型必须满足的完整性约束条件称为关系的两个不变性，应该由关系系统自动支持

* 用户定义的完整性: 应用领域需要遵循的约束条件，体现了具体领域中的语义约束 

关系完整性约束能够使得一些不符合条件的元组不能进入数据库

#### 实体完整性
* 关系的主属性不能取空值(码不能为空)

说明: 
* 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。
* 现实世界中的实体是可区分的，即它们具有某种唯一性标识。
* 关系模型中以主码作为唯一性标识。
* 主码中的属性即主属性不能取空值。主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与第（2）点相矛盾，因此这个规则称为实体完整性

#### 参照完整性
* 关系中的某些属性的取值需要参考另外一个关系中的相关数据

在关系模型中实体及实体间的联系都是用关系来描述的,自然存在着关系与关系间的引用,而这种引用应当是有意义的 

若关系R中的属性F的取值需要参考关系S中的主码K,则:
* F为R的外码/外键,此时F不能是R的码
* R为参照关系
* S为被参照关系或目标关系
* 外码F只能为空或者是关系S中某个存在的元组的K属性(有意义)
* R和S可以是同一个关系
 

#### 用户定义完整性 
其他一些用户定义的完整性规则,可以是列级完整性约束也可以是表级完整性约束

## 2.2 关系代数
关系数据库语言分类：
* 关系代数语言: 用对关系的运算来表达查询要求
* 关系演算语言：用谓词来表达查询要求
* 具有关系代数和关系演算双重特点的语言(SQL)

关系代数是一种抽象的查询语言，它用对关系的运算来表达查询,其以集合运算为数学基础
* 关系代数运算对象是关系
* 关系代数运算结果是关系
* 关系代数运算符分为集合运算符和专门关系的运算符

### 传统集合操作
一些记号的定义:
* $R(A_1,A_2,...,A_n)$表示n目的关系模式,$A_i$表示属性
* $R$为符合上述关系模式的一个关系
* $t\in R$是R中的一个元组
* $t[A_i]$表示元组$t$中属性$A_i$的值
* $A=\lbrace A_i,A_j,...,A_k \rbrace$表示属性列或属性组
* $t[A]$可以表示$t$在上述属性组中诸分量的集合
* $\overline A$表示$A$在全体属性中的补集

* $\widehat {t_rt_s}$表示关系R和关系S中两个元组的连接
* $Z_x$是象集,表示R中属性组$X$上值为$x$的所有元组在属性组$Z$上分量的集合,称为$x$在$R$中的象集

#### 关系的并
关系的并就是集合的并,运算要求如下:
* 关系R和S目数相同,相应的属性属于同一个域
* R并S仍为n目关系,R$\cup$S是R和S上所有元组的集合
* 并完之后要去重

#### 关系的差
关系的差就是集合的差,运算要求如下:
* 关系R和S目数相同,相应的属性属于同一个域
* R并S仍为n目关系,R-S是属于R而不属于S的所有元组的集合

#### 关系的交
要求同上,运算结果是在R和S中都存在的元组的集合

#### 笛卡尔积
关系的笛卡尔积中,$R\times S = \lbrace \widehat {t_rt_s} | t_r \in R \land t_s \in S \rbrace$
* 行:运算后为$n_R+n_S$目关系
* 列:运算后有$k_R*k_S$个元组

### 关系特有操作

#### 选择$\sigma$
* 选择运算又称为限制
* 是在关系R中选择符合条件的元组组成集合
* 条件是一个取值为真或假的逻辑表达式

#### 投影$\pi$
* 从关系R中选择出若干属性列组成新的关系
* 投影后形成的新的关系目数会减少
* 需要去重

#### 连接
连接是从两个关系的笛卡尔积中选择属性满足一定条件A$\theta$B的元组组成的关系

此时,参与连接的两个关系有一些度数相等且可以进行比较的属性组A和B

* 等值连接: 两个元组能连接的条件是对应属性组的值相等,即$\theta$为'='
* 自然连接: 一种特殊的等值连接,两个进行比较的属性组必须相同,且运算结束后这些重复的属性组将会被去掉,这是一种对行和列都进行操作的运算

* 两个关系R和S在做自然连接时，被舍弃的元组称为悬浮元组
* 外连接: 将悬浮元组也保留在结果关系中,附加的属性置为空
>* 左外连接:只保留左边关系R中的悬浮元组,悬浮元组中多出来的S分量全置为空
>* 右外连接:只保留右边关系S中的悬浮元组,多出来的R分量全置为空

#### 除运算
* 给定关系R (X，Y) 和S (Y，Z)，其中X，Y，Z为属性组;Y一般为R和S中都有的属性组
* R/S的结果是R上的一个投影P(X)的子集
* R/S中的元组在X上分量值x的象集Yx包含S在Y上投影的集合
>* 如果R是选课记录,S是全体课程,R/S就表示选了所有课程的学生
* 属性组Z没有参与到R/S的运算中


## 2.3 关系演算
关系演算是以谓词演算为数学基础

按谓词变元不同,可分为元组关系演算(ALPHA语言)和域关系演算(QBE语言)

### 元组关系演算ALPHA

#### 基本格式
`GET [(定额)] <工作空间> (<操作对象>) [:条件] [DOWN|UP 排序方式]`
* 以相应排序方式返回符合条件的操作对象
* 如果有定额则只返回前n个结果

#### 用元组变量进行检索
元组变量是可以在某一关系上任意取值的变量
* 可以用元组变量来代替较长的关系名
* 如果条件中使用量词,其后只能接元组变量

元组关系演算是以元组变量作为谓词变元的基本对象的关系演算

定义方式:`RANGE <关系名> <变量名>`

#### 用存在量词的检索
* 使用量词时先得定义在关系上的元组变量

条件语句格式: $\exists$ <元组变量> (<关于元组变量和目标元组的表达式>)

对于需要判断的目标元组,只要存在一个元组变量的取值使得后面的表达式成立,这个目标元组就能够被选择

#### 用全称量词检索
* 使用量词时先得定义在关系上的元组变量

条件语句格式: $\forall$ <元组变量> (<关于元组变量和目标元组的表达式>)

对于需要判断的目标元组,无论元组变量取什么值后面的表达式都成立,则这个目标元组能够被选择

#### 用蕴含的检索
在上述表达式中,可以使用蕴含条件

表达式格式:A$\to$B

当A成立时B一定成立,表达式为真

#### 聚集函数
常用聚集函数(内部函数):
* COUNT: 对元组计数(计数时会自动排除重复值)
* TOTAL: 求值的总和
* MAX: 求最大值
* MIN: 求最小值
* AVG: 求平均值

### 域关系演算QBE
域关系演算是以元组变量的分量即域变量作为谓词变元的基本对象的关系演算

# 三、关系数据库标准语言SQL
SQL: 结构化查询语言,Structured Query Language

目前,没有一个数据库系统能够支持SQL标准的所有概念和特性

## 3.1 SQL概述
SQL（Structured Query Language）结构化查询语言是关系数据库的标准语言

### SQL特点
综合统一: 
* 集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。 
* 可以独立完成数据库生命周期中的全部活动  

高度非过程化:
* 非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径。
* SQL只要提出“做什么”，无须了解存取路径。
* 存取路径的选择以及SQL的操作过程由系统自动完成。

面向集合的操作方式: 
* 非关系数据模型采用面向记录的操作方式，操作对象是一条记录
* SQL采用集合操作方式
* 操作对象、查找结果可以是元组的集合
* 一次插入、删除、更新操作的对象可以是元组的集合

以同一种语法结构提供多种使用方式: 
* SQL是独立的语言,能够独立地用于联机交互的使用方式
* SQL能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用

语言简洁，易学易用: 
* SQL功能极强，完成核心功能只用了9个动词。
>* 数据定义:CREATE,DROP,ALTER
>* 数据操纵:INSERT,UPDATE,DELETE
>* 数据查询:SELECT
>* 权限控制:GRANT,REVOKE

### SQL基本概念
数据库三级模式在SQL数据库中的体现:  
![sql](sql0.png)

* 基本表(模式)
>* 本身独立存在的表
>* SQL中一个关系就对应一个基本表
>* 一个（或多个）基本表对应一个存储文件
>* 一个表可以带若干索引

* 存储文件(内模式)
>* 存储文件以逻辑结构的方式组成了关系数据库的内模式
>* 而物理存储结构对用户是隐蔽的(透明)

* 视图(外模式)
>* 视图是由一个或几个基本表导出的表,是一个虚表
>* 视图不存储数据,数据库中只存放视图的定义
>* 视图上可以再定义视图

## 3.2 数据定义
数据定义是定义各种数据库的对象
> 数据定义包括模式(SCHEMA)定义,表(TABLE)定义,视图(VIEW)定义,索引(INDEX)定义  
>* 这里的模式通常指基本表的结构
>* 一个数据库中可以建立多个模式
>* 一个模式下可以建立多个表,视图,索引等数据库对象

上述对象的定义存储在数据库系统的数据字典中
* 数据字典: 数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有对象的定义等一些信息
>* 除了模式,表,视图,索引的定义(包括完整性约束)外, 数据字典还会存储各类用户对数据库的操作权限和统计信息等
>* 关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息

### 模式定义
为某人创建某名的模式
```
CREATE SCHEMA <模式名> AUTHORIZATION <用户名>
[<表定义子句>|<视图定义子句>|<权限定义子句>];
```
* 若没有指定模式名,则模式名隐含为用户名

删除某模式:` DROP SCHEMA <模式名> <CASCADE|RESTRICT>`  
删除选项:
>* CASADE 级联: 删除模式同时将该模式下的所有数据库对象删除
>* RESTRICT 限制: 仅当该模式中没有任何下属对象时才能执行, 如果这个模式下有表/视图等定义,则拒绝执行语句

### 基本表的定义

#### 创建基本表
```SQL
CREATE TABLE <表名> /* 基本表的名称 */ 
(<列名> <数据类型>[ <列级完整性约束条件> ] /*组成该表的列*/ 
[,<列名> <数据类型>[ <列级完整性约束条件>] ] 
… 
[,<表级完整性约束条件> ] );

```
* <列级完整性约束条件>: 涉及仅单个属性列的完整性约束条件 
* <表级完整性约束条件>: 涉及一个或多个属性列的完整性约束条件 
* <表名>:每一个基本表需属于某个模式,可以显式地在表名中给出,也可以在搜索路径中设置 
> 设置搜索路径(默认模式):`SET search_path TO <模式名>,PUBLIC;`
* <数据类型>: 有如下数据类型

 数据类型 | 含义 | 数据类型 | 含义
 :- | :- | :- | :-
 CHAR(n) | n位定长字符串 | CHARACTER(n) | 同CHAR(n)
 VRCHAR(n) | 最大长度为n的变长字符串 | VRCHARACTER(n) | 同VRCHAR(n)
 CLOB | 字符串大对象 | BLOB | 二进制大对象
 INT | 长整数(4字节) | INTEGER | 同INT
 BIGINT | 大整数(8字节) | SMALLINT | 短整数(2字节)
 DEC(p,d) | 精度为d的p位定点数 | DECIMAL(p,d),NUMERIC(p,d) | 同DEC(p,d)
 REAL | 单精度浮点数 | DOUBLE PRECISION | 双精度浮点数
 FLOAT(n) | 精度为n的浮点数 | BOOLEAN | 布尔值
 DATE | 格式为YYYY-MM-DD的日期 | TIME | 格式为HH:MM:SS的时间
 TIMESTAP | 时间戳类型 | INTERVAL | 时间间隔类型

#### 修改基本表
```SQL
ALTER TABLE <表名>
[ADD[COLUMN] <新列名> <数据类型> [ 完整性约束 ] ]
[ADD <表级完整性约束>] /*完整性约束只能添加表级完整性约束*/
[DROP [ COLUMN ] <列名> [CASCADE| RESTRICT] ]
[DROP CONSTRAINT<完整性约束名>[ RESTRICT | CASCADE ] ]
[ALTER COLUMN <列名><数据类型> ] ;
```
* ADD COLUMN: 增加列
* DROP COLUMN: 删除列
>* 级联: 删除该列及引用该列的其他对象
>* 限制: 如果该列被其他对象引用,则拒绝删除
* ALTER COLUMN:修改列,也可以用以下两种方法
>* `MODIFY <列名> <数据类型>`:修改列的数据类型
>* `CHANGE <列名> <新列名> <新数据类型>`:修改列名
* RENAME TO <新表名>:改个新表名

#### 删除基本表
```
DROP TABLE <表名>［RESTRICT| CASCADE］; 
```
* 级联:在删除基本表的同时，相关的依赖对象一起删除
* 限制:如果存在依赖该表的对象(该表被其他表引用),则拒绝删除
















### 索引的定义
建立索引目的: 加快查询速度
```SQL
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
ON <表名>(<列名>[<次序>][,<列名>[<次序>] ]…);
```
* <表名>：要建索引的基本表的名字  
* 索引：可以建立在该表的一列或多列上，各列名之间用逗号分隔  
* <次序>：指定索引值的排列次序，升序：ASC，降序：DESC。缺省 值：ASC  
* UNIQUE：此索引的每一个索引值只对应唯一的数据记录  
* CLUSTER：表示要建立的索引是聚簇索引

修改索引:
`ALTER INDEX <旧索引名> RENAME TO <新索 引名>`

删除索引:
`ALTER INDEX <旧索引名> RENAME TO <新索 引名>`

## 3.3 数据查询

### 单表查询
语句格式:
```SQL
SELECT [ALL|DISTINCT] <目标列表达式>[,<目标列表达式>] …
FROM <表名或视图名>[,<表名或视图名> ]…|(SELECT 语句)
[AS]<别名>
[ WHERE <条件表达式> ]
[ GROUP BY <列名1> [ HAVING <条件表达式> ] ]
[ ORDER BY <列名2> [ ASC|DESC ] ]
```

### 连接查询
不像关系代数中“连接”是用一个特殊符号来表达的，在 SQL中“连接”是用“连接条件”来表达的。  
`WHERE [<表名1>.]<列名1>  <比较运算符>  [<表名2>.]<列名2> `

对于表的自身连接，可以给同一个表取不同的别名来区分

### 嵌套查询

不相关子查询：子查询条件不依赖于父查询（可以用IN,比较运算符等语句）
```WHERE <name> IN
        (
            SELECT <name>
            ...
        )
```
* ANY,ALL,EXIST等谓词也可以在比较运算中使用(后面接多个查询结果)


相关子查询:子查询条件依赖于父查询

除法运算:
```
select distinct S.customer-name 
    from depositoras S 
    where not exists ( 
        (select branch-name 
        from branch 
        where branch-city = ‘Brooklyn’) 
      except 
        (select R.branch-name 
        from depositor as T, account as R 
        where T.account-number = R.account-number and 
            S.customer-name = T.customer-name));
```

### 集合查询
* UNION:并
* INTERSECT:交
* EXCEPT:差

## 3.4 数据更新

### 插入数据
```
INSERT INTO <表名>[属性列,]
VALUES (属性值,);
```
* 没有出现的属性列赋空值  
* 没有定义属性列时默认为原表所有属性
* VALUES可以由子查询表示

### 修改数据
```
UPDATE  <表名>
SET  <列名>=<表达式>[,<列名>=<表达式>]…
[WHERE <条件>]; 
```

### 删除数据
```
DELETE FROM <表名>
WHERE <条件>;
```

## 3.5 空值处理
空值一般可以表示不存在,无意义,未知值

空值一般用NULL表示

## 3.6 视图
视图是一种虚拟的表,是从基本表中导出的表

视图只有定义,不存放数据

### 定义视图
```
CREATE  VIEW 
    <视图名>  [(<列名>  [,<列名>]…)] 
   AS <子查询> 
   [WITH  CHECK  OPTION];
```
* WITH CHECK OPTION 可以保证通过该视图插入的数据符合该视图的定义
* 视图可以定义在视图之上

### 删除视图
`DROP  VIEW  <视图名>[CASCADE]; `

### 查询视图
视图查询与基本表查询相同

视图消解法:对于数据库系统而言,先得将查询转换为对基本表的查询,再进行查询

### 更新视图
```
UPDATE  <视图名>
SET  <列名>=<表达式>[,<列名>=<表达式>]…
[WHERE <条件>]; 
```
插入删除操作与基本表相同

* 一些视图是不可更新的,比如,平均成绩视图时不能更新的
>* 一般而言,行列子集视图是可以进行更新的

### 视图作用
* 视图能够简化用户的操作
* 视图使用户能以多种角度看待同一数据
* 视图对重构数据库提供了一定程度的逻辑独立性
* 视图能够对机密数据提供安全保护
* 适当的利用视图可以更清晰的表达查询

# 四、数据库安全性

## 4.1 概述

### 数据库不安全因素
* 非授权用户对数据库的恶意存取和破坏
* 数据库中重要或敏感数据被泄露 
* 安全环境的脆弱性

### 数据库安全标准
* TCSEC标准->CC标准

## 4.2 数据库安全性控制
* 用户身份鉴别
* 存取控制
* 视图
* 审计
* 数据加密

### 用户身份鉴别
* 系统提供的最外层安全保护措施

方法:静态口令识别,动态口令识别,智能卡识别,生物特征鉴别

### 存取控制
* 定义用户权限,并将权限登记到数据字典中
* 对每个用户发出的存取数据库的请求,DBMS都会查找数据字典进行合法权限检查

用户权限定义和合法权检查机制一起组成了DBMS的存取控制子系统 

### 自主存取控制方法
通过 SQL 的GRANT 语句和REVOKE 语句实现 

### 数据库角色
角色是权限的集合,通过为一组具有相同权限的用户创建一个角色来简化授权的过程

创建角色用CREATE ROLE rolename

给角色授权方式同上

`GRANT <角色> TO <用户>`

### 强制存取控制
自主存取控制可能存在数据的“无意泄露” 

强制存取控制（MAC）保证更高程度的安全性,用户不能直接感知或进行控制:适用于对数据有严格而固定密级分类的部门 

## 4.3 视图机制
把要保密的数据对无权存取这些数据的用户通过视图隐藏起来，对数据提供一定程度的安全保护

例如,允许用户对表的部分进行查询的权限,用GRANT语句就无法实现

## 4.4 审计

用户身份鉴别,自主存取控制,强制存取控制,视图是预防性措施

审计是监控措施

审计功能用AUDIT和NOAUDIT控制

## 4.5 数据加密
数据加密也是一种预防性措施,是防止数据库中数据在存储和传输中失密的有效手段

有存储加密和传输加密两种

存储加密:
* 透明存储加密
* 非透明存储加密

传输加密:
* 链路加密
* 端到端加密

## 4.6 其他安全性保护

### 推理控制
解决用于通过公开信息推理出机密信息的漏洞

### 隐蔽信道
处理强制存取控制未解决的问题: 高安全等级用户按事先约定的方式主动向低安全等级用户透露信息

# 五、数据库完整性
* 数据的正确性(实体完整性等)
* 数据的相容性(参照完整性)

数据库完整性防范的是非法数据  
数据库安全性防范的是非法操作

* 提供定义完整性约束条件的机制
* 提供完整性检查机制 
* 违约处理 

## 5.1 实体完整性

### 实体完整性定义

### 实体完整性检查和违约处理
实体完整性检查发生在插入或对主码列进行更新操作时

检查记录中主码值是否唯一的一种方法是进行全表扫描

建立索引可以加快实体完整性检查速度

## 5.2 参照完整性
保证外码取值符合参照完整性约束

### 参照完整性定义
* 定义表中的外码,以及其参照的其他表中的主码
```
(列级或表级参照完整性约束中)
FOREIGN KEY([name]) REFERENCES DEPT(name)
 [ON DELETE/UPDATE NO ACTION/CASCADE]
```

### 参照完整性检查和违约处理
参照完整性检查发生在对被参照表和参照表进行增删改操作时

违约处理:
* 拒绝执行
* 级联操作
* 设置空值:可能会违反实体完整性

## 5.3 用户定义完整性约束
针对某一具体应用的数据必须满足的语义要求

违约处理为拒绝操作

### 属性上的约束条件
* 列值非空:NOT NULL
* 列值唯一:UNIQUE(相当于主码)
* 列值满足某表达式:CHECK(expr)

属性约束条件检查发生在插入元组或修改属性的值时

### 元组上的约束条件
设置不同属性之间取值的相互约束条件

在表级完整性约束中用CHECK定义

元组上的约束条件检查发生在插入元组或修改属性的值时

## 5.4 完整性约束命名字句
为完整性约束条件起个名字,方便后面对它进行修改和删除,否则无法操作

`CONSTANT <name> <expr>`

用 ALTER TABLE 对约束条件修改

---

*待更新...*




























